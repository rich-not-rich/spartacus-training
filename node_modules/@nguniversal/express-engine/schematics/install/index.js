(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define("@nguniversal/express-engine/schematics/install/index", ["require", "exports", "@angular-devkit/core", "@angular-devkit/schematics", "@angular-devkit/schematics/tasks", "@schematics/angular/utility/config", "@schematics/angular/utility/dependencies", "@schematics/angular/utility/project", "@schematics/angular/utility/project-targets", "@schematics/angular/utility/ast-utils", "typescript", "@nguniversal/express-engine/schematics/install/utils", "@schematics/angular/utility/workspace"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    const core_1 = require("@angular-devkit/core");
    const schematics_1 = require("@angular-devkit/schematics");
    const tasks_1 = require("@angular-devkit/schematics/tasks");
    const config_1 = require("@schematics/angular/utility/config");
    const dependencies_1 = require("@schematics/angular/utility/dependencies");
    const project_1 = require("@schematics/angular/utility/project");
    const project_targets_1 = require("@schematics/angular/utility/project-targets");
    const ast_utils_1 = require("@schematics/angular/utility/ast-utils");
    const ts = require("typescript");
    const utils_1 = require("@nguniversal/express-engine/schematics/install/utils");
    const workspace_1 = require("@schematics/angular/utility/workspace");
    // TODO(CaerusKaru): make these configurable
    const BROWSER_DIST = 'dist/browser';
    const SERVER_DIST = 'dist/server';
    function getClientProject(host, options) {
        const workspace = config_1.getWorkspace(host);
        const clientProject = workspace.projects[options.clientProject];
        if (!clientProject) {
            throw new schematics_1.SchematicsException(`Client app ${options.clientProject} not found.`);
        }
        return clientProject;
    }
    function addDependenciesAndScripts(options) {
        return (host) => {
            dependencies_1.addPackageJsonDependency(host, {
                type: dependencies_1.NodeDependencyType.Default,
                name: '@nguniversal/express-engine',
                version: 'v8.2.6',
            });
            dependencies_1.addPackageJsonDependency(host, {
                type: dependencies_1.NodeDependencyType.Default,
                name: '@nguniversal/module-map-ngfactory-loader',
                version: 'v8.2.6',
            });
            dependencies_1.addPackageJsonDependency(host, {
                type: dependencies_1.NodeDependencyType.Default,
                name: 'express',
                version: '^4.15.2',
            });
            dependencies_1.addPackageJsonDependency(host, {
                type: dependencies_1.NodeDependencyType.Dev,
                name: '@types/express',
                version: '^4.17.0',
            });
            if (options.webpack) {
                dependencies_1.addPackageJsonDependency(host, {
                    type: dependencies_1.NodeDependencyType.Dev,
                    name: 'ts-loader',
                    version: '^5.2.0',
                });
                dependencies_1.addPackageJsonDependency(host, {
                    type: dependencies_1.NodeDependencyType.Dev,
                    name: 'webpack-cli',
                    version: '^3.1.0',
                });
            }
            const serverFileName = options.serverFileName.replace('.ts', '');
            const pkgPath = '/package.json';
            const buffer = host.read(pkgPath);
            if (buffer === null) {
                throw new schematics_1.SchematicsException('Could not find package.json');
            }
            const pkg = JSON.parse(buffer.toString());
            pkg.scripts['compile:server'] = options.webpack ?
                'webpack --config webpack.server.config.js --progress --colors' :
                `tsc -p ${serverFileName}.tsconfig.json`;
            pkg.scripts['serve:ssr'] = `node dist/${serverFileName}`;
            pkg.scripts['build:ssr'] = 'npm run build:client-and-server-bundles && npm run compile:server';
            pkg.scripts['build:client-and-server-bundles'] =
                // tslint:disable:max-line-length
                `ng build --prod && ng run ${options.clientProject}:server:production --bundleDependencies all`;
            host.overwrite(pkgPath, JSON.stringify(pkg, null, 2));
            return host;
        };
    }
    function updateConfigFile(options) {
        return workspace_1.updateWorkspace((workspace => {
            const clientProject = workspace.projects.get(options.clientProject);
            if (clientProject) {
                const buildTarget = clientProject.targets.get('build');
                const serverTarget = clientProject.targets.get('server');
                // We have to check if the project config has a server target, because
                // if the Universal step in this schematic isn't run, it can't be guaranteed
                // to exist
                if (!serverTarget || !buildTarget) {
                    return;
                }
                serverTarget.options = Object.assign({}, serverTarget.options, { outputPath: SERVER_DIST });
                buildTarget.options = Object.assign({}, buildTarget.options, { outputPath: BROWSER_DIST });
            }
        }));
    }
    function addModuleMapLoader(options) {
        return (host) => {
            const clientProject = project_1.getProject(host, options.clientProject);
            const clientTargets = project_targets_1.getProjectTargets(clientProject);
            if (!clientTargets.server) {
                // If they skipped Universal schematics and don't have a server target,
                // just get out
                return;
            }
            const mainPath = core_1.normalize('/' + clientTargets.server.options.main);
            const appServerModuleRelativePath = utils_1.findAppServerModulePath(host, mainPath);
            const modulePath = core_1.normalize(`/${clientProject.root}/src/${appServerModuleRelativePath}.ts`);
            // Add the module map loader import
            let moduleSource = utils_1.getTsSourceFile(host, modulePath);
            const importModule = 'ModuleMapLoaderModule';
            const importPath = '@nguniversal/module-map-ngfactory-loader';
            const moduleMapImportChange = ast_utils_1.insertImport(moduleSource, modulePath, importModule, importPath);
            if (moduleMapImportChange) {
                const recorder = host.beginUpdate(modulePath);
                recorder.insertLeft(moduleMapImportChange.pos, moduleMapImportChange.toAdd);
                host.commitUpdate(recorder);
            }
            // Add the module map loader module to the imports
            const importText = 'ModuleMapLoaderModule';
            moduleSource = utils_1.getTsSourceFile(host, modulePath);
            const metadataChanges = ast_utils_1.addSymbolToNgModuleMetadata(moduleSource, modulePath, 'imports', importText);
            if (metadataChanges) {
                const recorder = host.beginUpdate(modulePath);
                metadataChanges.forEach((change) => {
                    recorder.insertRight(change.pos, change.toAdd);
                });
                host.commitUpdate(recorder);
            }
        };
    }
    function addExports(options) {
        return (host) => {
            const clientProject = project_1.getProject(host, options.clientProject);
            const clientTargets = project_targets_1.getProjectTargets(clientProject);
            if (!clientTargets.server) {
                // If they skipped Universal schematics and don't have a server target,
                // just get out
                return;
            }
            const mainPath = core_1.normalize('/' + clientTargets.server.options.main);
            const mainSourceFile = utils_1.getTsSourceFile(host, mainPath);
            let mainText = utils_1.getTsSourceText(host, mainPath);
            const mainRecorder = host.beginUpdate(mainPath);
            const expressEngineExport = utils_1.generateExport(mainSourceFile, ['ngExpressEngine'], '@nguniversal/express-engine');
            const moduleMapExport = utils_1.generateExport(mainSourceFile, ['provideModuleMap'], '@nguniversal/module-map-ngfactory-loader');
            const exports = ast_utils_1.findNodes(mainSourceFile, ts.SyntaxKind.ExportDeclaration);
            const addedExports = `\n${expressEngineExport}\n${moduleMapExport}\n`;
            const exportChange = ast_utils_1.insertAfterLastOccurrence(exports, addedExports, mainText, 0);
            mainRecorder.insertLeft(exportChange.pos, exportChange.toAdd);
            host.commitUpdate(mainRecorder);
        };
    }
    function default_1(options) {
        return (host, context) => {
            const clientProject = getClientProject(host, options);
            if (clientProject.projectType !== 'application') {
                throw new schematics_1.SchematicsException(`Universal requires a project type of "application".`);
            }
            if (!options.skipInstall) {
                context.addTask(new tasks_1.NodePackageInstallTask());
            }
            const rootSource = schematics_1.apply(schematics_1.url('./files/root'), [
                options.skipServer ? schematics_1.filter(path => !path.startsWith('__serverFileName')) : schematics_1.noop(),
                options.webpack ?
                    schematics_1.filter(path => !path.includes('tsconfig')) : schematics_1.filter(path => !path.startsWith('webpack')),
                schematics_1.template(Object.assign({}, core_1.strings, options, { stripTsExtension: (s) => s.replace(/\.ts$/, ''), getBrowserDistDirectory: () => BROWSER_DIST, getServerDistDirectory: () => SERVER_DIST }))
            ]);
            return schematics_1.chain([
                options.skipUniversal ?
                    schematics_1.noop() : schematics_1.externalSchematic('@schematics/angular', 'universal', options),
                updateConfigFile(options),
                schematics_1.mergeWith(rootSource),
                addDependenciesAndScripts(options),
                addModuleMapLoader(options),
                addExports(options),
            ]);
        };
    }
    exports.default = default_1;
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi9tb2R1bGVzL2V4cHJlc3MtZW5naW5lL3NjaGVtYXRpY3MvaW5zdGFsbC9pbmRleC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztJQUFBOzs7Ozs7T0FNRztJQUNILCtDQUFzRTtJQUN0RSwyREFhb0M7SUFDcEMsNERBQXdFO0lBQ3hFLCtEQUFnRTtJQUVoRSwyRUFHa0Q7SUFDbEQsaUVBQStEO0lBQy9ELGlGQUE4RTtJQUU5RSxxRUFLK0M7SUFDL0MsaUNBQWlDO0lBQ2pDLGdGQUFrRztJQUNsRyxxRUFBc0U7SUFFdEUsNENBQTRDO0lBQzVDLE1BQU0sWUFBWSxHQUFHLGNBQWMsQ0FBQztJQUNwQyxNQUFNLFdBQVcsR0FBRyxhQUFhLENBQUM7SUFFbEMsU0FBUyxnQkFBZ0IsQ0FDdkIsSUFBVSxFQUFFLE9BQXlCO1FBRXJDLE1BQU0sU0FBUyxHQUFHLHFCQUFZLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDckMsTUFBTSxhQUFhLEdBQUcsU0FBUyxDQUFDLFFBQVEsQ0FBQyxPQUFPLENBQUMsYUFBYSxDQUFDLENBQUM7UUFDaEUsSUFBSSxDQUFDLGFBQWEsRUFBRTtZQUNsQixNQUFNLElBQUksZ0NBQW1CLENBQUMsY0FBYyxPQUFPLENBQUMsYUFBYSxhQUFhLENBQUMsQ0FBQztTQUNqRjtRQUVELE9BQU8sYUFBYSxDQUFDO0lBQ3ZCLENBQUM7SUFFRCxTQUFTLHlCQUF5QixDQUFDLE9BQXlCO1FBQzFELE9BQU8sQ0FBQyxJQUFVLEVBQUUsRUFBRTtZQUNwQix1Q0FBd0IsQ0FBQyxJQUFJLEVBQUU7Z0JBQzdCLElBQUksRUFBRSxpQ0FBa0IsQ0FBQyxPQUFPO2dCQUNoQyxJQUFJLEVBQUUsNkJBQTZCO2dCQUNuQyxPQUFPLEVBQUUsbUJBQW1CO2FBQzdCLENBQUMsQ0FBQztZQUNILHVDQUF3QixDQUFDLElBQUksRUFBRTtnQkFDN0IsSUFB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VyxFQUFFLE9BQU8sQ0FBQztnQkFDekUsZ0JBQWdCLENBQUMsT0FBTyxDQUFDO2dCQUN6QixzQkFBUyxDQUFDLFVBQVUsQ0FBQztnQkFDckIseUJBQXlCLENBQUMsT0FBTyxDQUFDO2dCQUNsQyxrQkFBa0IsQ0FBQyxPQUFPLENBQUM7Z0JBQzNCLFVBQVUsQ0FBQyxPQUFPLENBQUM7YUFDcEIsQ0FBQyxDQUFDO1FBQ0wsQ0FBQyxDQUFDO0lBQ0osQ0FBQztJQWxDRCw0QkFrQ0MiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIExMQyBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbmltcG9ydCB7ZXhwZXJpbWVudGFsLCBzdHJpbmdzLCBub3JtYWxpemV9IGZyb20gJ0Bhbmd1bGFyLWRldmtpdC9jb3JlJztcbmltcG9ydCB7XG4gIGFwcGx5LFxuICBjaGFpbixcbiAgZXh0ZXJuYWxTY2hlbWF0aWMsXG4gIGZpbHRlcixcbiAgbWVyZ2VXaXRoLFxuICBub29wLFxuICBSdWxlLFxuICBTY2hlbWF0aWNDb250ZXh0LFxuICBTY2hlbWF0aWNzRXhjZXB0aW9uLFxuICB0ZW1wbGF0ZSxcbiAgVHJlZSxcbiAgdXJsLFxufSBmcm9tICdAYW5ndWxhci1kZXZraXQvc2NoZW1hdGljcyc7XG5pbXBvcnQge05vZGVQYWNrYWdlSW5zdGFsbFRhc2t9IGZyb20gJ0Bhbmd1bGFyLWRldmtpdC9zY2hlbWF0aWNzL3Rhc2tzJztcbmltcG9ydCB7Z2V0V29ya3NwYWNlfSBmcm9tICdAc2NoZW1hdGljcy9hbmd1bGFyL3V0aWxpdHkvY29uZmlnJztcbmltcG9ydCB7U2NoZW1hIGFzIFVuaXZlcnNhbE9wdGlvbnN9IGZyb20gJy4vc2NoZW1hJztcbmltcG9ydCB7XG4gIGFkZFBhY2thZ2VKc29uRGVwZW5kZW5jeSxcbiAgTm9kZURlcGVuZGVuY3lUeXBlLFxufSBmcm9tICdAc2NoZW1hdGljcy9hbmd1bGFyL3V0aWxpdHkvZGVwZW5kZW5jaWVzJztcbmltcG9ydCB7Z2V0UHJvamVjdH0gZnJvbSAnQHNjaGVtYXRpY3MvYW5ndWxhci91dGlsaXR5L3Byb2plY3QnO1xuaW1wb3J0IHtnZXRQcm9qZWN0VGFyZ2V0c30gZnJvbSAnQHNjaGVtYXRpY3MvYW5ndWxhci91dGlsaXR5L3Byb2plY3QtdGFyZ2V0cyc7XG5pbXBvcnQge0luc2VydENoYW5nZX0gZnJvbSAnQHNjaGVtYXRpY3MvYW5ndWxhci91dGlsaXR5L2NoYW5nZSc7XG5pbXBvcnQge1xuICBhZGRTeW1ib2xUb05nTW9kdWxlTWV0YWRhdGEsXG4gIGZpbmROb2RlcyxcbiAgaW5zZXJ0QWZ0ZXJMYXN0T2NjdXJyZW5jZSxcbiAgaW5zZXJ0SW1wb3J0XG59IGZyb20gJ0BzY2hlbWF0aWNzL2FuZ3VsYXIvdXRpbGl0eS9hc3QtdXRpbHMnO1xuaW1wb3J0ICogYXMgdHMgZnJvbSAndHlwZXNjcmlwdCc7XG5pbXBvcnQge2ZpbmRBcHBTZXJ2ZXJNb2R1bGVQYXRoLCBnZW5lcmF0ZUV4cG9ydCwgZ2V0VHNTb3VyY2VGaWxlLCBnZXRUc1NvdXJjZVRleHR9IGZyb20gJy4vdXRpbHMnO1xuaW1wb3J0IHt1cGRhdGVXb3Jrc3BhY2V9IGZyb20gJ0BzY2hlbWF0aWNzL2FuZ3VsYXIvdXRpbGl0eS93b3Jrc3BhY2UnO1xuXG4vLyBUT0RPKENhZXJ1c0thcnUpOiBtYWtlIHRoZXNlIGNvbmZpZ3VyYWJsZVxuY29uc3QgQlJPV1NFUl9ESVNUID0gJ2Rpc3QvYnJvd3Nlcic7XG5jb25zdCBTRVJWRVJfRElTVCA9ICdkaXN0L3NlcnZlcic7XG5cbmZ1bmN0aW9uIGdldENsaWVudFByb2plY3QoXG4gIGhvc3Q6IFRyZWUsIG9wdGlvbnM6IFVuaXZlcnNhbE9wdGlvbnMsXG4pOiBleHBlcmltZW50YWwud29ya3NwYWNlLldvcmtzcGFjZVByb2plY3Qge1xuICBjb25zdCB3b3Jrc3BhY2UgPSBnZXRXb3Jrc3BhY2UoaG9zdCk7XG4gIGNvbnN0IGNsaWVudFByb2plY3QgPSB3b3Jrc3BhY2UucHJvamVjdHNbb3B0aW9ucy5jbGllbnRQcm9qZWN0XTtcbiAgaWYgKCFjbGllbnRQcm9qZWN0KSB7XG4gICAgdGhyb3cgbmV3IFNjaGVtYXRpY3NFeGNlcHRpb24oYENsaWVudCBhcHAgJHtvcHRpb25zLmNsaWVudFByb2plY3R9IG5vdCBmb3VuZC5gKTtcbiAgfVxuXG4gIHJldHVybiBjbGllbnRQcm9qZWN0O1xufVxuXG5mdW5jdGlvbiBhZGREZXBlbmRlbmNpZXNBbmRTY3JpcHRzKG9wdGlvbnM6IFVuaXZlcnNhbE9wdGlvbnMpOiBSdWxlIHtcbiAgcmV0dXJuIChob3N0OiBUcmVlKSA9PiB7XG4gICAgYWRkUGFja2FnZUpzb25EZXBlbmRlbmN5KGhvc3QsIHtcbiAgICAgIHR5cGU6IE5vZGVEZXBlbmRlbmN5VHlwZS5EZWZhdWx0LFxuICAgICAgbmFtZTogJ0BuZ3VuaXZlcnNhbC9leHByZXNzLWVuZ2luZScsXG4gICAgICB2ZXJzaW9uOiAnMC4wLjAtUExBQ0VIT0xERVInLFxuICAgIH0pO1xuICAgIGFkZFBhY2thZ2VKc29uRGVwZW5kZW5jeShob3N0LCB7XG4gICAgICB0eXBlOiBOb2RlRGVwZW5kZW5jeVR5cGUuRGVmYXVsdCxcbiAgICAgIG5hbWU6ICdAbmd1bml2ZXJzYWwvbW9kdWxlLW1hcC1uZ2ZhY3RvcnktbG9hZGVyJyxcbiAgICAgIHZlcnNpb246ICcwLjAuMC1QTEFDRUhPTERFUicsXG4gICAgfSk7XG4gICAgYWRkUGFja2FnZUpzb25EZXBlbmRlbmN5KGhvc3QsIHtcbiAgICAgIHR5cGU6IE5vZGVEZXBlbmRlbmN5VHlwZS5EZWZhdWx0LFxuICAgICAgbmFtZTogJ2V4cHJlc3MnLFxuICAgICAgdmVyc2lvbjogJ0VYUFJFU1NfVkVSU0lPTicsXG4gICAgfSk7XG4gICAgYWRkUGFja2FnZUpzb25EZXBlbmRlbmN5KGhvc3QsIHtcbiAgICAgIHR5cGU6IE5vZGVEZXBlbmRlbmN5VHlwZS5EZXYsXG4gICAgICBuYW1lOiAnQHR5cGVzL2V4cHJlc3MnLFxuICAgICAgdmVyc2lvbjogJ0VYUFJFU1NfVFlQRVNfVkVSU0lPTicsXG4gICAgfSk7XG5cbiAgICBpZiAob3B0aW9ucy53ZWJwYWNrKSB7XG4gICAgICBhZGRQYWNrYWdlSnNvbkRlcGVuZGVuY3koaG9zdCwge1xuICAgICAgICB0eXBlOiBOb2RlRGVwZW5kZW5jeVR5cGUuRGV2LFxuICAgICAgICBuYW1lOiAndHMtbG9hZGVyJyxcbiAgICAgICAgdmVyc2lvbjogJ141LjIuMCcsXG4gICAgICB9KTtcbiAgICAgIGFkZFBhY2thZ2VKc29uRGVwZW5kZW5jeShob3N0LCB7XG4gICAgICAgIHR5cGU6IE5vZGVEZXBlbmRlbmN5VHlwZS5EZXYsXG4gICAgICAgIG5hbWU6ICd3ZWJwYWNrLWNsaScsXG4gICAgICAgIHZlcnNpb246ICdeMy4xLjAnLFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgY29uc3Qgc2VydmVyRmlsZU5hbWUgPSBvcHRpb25zLnNlcnZlckZpbGVOYW1lLnJlcGxhY2UoJy50cycsICcnKTtcbiAgICBjb25zdCBwa2dQYXRoID0gJy9wYWNrYWdlLmpzb24nO1xuICAgIGNvbnN0IGJ1ZmZlciA9IGhvc3QucmVhZChwa2dQYXRoKTtcbiAgICBpZiAoYnVmZmVyID09PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgU2NoZW1hdGljc0V4Y2VwdGlvbignQ291bGQgbm90IGZpbmQgcGFja2FnZS5qc29uJyk7XG4gICAgfVxuXG4gICAgY29uc3QgcGtnID0gSlNPTi5wYXJzZShidWZmZXIudG9TdHJpbmcoKSk7XG5cbiAgICBwa2cuc2NyaXB0c1snY29tcGlsZTpzZXJ2ZXInXSA9IG9wdGlvbnMud2VicGFjayA/XG4gICAgICAnd2VicGFjayAtLWNvbmZpZyB3ZWJwYWNrLnNlcnZlci5jb25maWcuanMgLS1wcm9ncmVzcyAtLWNvbG9ycycgOlxuICAgICAgYHRzYyAtcCAke3NlcnZlckZpbGVOYW1lfS50c2NvbmZpZy5qc29uYDtcbiAgICBwa2cuc2NyaXB0c1snc2VydmU6c3NyJ10gPSBgbm9kZSBkaXN0LyR7c2VydmVyRmlsZU5hbWV9YDtcbiAgICBwa2cuc2NyaXB0c1snYnVpbGQ6c3NyJ10gPSAnbnBtIHJ1biBidWlsZDpjbGllbnQtYW5kLXNlcnZlci1idW5kbGVzICYmIG5wbSBydW4gY29tcGlsZTpzZXJ2ZXInO1xuICAgIHBrZy5zY3JpcHRzWydidWlsZDpjbGllbnQtYW5kLXNlcnZlci1idW5kbGVzJ10gPVxuICAgICAgLy8gdHNsaW50OmRpc2FibGU6bWF4LWxpbmUtbGVuZ3RoXG4gICAgICBgbmcgYnVpbGQgLS1wcm9kICYmIG5nIHJ1biAke29wdGlvbnMuY2xpZW50UHJvamVjdH06c2VydmVyOnByb2R1Y3Rpb24gLS1idW5kbGVEZXBlbmRlbmNpZXMgYWxsYDtcblxuICAgIGhvc3Qub3ZlcndyaXRlKHBrZ1BhdGgsIEpTT04uc3RyaW5naWZ5KHBrZywgbnVsbCwgMikpO1xuXG4gICAgcmV0dXJuIGhvc3Q7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUNvbmZpZ0ZpbGUob3B0aW9uczogVW5pdmVyc2FsT3B0aW9ucykge1xuICByZXR1cm4gdXBkYXRlV29ya3NwYWNlKCh3b3Jrc3BhY2UgPT4ge1xuICAgIGNvbnN0IGNsaWVudFByb2plY3QgPSB3b3Jrc3BhY2UucHJvamVjdHMuZ2V0KG9wdGlvbnMuY2xpZW50UHJvamVjdCk7XG4gICAgaWYgKGNsaWVudFByb2plY3QpIHtcbiAgICAgIGNvbnN0IGJ1aWxkVGFyZ2V0ID0gY2xpZW50UHJvamVjdC50YXJnZXRzLmdldCgnYnVpbGQnKTtcbiAgICAgIGNvbnN0IHNlcnZlclRhcmdldCA9IGNsaWVudFByb2plY3QudGFyZ2V0cy5nZXQoJ3NlcnZlcicpO1xuXG4gICAgICAvLyBXZSBoYXZlIHRvIGNoZWNrIGlmIHRoZSBwcm9qZWN0IGNvbmZpZyBoYXMgYSBzZXJ2ZXIgdGFyZ2V0LCBiZWNhdXNlXG4gICAgICAvLyBpZiB0aGUgVW5pdmVyc2FsIHN0ZXAgaW4gdGhpcyBzY2hlbWF0aWMgaXNuJ3QgcnVuLCBpdCBjYW4ndCBiZSBndWFyYW50ZWVkXG4gICAgICAvLyB0byBleGlzdFxuICAgICAgaWYgKCFzZXJ2ZXJUYXJnZXQgfHwgIWJ1aWxkVGFyZ2V0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgc2VydmVyVGFyZ2V0Lm9wdGlvbnMgPSB7XG4gICAgICAgIC4uLnNlcnZlclRhcmdldC5vcHRpb25zLFxuICAgICAgICBvdXRwdXRQYXRoOiBTRVJWRVJfRElTVCxcbiAgICAgIH07XG5cbiAgICAgIGJ1aWxkVGFyZ2V0Lm9wdGlvbnMgPSB7XG4gICAgICAgIC4uLmJ1aWxkVGFyZ2V0Lm9wdGlvbnMsXG4gICAgICAgIG91dHB1dFBhdGg6IEJST1dTRVJfRElTVCxcbiAgICAgIH07XG4gICAgfVxuICB9KSk7XG59XG5cbmZ1bmN0aW9uIGFkZE1vZHVsZU1hcExvYWRlcihvcHRpb25zOiBVbml2ZXJzYWxPcHRpb25zKTogUnVsZSB7XG4gIHJldHVybiAoaG9zdDogVHJlZSkgPT4ge1xuICAgIGNvbnN0IGNsaWVudFByb2plY3QgPSBnZXRQcm9qZWN0KGhvc3QsIG9wdGlvbnMuY2xpZW50UHJvamVjdCk7XG4gICAgY29uc3QgY2xpZW50VGFyZ2V0cyA9IGdldFByb2plY3RUYXJnZXRzKGNsaWVudFByb2plY3QpO1xuICAgIGlmICghY2xpZW50VGFyZ2V0cy5zZXJ2ZXIpIHtcbiAgICAgIC8vIElmIHRoZXkgc2tpcHBlZCBVbml2ZXJzYWwgc2NoZW1hdGljcyBhbmQgZG9uJ3QgaGF2ZSBhIHNlcnZlciB0YXJnZXQsXG4gICAgICAvLyBqdXN0IGdldCBvdXRcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbWFpblBhdGggPSBub3JtYWxpemUoJy8nICsgY2xpZW50VGFyZ2V0cy5zZXJ2ZXIub3B0aW9ucy5tYWluKTtcbiAgICBjb25zdCBhcHBTZXJ2ZXJNb2R1bGVSZWxhdGl2ZVBhdGggPSBmaW5kQXBwU2VydmVyTW9kdWxlUGF0aChob3N0LCBtYWluUGF0aCk7XG4gICAgY29uc3QgbW9kdWxlUGF0aCA9IG5vcm1hbGl6ZShcbiAgICAgIGAvJHtjbGllbnRQcm9qZWN0LnJvb3R9L3NyYy8ke2FwcFNlcnZlck1vZHVsZVJlbGF0aXZlUGF0aH0udHNgKTtcblxuICAgIC8vIEFkZCB0aGUgbW9kdWxlIG1hcCBsb2FkZXIgaW1wb3J0XG4gICAgbGV0IG1vZHVsZVNvdXJjZSA9IGdldFRzU291cmNlRmlsZShob3N0LCBtb2R1bGVQYXRoKTtcbiAgICBjb25zdCBpbXBvcnRNb2R1bGUgPSAnTW9kdWxlTWFwTG9hZGVyTW9kdWxlJztcbiAgICBjb25zdCBpbXBvcnRQYXRoID0gJ0BuZ3VuaXZlcnNhbC9tb2R1bGUtbWFwLW5nZmFjdG9yeS1sb2FkZXInO1xuICAgIGNvbnN0IG1vZHVsZU1hcEltcG9ydENoYW5nZSA9IGluc2VydEltcG9ydChtb2R1bGVTb3VyY2UsIG1vZHVsZVBhdGgsIGltcG9ydE1vZHVsZSxcbiAgICAgIGltcG9ydFBhdGgpIGFzIEluc2VydENoYW5nZTtcbiAgICBpZiAobW9kdWxlTWFwSW1wb3J0Q2hhbmdlKSB7XG4gICAgICBjb25zdCByZWNvcmRlciA9IGhvc3QuYmVnaW5VcGRhdGUobW9kdWxlUGF0aCk7XG4gICAgICByZWNvcmRlci5pbnNlcnRMZWZ0KG1vZHVsZU1hcEltcG9ydENoYW5nZS5wb3MsIG1vZHVsZU1hcEltcG9ydENoYW5nZS50b0FkZCk7XG4gICAgICBob3N0LmNvbW1pdFVwZGF0ZShyZWNvcmRlcik7XG4gICAgfVxuXG4gICAgLy8gQWRkIHRoZSBtb2R1bGUgbWFwIGxvYWRlciBtb2R1bGUgdG8gdGhlIGltcG9ydHNcbiAgICBjb25zdCBpbXBvcnRUZXh0ID0gJ01vZHVsZU1hcExvYWRlck1vZHVsZSc7XG4gICAgbW9kdWxlU291cmNlID0gZ2V0VHNTb3VyY2VGaWxlKGhvc3QsIG1vZHVsZVBhdGgpO1xuICAgIGNvbnN0IG1ldGFkYXRhQ2hhbmdlcyA9IGFkZFN5bWJvbFRvTmdNb2R1bGVNZXRhZGF0YShcbiAgICAgIG1vZHVsZVNvdXJjZSwgbW9kdWxlUGF0aCwgJ2ltcG9ydHMnLCBpbXBvcnRUZXh0KTtcbiAgICBpZiAobWV0YWRhdGFDaGFuZ2VzKSB7XG4gICAgICBjb25zdCByZWNvcmRlciA9IGhvc3QuYmVnaW5VcGRhdGUobW9kdWxlUGF0aCk7XG4gICAgICBtZXRhZGF0YUNoYW5nZXMuZm9yRWFjaCgoY2hhbmdlOiBJbnNlcnRDaGFuZ2UpID0+IHtcbiAgICAgICAgcmVjb3JkZXIuaW5zZXJ0UmlnaHQoY2hhbmdlLnBvcywgY2hhbmdlLnRvQWRkKTtcbiAgICAgIH0pO1xuICAgICAgaG9zdC5jb21taXRVcGRhdGUocmVjb3JkZXIpO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gYWRkRXhwb3J0cyhvcHRpb25zOiBVbml2ZXJzYWxPcHRpb25zKTogUnVsZSB7XG4gIHJldHVybiAoaG9zdDogVHJlZSkgPT4ge1xuICAgIGNvbnN0IGNsaWVudFByb2plY3QgPSBnZXRQcm9qZWN0KGhvc3QsIG9wdGlvbnMuY2xpZW50UHJvamVjdCk7XG4gICAgY29uc3QgY2xpZW50VGFyZ2V0cyA9IGdldFByb2plY3RUYXJnZXRzKGNsaWVudFByb2plY3QpO1xuXG4gICAgaWYgKCFjbGllbnRUYXJnZXRzLnNlcnZlcikge1xuICAgICAgLy8gSWYgdGhleSBza2lwcGVkIFVuaXZlcnNhbCBzY2hlbWF0aWNzIGFuZCBkb24ndCBoYXZlIGEgc2VydmVyIHRhcmdldCxcbiAgICAgIC8vIGp1c3QgZ2V0IG91dFxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IG1haW5QYXRoID0gbm9ybWFsaXplKCcvJyArIGNsaWVudFRhcmdldHMuc2VydmVyLm9wdGlvbnMubWFpbik7XG4gICAgY29uc3QgbWFpblNvdXJjZUZpbGUgPSBnZXRUc1NvdXJjZUZpbGUoaG9zdCwgbWFpblBhdGgpO1xuICAgIGxldCBtYWluVGV4dCA9IGdldFRzU291cmNlVGV4dChob3N0LCBtYWluUGF0aCk7XG4gICAgY29uc3QgbWFpblJlY29yZGVyID0gaG9zdC5iZWdpblVwZGF0ZShtYWluUGF0aCk7XG4gICAgY29uc3QgZXhwcmVzc0VuZ2luZUV4cG9ydCA9IGdlbmVyYXRlRXhwb3J0KG1haW5Tb3VyY2VGaWxlLCBbJ25nRXhwcmVzc0VuZ2luZSddLFxuICAgICAgJ0BuZ3VuaXZlcnNhbC9leHByZXNzLWVuZ2luZScpO1xuICAgIGNvbnN0IG1vZHVsZU1hcEV4cG9ydCA9IGdlbmVyYXRlRXhwb3J0KG1haW5Tb3VyY2VGaWxlLCBbJ3Byb3ZpZGVNb2R1bGVNYXAnXSxcbiAgICAgICdAbmd1bml2ZXJzYWwvbW9kdWxlLW1hcC1uZ2ZhY3RvcnktbG9hZGVyJyk7XG4gICAgY29uc3QgZXhwb3J0cyA9IGZpbmROb2RlcyhtYWluU291cmNlRmlsZSwgdHMuU3ludGF4S2luZC5FeHBvcnREZWNsYXJhdGlvbik7XG4gICAgY29uc3QgYWRkZWRFeHBvcnRzID0gYFxcbiR7ZXhwcmVzc0VuZ2luZUV4cG9ydH1cXG4ke21vZHVsZU1hcEV4cG9ydH1cXG5gO1xuICAgIGNvbnN0IGV4cG9ydENoYW5nZSA9IGluc2VydEFmdGVyTGFzdE9jY3VycmVuY2UoZXhwb3J0cywgYWRkZWRFeHBvcnRzLCBtYWluVGV4dCxcbiAgICAgIDApIGFzIEluc2VydENoYW5nZTtcblxuICAgIG1haW5SZWNvcmRlci5pbnNlcnRMZWZ0KGV4cG9ydENoYW5nZS5wb3MsIGV4cG9ydENoYW5nZS50b0FkZCk7XG4gICAgaG9zdC5jb21taXRVcGRhdGUobWFpblJlY29yZGVyKTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gKG9wdGlvbnM6IFVuaXZlcnNhbE9wdGlvbnMpOiBSdWxlIHtcbiAgcmV0dXJuIChob3N0OiBUcmVlLCBjb250ZXh0OiBTY2hlbWF0aWNDb250ZXh0KSA9PiB7XG4gICAgY29uc3QgY2xpZW50UHJvamVjdCA9IGdldENsaWVudFByb2plY3QoaG9zdCwgb3B0aW9ucyk7XG4gICAgaWYgKGNsaWVudFByb2plY3QucHJvamVjdFR5cGUgIT09ICdhcHBsaWNhdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBTY2hlbWF0aWNzRXhjZXB0aW9uKGBVbml2ZXJzYWwgcmVxdWlyZXMgYSBwcm9qZWN0IHR5cGUgb2YgXCJhcHBsaWNhdGlvblwiLmApO1xuICAgIH1cblxuICAgIGlmICghb3B0aW9ucy5za2lwSW5zdGFsbCkge1xuICAgICAgY29udGV4dC5hZGRUYXNrKG5ldyBOb2RlUGFja2FnZUluc3RhbGxUYXNrKCkpO1xuICAgIH1cblxuICAgIGNvbnN0IHJvb3RTb3VyY2UgPSBhcHBseSh1cmwoJy4vZmlsZXMvcm9vdCcpLCBbXG4gICAgICBvcHRpb25zLnNraXBTZXJ2ZXIgPyBmaWx0ZXIocGF0aCA9PiAhcGF0aC5zdGFydHNXaXRoKCdfX3NlcnZlckZpbGVOYW1lJykpIDogbm9vcCgpLFxuICAgICAgb3B0aW9ucy53ZWJwYWNrID9cbiAgICAgICAgZmlsdGVyKHBhdGggPT4gIXBhdGguaW5jbHVkZXMoJ3RzY29uZmlnJykpIDogZmlsdGVyKHBhdGggPT4gIXBhdGguc3RhcnRzV2l0aCgnd2VicGFjaycpKSxcbiAgICAgIHRlbXBsYXRlKHtcbiAgICAgICAgLi4uc3RyaW5ncyxcbiAgICAgICAgLi4ub3B0aW9ucyBhcyBvYmplY3QsXG4gICAgICAgIHN0cmlwVHNFeHRlbnNpb246IChzOiBzdHJpbmcpID0+IHMucmVwbGFjZSgvXFwudHMkLywgJycpLFxuICAgICAgICBnZXRCcm93c2VyRGlzdERpcmVjdG9yeTogKCkgPT4gQlJPV1NFUl9ESVNULFxuICAgICAgICBnZXRTZXJ2ZXJEaXN0RGlyZWN0b3J5OiAoKSA9PiBTRVJWRVJfRElTVCxcbiAgICAgIH0pXG4gICAgXSk7XG5cbiAgICByZXR1cm4gY2hhaW4oW1xuICAgICAgb3B0aW9ucy5za2lwVW5pdmVyc2FsID9cbiAgICAgICAgbm9vcCgpIDogZXh0ZXJuYWxTY2hlbWF0aWMoJ0BzY2hlbWF0aWNzL2FuZ3VsYXInLCAndW5pdmVyc2FsJywgb3B0aW9ucyksXG4gICAgICB1cGRhdGVDb25maWdGaWxlKG9wdGlvbnMpLFxuICAgICAgbWVyZ2VXaXRoKHJvb3RTb3VyY2UpLFxuICAgICAgYWRkRGVwZW5kZW5jaWVzQW5kU2NyaXB0cyhvcHRpb25zKSxcbiAgICAgIGFkZE1vZHVsZU1hcExvYWRlcihvcHRpb25zKSxcbiAgICAgIGFkZEV4cG9ydHMob3B0aW9ucyksXG4gICAgXSk7XG4gIH07XG59XG4iXX0=