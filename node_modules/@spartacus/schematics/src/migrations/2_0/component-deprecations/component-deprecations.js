'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
const schematics_1 = require('@angular/cdk/schematics');
const change_1 = require('@schematics/angular/utility/change');
const constants_1 = require('../../../shared/constants');
const file_utils_1 = require('../../../shared/utils/file-utils');
const module_file_utils_1 = require('../../../shared/utils/module-file-utils');
const workspace_utils_1 = require('../../../shared/utils/workspace-utils');
const component_deprecations_data_1 = require('./component-deprecations-data');
function migrate() {
  return (tree, context) => {
    context.logger.info('Checking component selectors...');
    const project = workspace_utils_1.getSourceRoot(tree, {});
    const sourceFiles = file_utils_1.getAllTsSourceFiles(tree, project);
    for (const originalSource of sourceFiles) {
      const sourcePath = originalSource.fileName;
      const nodes = schematics_1.getSourceNodes(originalSource);
      for (const deprecatedComponent of component_deprecations_data_1.COMPONENT_DEPRECATION_DATA) {
        // check for usages of inputs / outputs of the deprecated component
        const sourceRoot = workspace_utils_1.getSourceRoot(tree);
        const allHtmlFiles = file_utils_1.getHtmlFiles(
          tree,
          '.html',
          sourceRoot
        );
        for (const htmlFile of allHtmlFiles) {
          for (const removedProperty of deprecatedComponent.removedInputOutputProperties ||
            []) {
            const buffer = tree.read(htmlFile);
            if (!buffer) {
              context.logger.warn(`Could not read file (${htmlFile}).`);
              continue;
            }
            const content = buffer.toString(constants_1.UTF_8);
            const contentChange = file_utils_1.insertComponentSelectorComment(
              content,
              deprecatedComponent.selector,
              removedProperty
            );
            if (contentChange) {
              tree.overwrite(htmlFile, contentChange);
            }
          }
        }
        // check for usages of the deprecated component properties in the .ts and the corresponding template (.html) files
        if (
          file_utils_1.isInheriting(
            nodes,
            deprecatedComponent.componentClassName
          )
        ) {
          for (const removedProperty of deprecatedComponent.removedProperties ||
            []) {
            // 'source' has to be reloaded after each committed change
            const source = file_utils_1.getTsSourceFile(tree, sourcePath);
            const changes = file_utils_1.insertCommentAboveIdentifier(
              sourcePath,
              source,
              removedProperty.name,
              file_utils_1.buildSpartacusComment(removedProperty.comment)
            );
            const templateInfo = module_file_utils_1.getTemplateInfo(source);
            if (!templateInfo) {
              file_utils_1.commitChanges(
                tree,
                sourcePath,
                changes,
                file_utils_1.InsertDirection.RIGHT
              );
              continue;
            }
            const htmlFileName = templateInfo.templateUrl;
            if (htmlFileName) {
              const htmlFilePath = file_utils_1.getHtmlFiles(
                tree,
                htmlFileName,
                sourceRoot
              )[0];
              const buffer = tree.read(htmlFilePath);
              if (!buffer) {
                context.logger.warn(`Could not read file (${htmlFilePath}).`);
                file_utils_1.commitChanges(
                  tree,
                  sourcePath,
                  changes,
                  file_utils_1.InsertDirection.RIGHT
                );
                continue;
              }
              const content = buffer.toString(constants_1.UTF_8);
              const contentChange = file_utils_1.insertHtmlComment(
                content,
                removedProperty
              );
              if (contentChange) {
                tree.overwrite(htmlFilePath, contentChange);
              }
            } else if (templateInfo.inlineTemplateContent) {
              const oldContent = templateInfo.inlineTemplateContent;
              const contentChange = file_utils_1.insertHtmlComment(
                oldContent,
                removedProperty
              );
              if (contentChange) {
                const replaceChange = new change_1.ReplaceChange(
                  sourcePath,
                  templateInfo.inlineTemplateStart || 0,
                  oldContent,
                  contentChange
                );
                changes.push(replaceChange);
              }
            }
            file_utils_1.commitChanges(
              tree,
              sourcePath,
              changes,
              file_utils_1.InsertDirection.RIGHT
            );
          }
        }
      }
    }
    return tree;
  };
}
exports.migrate = migrate;
//# sourceMappingURL=component-deprecations.js.map
