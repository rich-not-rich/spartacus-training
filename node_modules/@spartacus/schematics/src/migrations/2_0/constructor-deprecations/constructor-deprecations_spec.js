'use strict';
var __awaiter =
  (this && this.__awaiter) ||
  function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P
        ? value
        : new P(function(resolve) {
            resolve(value);
          });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator['throw'](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done
          ? resolve(result.value)
          : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
var __importStar =
  (this && this.__importStar) ||
  function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null)
      for (var k in mod)
        if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result['default'] = mod;
    return result;
  };
Object.defineProperty(exports, '__esModule', { value: true });
const core_1 = require('@angular-devkit/core');
const testing_1 = require('@angular-devkit/core/node/testing');
const schematics_1 = require('@angular-devkit/schematics');
const testing_2 = require('@angular-devkit/schematics/testing');
const ast_utils_1 = require('@schematics/angular/utility/ast-utils');
const shx = __importStar(require('shelljs'));
const ts = __importStar(require('typescript'));
const constants_1 = require('../../../shared/constants');
const test_utils_1 = require('../../../shared/utils/test-utils');
const MIGRATION_SCRIPT_NAME = 'migration-v2-constructor-deprecations-03';
const NOT_INHERITING_SPARTACUS_CLASS = `
    import { Store } from '@ngrx/store';
    import { StateWithProcess, StateWithUser } from '@spartacus/core';
    export class InheritingService {
      constructor(_store: Store<StateWithUser | StateWithProcess<void>>) {}
    }
`;
const NO_CONSTRUCTOR = `
    import { UserAddressService } from '@spartacus/core';
    import { Store } from '@ngrx/store';
    export class InheritingService extends UserAddressService {}
`;
const WRONG_PARAM_ORDER_BUT_VALID = `
import { ChangeDetectorRef } from '@angular/core';
import { CartService } from '@spartacus/core';
import {
  AddToCartComponent,
  CurrentProductService,
  ModalService,
} from '@spartacus/storefront';
export class InheritingService extends AddToCartComponent {
  constructor(
    modalService: ModalService,
    currentProductService: CurrentProductService,
    cartService: CartService,
    changeDetectorRef: ChangeDetectorRef
  ) {
    super(cartService, modalService, currentProductService, changeDetectorRef);
  }
}
`;
const WRONG_PARAM_ORDER_EXPECTED = `
import { ChangeDetectorRef } from '@angular/core';
import {  ActiveCartService } from '@spartacus/core';
import {
  AddToCartComponent,
  CurrentProductService,
  ModalService,
} from '@spartacus/storefront';
export class InheritingService extends AddToCartComponent {
  constructor(
    modalService: ModalService,
    currentProductService: CurrentProductService
    ,
    changeDetectorRef: ChangeDetectorRef, activeCartService: ActiveCartService
  ) {
    super( modalService, currentProductService, changeDetectorRef, activeCartService);
  }
}
`;
const NO_SUPER_CALL = `
    import { Store } from '@ngrx/store';
    import {
      StateWithProcess,
      StateWithUser,
      UserAddressService
    } from '@spartacus/core';
    export class InheritingService extends UserAddressService {
      constructor(store: Store<StateWithUser | StateWithProcess<void>>) {}
    }
`;
const CALL_EXPRESSION_NO_SUPER = `
    import { Store } from '@ngrx/store';
    import {
      StateWithProcess,
      StateWithUser,
      UserAddressService
    } from '@spartacus/core';
    export class InheritingService extends UserAddressService {
      constructor(store: Store<StateWithUser | StateWithProcess<void>>) {
        console.log(Math.random());
      }
    }
`;
const ADD_PARAMETER_VALID_TEST_CLASS = `
    import { Store } from '@ngrx/store';
    import {
      StateWithProcess,
      StateWithUser,
      UserAddressService
    } from '@spartacus/core';
    export class InheritedService extends UserAddressService {
      constructor(store: Store<StateWithUser | StateWithProcess<void>>) {
        super(store);
      }
    }
`;
const ADD_PARAMETER_WITH_ADDITIONAL_INJECTED_SERVICE_VALID_TEST_CLASS = `
    import { ActionsSubject, Store } from '@ngrx/store';
    import {
      StateWithProcess,
      StateWithUser,
      UserAddressService
    } from '@spartacus/core';
    export class InheritedService extends UserAddressService {
      constructor(
        store: Store<StateWithUser | StateWithProcess<void>>,
        private actions: ActionsSubject
      ) {
        super(store);
        console.log(this.actions);
      }
    }
`;
const ADD_PARAMETER_WITH_ALREADY_ADDED_SERVICE_VALID_TEST_CLASS = `
import { ActionsSubject, Store } from '@ngrx/store';
import {
  StateWithProcess,
  StateWithUser,
  UserAddressService,
  AuthService
} from '@spartacus/core';
export class InheritedService extends UserAddressService {
  constructor(
    store: Store<StateWithUser | StateWithProcess<void>>,
    private auth: AuthService,
  ) {
    super(store);
  }
}
`;
const ADD_PARAMETER_WITH_ALREADY_ADDED_SERVICE_EXPECTED_CLASS = `
import { ActionsSubject, Store } from '@ngrx/store';
import {
  StateWithProcess,
  StateWithUser,
  UserAddressService,
  AuthService
} from '@spartacus/core';
export class InheritedService extends UserAddressService {
  constructor(
    store: Store<StateWithUser | StateWithProcess<void>>,
    private auth: AuthService,
  ) {
    super(store, auth);
  }
}
`;
const REMOVE_PARAMETER_VALID_TEST_CLASS = `
import { Dummy } from '@angular/core';
import {
  CmsService,
  FeatureConfigService,
  PageMetaResolver,
  PageMetaService
} from '@spartacus/core';
export class Test extends PageMetaService {
  constructor(
    resolvers: PageMetaResolver[],
    cms: CmsService,
    featureConfigService?: FeatureConfigService
  ) {
    super(resolvers, cms, featureConfigService);
  }
}
`;
const REMOVE_PARAMETER_EXPECTED_CLASS = `
import { Dummy } from '@angular/core';
import {
  CmsService,
  
  PageMetaResolver,
  PageMetaService
} from '@spartacus/core';
export class Test extends PageMetaService {
  constructor(
    resolvers: PageMetaResolver[],
    cms: CmsService
    
  ) {
    super(resolvers, cms );
  }
}
`;
const REMOVE_PARAMETER_WITH_ADDITIONAL_INJECTED_SERVICE_VALID_TEST_CLASS = `
import { ActionsSubject } from '@ngrx/store';
import {
  CmsService,
  FeatureConfigService,
  PageMetaResolver,
  PageMetaService
} from '@spartacus/core';
export class Test extends PageMetaService {
  constructor(
    resolvers: PageMetaResolver[],
    cms: CmsService,
    featureConfigService: FeatureConfigService,
    private actions: ActionsSubject
  ) {
    super(resolvers, cms, featureConfigService);
    console.log(this.actions);
  }
}
`;
const REMOVE_PARAMETER_WITH_ADDITIONAL_INJECTED_SERVICE_EXPECTED_CLASS = `
import { ActionsSubject } from '@ngrx/store';
import {
  CmsService,
  
  PageMetaResolver,
  PageMetaService
} from '@spartacus/core';
export class Test extends PageMetaService {
  constructor(
    resolvers: PageMetaResolver[],
    cms: CmsService
    ,
    private actions: ActionsSubject
  ) {
    super(resolvers, cms );
    console.log(this.actions);
  }
}
`;
const REMOVE_PARAMETER_BUT_NOT_IMPORT_VALID_TEST_CLASS = `
import {
  CmsService,
  FeatureConfigService,
  PageMetaResolver,
  PageMetaService
} from '@spartacus/core';
export class Test extends PageMetaService {
  constructor(
    resolvers: PageMetaResolver[],
    cms: CmsService,
    featureConfigService: FeatureConfigService
  ) {
    super(resolvers, cms, featureConfigService);
  }
  test(): void {
    console.log(this.featureConfigService);
  }
}
`;
const REMOVE_PARAMETER_BUT_NOT_IMPORT_EXPECTED_CLASS = `
import {
  CmsService,
  FeatureConfigService,
  PageMetaResolver,
  PageMetaService
} from '@spartacus/core';
export class Test extends PageMetaService {
  constructor(
    resolvers: PageMetaResolver[],
    cms: CmsService,
    featureConfigService: FeatureConfigService
  ) {
    super(resolvers, cms );
  }
  test(): void {
    console.log(this.featureConfigService);
  }
}
`;
const ADD_AND_REMOVE_PARAMETER_VALID_TEST_CLASS = `
    import { Store } from '@ngrx/store';
    import { StateWithCheckout, CheckoutService, CartDataService } from '@spartacus/core';
    export class InheritingService extends CheckoutService {
      constructor(store: Store<StateWithCheckout>, cartDataService: CartDataService) {
        super(store, cartDataService);
      }
    }
`;
const ADD_AND_REMOVE_PARAMETER_EXPECTED_CLASS = `
    import { Store } from '@ngrx/store';
    import { StateWithCheckout, CheckoutService,  AuthService, ActiveCartService } from '@spartacus/core';
    export class InheritingService extends CheckoutService {
      constructor(store: Store<StateWithCheckout> , authService: AuthService, activeCartService: ActiveCartService) {
        super(store , authService, activeCartService);
      }
    }
`;
const CART_PAGE_LAYOUT_HANDLER = `
    import { CartPageLayoutHandler } from '@spartacus/storefront';
    import { CartService } from '@spartacus/core';
    export class InheritingService extends CartPageLayoutHandler {
      constructor(cartService: CartService) {
        super(cartService);
      }
    }
`;
const CART_PAGE_LAYOUT_HANDLER_EXPECTED = `
    import { CartPageLayoutHandler } from '@spartacus/storefront';
    import {  ActiveCartService, SelectiveCartService } from '@spartacus/core';
    export class InheritingService extends CartPageLayoutHandler {
      constructor( activeCartService: ActiveCartService, selectiveCartService: SelectiveCartService) {
        super( activeCartService, selectiveCartService);
      }
    }
`;
describe('constructor migrations', () => {
  let host = new testing_1.TempScopedNodeJsSyncHost();
  let appTree = schematics_1.Tree.empty();
  let schematicRunner;
  let tmpDirPath;
  let previousWorkingDir;
  beforeEach(() => {
    schematicRunner = new testing_2.SchematicTestRunner(
      'test',
      require.resolve('../../migrations.json')
    );
    host = new testing_1.TempScopedNodeJsSyncHost();
    appTree = new testing_2.UnitTestTree(new schematics_1.HostTree(host));
    test_utils_1.writeFile(
      host,
      '/tsconfig.json',
      JSON.stringify({
        compilerOptions: {
          lib: ['es2015'],
        },
      })
    );
    test_utils_1.writeFile(
      host,
      '/angular.json',
      JSON.stringify({
        projects: {
          'spartacus-test': {
            sourceRoot: 'src',
            test: {
              architect: {
                build: { options: { tsConfig: './tsconfig.json' } },
              },
            },
          },
        },
      })
    );
    previousWorkingDir = shx.pwd();
    tmpDirPath = core_1.getSystemPath(host.root);
    // Switch into the temporary directory path. This allows us to run
    // the schematic against our custom unit test tree.
    shx.cd(tmpDirPath);
  });
  afterEach(() => {
    shx.cd(previousWorkingDir);
    shx.rm('-r', tmpDirPath);
  });
  describe('when the class does NOT extend a Spartacus class', () => {
    it('should skip it', () =>
      __awaiter(void 0, void 0, void 0, function*() {
        test_utils_1.writeFile(
          host,
          '/src/index.ts',
          NOT_INHERITING_SPARTACUS_CLASS
        );
        yield test_utils_1.runMigration(
          appTree,
          schematicRunner,
          MIGRATION_SCRIPT_NAME
        );
        const content = appTree.readContent('/src/index.ts');
        expect(content).toEqual(NOT_INHERITING_SPARTACUS_CLASS);
      }));
  });
  describe('when the class does NOT have a constructor', () => {
    it('should skip it', () =>
      __awaiter(void 0, void 0, void 0, function*() {
        test_utils_1.writeFile(host, '/src/index.ts', NO_CONSTRUCTOR);
        yield test_utils_1.runMigration(
          appTree,
          schematicRunner,
          MIGRATION_SCRIPT_NAME
        );
        const content = appTree.readContent('/src/index.ts');
        expect(content).toEqual(NO_CONSTRUCTOR);
      }));
  });
  describe('when the class has the wrong param order', () => {
    it('should NOT skip it', () =>
      __awaiter(void 0, void 0, void 0, function*() {
        test_utils_1.writeFile(
          host,
          '/src/index.ts',
          WRONG_PARAM_ORDER_BUT_VALID
        );
        yield test_utils_1.runMigration(
          appTree,
          schematicRunner,
          MIGRATION_SCRIPT_NAME
        );
        const content = appTree.readContent('/src/index.ts');
        expect(content).toEqual(WRONG_PARAM_ORDER_EXPECTED);
      }));
  });
  describe('when the class does NOT have a super call', () => {
    it('should skip it', () =>
      __awaiter(void 0, void 0, void 0, function*() {
        test_utils_1.writeFile(host, '/src/index.ts', NO_SUPER_CALL);
        yield test_utils_1.runMigration(
          appTree,
          schematicRunner,
          MIGRATION_SCRIPT_NAME
        );
        const content = appTree.readContent('/src/index.ts');
        expect(content).toEqual(NO_SUPER_CALL);
      }));
  });
  describe('when the class has a CallExpression node which is NOT of type super', () => {
    it('should skip it', () =>
      __awaiter(void 0, void 0, void 0, function*() {
        const filePath = '/src/index.ts';
        test_utils_1.writeFile(host, filePath, CALL_EXPRESSION_NO_SUPER);
        yield test_utils_1.runMigration(
          appTree,
          schematicRunner,
          MIGRATION_SCRIPT_NAME
        );
        const content = appTree.readContent(filePath);
        expect(content).toEqual(CALL_EXPRESSION_NO_SUPER);
      }));
  });
  describe('when all the pre-conditions are valid for adding a parameter', () => {
    it('should just append the missing parameters', () =>
      __awaiter(void 0, void 0, void 0, function*() {
        const filePath = '/src/index.ts';
        test_utils_1.writeFile(host, filePath, ADD_PARAMETER_VALID_TEST_CLASS);
        yield test_utils_1.runMigration(
          appTree,
          schematicRunner,
          MIGRATION_SCRIPT_NAME
        );
        const content = appTree.readContent(filePath);
        const source = ts.createSourceFile(
          filePath,
          content,
          ts.ScriptTarget.Latest,
          true
        );
        const nodes = ast_utils_1.getSourceNodes(source);
        const constructorNode = test_utils_1.getConstructor(nodes);
        const params = test_utils_1.getParams(constructorNode, [
          core_1.strings.camelize(constants_1.STORE),
          core_1.strings.camelize(constants_1.AUTH_SERVICE),
        ]);
        expect(params).toEqual([
          core_1.strings.camelize(constants_1.STORE),
          core_1.strings.camelize(constants_1.AUTH_SERVICE),
        ]);
        expect(
          ast_utils_1.isImported(
            source,
            constants_1.AUTH_SERVICE,
            constants_1.SPARTACUS_CORE
          )
        ).toEqual(true);
      }));
    describe('when the class has additional services injected', () => {
      it('should just append the missing parameters', () =>
        __awaiter(void 0, void 0, void 0, function*() {
          const filePath = '/src/index.ts';
          test_utils_1.writeFile(
            host,
            filePath,
            ADD_PARAMETER_WITH_ADDITIONAL_INJECTED_SERVICE_VALID_TEST_CLASS
          );
          yield test_utils_1.runMigration(
            appTree,
            schematicRunner,
            MIGRATION_SCRIPT_NAME
          );
          const content = appTree.readContent(filePath);
          const source = ts.createSourceFile(
            filePath,
            content,
            ts.ScriptTarget.Latest,
            true
          );
          const nodes = ast_utils_1.getSourceNodes(source);
          const constructorNode = test_utils_1.getConstructor(nodes);
          const params = test_utils_1.getParams(constructorNode, [
            core_1.strings.camelize(constants_1.STORE),
            core_1.strings.camelize(constants_1.AUTH_SERVICE),
          ]);
          expect(params).toEqual([
            core_1.strings.camelize(constants_1.STORE),
            core_1.strings.camelize(constants_1.AUTH_SERVICE),
          ]);
          expect(
            ast_utils_1.isImported(
              source,
              constants_1.AUTH_SERVICE,
              constants_1.SPARTACUS_CORE
            )
          ).toEqual(true);
        }));
    });
    describe('when the service to be added is already injected', () => {
      it('should just not add the parameter', () =>
        __awaiter(void 0, void 0, void 0, function*() {
          const filePath = '/src/index.ts';
          test_utils_1.writeFile(
            host,
            filePath,
            ADD_PARAMETER_WITH_ALREADY_ADDED_SERVICE_VALID_TEST_CLASS
          );
          yield test_utils_1.runMigration(
            appTree,
            schematicRunner,
            MIGRATION_SCRIPT_NAME
          );
          const content = appTree.readContent(filePath);
          expect(content).toEqual(
            ADD_PARAMETER_WITH_ALREADY_ADDED_SERVICE_EXPECTED_CLASS
          );
        }));
    });
  });
  describe('when all the pre-conditions are valid for removing a parameter', () => {
    it('should make the required changes', () =>
      __awaiter(void 0, void 0, void 0, function*() {
        test_utils_1.writeFile(
          host,
          '/src/index.ts',
          REMOVE_PARAMETER_VALID_TEST_CLASS
        );
        yield test_utils_1.runMigration(
          appTree,
          schematicRunner,
          MIGRATION_SCRIPT_NAME
        );
        const content = appTree.readContent('/src/index.ts');
        expect(content).toEqual(REMOVE_PARAMETER_EXPECTED_CLASS);
      }));
    describe('when an additional parameter is injected', () => {
      it('should make the required changes', () =>
        __awaiter(void 0, void 0, void 0, function*() {
          test_utils_1.writeFile(
            host,
            '/src/index.ts',
            REMOVE_PARAMETER_WITH_ADDITIONAL_INJECTED_SERVICE_VALID_TEST_CLASS
          );
          yield test_utils_1.runMigration(
            appTree,
            schematicRunner,
            MIGRATION_SCRIPT_NAME
          );
          const content = appTree.readContent('/src/index.ts');
          expect(content).toEqual(
            REMOVE_PARAMETER_WITH_ADDITIONAL_INJECTED_SERVICE_EXPECTED_CLASS
          );
        }));
    });
    describe('when the param to be removed is being used elsewhere', () => {
      it('should make the required changes, but not remove the import and param from the ctor', () =>
        __awaiter(void 0, void 0, void 0, function*() {
          test_utils_1.writeFile(
            host,
            '/src/index.ts',
            REMOVE_PARAMETER_BUT_NOT_IMPORT_VALID_TEST_CLASS
          );
          yield test_utils_1.runMigration(
            appTree,
            schematicRunner,
            MIGRATION_SCRIPT_NAME
          );
          const content = appTree.readContent('/src/index.ts');
          expect(content).toEqual(
            REMOVE_PARAMETER_BUT_NOT_IMPORT_EXPECTED_CLASS
          );
        }));
    });
    describe('when the first constructor parameter should be removed', () => {
      it('should remove the trailing comma as well', () =>
        __awaiter(void 0, void 0, void 0, function*() {
          test_utils_1.writeFile(
            host,
            '/src/index.ts',
            CART_PAGE_LAYOUT_HANDLER
          );
          yield test_utils_1.runMigration(
            appTree,
            schematicRunner,
            MIGRATION_SCRIPT_NAME
          );
          const content = appTree.readContent('/src/index.ts');
          expect(content).toEqual(CART_PAGE_LAYOUT_HANDLER_EXPECTED);
        }));
    });
  });
  describe('when all the pre-conditions are valid for adding and removing parameters', () => {
    it('should make the required changes', () =>
      __awaiter(void 0, void 0, void 0, function*() {
        test_utils_1.writeFile(
          host,
          '/src/index.ts',
          ADD_AND_REMOVE_PARAMETER_VALID_TEST_CLASS
        );
        yield test_utils_1.runMigration(
          appTree,
          schematicRunner,
          MIGRATION_SCRIPT_NAME
        );
        const content = appTree.readContent('/src/index.ts');
        expect(content).toEqual(ADD_AND_REMOVE_PARAMETER_EXPECTED_CLASS);
      }));
  });
  describe('when all the pre-conditions are valid for adding and removing parameters', () => {
    it('should make the required changes', () =>
      __awaiter(void 0, void 0, void 0, function*() {
        test_utils_1.writeFile(
          host,
          '/src/index.ts',
          ADD_AND_REMOVE_PARAMETER_VALID_TEST_CLASS
        );
        yield test_utils_1.runMigration(
          appTree,
          schematicRunner,
          MIGRATION_SCRIPT_NAME
        );
        const content = appTree.readContent('/src/index.ts');
        expect(content).toEqual(ADD_AND_REMOVE_PARAMETER_EXPECTED_CLASS);
      }));
  });
});
//# sourceMappingURL=constructor-deprecations_spec.js.map
