"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const terminal_1 = require("@angular-devkit/core/src/terminal");
const schematics_1 = require("@angular-devkit/schematics");
const tasks_1 = require("@angular-devkit/schematics/tasks");
const schematics_2 = require("@angular/cdk/schematics");
const dependencies_1 = require("@schematics/angular/utility/dependencies");
const ng_ast_utils_1 = require("@schematics/angular/utility/ng-ast-utils");
const project_targets_1 = require("@schematics/angular/utility/project-targets");
const file_utils_1 = require("../shared/utils/file-utils");
const module_file_utils_1 = require("../shared/utils/module-file-utils");
const package_utils_1 = require("../shared/utils/package-utils");
const workspace_utils_1 = require("../shared/utils/workspace-utils");
function addPackageJsonDependencies() {
    return (tree, context) => {
        const spartacusVersion = `^${package_utils_1.getSpartacusSchematicsVersion()}`;
        const ngrxVersion = '^8.3.0';
        const angularVersion = package_utils_1.getAngularVersion(tree);
        const dependencies = [
            {
                type: dependencies_1.NodeDependencyType.Default,
                version: spartacusVersion,
                name: '@spartacus/core',
            },
            {
                type: dependencies_1.NodeDependencyType.Default,
                version: spartacusVersion,
                name: '@spartacus/storefront',
            },
            {
                type: dependencies_1.NodeDependencyType.Default,
                version: spartacusVersion,
                name: '@spartacus/assets',
            },
            {
                type: dependencies_1.NodeDependencyType.Default,
                version: spartacusVersion,
                name: '@spartacus/styles',
            },
            {
                type: dependencies_1.NodeDependencyType.Default,
                version: '^4.1.0',
                name: '@ng-bootstrap/ng-bootstrap',
            },
            {
                type: dependencies_1.NodeDependencyType.Default,
                version: '^2.13.2',
                name: '@ng-select/ng-select',
            },
            {
                type: dependencies_1.NodeDependencyType.Default,
                version: ngrxVersion,
                name: '@ngrx/store',
            },
            {
                type: dependencies_1.NodeDependencyType.Default,
                version: ngrxVersion,
                name: '@ngrx/effects',
            },
            {
                type: dependencies_1.NodeDependencyType.Default,
                version: ngrxVersion,
                name: '@ngrx/router-store',
            },
            {
                type: dependencies_1.NodeDependencyType.Default,
                version: '^4.2.1',
                name: 'bootstrap',
            },
            { type: dependencies_1.NodeDependencyType.Default, version: '^15.0.6', name: 'i18next' },
            {
                type: dependencies_1.NodeDependencyType.Default,
                version: '^2.0.1',
                name: 'i18next-xhr-backend',
            },
            {
                type: dependencies_1.NodeDependencyType.Default,
                version: angularVersion || '~8.2.5',
                name: '@angular/service-worker',
            },
            {
                type: dependencies_1.NodeDependencyType.Default,
                version: '^8.0.0',
                name: 'ngx-infinite-scroll',
            },
        ];
        dependencies.forEach(dependency => {
            dependencies_1.addPackageJsonDependency(tree, dependency);
            context.logger.log('info', `✅️ Added '${dependency.name}' into ${dependency.type}`);
        });
        return tree;
    };
}
function installPackageJsonDependencies() {
    return (tree, context) => {
        context.addTask(new tasks_1.NodePackageInstallTask());
        context.logger.log('info', `🔍 Installing packages...`);
        return tree;
    };
}
function getStorefrontConfig(options) {
    const baseUrlPart = `\n          baseUrl: '${options.baseUrl}',`;
    const contextContent = !options.baseSite
        ? ''
        : `
      context: {
        baseSite: ['${options.baseSite}']
      },`;
    return `{
      backend: {
        occ: {${options.useMetaTags ? '' : baseUrlPart}
          prefix: '/rest/v2/'
        }
      },${contextContent}
      i18n: {
        resources: translations,
        chunks: translationChunksConfig,
        fallbackLang: 'en'
      },
      features: {
        level: '${options.featureLevel || package_utils_1.getSpartacusCurrentFeatureLevel()}',
        anonymousConsents: true
      }
    }`;
}
function updateAppModule(options) {
    return (host, context) => {
        context.logger.debug('Updating main module');
        // find app module
        const projectTargets = project_targets_1.getProjectTargets(host, options.project);
        if (!projectTargets.build) {
            throw new schematics_1.SchematicsException(`Project target "build" not found.`);
        }
        const mainPath = projectTargets.build.options.main;
        const modulePath = ng_ast_utils_1.getAppModulePath(host, mainPath);
        context.logger.debug(`main module path: ${modulePath}`);
        // add imports
        module_file_utils_1.addImport(host, modulePath, 'translations', '@spartacus/assets');
        module_file_utils_1.addImport(host, modulePath, 'translationChunksConfig', '@spartacus/assets');
        module_file_utils_1.addImport(host, modulePath, 'B2cStorefrontModule', '@spartacus/storefront');
        module_file_utils_1.addToModuleImportsAndCommitChanges(host, modulePath, `B2cStorefrontModule.withConfig(${getStorefrontConfig(options)})`);
        return host;
    };
}
function installStyles(project) {
    return (host) => {
        const styleFilePath = schematics_2.getProjectStyleFile(project);
        if (!styleFilePath) {
            console.warn(terminal_1.red(`Could not find the default style file for this project.`));
            console.warn(terminal_1.red(`Please consider manually setting up spartacus styles`));
            return;
        }
        if (styleFilePath.split('.').pop() !== 'scss') {
            console.warn(terminal_1.red(`Could not find the default SCSS style file for this project. `));
            console.warn(terminal_1.red(`Please make sure your project is configured with SCSS and consider manually setting up spartacus styles.`));
            return;
        }
        const buffer = host.read(styleFilePath);
        if (!buffer) {
            console.warn(terminal_1.red(`Could not read the default style file within the project ` +
                `(${terminal_1.italic(styleFilePath)})`));
            console.warn(terminal_1.red(`Please consider manually importing spartacus styles.`));
            return;
        }
        const htmlContent = buffer.toString();
        const insertion = '\n' + `@import '~@spartacus/styles/index';\n`;
        if (htmlContent.includes(insertion)) {
            return;
        }
        const recorder = host.beginUpdate(styleFilePath);
        recorder.insertLeft(htmlContent.length, insertion);
        host.commitUpdate(recorder);
    };
}
function updateMainComponent(project, options) {
    return (host, _context) => {
        const filePath = project.sourceRoot + '/app/app.component.html';
        const buffer = host.read(filePath);
        if (!buffer) {
            console.warn(terminal_1.red(`Could not read app.component.html file.`));
            return;
        }
        const htmlContent = buffer.toString();
        const insertion = '\n' + `<cx-storefront></cx-storefront>\n`;
        if (htmlContent.includes(insertion)) {
            return;
        }
        const recorder = host.beginUpdate(filePath);
        if (options && options.overwriteAppComponent) {
            recorder.remove(0, htmlContent.length);
            recorder.insertLeft(0, insertion);
        }
        else {
            recorder.insertLeft(htmlContent.length, insertion);
        }
        host.commitUpdate(recorder);
        return host;
    };
}
function updateIndexFile(project, options) {
    return (host) => {
        const projectIndexHtmlPath = file_utils_1.getIndexHtmlPath(project);
        const baseUrl = options.baseUrl || 'OCC_BACKEND_BASE_URL_VALUE';
        const metaTags = [
            `<meta name="occ-backend-base-url" content="${baseUrl}" />`,
            `<meta name="media-backend-base-url" content="MEDIA_BACKEND_BASE_URL_VALUE" />`,
        ];
        metaTags.forEach(metaTag => {
            schematics_2.appendHtmlElementToHead(host, projectIndexHtmlPath, metaTag);
        });
        return host;
    };
}
function addSpartacus(options) {
    return (tree, context) => {
        const possibleProjectFiles = ['/angular.json', '/.angular.json'];
        const project = workspace_utils_1.getProjectFromWorkspace(tree, options, possibleProjectFiles);
        return schematics_1.chain([
            addPackageJsonDependencies(),
            updateAppModule(options),
            installStyles(project),
            updateMainComponent(project, options),
            options.useMetaTags ? updateIndexFile(project, options) : schematics_1.noop(),
            installPackageJsonDependencies(),
        ])(tree, context);
    };
}
exports.addSpartacus = addSpartacus;
//# sourceMappingURL=index.js.map