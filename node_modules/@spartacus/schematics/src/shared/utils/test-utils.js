'use strict';
var __importStar =
  (this && this.__importStar) ||
  function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null)
      for (var k in mod)
        if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result['default'] = mod;
    return result;
  };
Object.defineProperty(exports, '__esModule', { value: true });
const core_1 = require('@angular-devkit/core');
const ast_utils_1 = require('@schematics/angular/utility/ast-utils');
const ts = __importStar(require('typescript'));
const file_utils_1 = require('./file-utils');
function writeFile(host, filePath, contents) {
  host.sync.write(
    core_1.normalize(filePath),
    core_1.virtualFs.stringToFileBuffer(contents)
  );
}
exports.writeFile = writeFile;
function runMigration(appTree, schematicRunner, migrationScript, options = {}) {
  return schematicRunner
    .runSchematicAsync(migrationScript, options, appTree)
    .toPromise();
}
exports.runMigration = runMigration;
function getConstructor(nodes) {
  const constructorNode = file_utils_1.findConstructor(nodes);
  if (!constructorNode) {
    throw new Error('No constructor node found');
  }
  return constructorNode;
}
exports.getConstructor = getConstructor;
function getSuperNode(constructorNode) {
  const superNodes = ast_utils_1.findNodes(
    constructorNode,
    ts.SyntaxKind.SuperKeyword
  );
  if (!superNodes || superNodes.length === 0) {
    return undefined;
  }
  return superNodes[0];
}
exports.getSuperNode = getSuperNode;
function getParams(constructorNode, camelizedParamNames) {
  const superNode = getSuperNode(constructorNode);
  if (!superNode) {
    throw new Error('No super() node found');
  }
  const callExpressions = ast_utils_1.findNodes(
    constructorNode,
    ts.SyntaxKind.CallExpression
  );
  if (!callExpressions || callExpressions.length === 0) {
    throw new Error('No call expressions found in constructor');
  }
  const params = ast_utils_1.findNodes(
    callExpressions[0],
    ts.SyntaxKind.Identifier
  );
  camelizedParamNames = camelizedParamNames.map(param =>
    core_1.strings.camelize(param)
  );
  return params
    .filter(n => n.kind === ts.SyntaxKind.Identifier)
    .map(n => n.getText())
    .filter(text => camelizedParamNames.includes(text));
}
exports.getParams = getParams;
//# sourceMappingURL=test-utils.js.map
