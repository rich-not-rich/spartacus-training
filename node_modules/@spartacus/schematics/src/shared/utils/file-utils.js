"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const core_1 = require("@angular-devkit/core");
const schematics_1 = require("@angular-devkit/schematics");
const schematics_2 = require("@angular/cdk/schematics");
const change_1 = require("@schematics/angular/utility/change");
const ts = __importStar(require("typescript"));
function getTsSourceFile(tree, path) {
    const buffer = tree.read(path);
    if (!buffer) {
        throw new schematics_1.SchematicsException(`Could not read file (${path}).`);
    }
    const content = buffer.toString();
    const source = ts.createSourceFile(path, content, ts.ScriptTarget.Latest, true);
    return source;
}
exports.getTsSourceFile = getTsSourceFile;
function getIndexHtmlPath(project) {
    const buildOptions = schematics_2.getProjectTargetOptions(project, 'build');
    if (!buildOptions.index) {
        throw new schematics_1.SchematicsException('"index.html" file not found.');
    }
    return buildOptions.index;
}
exports.getIndexHtmlPath = getIndexHtmlPath;
function getPathResultsForFile(tree, file, directory) {
    const results = [];
    const dir = directory || '/';
    tree.getDir(dir).visit(filePath => {
        if (filePath.endsWith(file)) {
            results.push(filePath);
        }
    });
    return results;
}
exports.getPathResultsForFile = getPathResultsForFile;
var InsertDirection;
(function (InsertDirection) {
    InsertDirection[InsertDirection["LEFT"] = 0] = "LEFT";
    InsertDirection[InsertDirection["RIGHT"] = 1] = "RIGHT";
})(InsertDirection = exports.InsertDirection || (exports.InsertDirection = {}));
function commitChanges(host, path, changes, insertDirection) {
    if (!changes) {
        return;
    }
    const recorder = host.beginUpdate(path);
    changes.forEach(change => {
        const pos = change.pos;
        const toAdd = change.toAdd;
        if (insertDirection === InsertDirection.LEFT) {
            recorder.insertLeft(pos, toAdd);
        }
        else {
            recorder.insertRight(pos, toAdd);
        }
    });
    host.commitUpdate(recorder);
}
exports.commitChanges = commitChanges;
function defineProperty(nodes, path, toAdd) {
    const constructorNode = nodes.find(n => n.kind === ts.SyntaxKind.Constructor);
    if (!constructorNode) {
        throw new schematics_1.SchematicsException(`No constructor found in ${path}.`);
    }
    return new change_1.InsertChange(path, constructorNode.pos + 1, toAdd);
}
exports.defineProperty = defineProperty;
function injectService(nodes, path, serviceName, propertyName) {
    const constructorNode = nodes.find(n => n.kind === ts.SyntaxKind.Constructor);
    if (!constructorNode) {
        throw new schematics_1.SchematicsException(`No constructor found in ${path}.`);
    }
    const parameterListNode = constructorNode
        .getChildren()
        .find(n => n.kind === ts.SyntaxKind.SyntaxList);
    if (!parameterListNode) {
        throw new schematics_1.SchematicsException(`No no parameter list found in ${path}'s constructor.`);
    }
    propertyName = propertyName
        ? core_1.strings.camelize(propertyName)
        : core_1.strings.camelize(serviceName);
    const toAdd = `private ${propertyName}: ${core_1.strings.classify(serviceName)}`;
    return new change_1.InsertChange(path, parameterListNode.pos, toAdd);
}
exports.injectService = injectService;
// as this is copied from https://github.com/angular/angular-cli/blob/master/packages/schematics/angular/app-shell/index.ts#L211, no need to test Angular's code
function getMetadataProperty(metadata, propertyName) {
    const properties = metadata.properties;
    const property = properties
        .filter(prop => prop.kind === ts.SyntaxKind.PropertyAssignment)
        .filter((prop) => {
        const name = prop.name;
        switch (name.kind) {
            case ts.SyntaxKind.Identifier:
                return name.getText() === propertyName;
            case ts.SyntaxKind.StringLiteral:
                return name.text === propertyName;
        }
        return false;
    })[0];
    return property;
}
exports.getMetadataProperty = getMetadataProperty;
//# sourceMappingURL=file-utils.js.map