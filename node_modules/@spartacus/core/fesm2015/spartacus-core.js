import { InjectionToken, isDevMode, Optional, NgModule, PLATFORM_ID, Injectable, Inject, ɵɵdefineInjectable, ɵɵinject, APP_INITIALIZER, Directive, TemplateRef, ViewContainerRef, Input, Injector, INJECTOR, Pipe, ChangeDetectorRef, NgZone } from '@angular/core';
import { CommonModule, isPlatformBrowser, DOCUMENT, isPlatformServer, Location, DatePipe, getLocaleId } from '@angular/common';
import { __awaiter, __decorate, __metadata } from 'tslib';
import { BehaviorSubject, of, fromEvent, throwError, EMPTY, Observable, iif, combineLatest, forkJoin, Subscription, timer, queueScheduler, using, from, merge, defer } from 'rxjs';
import { filter, take, mapTo, map, switchMap, debounceTime, startWith, distinctUntilChanged, tap, catchError, exhaustMap, mergeMap, withLatestFrom, pluck, shareReplay, concatMap, delay, debounce, observeOn, switchMapTo, groupBy, auditTime, takeWhile } from 'rxjs/operators';
import { createFeatureSelector, createSelector, select, Store, INIT, UPDATE, META_REDUCERS, combineReducers, StoreModule } from '@ngrx/store';
import { HttpHeaders, HttpErrorResponse, HttpParams, HTTP_INTERCEPTORS, HttpClient, HttpClientModule, HttpResponse } from '@angular/common/http';
import { PRIMARY_OUTLET, Router, DefaultUrlSerializer, NavigationStart, NavigationEnd, NavigationError, NavigationCancel, UrlSerializer, RouterModule } from '@angular/router';
import { ofType, Actions, Effect, EffectsModule, createEffect } from '@ngrx/effects';
import { makeStateKey, TransferState, Meta } from '@angular/platform-browser';
import { ReactiveFormsModule } from '@angular/forms';
import { ROUTER_NAVIGATION, ROUTER_ERROR, ROUTER_CANCEL, ROUTER_NAVIGATED, RouterStateSerializer, StoreRouterConnectingModule } from '@ngrx/router-store';
import i18next from 'i18next';
import i18nextXhrBackend from 'i18next-xhr-backend';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const ConfigValidatorToken = new InjectionToken('ConfigurationValidator');
/**
 * Use to probide config validation at app bootstrap (when all config chunks are merged)
 *
 * @param {?} configValidator
 * @return {?}
 */
function provideConfigValidator(configValidator) {
    return {
        provide: ConfigValidatorToken,
        useValue: configValidator,
        multi: true,
    };
}
/**
 * @param {?} config
 * @param {?} configValidators
 * @return {?}
 */
function validateConfig(config, configValidators) {
    for (const validate of configValidators) {
        /** @type {?} */
        const warning = validate(config);
        if (warning) {
            console.warn(warning);
        }
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} item
 * @return {?}
 */
function isObject(item) {
    return item && typeof item === 'object' && !Array.isArray(item);
}
/**
 * @param {?=} target
 * @param {...?} sources
 * @return {?}
 */
function deepMerge(target = {}, ...sources) {
    if (!sources.length) {
        return target;
    }
    /** @type {?} */
    const source = sources.shift() || {};
    if (isObject(target) && isObject(source)) {
        for (const key in source) {
            if (source[key] instanceof Date) {
                Object.assign(target, { [key]: source[key] });
            }
            else if (isObject(source[key])) {
                if (!target[key]) {
                    Object.assign(target, { [key]: {} });
                }
                deepMerge(target[key], source[key]);
            }
            else {
                Object.assign(target, { [key]: source[key] });
            }
        }
    }
    return deepMerge(target, ...sources);
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const CONFIG_INITIALIZER = new InjectionToken('ConfigInitializer');
/**
 * Used to provide asynchronous config during app initialization
 * @record
 */
function ConfigInitializer() { }
if (false) {
    /**
     * List of config parts that are resolved by configFactory, e.g.:
     * 'context.baseSite', 'context.language'
     * @type {?}
     */
    ConfigInitializer.prototype.scopes;
    /**
     * Promise that returns config chunk
     * @type {?}
     */
    ConfigInitializer.prototype.configFactory;
}
/** @type {?} */
const CONFIG_INITIALIZER_FORROOT_GUARD = new InjectionToken('CONFIG_INITIALIZER_FORROOT_GUARD');

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Global Configuration injection token, can be used to inject configuration to any part of the app
 * @type {?}
 */
const Config = new InjectionToken('Configuration');
/**
 * Config chunk token, can be used to provide configuration chunk and contribute to the global configuration object.
 * Should not be used directly, use `provideConfig` or import `ConfigModule.withConfig` instead.
 * @type {?}
 */
const ConfigChunk = new InjectionToken('ConfigurationChunk');
/**
 * Helper function to provide configuration chunk using ConfigChunk token
 *
 * @param {?=} config Config object to merge with the global configuration
 * @return {?}
 */
function provideConfig(config = {}) {
    return { provide: ConfigChunk, useValue: config, multi: true };
}
/**
 * Helper function to provide configuration with factory function, using ConfigChunk token
 *
 * @param {?} configFactory Factory Function that will generate config object
 * @param {?=} deps Optional dependencies to a factory function
 * @return {?}
 */
function provideConfigFactory(configFactory, deps) {
    return {
        provide: ConfigChunk,
        useFactory: configFactory,
        multi: true,
        deps: deps,
    };
}
/**
 * Factory function that merges all configurations chunks. Should not be used directly without explicit reason.
 *
 * @param {?} configChunks
 * @param {?} configValidators
 * @param {?=} configInitializerGuard
 * @return {?}
 */
function configurationFactory(configChunks, configValidators, // TODO: remove, deprecated since 1.3, issue #5279
configInitializerGuard // TODO: remove, deprecated since 1.3, issue #5279
) {
    /** @type {?} */
    const config = deepMerge({}, ...configChunks);
    // TODO: remove as validators should run independently, deprecated since 1.3, issue #5279
    if (isDevMode() && !configInitializerGuard) {
        validateConfig(config, configValidators || []);
    }
    return config;
}
class ConfigModule {
    /**
     * Import ConfigModule and contribute config to the global configuration
     *
     * @param {?} config Config object to merge with the global configuration
     * @return {?}
     */
    static withConfig(config) {
        return {
            ngModule: ConfigModule,
            providers: [provideConfig(config)],
        };
    }
    /**
     * Import ConfigModule and contribute config to the global configuration using factory function
     *
     * @param {?} configFactory Factory function that will generate configuration
     * @param {?=} deps Optional dependencies to factory function
     * @return {?}
     */
    static withConfigFactory(configFactory, deps) {
        return {
            ngModule: ConfigModule,
            providers: [provideConfigFactory(configFactory, deps)],
        };
    }
    /**
     * Module with providers, should be imported only once, if possible, at the root of the app.
     *
     * @param {?=} config
     * @return {?}
     */
    static forRoot(config = {}) {
        return {
            ngModule: ConfigModule,
            providers: [
                provideConfig(config),
                {
                    provide: Config,
                    useFactory: configurationFactory,
                    deps: [
                        ConfigChunk,
                        [new Optional(), ConfigValidatorToken],
                        [new Optional(), CONFIG_INITIALIZER_FORROOT_GUARD],
                    ],
                },
            ],
        };
    }
}
ConfigModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule],
                declarations: [],
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} cookie
 * @param {?} name
 * @return {?}
 */
function getCookie(cookie, name) {
    /** @type {?} */
    const regExp = new RegExp('(?:^|;\\s*)' + name + '=([^;]*)', 'g');
    /** @type {?} */
    const result = regExp.exec(cookie);
    return (result && decodeURIComponent(result[1])) || '';
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const TEST_CONFIG_COOKIE_NAME = new InjectionToken('TEST_CONFIG_COOKIE_NAME');
/**
 * @param {?} config
 * @return {?}
 */
function parseConfigJSON(config) {
    try {
        return JSON.parse(decodeURIComponent(config));
    }
    catch (_) {
        return {};
    }
}
/**
 * @param {?} cookieName
 * @param {?} platform
 * @param {?} document
 * @return {?}
 */
function configFromCookieFactory(cookieName, platform, document) {
    if (isPlatformBrowser(platform) && cookieName) {
        /** @type {?} */
        const config = getCookie(document.cookie, cookieName);
        return parseConfigJSON(config);
    }
    return {};
}
/**
 * @record
 */
function TestConfigModuleOptions() { }
if (false) {
    /** @type {?} */
    TestConfigModuleOptions.prototype.cookie;
}
/**
 * Designed/intended to provide dynamic configuration for testing scenarios ONLY (e.g. e2e tests).
 *
 * CAUTION: DON'T USE IT IN PRODUCTION! IT HASN'T BEEN REVIEWED FOR SECURITY ISSUES.
 */
class TestConfigModule {
    /**
     * Injects JSON config from the cookie of the given name.
     *
     * Be aware of the cookie limitations (4096 bytes).
     *
     * CAUTION: DON'T USE IT IN PRODUCTION! IT HASN'T BEEN REVIEWED FOR SECURITY ISSUES.
     * @param {?} options
     * @return {?}
     */
    static forRoot(options) {
        return {
            ngModule: TestConfigModule,
            providers: [
                {
                    provide: TEST_CONFIG_COOKIE_NAME,
                    useValue: options && options.cookie,
                },
                provideConfigFactory(configFromCookieFactory, [
                    TEST_CONFIG_COOKIE_NAME,
                    PLATFORM_ID,
                    DOCUMENT,
                ]),
            ],
        };
    }
}
TestConfigModule.decorators = [
    { type: NgModule, args: [{},] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Provides support for CONFIG_INITIALIZERS
 */
class ConfigInitializerService {
    /**
     * @param {?} config
     * @param {?} initializerGuard
     */
    constructor(config, initializerGuard) {
        this.config = config;
        this.initializerGuard = initializerGuard;
        this.ongoingScopes$ = new BehaviorSubject(undefined);
    }
    /**
     * Returns true if config is stable, i.e. all CONFIG_INITIALIZERS resolved correctly
     * @return {?}
     */
    get isStable() {
        return (!this.initializerGuard ||
            (this.ongoingScopes$.value && this.ongoingScopes$.value.length === 0));
    }
    /**
     * Recommended way to get config for code that can run before app will finish
     * initialization (APP_INITIALIZERS, selected service constructors)
     *
     * Used without parameters waits for the whole config to become stable
     *
     * Parameters allow to describe which part of the config should be stable using
     * string describing config part, e.g.:
     * 'siteContext', 'siteContext.language', etc.
     *
     * @param {...?} scopes String describing parts of the config we want to be sure are stable
     * @return {?}
     */
    getStableConfig(...scopes) {
        return __awaiter(this, void 0, void 0, /** @this {!ConfigInitializerService} */ function* () {
            if (this.isStable) {
                return this.config;
            }
            return this.ongoingScopes$
                .pipe(filter((/**
             * @param {?} ongoingScopes
             * @return {?}
             */
            ongoingScopes => ongoingScopes && this.areReady(scopes, ongoingScopes))), take(1), mapTo(this.config))
                .toPromise();
        });
    }
    /**
     * Removes provided scopes from currently ongoingScopes
     *
     * @protected
     * @param {?} scopes
     * @return {?}
     */
    finishScopes(scopes) {
        /** @type {?} */
        const newScopes = [...this.ongoingScopes$.value];
        for (const scope of scopes) {
            newScopes.splice(newScopes.indexOf(scope), 1);
        }
        this.ongoingScopes$.next(newScopes);
    }
    /**
     * Return true if provided scopes are not part of ongoingScopes
     *
     * @protected
     * @param {?} scopes
     * @param {?} ongoingScopes
     * @return {?}
     */
    areReady(scopes, ongoingScopes) {
        if (!scopes.length) {
            return !ongoingScopes.length;
        }
        for (const scope of scopes) {
            for (const ongoingScope of ongoingScopes) {
                if (this.scopesOverlap(scope, ongoingScope)) {
                    return false;
                }
            }
        }
        return true;
    }
    /**
     * Check if two scopes overlap.
     *
     * Example of scopes that overlap:
     * 'test' and 'test', 'test.a' and 'test', 'test' and 'test.a'
     *
     * Example of scopes that do not overlap:
     * 'test' and 'testA', 'test.a' and 'test.b', 'test.nested' and 'test.nest'
     *
     * @protected
     * @param {?} a ScopeA
     * @param {?} b ScopeB
     * @return {?}
     */
    scopesOverlap(a, b) {
        if (b.length > a.length) {
            [a, b] = [b, a];
        }
        return a.startsWith(b) && (a[b.length] || '.') === '.';
    }
    /**
     * \@internal
     *
     * Not a part of a public API, used by APP_INITIALIZER to initialize all provided CONFIG_INITIALIZERS
     *
     * @param {?=} initializers
     * @return {?}
     */
    initialize(initializers) {
        return __awaiter(this, void 0, void 0, /** @this {!ConfigInitializerService} */ function* () {
            if (this.ongoingScopes$.value) {
                // guard for double initialization
                return;
            }
            /** @type {?} */
            const ongoingScopes = [];
            /** @type {?} */
            const asyncConfigs = [];
            for (const initializer of initializers || []) {
                if (!initializer) {
                    continue;
                }
                if (!initializer.scopes || !initializer.scopes.length) {
                    throw new Error('CONFIG_INITIALIZER should provide scope!');
                }
                if (isDevMode() && !this.areReady(initializer.scopes, ongoingScopes)) {
                    console.warn('More than one CONFIG_INITIALIZER is initializing the same config scope.');
                }
                ongoingScopes.push(...initializer.scopes);
                asyncConfigs.push(((/**
                 * @return {?}
                 */
                () => __awaiter(this, void 0, void 0, /** @this {!ConfigInitializerService} */ function* () {
                    deepMerge(this.config, yield initializer.configFactory());
                    this.finishScopes(initializer.scopes);
                })))());
            }
            this.ongoingScopes$.next(ongoingScopes);
            if (asyncConfigs.length) {
                yield Promise.all(asyncConfigs);
            }
        });
    }
}
ConfigInitializerService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root',
            },] }
];
/** @nocollapse */
ConfigInitializerService.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [Config,] }] },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [CONFIG_INITIALIZER_FORROOT_GUARD,] }] }
];
/** @nocollapse */ ConfigInitializerService.ngInjectableDef = ɵɵdefineInjectable({ factory: function ConfigInitializerService_Factory() { return new ConfigInitializerService(ɵɵinject(Config), ɵɵinject(CONFIG_INITIALIZER_FORROOT_GUARD, 8)); }, token: ConfigInitializerService, providedIn: "root" });
if (false) {
    /**
     * @type {?}
     * @protected
     */
    ConfigInitializerService.prototype.ongoingScopes$;
    /**
     * @type {?}
     * @protected
     */
    ConfigInitializerService.prototype.config;
    /**
     * @type {?}
     * @protected
     */
    ConfigInitializerService.prototype.initializerGuard;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} configInitializer
 * @param {?} validators
 * @return {?}
 */
function configValidatorFactory(configInitializer, validators) {
    /** @type {?} */
    const validate = (/**
     * @return {?}
     */
    () => {
        if (isDevMode()) {
            configInitializer
                .getStableConfig()
                .then((/**
             * @param {?} config
             * @return {?}
             */
            config => validateConfig(config, validators || [])));
        }
    });
    return validate;
}
/**
 * Should stay private in 1.x
 * as forRoot() is used internally by ConfigInitializerModule
 *
 * issue: #5279
 */
class ConfigValidatorModule {
    /**
     * @return {?}
     */
    static forRoot() {
        return {
            ngModule: ConfigValidatorModule,
            providers: [
                {
                    provide: APP_INITIALIZER,
                    multi: true,
                    useFactory: configValidatorFactory,
                    deps: [
                        ConfigInitializerService,
                        [new Optional(), ConfigValidatorToken],
                    ],
                },
            ],
        };
    }
}
ConfigValidatorModule.decorators = [
    { type: NgModule }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} configInitializer
 * @param {?} initializers
 * @return {?}
 */
function configInitializerFactory(configInitializer, initializers) {
    /** @type {?} */
    const isReady = (/**
     * @return {?}
     */
    () => configInitializer.initialize(initializers));
    return isReady;
}
class ConfigInitializerModule {
    /**
     * @return {?}
     */
    static forRoot() {
        return {
            ngModule: ConfigInitializerModule,
            providers: [
                {
                    provide: CONFIG_INITIALIZER_FORROOT_GUARD,
                    useValue: true,
                },
                {
                    provide: APP_INITIALIZER,
                    multi: true,
                    useFactory: configInitializerFactory,
                    deps: [
                        ConfigInitializerService,
                        [new Optional(), CONFIG_INITIALIZER],
                    ],
                },
            ],
        };
    }
}
ConfigInitializerModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    ConfigValidatorModule.forRoot(),
                ],
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @abstract
 */
class SiteContextConfig {
}
if (false) {
    /** @type {?} */
    SiteContextConfig.prototype.context;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @abstract
 */
class OccConfig extends SiteContextConfig {
}
if (false) {
    /** @type {?} */
    OccConfig.prototype.backend;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @abstract
 */
class AnonymousConsentsConfig extends OccConfig {
}
if (false) {
    /** @type {?} */
    AnonymousConsentsConfig.prototype.anonymousConsents;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const defaultAnonymousConsentsConfig = {
    anonymousConsents: {
        registerConsent: 'MARKETING_NEWSLETTER',
        showLegalDescriptionInDialog: true,
        requiredConsents: [],
        consentManagementPage: {
            showAnonymousConsents: true,
            hideConsents: [],
        },
    },
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @abstract
 */
class AuthConfig extends OccConfig {
}
if (false) {
    /** @type {?} */
    AuthConfig.prototype.authentication;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const defaultAuthConfig = {
    authentication: {
        client_id: 'mobile_android',
        client_secret: 'secret',
    },
    backend: {
        occ: {
            endpoints: {
                login: '/authorizationserver/oauth/token',
                revoke: '/authorizationserver/oauth/revoke',
            },
        },
    },
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const USE_CLIENT_TOKEN = 'cx-use-client-token';
/** @type {?} */
const USE_CUSTOMER_SUPPORT_AGENT_TOKEN = 'cx-use-csagent-token';
/** @type {?} */
const TOKEN_REVOCATION_HEADER = 'cx-token-revocation';
class InterceptorUtil {
    /**
     * @template T
     * @param {?} headerName
     * @param {?} interceptorParam
     * @param {?=} headers
     * @return {?}
     */
    static createHeader(headerName, interceptorParam, headers) {
        if (headers) {
            return headers.append(headerName, JSON.stringify(interceptorParam));
        }
        headers = new HttpHeaders().set(headerName, JSON.stringify(interceptorParam));
        return headers;
    }
    /**
     * @param {?} headerName
     * @param {?} request
     * @return {?}
     */
    static removeHeader(headerName, request) {
        /** @type {?} */
        const updatedHeaders = request.headers.delete(headerName);
        return request.clone({ headers: updatedHeaders });
    }
    /**
     * @template T
     * @param {?} headerName
     * @param {?} headers
     * @return {?}
     */
    static getInterceptorParam(headerName, headers) {
        /** @type {?} */
        const rawValue = headers.get(headerName);
        if (rawValue) {
            return JSON.parse(rawValue);
        }
        return undefined;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const OCC_USER_ID_CURRENT = 'current';
/** @type {?} */
const OCC_USER_ID_ANONYMOUS = 'anonymous';
/** @type {?} */
const OCC_USER_ID_GUEST = 'guest';
/** @type {?} */
const OCC_CART_ID_CURRENT = 'current';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const ENTITY_REMOVE_ACTION = '[ENTITY] REMOVE';
/** @type {?} */
const ENTITY_REMOVE_ALL_ACTION = '[ENTITY] REMOVE ALL';
/**
 * @record
 */
function EntityMeta() { }
if (false) {
    /** @type {?} */
    EntityMeta.prototype.entityType;
    /** @type {?} */
    EntityMeta.prototype.entityId;
    /** @type {?|undefined} */
    EntityMeta.prototype.entityRemove;
}
/**
 * @param {?} type
 * @param {?} id
 * @return {?}
 */
function entityMeta(type, id) {
    return {
        entityType: type,
        entityId: id,
    };
}
/**
 * @param {?} type
 * @param {?} id
 * @return {?}
 */
function entityRemoveMeta(type, id) {
    return {
        entityId: id,
        entityType: type,
        entityRemove: true,
    };
}
/**
 * @param {?} type
 * @return {?}
 */
function entityRemoveAllMeta(type) {
    return {
        entityId: null,
        entityType: type,
        entityRemove: true,
    };
}
/**
 * @record
 */
function EntityAction() { }
if (false) {
    /** @type {?|undefined} */
    EntityAction.prototype.payload;
    /** @type {?|undefined} */
    EntityAction.prototype.meta;
}
class EntityRemoveAction {
    /**
     * @param {?} entityType
     * @param {?} id
     */
    constructor(entityType, id) {
        this.type = ENTITY_REMOVE_ACTION;
        this.meta = entityRemoveMeta(entityType, id);
    }
}
if (false) {
    /** @type {?} */
    EntityRemoveAction.prototype.type;
    /** @type {?} */
    EntityRemoveAction.prototype.meta;
}
class EntityRemoveAllAction {
    /**
     * @param {?} entityType
     */
    constructor(entityType) {
        this.type = ENTITY_REMOVE_ALL_ACTION;
        this.meta = entityRemoveAllMeta(entityType);
    }
}
if (false) {
    /** @type {?} */
    EntityRemoveAllAction.prototype.type;
    /** @type {?} */
    EntityRemoveAllAction.prototype.meta;
}

var entity_action = /*#__PURE__*/Object.freeze({
    ENTITY_REMOVE_ACTION: ENTITY_REMOVE_ACTION,
    ENTITY_REMOVE_ALL_ACTION: ENTITY_REMOVE_ALL_ACTION,
    EntityMeta: EntityMeta,
    entityMeta: entityMeta,
    entityRemoveMeta: entityRemoveMeta,
    entityRemoveAllMeta: entityRemoveAllMeta,
    EntityAction: EntityAction,
    EntityRemoveAction: EntityRemoveAction,
    EntityRemoveAllAction: EntityRemoveAllAction
});

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const LOADER_LOAD_ACTION = '[LOADER] LOAD';
/** @type {?} */
const LOADER_FAIL_ACTION = '[LOADER] FAIL';
/** @type {?} */
const LOADER_SUCCESS_ACTION = '[LOADER] SUCCESS';
/** @type {?} */
const LOADER_RESET_ACTION = '[LOADER] RESET';
/**
 * @record
 */
function LoaderMeta() { }
if (false) {
    /** @type {?} */
    LoaderMeta.prototype.entityType;
    /** @type {?} */
    LoaderMeta.prototype.loader;
}
/**
 * @record
 */
function LoaderAction() { }
if (false) {
    /** @type {?|undefined} */
    LoaderAction.prototype.payload;
    /** @type {?|undefined} */
    LoaderAction.prototype.meta;
}
/**
 * @param {?} entityType
 * @return {?}
 */
function loadMeta(entityType) {
    return {
        entityType: entityType,
        loader: {
            load: true,
        },
    };
}
/**
 * @param {?} entityType
 * @param {?=} error
 * @return {?}
 */
function failMeta(entityType, error) {
    return {
        entityType: entityType,
        loader: {
            error: error ? error : true,
        },
    };
}
/**
 * @param {?} entityType
 * @return {?}
 */
function successMeta(entityType) {
    return {
        entityType: entityType,
        loader: {
            success: true,
        },
    };
}
/**
 * @param {?} entityType
 * @return {?}
 */
function resetMeta(entityType) {
    return {
        entityType: entityType,
        loader: {},
    };
}
class LoaderLoadAction {
    /**
     * @param {?} entityType
     */
    constructor(entityType) {
        this.type = LOADER_LOAD_ACTION;
        this.meta = loadMeta(entityType);
    }
}
if (false) {
    /** @type {?} */
    LoaderLoadAction.prototype.type;
    /** @type {?} */
    LoaderLoadAction.prototype.meta;
}
class LoaderFailAction {
    /**
     * @param {?} entityType
     * @param {?=} error
     */
    constructor(entityType, error) {
        this.type = LOADER_FAIL_ACTION;
        this.meta = failMeta(entityType, error);
    }
}
if (false) {
    /** @type {?} */
    LoaderFailAction.prototype.type;
    /** @type {?} */
    LoaderFailAction.prototype.meta;
}
class LoaderSuccessAction {
    /**
     * @param {?} entityType
     */
    constructor(entityType) {
        this.type = LOADER_SUCCESS_ACTION;
        this.meta = successMeta(entityType);
    }
}
if (false) {
    /** @type {?} */
    LoaderSuccessAction.prototype.type;
    /** @type {?} */
    LoaderSuccessAction.prototype.meta;
}
class LoaderResetAction {
    /**
     * @param {?} entityType
     */
    constructor(entityType) {
        this.type = LOADER_RESET_ACTION;
        this.meta = resetMeta(entityType);
    }
}
if (false) {
    /** @type {?} */
    LoaderResetAction.prototype.type;
    /** @type {?} */
    LoaderResetAction.prototype.meta;
}

var loader_action = /*#__PURE__*/Object.freeze({
    LOADER_LOAD_ACTION: LOADER_LOAD_ACTION,
    LOADER_FAIL_ACTION: LOADER_FAIL_ACTION,
    LOADER_SUCCESS_ACTION: LOADER_SUCCESS_ACTION,
    LOADER_RESET_ACTION: LOADER_RESET_ACTION,
    LoaderMeta: LoaderMeta,
    LoaderAction: LoaderAction,
    loadMeta: loadMeta,
    failMeta: failMeta,
    successMeta: successMeta,
    resetMeta: resetMeta,
    LoaderLoadAction: LoaderLoadAction,
    LoaderFailAction: LoaderFailAction,
    LoaderSuccessAction: LoaderSuccessAction,
    LoaderResetAction: LoaderResetAction
});

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const ENTITY_LOAD_ACTION = '[ENTITY] LOAD';
/** @type {?} */
const ENTITY_FAIL_ACTION = '[ENTITY] LOAD FAIL';
/** @type {?} */
const ENTITY_SUCCESS_ACTION = '[ENTITY] LOAD SUCCESS';
/** @type {?} */
const ENTITY_RESET_ACTION = '[ENTITY] RESET';
/**
 * @record
 */
function EntityLoaderMeta() { }
/**
 * @record
 */
function EntityLoaderAction() { }
if (false) {
    /** @type {?|undefined} */
    EntityLoaderAction.prototype.payload;
    /** @type {?|undefined} */
    EntityLoaderAction.prototype.meta;
}
/**
 * @param {?} entityType
 * @param {?} id
 * @return {?}
 */
function entityLoadMeta(entityType, id) {
    return Object.assign({}, loadMeta(entityType), entityMeta(entityType, id));
}
/**
 * @param {?} entityType
 * @param {?} id
 * @param {?=} error
 * @return {?}
 */
function entityFailMeta(entityType, id, error) {
    return Object.assign({}, failMeta(entityType, error), entityMeta(entityType, id));
}
/**
 * @param {?} entityType
 * @param {?} id
 * @return {?}
 */
function entitySuccessMeta(entityType, id) {
    return Object.assign({}, successMeta(entityType), entityMeta(entityType, id));
}
/**
 * @param {?} entityType
 * @param {?} id
 * @return {?}
 */
function entityResetMeta(entityType, id) {
    return Object.assign({}, resetMeta(entityType), entityMeta(entityType, id));
}
class EntityLoadAction {
    /**
     * @param {?} entityType
     * @param {?} id
     */
    constructor(entityType, id) {
        this.type = ENTITY_LOAD_ACTION;
        this.meta = entityLoadMeta(entityType, id);
    }
}
if (false) {
    /** @type {?} */
    EntityLoadAction.prototype.type;
    /** @type {?} */
    EntityLoadAction.prototype.meta;
}
class EntityFailAction {
    /**
     * @param {?} entityType
     * @param {?} id
     * @param {?=} error
     */
    constructor(entityType, id, error) {
        this.type = ENTITY_FAIL_ACTION;
        this.meta = entityFailMeta(entityType, id, error);
    }
}
if (false) {
    /** @type {?} */
    EntityFailAction.prototype.type;
    /** @type {?} */
    EntityFailAction.prototype.meta;
}
class EntitySuccessAction {
    /**
     * @param {?} entityType
     * @param {?} id
     * @param {?=} payload
     */
    constructor(entityType, id, payload) {
        this.payload = payload;
        this.type = ENTITY_SUCCESS_ACTION;
        this.meta = entitySuccessMeta(entityType, id);
    }
}
if (false) {
    /** @type {?} */
    EntitySuccessAction.prototype.type;
    /** @type {?} */
    EntitySuccessAction.prototype.meta;
    /** @type {?} */
    EntitySuccessAction.prototype.payload;
}
class EntityResetAction {
    /**
     * @param {?} entityType
     * @param {?} id
     */
    constructor(entityType, id) {
        this.type = ENTITY_RESET_ACTION;
        this.meta = entityResetMeta(entityType, id);
    }
}
if (false) {
    /** @type {?} */
    EntityResetAction.prototype.type;
    /** @type {?} */
    EntityResetAction.prototype.meta;
}

var entityLoader_action = /*#__PURE__*/Object.freeze({
    ENTITY_LOAD_ACTION: ENTITY_LOAD_ACTION,
    ENTITY_FAIL_ACTION: ENTITY_FAIL_ACTION,
    ENTITY_SUCCESS_ACTION: ENTITY_SUCCESS_ACTION,
    ENTITY_RESET_ACTION: ENTITY_RESET_ACTION,
    EntityLoaderMeta: EntityLoaderMeta,
    EntityLoaderAction: EntityLoaderAction,
    entityLoadMeta: entityLoadMeta,
    entityFailMeta: entityFailMeta,
    entitySuccessMeta: entitySuccessMeta,
    entityResetMeta: entityResetMeta,
    EntityLoadAction: EntityLoadAction,
    EntityFailAction: EntityFailAction,
    EntitySuccessAction: EntitySuccessAction,
    EntityResetAction: EntityResetAction
});

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const initialLoaderState = {
    loading: false,
    error: false,
    success: false,
    value: undefined,
};
/**
 * Higher order reducer that adds generic loading flag to chunk of the state
 *
 * Utilizes "loader" meta field of actions to set specific flags for specific
 * action (LOAD, SUCCESS, FAIL, RESET)
 * @template T
 * @param {?} entityType
 * @param {?=} reducer
 * @return {?}
 */
function loaderReducer(entityType, reducer) {
    return (/**
     * @param {?=} state
     * @param {?=} action
     * @return {?}
     */
    (state = initialLoaderState, action) => {
        if (action.meta &&
            action.meta.loader &&
            action.meta.entityType === entityType) {
            /** @type {?} */
            const entity = action.meta.loader;
            if (entity.load) {
                return Object.assign({}, state, { loading: true, value: reducer ? reducer(state.value, action) : state.value });
            }
            else if (entity.error) {
                return Object.assign({}, state, { loading: false, error: true, success: false, value: reducer ? reducer(state.value, action) : undefined });
            }
            else if (entity.success) {
                return Object.assign({}, state, { value: reducer ? reducer(state.value, action) : action.payload, loading: false, error: false, success: true });
            }
            else {
                // reset state action
                return Object.assign({}, initialLoaderState, { value: reducer
                        ? reducer(initialLoaderState.value, action)
                        : initialLoaderState.value });
            }
        }
        if (reducer) {
            /** @type {?} */
            const newValue = reducer(state.value, action);
            if (newValue !== state.value) {
                return Object.assign({}, state, { value: newValue });
            }
        }
        return state;
    });
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @template T
 * @param {?} state
 * @param {?} id
 * @return {?}
 */
function entityStateSelector(state, id) {
    return state.entities[id] || initialLoaderState;
}
/**
 * @template T
 * @param {?} state
 * @param {?} id
 * @return {?}
 */
function entityValueSelector(state, id) {
    /** @type {?} */
    const entityState = entityStateSelector(state, id);
    return entityState.value;
}
/**
 * @template T
 * @param {?} state
 * @param {?} id
 * @return {?}
 */
function entityLoadingSelector(state, id) {
    /** @type {?} */
    const entityState = entityStateSelector(state, id);
    return entityState.loading;
}
/**
 * @template T
 * @param {?} state
 * @param {?} id
 * @return {?}
 */
function entityErrorSelector(state, id) {
    /** @type {?} */
    const entityState = entityStateSelector(state, id);
    return entityState.error;
}
/**
 * @template T
 * @param {?} state
 * @param {?} id
 * @return {?}
 */
function entitySuccessSelector(state, id) {
    /** @type {?} */
    const entityState = entityStateSelector(state, id);
    return entityState.success;
}

var entityLoader_selectors = /*#__PURE__*/Object.freeze({
    entityStateSelector: entityStateSelector,
    entityValueSelector: entityValueSelector,
    entityLoadingSelector: entityLoadingSelector,
    entityErrorSelector: entityErrorSelector,
    entitySuccessSelector: entitySuccessSelector
});

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const initialEntityState = { entities: {} };
/**
 * Higher order reducer for reusing reducer logic for multiple entities
 *
 * Utilizes entityId meta field to target entity by id in actions
 * @template T
 * @param {?} entityType
 * @param {?} reducer
 * @return {?}
 */
function entityReducer(entityType, reducer) {
    return (/**
     * @param {?=} state
     * @param {?=} action
     * @return {?}
     */
    (state = initialEntityState, action) => {
        /** @type {?} */
        let ids;
        /** @type {?} */
        let partitionPayload = false;
        if (action.meta &&
            action.meta.entityType === entityType &&
            action.meta.entityId !== undefined) {
            ids = [].concat(action.meta.entityId);
            // remove selected entities
            if (action.meta.entityRemove) {
                if (action.meta.entityId === null) {
                    return initialEntityState;
                }
                else {
                    /** @type {?} */
                    let removed = false;
                    /** @type {?} */
                    const newEntities = Object.keys(state.entities).reduce((/**
                     * @param {?} acc
                     * @param {?} cur
                     * @return {?}
                     */
                    (acc, cur) => {
                        if (ids.includes(cur)) {
                            removed = true;
                        }
                        else {
                            acc[cur] = state.entities[cur];
                        }
                        return acc;
                    }), {});
                    return removed ? { entities: newEntities } : state;
                }
            }
            partitionPayload =
                Array.isArray(action.meta.entityId) && Array.isArray(action.payload);
        }
        else {
            ids = Object.keys(state.entities);
        }
        /** @type {?} */
        const entityUpdates = {};
        for (let i = 0; i < ids.length; i++) {
            /** @type {?} */
            const id = ids[i];
            /** @type {?} */
            const subAction = partitionPayload
                ? Object.assign({}, action, { payload: action.payload[i] }) : action;
            /** @type {?} */
            const newState = reducer(state.entities[id], subAction);
            if (newState) {
                entityUpdates[id] = newState;
            }
        }
        if (Object.keys(entityUpdates).length > 0) {
            return Object.assign({}, state, { entities: Object.assign({}, state.entities, entityUpdates) });
        }
        return state;
    });
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Higher order reducer that wraps LoaderReducer and EntityReducer enhancing
 * single state reducer to support multiple entities with generic loading flags
 * @template T
 * @param {?} entityType
 * @param {?=} reducer
 * @return {?}
 */
function entityLoaderReducer(entityType, reducer) {
    return entityReducer(entityType, loaderReducer(entityType, reducer));
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const PROCESSES_INCREMENT_ACTION = '[PROCESSES LOADER] INCREMENT';
/** @type {?} */
const PROCESSES_DECREMENT_ACTION = '[PROCESSES LOADER] DECREMENT';
/** @type {?} */
const PROCESSES_LOADER_RESET_ACTION = '[PROCESSES LOADER] RESET';
/**
 * @record
 */
function ProcessesLoaderMeta() { }
if (false) {
    /** @type {?} */
    ProcessesLoaderMeta.prototype.entityType;
    /** @type {?|undefined} */
    ProcessesLoaderMeta.prototype.processesCountDiff;
}
/**
 * @record
 */
function ProcessesLoaderAction() { }
if (false) {
    /** @type {?|undefined} */
    ProcessesLoaderAction.prototype.payload;
    /** @type {?|undefined} */
    ProcessesLoaderAction.prototype.meta;
}
/**
 * @param {?} entityType
 * @return {?}
 */
function processesIncrementMeta(entityType) {
    return {
        entityType: entityType,
        loader: undefined,
        processesCountDiff: 1,
    };
}
/**
 * @param {?} entityType
 * @return {?}
 */
function processesDecrementMeta(entityType) {
    return {
        entityType: entityType,
        loader: undefined,
        processesCountDiff: -1,
    };
}
/**
 * @param {?} entityType
 * @return {?}
 */
function processesLoaderResetMeta(entityType) {
    // processes reset action is a reset action for loader reducer, but not the other way around
    return Object.assign({}, resetMeta(entityType), { processesCountDiff: null });
}
class ProcessesLoaderResetAction {
    /**
     * @param {?} entityType
     */
    constructor(entityType) {
        this.type = PROCESSES_LOADER_RESET_ACTION;
        this.meta = processesLoaderResetMeta(entityType);
    }
}
if (false) {
    /** @type {?} */
    ProcessesLoaderResetAction.prototype.type;
    /** @type {?} */
    ProcessesLoaderResetAction.prototype.meta;
}
class ProcessesIncrementAction {
    /**
     * @param {?} entityType
     */
    constructor(entityType) {
        this.type = PROCESSES_INCREMENT_ACTION;
        this.meta = processesIncrementMeta(entityType);
    }
}
if (false) {
    /** @type {?} */
    ProcessesIncrementAction.prototype.type;
    /** @type {?} */
    ProcessesIncrementAction.prototype.meta;
}
class ProcessesDecrementAction {
    /**
     * @param {?} entityType
     */
    constructor(entityType) {
        this.type = PROCESSES_DECREMENT_ACTION;
        this.meta = processesDecrementMeta(entityType);
    }
}
if (false) {
    /** @type {?} */
    ProcessesDecrementAction.prototype.type;
    /** @type {?} */
    ProcessesDecrementAction.prototype.meta;
}

var processesLoader_action = /*#__PURE__*/Object.freeze({
    PROCESSES_INCREMENT_ACTION: PROCESSES_INCREMENT_ACTION,
    PROCESSES_DECREMENT_ACTION: PROCESSES_DECREMENT_ACTION,
    PROCESSES_LOADER_RESET_ACTION: PROCESSES_LOADER_RESET_ACTION,
    ProcessesLoaderMeta: ProcessesLoaderMeta,
    ProcessesLoaderAction: ProcessesLoaderAction,
    processesIncrementMeta: processesIncrementMeta,
    processesDecrementMeta: processesDecrementMeta,
    processesLoaderResetMeta: processesLoaderResetMeta,
    ProcessesLoaderResetAction: ProcessesLoaderResetAction,
    ProcessesIncrementAction: ProcessesIncrementAction,
    ProcessesDecrementAction: ProcessesDecrementAction
});

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const ENTITY_PROCESSES_LOADER_RESET_ACTION = '[ENTITY] PROCESSES LOADER RESET';
/** @type {?} */
const ENTITY_PROCESSES_INCREMENT_ACTION = '[ENTITY] PROCESSES INCREMENT';
/** @type {?} */
const ENTITY_PROCESSES_DECREMENT_ACTION = '[ENTITY] PROCESSES DECREMENT';
/**
 * @record
 */
function EntityProcessesLoaderMeta() { }
/**
 * @record
 */
function EntityProcessesLoaderAction() { }
if (false) {
    /** @type {?|undefined} */
    EntityProcessesLoaderAction.prototype.payload;
    /** @type {?|undefined} */
    EntityProcessesLoaderAction.prototype.meta;
}
/**
 * @param {?} entityType
 * @param {?} id
 * @return {?}
 */
function entityProcessesLoaderResetMeta(entityType, id) {
    return Object.assign({}, processesLoaderResetMeta(entityType), entityMeta(entityType, id));
}
/**
 * @param {?} entityType
 * @param {?} id
 * @return {?}
 */
function entityProcessesIncrementMeta(entityType, id) {
    return Object.assign({}, processesIncrementMeta(entityType), entityMeta(entityType, id));
}
/**
 * @param {?} entityType
 * @param {?} id
 * @return {?}
 */
function entityProcessesDecrementMeta(entityType, id) {
    return Object.assign({}, processesDecrementMeta(entityType), entityMeta(entityType, id));
}
class EntityProcessesLoaderResetAction {
    /**
     * @param {?} entityType
     * @param {?} id
     */
    constructor(entityType, id) {
        this.type = ENTITY_PROCESSES_LOADER_RESET_ACTION;
        this.meta = entityProcessesLoaderResetMeta(entityType, id);
    }
}
if (false) {
    /** @type {?} */
    EntityProcessesLoaderResetAction.prototype.type;
    /** @type {?} */
    EntityProcessesLoaderResetAction.prototype.meta;
}
class EntityProcessesIncrementAction {
    /**
     * @param {?} entityType
     * @param {?} id
     */
    constructor(entityType, id) {
        this.type = ENTITY_PROCESSES_INCREMENT_ACTION;
        this.meta = entityProcessesIncrementMeta(entityType, id);
    }
}
if (false) {
    /** @type {?} */
    EntityProcessesIncrementAction.prototype.type;
    /** @type {?} */
    EntityProcessesIncrementAction.prototype.meta;
}
class EntityProcessesDecrementAction {
    /**
     * @param {?} entityType
     * @param {?} id
     */
    constructor(entityType, id) {
        this.type = ENTITY_PROCESSES_DECREMENT_ACTION;
        this.meta = entityProcessesDecrementMeta(entityType, id);
    }
}
if (false) {
    /** @type {?} */
    EntityProcessesDecrementAction.prototype.type;
    /** @type {?} */
    EntityProcessesDecrementAction.prototype.meta;
}

var entityProcessesLoader_action = /*#__PURE__*/Object.freeze({
    ENTITY_PROCESSES_LOADER_RESET_ACTION: ENTITY_PROCESSES_LOADER_RESET_ACTION,
    ENTITY_PROCESSES_INCREMENT_ACTION: ENTITY_PROCESSES_INCREMENT_ACTION,
    ENTITY_PROCESSES_DECREMENT_ACTION: ENTITY_PROCESSES_DECREMENT_ACTION,
    EntityProcessesLoaderMeta: EntityProcessesLoaderMeta,
    EntityProcessesLoaderAction: EntityProcessesLoaderAction,
    entityProcessesLoaderResetMeta: entityProcessesLoaderResetMeta,
    entityProcessesIncrementMeta: entityProcessesIncrementMeta,
    entityProcessesDecrementMeta: entityProcessesDecrementMeta,
    EntityProcessesLoaderResetAction: EntityProcessesLoaderResetAction,
    EntityProcessesIncrementAction: EntityProcessesIncrementAction,
    EntityProcessesDecrementAction: EntityProcessesDecrementAction
});

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @template T
 * @param {?} state
 * @return {?}
 */
function isStableSelector(state) {
    return state.processesCount === 0 && !state.loading;
}
/**
 * @template T
 * @param {?} state
 * @return {?}
 */
function hasPendingProcessesSelector(state) {
    return state.processesCount > 0;
}

var processesLoader_selectors = /*#__PURE__*/Object.freeze({
    isStableSelector: isStableSelector,
    hasPendingProcessesSelector: hasPendingProcessesSelector
});

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @record
 * @template T
 */
function ProcessesLoaderState() { }
if (false) {
    /** @type {?|undefined} */
    ProcessesLoaderState.prototype.processesCount;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const initialProcessesState = {
    processesCount: 0,
};
/**
 * Higher order reducer that adds processes count
 * @template T
 * @param {?} entityType
 * @param {?=} reducer
 * @return {?}
 */
function processesLoaderReducer(entityType, reducer) {
    return (/**
     * @param {?=} state
     * @param {?=} action
     * @return {?}
     */
    (state = Object.assign({}, initialProcessesState, initialLoaderState), action) => {
        /** @type {?} */
        const loaderState = loaderReducer(entityType, reducer)(state, action);
        if (action.meta && action.meta.entityType === entityType) {
            /** @type {?} */
            const processesCountDiff = action.meta.processesCountDiff;
            if (isDevMode() && state.processesCount + processesCountDiff < 0) {
                console.error(`Action '${action.type}' sets processesCount to value < 0!\n` +
                    'Make sure to keep processesCount in sync.\n' +
                    'There should always be only one decrement action for each increment action.\n' +
                    "Make sure that you don't reset state in between those actions.\n", action);
            }
            if (processesCountDiff) {
                return Object.assign({}, loaderState, { processesCount: state.processesCount
                        ? state.processesCount + processesCountDiff
                        : processesCountDiff });
            }
            else if (processesCountDiff === null) {
                // reset action
                return Object.assign({}, loaderState, initialProcessesState);
            }
        }
        return loaderState;
    });
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const initialProcessesLoaderState = Object.assign({}, initialLoaderState, initialProcessesState);
/**
 * @template T
 * @param {?} state
 * @param {?} id
 * @return {?}
 */
function entityHasPendingProcessesSelector(state, id) {
    /** @type {?} */
    const entityState = entityStateSelector(state, id);
    return hasPendingProcessesSelector(entityState);
}
/**
 * @template T
 * @param {?} state
 * @param {?} id
 * @return {?}
 */
function entityIsStableSelector(state, id) {
    /** @type {?} */
    const entityState = entityStateSelector(state, id);
    return isStableSelector(entityState);
}
/**
 * @template T
 * @param {?} state
 * @param {?} id
 * @return {?}
 */
function entityProcessesLoaderStateSelector(state, id) {
    return state.entities[id] || initialProcessesLoaderState;
}

var entityProcessesLoader_selectors = /*#__PURE__*/Object.freeze({
    entityHasPendingProcessesSelector: entityHasPendingProcessesSelector,
    entityIsStableSelector: entityIsStableSelector,
    entityProcessesLoaderStateSelector: entityProcessesLoaderStateSelector
});

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Higher order reducer that wraps ProcessesLoaderReducer and EntityReducer enhancing
 * single state reducer to support multiple entities with generic processesCount flag
 * @template T
 * @param {?} entityType
 * @param {?=} reducer
 * @return {?}
 */
function entityProcessesLoaderReducer(entityType, reducer) {
    return entityReducer(entityType, processesLoaderReducer(entityType, reducer));
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @template T
 * @param {?} state
 * @param {?} id
 * @return {?}
 */
function entitySelector(state, id) {
    return state.entities[id] || undefined;
}

var entity_selectors = /*#__PURE__*/Object.freeze({
    entitySelector: entitySelector
});

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @record
 * @template T
 */
function EntityState() { }
if (false) {
    /** @type {?} */
    EntityState.prototype.entities;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const OBJECT_SEPARATOR = '.';
/**
 * @template T, E
 * @param {?} keys
 * @param {?} state
 * @return {?}
 */
function getStateSliceValue(keys, state) {
    return keys
        .split(OBJECT_SEPARATOR)
        .reduce((/**
     * @param {?} previous
     * @param {?} current
     * @return {?}
     */
    (previous, current) => (previous ? previous[current] : undefined)), state);
}
/**
 * @template T, E
 * @param {?} key
 * @param {?} excludeKeys
 * @param {?} value
 * @return {?}
 */
function createShellObject(key, excludeKeys, value) {
    if (!key || !value || Object.keys(value).length === 0) {
        return (/** @type {?} */ ({}));
    }
    /** @type {?} */
    const shell = key.split(OBJECT_SEPARATOR).reduceRight((/**
     * @param {?} acc
     * @param {?} previous
     * @return {?}
     */
    (acc, previous) => {
        return (/** @type {?} */ (((/** @type {?} */ ({ [previous]: acc })))));
    }), value);
    return handleExclusions(key, excludeKeys, shell);
}
/**
 * @template T, E
 * @param {?} keys
 * @param {?} excludeKeys
 * @param {?} state
 * @return {?}
 */
function getStateSlice(keys, excludeKeys, state) {
    if (keys && keys.length === 0) {
        return (/** @type {?} */ ({}));
    }
    /** @type {?} */
    let stateSlices = {};
    for (const currentKey of keys) {
        /** @type {?} */
        const stateValue = getStateSliceValue(currentKey, state);
        /** @type {?} */
        const shell = createShellObject(currentKey, excludeKeys, stateValue);
        stateSlices = deepMerge(stateSlices, shell);
    }
    return (/** @type {?} */ (stateSlices));
}
/**
 * @param {?} key
 * @param {?} excludeKeys
 * @param {?} value
 * @return {?}
 */
function handleExclusions(key, excludeKeys, value) {
    /** @type {?} */
    const exclusionKeys = getExclusionKeys(key, excludeKeys);
    if (exclusionKeys.length === 0) {
        return value;
    }
    /** @type {?} */
    const finalValue = deepMerge({}, value);
    for (const currentExclusionKey of exclusionKeys) {
        /** @type {?} */
        const exclusionChunksSplit = currentExclusionKey.split(OBJECT_SEPARATOR);
        /** @type {?} */
        let nestedTemp = finalValue;
        for (let i = 0; i < exclusionChunksSplit.length; i++) {
            /** @type {?} */
            const currentChunk = exclusionChunksSplit[i];
            // last iteration
            if (i === exclusionChunksSplit.length - 1) {
                if (nestedTemp && nestedTemp[currentChunk]) {
                    delete nestedTemp[currentChunk];
                }
            }
            else {
                nestedTemp = nestedTemp[currentChunk];
            }
        }
    }
    return finalValue;
}
/**
 * @param {?} key
 * @param {?} excludeKeys
 * @return {?}
 */
function getExclusionKeys(key, excludeKeys) {
    if (!key || !excludeKeys) {
        return [];
    }
    /** @type {?} */
    const exclusionKeys = [];
    for (const exclusionKey of excludeKeys) {
        if (exclusionKey.includes(key)) {
            exclusionKeys.push(exclusionKey);
        }
    }
    return exclusionKeys;
}
/**
 * @param {?} keys
 * @param {?} type
 * @return {?}
 */
function filterKeysByType(keys, type) {
    if (!keys) {
        return [];
    }
    return Object.keys(keys).filter((/**
     * @param {?} key
     * @return {?}
     */
    key => keys[key] === type));
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @template T
 * @param {?} state
 * @return {?}
 */
function loaderValueSelector(state) {
    return state.value;
}
/**
 * @template T
 * @param {?} state
 * @return {?}
 */
function loaderLoadingSelector(state) {
    return state.loading;
}
/**
 * @template T
 * @param {?} state
 * @return {?}
 */
function loaderErrorSelector(state) {
    return state.error;
}
/**
 * @template T
 * @param {?} state
 * @return {?}
 */
function loaderSuccessSelector(state) {
    return state.success;
}

var loader_selectors = /*#__PURE__*/Object.freeze({
    loaderValueSelector: loaderValueSelector,
    loaderLoadingSelector: loaderLoadingSelector,
    loaderErrorSelector: loaderErrorSelector,
    loaderSuccessSelector: loaderSuccessSelector
});

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @record
 * @template T
 */
function LoaderState() { }
if (false) {
    /** @type {?|undefined} */
    LoaderState.prototype.loading;
    /** @type {?|undefined} */
    LoaderState.prototype.error;
    /** @type {?|undefined} */
    LoaderState.prototype.success;
    /** @type {?|undefined} */
    LoaderState.prototype.value;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} entityType
 * @return {?}
 */
function ofLoaderLoad(entityType) {
    return filter((/**
     * @param {?} action
     * @return {?}
     */
    (action) => action.meta &&
        action.meta.loader &&
        action.meta.entityType === entityType &&
        action.meta.loader.load));
}
/**
 * @param {?} entityType
 * @return {?}
 */
function ofLoaderFail(entityType) {
    return filter((/**
     * @param {?} action
     * @return {?}
     */
    (action) => action.meta &&
        action.meta.loader &&
        action.meta.entityType === entityType &&
        action.meta.loader.error));
}
/**
 * @param {?} entityType
 * @return {?}
 */
function ofLoaderSuccess(entityType) {
    return filter((/**
     * @param {?} action
     * @return {?}
     */
    (action) => action.meta &&
        action.meta.loader &&
        action.meta.entityType === entityType &&
        !action.meta.loader.load &&
        !action.meta.loader.error));
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const AUTH_FEATURE = 'auth';
/** @type {?} */
const CLIENT_TOKEN_DATA = '[Auth] Client Token Data';
/**
 * @record
 */
function StateWithAuth() { }
if (false) {
    /* Skipping unnamed member:
    [AUTH_FEATURE]: AuthState;*/
}
/**
 * @record
 */
function AuthState() { }
if (false) {
    /** @type {?} */
    AuthState.prototype.userToken;
    /** @type {?} */
    AuthState.prototype.clientToken;
}
/**
 * @record
 */
function UserTokenState() { }
if (false) {
    /** @type {?} */
    UserTokenState.prototype.token;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const LOAD_CLIENT_TOKEN = '[Token] Load Client Token';
/** @type {?} */
const LOAD_CLIENT_TOKEN_FAIL = '[Token] Load Client Token Fail';
/** @type {?} */
const LOAD_CLIENT_TOKEN_SUCCESS = '[Token] Load Client Token Success';
class LoadClientToken extends LoaderLoadAction {
    constructor() {
        super(CLIENT_TOKEN_DATA);
        this.type = LOAD_CLIENT_TOKEN;
    }
}
if (false) {
    /** @type {?} */
    LoadClientToken.prototype.type;
}
class LoadClientTokenFail extends LoaderFailAction {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        super(CLIENT_TOKEN_DATA, payload);
        this.payload = payload;
        this.type = LOAD_CLIENT_TOKEN_FAIL;
    }
}
if (false) {
    /** @type {?} */
    LoadClientTokenFail.prototype.type;
    /** @type {?} */
    LoadClientTokenFail.prototype.payload;
}
class LoadClientTokenSuccess extends LoaderSuccessAction {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        super(CLIENT_TOKEN_DATA);
        this.payload = payload;
        this.type = LOAD_CLIENT_TOKEN_SUCCESS;
    }
}
if (false) {
    /** @type {?} */
    LoadClientTokenSuccess.prototype.type;
    /** @type {?} */
    LoadClientTokenSuccess.prototype.payload;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const LOGIN = '[Auth] Login';
/** @type {?} */
const LOGOUT = '[Auth] Logout';
/** @type {?} */
const LOGOUT_CUSTOMER_SUPPORT_AGENT = '[Auth] Logout Customer Support Agent';
class Login {
    constructor() {
        this.type = LOGIN;
    }
}
if (false) {
    /** @type {?} */
    Login.prototype.type;
}
class Logout {
    constructor() {
        this.type = LOGOUT;
    }
}
if (false) {
    /** @type {?} */
    Logout.prototype.type;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const LOAD_USER_TOKEN = '[Auth] Load User Token';
/** @type {?} */
const LOAD_USER_TOKEN_FAIL = '[Auth] Load User Token Fail';
/** @type {?} */
const LOAD_USER_TOKEN_SUCCESS = '[Auth] Load User Token Success';
/** @type {?} */
const REFRESH_USER_TOKEN = '[Auth] Refresh User Token';
/** @type {?} */
const REFRESH_USER_TOKEN_FAIL = '[Auth] Refresh User Token Fail';
/** @type {?} */
const REFRESH_USER_TOKEN_SUCCESS = '[Auth] Refresh User Token Success';
/** @type {?} */
const REVOKE_USER_TOKEN = '[Auth] Revoke User Token';
/** @type {?} */
const REVOKE_USER_TOKEN_FAIL = '[Auth] Revoke User Token Fail';
/** @type {?} */
const REVOKE_USER_TOKEN_SUCCESS = '[Auth] Revoke User Token Success';
class LoadUserToken {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        this.payload = payload;
        this.type = LOAD_USER_TOKEN;
    }
}
if (false) {
    /** @type {?} */
    LoadUserToken.prototype.type;
    /** @type {?} */
    LoadUserToken.prototype.payload;
}
class LoadUserTokenFail {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        this.payload = payload;
        this.type = LOAD_USER_TOKEN_FAIL;
    }
}
if (false) {
    /** @type {?} */
    LoadUserTokenFail.prototype.type;
    /** @type {?} */
    LoadUserTokenFail.prototype.payload;
}
class LoadUserTokenSuccess {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        this.payload = payload;
        this.type = LOAD_USER_TOKEN_SUCCESS;
    }
}
if (false) {
    /** @type {?} */
    LoadUserTokenSuccess.prototype.type;
    /** @type {?} */
    LoadUserTokenSuccess.prototype.payload;
}
class RefreshUserToken {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        this.payload = payload;
        this.type = REFRESH_USER_TOKEN;
    }
}
if (false) {
    /** @type {?} */
    RefreshUserToken.prototype.type;
    /** @type {?} */
    RefreshUserToken.prototype.payload;
}
class RefreshUserTokenSuccess {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        this.payload = payload;
        this.type = REFRESH_USER_TOKEN_SUCCESS;
    }
}
if (false) {
    /** @type {?} */
    RefreshUserTokenSuccess.prototype.type;
    /** @type {?} */
    RefreshUserTokenSuccess.prototype.payload;
}
class RefreshUserTokenFail {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        this.payload = payload;
        this.type = REFRESH_USER_TOKEN_FAIL;
    }
}
if (false) {
    /** @type {?} */
    RefreshUserTokenFail.prototype.type;
    /** @type {?} */
    RefreshUserTokenFail.prototype.payload;
}
class RevokeUserToken {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        this.payload = payload;
        this.type = REVOKE_USER_TOKEN;
    }
}
if (false) {
    /** @type {?} */
    RevokeUserToken.prototype.type;
    /** @type {?} */
    RevokeUserToken.prototype.payload;
}
class RevokeUserTokenSuccess {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        this.payload = payload;
        this.type = REVOKE_USER_TOKEN_SUCCESS;
    }
}
if (false) {
    /** @type {?} */
    RevokeUserTokenSuccess.prototype.type;
    /** @type {?} */
    RevokeUserTokenSuccess.prototype.payload;
}
class RevokeUserTokenFail {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        this.payload = payload;
        this.type = REVOKE_USER_TOKEN_FAIL;
    }
}
if (false) {
    /** @type {?} */
    RevokeUserTokenFail.prototype.type;
    /** @type {?} */
    RevokeUserTokenFail.prototype.payload;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

var authGroup_actions = /*#__PURE__*/Object.freeze({
    LOAD_CLIENT_TOKEN: LOAD_CLIENT_TOKEN,
    LOAD_CLIENT_TOKEN_FAIL: LOAD_CLIENT_TOKEN_FAIL,
    LOAD_CLIENT_TOKEN_SUCCESS: LOAD_CLIENT_TOKEN_SUCCESS,
    LoadClientToken: LoadClientToken,
    LoadClientTokenFail: LoadClientTokenFail,
    LoadClientTokenSuccess: LoadClientTokenSuccess,
    LOGIN: LOGIN,
    LOGOUT: LOGOUT,
    LOGOUT_CUSTOMER_SUPPORT_AGENT: LOGOUT_CUSTOMER_SUPPORT_AGENT,
    Login: Login,
    Logout: Logout,
    LOAD_USER_TOKEN: LOAD_USER_TOKEN,
    LOAD_USER_TOKEN_FAIL: LOAD_USER_TOKEN_FAIL,
    LOAD_USER_TOKEN_SUCCESS: LOAD_USER_TOKEN_SUCCESS,
    REFRESH_USER_TOKEN: REFRESH_USER_TOKEN,
    REFRESH_USER_TOKEN_FAIL: REFRESH_USER_TOKEN_FAIL,
    REFRESH_USER_TOKEN_SUCCESS: REFRESH_USER_TOKEN_SUCCESS,
    REVOKE_USER_TOKEN: REVOKE_USER_TOKEN,
    REVOKE_USER_TOKEN_FAIL: REVOKE_USER_TOKEN_FAIL,
    REVOKE_USER_TOKEN_SUCCESS: REVOKE_USER_TOKEN_SUCCESS,
    LoadUserToken: LoadUserToken,
    LoadUserTokenFail: LoadUserTokenFail,
    LoadUserTokenSuccess: LoadUserTokenSuccess,
    RefreshUserToken: RefreshUserToken,
    RefreshUserTokenSuccess: RefreshUserTokenSuccess,
    RefreshUserTokenFail: RefreshUserTokenFail,
    RevokeUserToken: RevokeUserToken,
    RevokeUserTokenSuccess: RevokeUserTokenSuccess,
    RevokeUserTokenFail: RevokeUserTokenFail
});

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const getAuthState = createFeatureSelector(AUTH_FEATURE);

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
const ɵ0 = /**
 * @param {?} state
 * @return {?}
 */
(state) => state.clientToken;
/** @type {?} */
const getClientTokenState = createSelector(getAuthState, (ɵ0));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const getUserTokenSelector = (/**
 * @param {?} state
 * @return {?}
 */
(state) => state.token);
const ɵ0$1 = getUserTokenSelector;
const ɵ1 = /**
 * @param {?} state
 * @return {?}
 */
(state) => state.userToken;
/** @type {?} */
const getUserTokenState = createSelector(getAuthState, (ɵ1));
/** @type {?} */
const getUserToken = createSelector(getUserTokenState, getUserTokenSelector);

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

var authGroup_selectors = /*#__PURE__*/Object.freeze({
    getClientTokenState: getClientTokenState,
    getAuthState: getAuthState,
    getUserTokenState: getUserTokenState,
    getUserToken: getUserToken
});

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class AuthService {
    /**
     * @param {?} store
     */
    constructor(store) {
        this.store = store;
    }
    /**
     * Loads a new user token
     * @param {?} userId
     * @param {?} password
     * @return {?}
     */
    authorize(userId, password) {
        this.store.dispatch(new LoadUserToken({
            userId: userId,
            password: password,
        }));
    }
    /**
     * This function provides the userId the OCC calls should use, depending
     * on whether there is an active storefront session or not.
     *
     * It returns the userId of the current storefront user or 'anonymous'
     * in the case there are no signed in user in the storefront.
     *
     * The user id of a regular customer session is 'current'.  In the case of an
     * asm customer emulation session, the userId will be the customerId.
     * @return {?}
     */
    getOccUserId() {
        return this.getUserToken().pipe(map((/**
         * @param {?} userToken
         * @return {?}
         */
        userToken => {
            if (!!userToken && !!userToken.userId) {
                return userToken.userId;
            }
            else {
                return OCC_USER_ID_ANONYMOUS;
            }
        })));
    }
    /**
     * Returns the user's token
     * @return {?}
     */
    getUserToken() {
        return this.store.pipe(select(getUserToken));
    }
    /**
     * Refreshes the user token
     * @param {?} token a user token to refresh
     * @return {?}
     */
    refreshUserToken(token) {
        this.store.dispatch(new RefreshUserToken({
            refreshToken: token.refresh_token,
        }));
    }
    /**
     * Store the provided token
     * @param {?} token
     * @return {?}
     */
    authorizeWithToken(token) {
        this.store.dispatch(new LoadUserTokenSuccess(token));
    }
    /**
     * Logout a storefront customer
     * @return {?}
     */
    logout() {
        this.getUserToken()
            .pipe(take(1))
            .subscribe((/**
         * @param {?} userToken
         * @return {?}
         */
        userToken => {
            this.store.dispatch(new Logout());
            if (Boolean(userToken) && userToken.userId === OCC_USER_ID_CURRENT) {
                this.store.dispatch(new RevokeUserToken(userToken));
            }
        }));
    }
    /**
     * Returns a client token.  The client token from the store is returned if there is one.
     * Otherwise, an new token is fetched from the backend and saved in the store.
     * @return {?}
     */
    getClientToken() {
        return this.store.pipe(select(getClientTokenState), filter((/**
         * @param {?} state
         * @return {?}
         */
        (state) => {
            if (this.isClientTokenLoaded(state)) {
                return true;
            }
            else {
                if (!state.loading) {
                    this.store.dispatch(new LoadClientToken());
                }
                return false;
            }
        })), map((/**
         * @param {?} state
         * @return {?}
         */
        (state) => state.value)));
    }
    /**
     * Fetches a clientToken from the backend ans saves it in the store where getClientToken can use it.
     * The new clientToken is returned.
     * @return {?}
     */
    refreshClientToken() {
        this.store.dispatch(new LoadClientToken());
        return this.store.pipe(select(getClientTokenState), filter((/**
         * @param {?} state
         * @return {?}
         */
        (state) => this.isClientTokenLoaded(state))), map((/**
         * @param {?} state
         * @return {?}
         */
        (state) => state.value)));
    }
    /**
     * @protected
     * @param {?} state
     * @return {?}
     */
    isClientTokenLoaded(state) {
        return (state.success || state.error) && !state.loading;
    }
    /**
     * Returns `true` if the user is logged in; and `false` if the user is anonymous.
     * @return {?}
     */
    isUserLoggedIn() {
        return this.getUserToken().pipe(map((/**
         * @param {?} userToken
         * @return {?}
         */
        userToken => Boolean(userToken) && Boolean(userToken.access_token))));
    }
}
AuthService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root',
            },] }
];
/** @nocollapse */
AuthService.ctorParameters = () => [
    { type: Store }
];
/** @nocollapse */ AuthService.ngInjectableDef = ɵɵdefineInjectable({ factory: function AuthService_Factory() { return new AuthService(ɵɵinject(Store)); }, token: AuthService, providedIn: "root" });
if (false) {
    /**
     * @type {?}
     * @protected
     */
    AuthService.prototype.store;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ClientErrorHandlingService {
    /**
     * @param {?} authService
     */
    constructor(authService) {
        this.authService = authService;
    }
    /**
     * @param {?} request
     * @param {?} next
     * @return {?}
     */
    handleExpiredClientToken(request, next) {
        return this.authService.refreshClientToken().pipe(take(1), switchMap((/**
         * @param {?} token
         * @return {?}
         */
        (token) => {
            return next.handle(this.createNewRequestWithNewToken(request, token));
        })));
    }
    /**
     * @protected
     * @param {?} request
     * @param {?} token
     * @return {?}
     */
    createNewRequestWithNewToken(request, token) {
        request = request.clone({
            setHeaders: {
                Authorization: `${token.token_type} ${token.access_token}`,
            },
        });
        return request;
    }
}
ClientErrorHandlingService.decorators = [
    { type: Injectable }
];
/** @nocollapse */
ClientErrorHandlingService.ctorParameters = () => [
    { type: AuthService }
];
if (false) {
    /**
     * @type {?}
     * @protected
     */
    ClientErrorHandlingService.prototype.authService;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class WindowRef {
    /**
     * @param {?} document
     */
    constructor(document) {
        // it's a workaround to have document property properly typed
        // see: https://github.com/angular/angular/issues/15640
        this.document = document;
    }
    /**
     * @return {?}
     */
    get nativeWindow() {
        return typeof window !== 'undefined' ? window : undefined;
    }
    /**
     * @return {?}
     */
    get sessionStorage() {
        return this.nativeWindow ? this.nativeWindow.sessionStorage : undefined;
    }
    /**
     * @return {?}
     */
    get localStorage() {
        return this.nativeWindow ? this.nativeWindow.localStorage : undefined;
    }
    /**
     * Returns an observable for the window resize event and emits an event
     * every 300ms in case of resizing. An event is simulated initially.
     *
     * If there's no window object availale (i.e. in SSR), a null value is emitted.
     * @return {?}
     */
    get resize$() {
        if (!this.nativeWindow) {
            return of(null);
        }
        else {
            return fromEvent(this.nativeWindow, 'resize').pipe(debounceTime(300), startWith({ target: this.nativeWindow }), distinctUntilChanged());
        }
    }
}
WindowRef.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root',
            },] }
];
/** @nocollapse */
WindowRef.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] }
];
/** @nocollapse */ WindowRef.ngInjectableDef = ɵɵdefineInjectable({ factory: function WindowRef_Factory() { return new WindowRef(ɵɵinject(DOCUMENT)); }, token: WindowRef, providedIn: "root" });
if (false) {
    /** @type {?} */
    WindowRef.prototype.document;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class UrlParsingService {
    /**
     * @param {?} router
     */
    constructor(router) {
        this.router = router;
    }
    /**
     * @param {?} url
     * @return {?}
     */
    getPrimarySegments(url) {
        /** @type {?} */
        const urlTree = this.router.parseUrl(url);
        return this._getPrimarySegmentsFromUrlTree(urlTree.root);
    }
    /**
     * @private
     * @param {?} tree
     * @return {?}
     */
    _getPrimarySegmentsFromUrlTree(tree) {
        /** @type {?} */
        const segments = tree.segments.map((/**
         * @param {?} s
         * @return {?}
         */
        s => s.path));
        /** @type {?} */
        const childrenSegments = tree.children[PRIMARY_OUTLET]
            ? this._getPrimarySegmentsFromUrlTree(tree.children[PRIMARY_OUTLET])
            : [];
        return segments.concat(childrenSegments);
    }
}
UrlParsingService.decorators = [
    { type: Injectable, args: [{ providedIn: 'root' },] }
];
/** @nocollapse */
UrlParsingService.ctorParameters = () => [
    { type: Router }
];
/** @nocollapse */ UrlParsingService.ngInjectableDef = ɵɵdefineInjectable({ factory: function UrlParsingService_Factory() { return new UrlParsingService(ɵɵinject(Router)); }, token: UrlParsingService, providedIn: "root" });
if (false) {
    /**
     * @type {?}
     * @private
     */
    UrlParsingService.prototype.router;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const isParam = (/**
 * @param {?} segment
 * @return {?}
 */
(segment) => segment.startsWith(':'));
/** @type {?} */
const getParamName = (/**
 * @param {?} segment
 * @return {?}
 */
(segment) => segment.slice(1));
// it just removes leading ':'
/** @type {?} */
const ensureLeadingSlash = (/**
 * @param {?} path
 * @return {?}
 */
(path) => path.startsWith('/') ? path : '/' + path);
/** @type {?} */
const removeLeadingSlash = (/**
 * @param {?} path
 * @return {?}
 */
(path) => path.startsWith('/') ? path.slice(1) : path);

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @abstract
 */
class RoutingConfig {
}
if (false) {
    /** @type {?} */
    RoutingConfig.prototype.routing;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class RoutingConfigService {
    /**
     * @param {?} config
     */
    constructor(config) {
        this.config = config;
    }
    /**
     * @param {?} routeName
     * @return {?}
     */
    getRouteConfig(routeName) {
        /** @type {?} */
        const routeConfig = this.config && this.config.routing && this.config.routing.routes;
        /** @type {?} */
        const result = routeConfig && routeConfig[routeName];
        if (!routeConfig || result === undefined) {
            this.warn(`No path was configured for the named route '${routeName}'!`);
        }
        return result;
    }
    /**
     * @private
     * @param {...?} args
     * @return {?}
     */
    warn(...args) {
        if (isDevMode()) {
            console.warn(...args);
        }
    }
}
RoutingConfigService.decorators = [
    { type: Injectable, args: [{ providedIn: 'root' },] }
];
/** @nocollapse */
RoutingConfigService.ctorParameters = () => [
    { type: RoutingConfig }
];
/** @nocollapse */ RoutingConfigService.ngInjectableDef = ɵɵdefineInjectable({ factory: function RoutingConfigService_Factory() { return new RoutingConfigService(ɵɵinject(RoutingConfig)); }, token: RoutingConfigService, providedIn: "root" });
if (false) {
    /**
     * @type {?}
     * @protected
     */
    RoutingConfigService.prototype.config;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SemanticPathService {
    /**
     * @param {?} routingConfigService
     * @param {?} urlParser
     */
    constructor(routingConfigService, urlParser) {
        this.routingConfigService = routingConfigService;
        this.urlParser = urlParser;
        this.ROOT_URL = ['/'];
    }
    /**
     * Returns the first path alias configured for a given route name. It adds `/` at the beginning.
     * @param {?} routeName
     * @return {?}
     */
    get(routeName) {
        /** @type {?} */
        const routeConfig = this.routingConfigService.getRouteConfig(routeName);
        return routeConfig && Array.isArray(routeConfig.paths)
            ? '/' + routeConfig.paths[0]
            : undefined;
    }
    /**
     * Transforms the array of url commands. Each command can be:
     * a) string - will be left untouched
     * b) object { cxRoute: <route name> } - will be replaced with semantic path
     * c) object { cxRoute: <route name>, params: { ... } } - same as above, but with passed params
     *
     * If the first command is the object with the `cxRoute` property, returns an absolute url (with the first element of the array `'/'`)
     * @param {?} commands
     * @return {?}
     */
    transform(commands) {
        if (!Array.isArray(commands)) {
            commands = [commands];
        }
        /** @type {?} */
        const result = [];
        for (const command of commands) {
            if (!this.isRouteCommand(command)) {
                // don't modify segment that is not route command:
                result.push(command);
            }
            else {
                // generate array with url segments for given route command:
                /** @type {?} */
                const partialResult = this.generateUrlPart(command);
                if (partialResult === null) {
                    return this.ROOT_URL;
                }
                result.push(...partialResult);
            }
        }
        if (this.shouldOutputAbsolute(commands)) {
            result.unshift('/');
        }
        return result;
    }
    /**
     * @private
     * @param {?} command
     * @return {?}
     */
    isRouteCommand(command) {
        return command && Boolean(command.cxRoute);
    }
    /**
     * @private
     * @param {?} commands
     * @return {?}
     */
    shouldOutputAbsolute(commands) {
        return this.isRouteCommand(commands[0]);
    }
    /**
     * @private
     * @param {?} command
     * @return {?}
     */
    generateUrlPart(command) {
        this.standarizeRouteCommand(command);
        if (!command.cxRoute) {
            return null;
        }
        /** @type {?} */
        const routeConfig = this.routingConfigService.getRouteConfig(command.cxRoute);
        // if no route translation was configured, return null:
        if (!routeConfig || !routeConfig.paths) {
            return null;
        }
        // find first path that can satisfy it's parameters with given parameters
        /** @type {?} */
        const path = this.findPathWithFillableParams(routeConfig, command.params);
        // if there is no configured path that can be satisfied with given params, return null
        if (!path) {
            return null;
        }
        /** @type {?} */
        const result = this.provideParamsValues(path, command.params, routeConfig.paramsMapping);
        return result;
    }
    /**
     * @private
     * @param {?} command
     * @return {?}
     */
    standarizeRouteCommand(command) {
        command.params = command.params || {};
    }
    /**
     * @private
     * @param {?} path
     * @param {?} params
     * @param {?} paramsMapping
     * @return {?}
     */
    provideParamsValues(path, params, paramsMapping) {
        return this.urlParser.getPrimarySegments(path).map((/**
         * @param {?} segment
         * @return {?}
         */
        segment => {
            if (isParam(segment)) {
                /** @type {?} */
                const paramName = getParamName(segment);
                /** @type {?} */
                const mappedParamName = this.getMappedParamName(paramName, paramsMapping);
                return params[mappedParamName];
            }
            return segment;
        }));
    }
    /**
     * @private
     * @param {?} routeConfig
     * @param {?} params
     * @return {?}
     */
    findPathWithFillableParams(routeConfig, params) {
        /** @type {?} */
        const foundPath = routeConfig.paths.find((/**
         * @param {?} path
         * @return {?}
         */
        path => this.getParams(path).every((/**
         * @param {?} paramName
         * @return {?}
         */
        paramName => {
            /** @type {?} */
            const mappedParamName = this.getMappedParamName(paramName, routeConfig.paramsMapping);
            return params[mappedParamName] !== undefined;
        }))));
        if (foundPath === undefined || foundPath === null) {
            this.warn(`No configured path matches all its params to given object. `, `Route config: `, routeConfig, `Params object: `, params);
            return null;
        }
        return foundPath;
    }
    /**
     * @private
     * @param {?} path
     * @return {?}
     */
    getParams(path) {
        return this.urlParser
            .getPrimarySegments(path)
            .filter(isParam)
            .map(getParamName);
    }
    /**
     * @private
     * @param {?} paramName
     * @param {?} paramsMapping
     * @return {?}
     */
    getMappedParamName(paramName, paramsMapping) {
        if (paramsMapping) {
            return paramsMapping[paramName] || paramName;
        }
        return paramName;
    }
    /**
     * @private
     * @param {...?} args
     * @return {?}
     */
    warn(...args) {
        if (isDevMode()) {
            console.warn(...args);
        }
    }
}
SemanticPathService.decorators = [
    { type: Injectable, args: [{ providedIn: 'root' },] }
];
/** @nocollapse */
SemanticPathService.ctorParameters = () => [
    { type: RoutingConfigService },
    { type: UrlParsingService }
];
/** @nocollapse */ SemanticPathService.ngInjectableDef = ɵɵdefineInjectable({ factory: function SemanticPathService_Factory() { return new SemanticPathService(ɵɵinject(RoutingConfigService), ɵɵinject(UrlParsingService)); }, token: SemanticPathService, providedIn: "root" });
if (false) {
    /** @type {?} */
    SemanticPathService.prototype.ROOT_URL;
    /**
     * @type {?}
     * @protected
     */
    SemanticPathService.prototype.routingConfigService;
    /**
     * @type {?}
     * @protected
     */
    SemanticPathService.prototype.urlParser;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const ROUTER_GO = '[Router] Go';
/** @type {?} */
const ROUTER_GO_BY_URL = '[Router] Go By Url';
/** @type {?} */
const ROUTER_BACK = '[Router] Back';
/** @type {?} */
const ROUTER_FORWARD = '[Router] Forward';
class RouteGoAction {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        this.payload = payload;
        this.type = ROUTER_GO;
    }
}
if (false) {
    /** @type {?} */
    RouteGoAction.prototype.type;
    /** @type {?} */
    RouteGoAction.prototype.payload;
}
class RouteGoByUrlAction {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        this.payload = payload;
        this.type = ROUTER_GO_BY_URL;
    }
}
if (false) {
    /** @type {?} */
    RouteGoByUrlAction.prototype.type;
    /** @type {?} */
    RouteGoByUrlAction.prototype.payload;
}
class RouteBackAction {
    constructor() {
        this.type = ROUTER_BACK;
    }
}
if (false) {
    /** @type {?} */
    RouteBackAction.prototype.type;
}
class RouteForwardAction {
    constructor() {
        this.type = ROUTER_FORWARD;
    }
}
if (false) {
    /** @type {?} */
    RouteForwardAction.prototype.type;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

var routingGroup_actions = /*#__PURE__*/Object.freeze({
    ROUTER_GO: ROUTER_GO,
    ROUTER_GO_BY_URL: ROUTER_GO_BY_URL,
    ROUTER_BACK: ROUTER_BACK,
    ROUTER_FORWARD: ROUTER_FORWARD,
    RouteGoAction: RouteGoAction,
    RouteGoByUrlAction: RouteGoByUrlAction,
    RouteBackAction: RouteBackAction,
    RouteForwardAction: RouteForwardAction
});

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const ROUTING_FEATURE = 'router';
/**
 * @record
 */
function RouterState() { }
if (false) {
    /** @type {?|undefined} */
    RouterState.prototype.nextState;
}
/**
 * @record
 */
function ActivatedRouterStateSnapshot() { }
if (false) {
    /** @type {?} */
    ActivatedRouterStateSnapshot.prototype.url;
    /** @type {?} */
    ActivatedRouterStateSnapshot.prototype.queryParams;
    /** @type {?} */
    ActivatedRouterStateSnapshot.prototype.params;
    /** @type {?} */
    ActivatedRouterStateSnapshot.prototype.context;
    /** @type {?} */
    ActivatedRouterStateSnapshot.prototype.cmsRequired;
}
/**
 * @record
 */
function State() { }
if (false) {
    /* Skipping unnamed member:
    [ROUTING_FEATURE]: RouterState;*/
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const getRouterFeatureState = createFeatureSelector(ROUTING_FEATURE);
const ɵ0$2 = /**
 * @param {?} state
 * @return {?}
 */
state => state.router;
/** @type {?} */
const getRouterState = createSelector(getRouterFeatureState, (ɵ0$2));
const ɵ1$1 = /**
 * @param {?} routingState
 * @return {?}
 */
(routingState) => (routingState.state && routingState.state.context) || { id: '' };
/** @type {?} */
const getPageContext = createSelector(getRouterState, (ɵ1$1));
const ɵ2 = /**
 * @param {?} routingState
 * @return {?}
 */
(routingState) => routingState.nextState && routingState.nextState.context;
/** @type {?} */
const getNextPageContext = createSelector(getRouterState, (ɵ2));
const ɵ3 = /**
 * @param {?} context
 * @return {?}
 */
context => !!context;
/** @type {?} */
const isNavigating = createSelector(getNextPageContext, (ɵ3));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

var routingGroup_selectors = /*#__PURE__*/Object.freeze({
    getRouterFeatureState: getRouterFeatureState,
    getRouterState: getRouterState,
    getPageContext: getPageContext,
    getNextPageContext: getNextPageContext,
    isNavigating: isNavigating
});

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class RoutingService {
    /**
     * @param {?} store
     * @param {?} winRef
     * @param {?} semanticPathService
     */
    constructor(store, winRef, semanticPathService) {
        this.store = store;
        this.winRef = winRef;
        this.semanticPathService = semanticPathService;
    }
    /**
     * Get the current router state
     * @return {?}
     */
    getRouterState() {
        return this.store.pipe(select(getRouterState));
    }
    /**
     * Get the `PageContext` from the state
     * @return {?}
     */
    getPageContext() {
        return this.store.pipe(select(getPageContext));
    }
    /**
     * Get the next `PageContext` from the state
     * @return {?}
     */
    getNextPageContext() {
        return this.store.pipe(select(getNextPageContext));
    }
    /**
     * Get the `isNavigating` info from the state
     * @return {?}
     */
    isNavigating() {
        return this.store.pipe(select(isNavigating));
    }
    /**
     * Navigation with a new state into history
     * @param {?} commands
     * @param {?=} query
     * @param {?=} extras
     * @return {?}
     */
    go(commands, query, extras) {
        /** @type {?} */
        const path = this.semanticPathService.transform(commands);
        return this.navigate(path, query, extras);
    }
    /**
     * Navigation using URL
     * @param {?} url
     * @return {?}
     */
    goByUrl(url) {
        this.store.dispatch(new RouteGoByUrlAction(url));
    }
    /**
     * Navigating back
     * @return {?}
     */
    back() {
        /** @type {?} */
        const isLastPageInApp = this.winRef.document.referrer.includes(this.winRef.nativeWindow.location.origin);
        if (isLastPageInApp) {
            this.store.dispatch(new RouteBackAction());
            return;
        }
        this.go(['/']);
        return;
    }
    /**
     * Navigating forward
     * @return {?}
     */
    forward() {
        this.store.dispatch(new RouteForwardAction());
    }
    /**
     * Navigation with a new state into history
     * @protected
     * @param {?} path
     * @param {?=} query
     * @param {?=} extras
     * @return {?}
     */
    navigate(path, query, extras) {
        this.store.dispatch(new RouteGoAction({
            path,
            query,
            extras,
        }));
    }
}
RoutingService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root',
            },] }
];
/** @nocollapse */
RoutingService.ctorParameters = () => [
    { type: Store },
    { type: WindowRef },
    { type: SemanticPathService }
];
/** @nocollapse */ RoutingService.ngInjectableDef = ɵɵdefineInjectable({ factory: function RoutingService_Factory() { return new RoutingService(ɵɵinject(Store), ɵɵinject(WindowRef), ɵɵinject(SemanticPathService)); }, token: RoutingService, providedIn: "root" });
if (false) {
    /**
     * @type {?}
     * @protected
     */
    RoutingService.prototype.store;
    /**
     * @type {?}
     * @protected
     */
    RoutingService.prototype.winRef;
    /**
     * @type {?}
     * @protected
     */
    RoutingService.prototype.semanticPathService;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class UserErrorHandlingService {
    /**
     * @param {?} authService
     * @param {?} routingService
     */
    constructor(authService, routingService) {
        this.authService = authService;
        this.routingService = routingService;
    }
    /**
     * @param {?} request
     * @param {?} next
     * @return {?}
     */
    handleExpiredUserToken(request, next) {
        return this.handleExpiredToken().pipe(switchMap((/**
         * @param {?} token
         * @return {?}
         */
        (token) => {
            return next.handle(this.createNewRequestWithNewToken(request, token));
        })));
    }
    /**
     * @return {?}
     */
    handleExpiredRefreshToken() {
        // Logout user
        this.authService.logout();
    }
    /**
     * @protected
     * @return {?}
     */
    handleExpiredToken() {
        /** @type {?} */
        let oldToken;
        return this.authService.getUserToken().pipe(tap((/**
         * @param {?} token
         * @return {?}
         */
        (token) => {
            if (token.access_token && token.refresh_token && !oldToken) {
                this.authService.refreshUserToken(token);
            }
            else if (!token.access_token && !token.refresh_token) {
                this.routingService.go({ cxRoute: 'login' });
            }
            else if (!token.refresh_token) {
                this.authService.logout();
                this.routingService.go({ cxRoute: 'login' });
            }
            oldToken = oldToken || token;
        })), filter((/**
         * @param {?} token
         * @return {?}
         */
        (token) => oldToken.access_token !== token.access_token)), take(1));
    }
    /**
     * @protected
     * @param {?} request
     * @param {?} token
     * @return {?}
     */
    createNewRequestWithNewToken(request, token) {
        request = request.clone({
            setHeaders: {
                Authorization: `${token.token_type} ${token.access_token}`,
            },
        });
        return request;
    }
}
UserErrorHandlingService.decorators = [
    { type: Injectable }
];
/** @nocollapse */
UserErrorHandlingService.ctorParameters = () => [
    { type: AuthService },
    { type: RoutingService }
];
if (false) {
    /**
     * @type {?}
     * @protected
     */
    UserErrorHandlingService.prototype.authService;
    /**
     * @type {?}
     * @protected
     */
    UserErrorHandlingService.prototype.routingService;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const OAUTH_ENDPOINT = '/authorizationserver/oauth/token';
class AuthErrorInterceptor {
    /**
     * @param {?} userErrorHandlingService
     * @param {?} clientErrorHandlingService
     * @param {?} authService
     */
    constructor(userErrorHandlingService, clientErrorHandlingService, authService) {
        this.userErrorHandlingService = userErrorHandlingService;
        this.clientErrorHandlingService = clientErrorHandlingService;
        this.authService = authService;
    }
    /**
     * @param {?} request
     * @param {?} next
     * @return {?}
     */
    intercept(request, next) {
        /** @type {?} */
        const isClientTokenRequest = this.isClientTokenRequest(request);
        if (isClientTokenRequest) {
            request = InterceptorUtil.removeHeader(USE_CLIENT_TOKEN, request);
        }
        return next.handle(request).pipe(catchError((/**
         * @param {?} errResponse
         * @return {?}
         */
        (errResponse) => {
            if (errResponse instanceof HttpErrorResponse) {
                switch (errResponse.status) {
                    case 401: // Unauthorized
                        if (isClientTokenRequest) {
                            if (this.isExpiredToken(errResponse)) {
                                return this.clientErrorHandlingService.handleExpiredClientToken(request, next);
                            }
                            // user token request
                        }
                        else {
                            if (this.isExpiredToken(errResponse)) {
                                return this.userErrorHandlingService.handleExpiredUserToken(request, next);
                            }
                            else if (
                            // Refresh expired token
                            // Check that the OAUTH endpoint was called and the error is for refresh token is expired
                            errResponse.url.includes(OAUTH_ENDPOINT) &&
                                errResponse.error.error === 'invalid_token') {
                                this.userErrorHandlingService.handleExpiredRefreshToken();
                                return of();
                            }
                        }
                        break;
                    case 400: // Bad Request
                        if (errResponse.url.includes(OAUTH_ENDPOINT) &&
                            errResponse.error.error === 'invalid_grant') {
                            if (request.body.get('grant_type') === 'refresh_token') {
                                // refresh token fail, force user logout
                                this.authService.logout();
                            }
                        }
                        break;
                }
            }
            return throwError(errResponse);
        })));
    }
    /**
     * @private
     * @param {?} request
     * @return {?}
     */
    isClientTokenRequest(request) {
        /** @type {?} */
        const isRequestMapping = InterceptorUtil.getInterceptorParam(USE_CLIENT_TOKEN, request.headers);
        return Boolean(isRequestMapping);
    }
    /**
     * @private
     * @param {?} resp
     * @return {?}
     */
    isExpiredToken(resp) {
        if (resp.error &&
            resp.error.errors &&
            resp.error.errors instanceof Array &&
            resp.error.errors[0]) {
            return resp.error.errors[0].type === 'InvalidTokenError';
        }
        return false;
    }
}
AuthErrorInterceptor.decorators = [
    { type: Injectable, args: [{ providedIn: 'root' },] }
];
/** @nocollapse */
AuthErrorInterceptor.ctorParameters = () => [
    { type: UserErrorHandlingService },
    { type: ClientErrorHandlingService },
    { type: AuthService }
];
/** @nocollapse */ AuthErrorInterceptor.ngInjectableDef = ɵɵdefineInjectable({ factory: function AuthErrorInterceptor_Factory() { return new AuthErrorInterceptor(ɵɵinject(UserErrorHandlingService), ɵɵinject(ClientErrorHandlingService), ɵɵinject(AuthService)); }, token: AuthErrorInterceptor, providedIn: "root" });
if (false) {
    /**
     * @type {?}
     * @private
     */
    AuthErrorInterceptor.prototype.userErrorHandlingService;
    /**
     * @type {?}
     * @private
     */
    AuthErrorInterceptor.prototype.clientErrorHandlingService;
    /**
     * @type {?}
     * @private
     */
    AuthErrorInterceptor.prototype.authService;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class DynamicTemplate {
    /**
     * @param {?} templateString
     * @param {?} templateVariables
     * @return {?}
     */
    static resolve(templateString, templateVariables) {
        for (const variableLabel of Object.keys(templateVariables)) {
            /** @type {?} */
            const placeholder = new RegExp('\\${' + variableLabel + '}', 'g');
            templateString = templateString.replace(placeholder, templateVariables[variableLabel]);
        }
        return templateString;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Helper function for safely getting context parameter config
 *
 * @param {?} config
 * @param {?} parameter
 * @return {?}
 */
function getContextParameterValues(config, parameter) {
    return (config.context && config.context[parameter]) || [];
}
/**
 * Helper function for calculating default value for context parameter from config
 *
 * @param {?} config
 * @param {?} parameter
 * @return {?}
 */
function getContextParameterDefault(config, parameter) {
    /** @type {?} */
    const param = getContextParameterValues(config, parameter);
    return param && param.length ? param[0] : undefined;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const LOAD_BASE_SITE = '[Site-context] Load BaseSite';
/** @type {?} */
const LOAD_BASE_SITE_FAIL = '[Site-context] Load BaseSite Fail';
/** @type {?} */
const LOAD_BASE_SITE_SUCCESS = '[Site-context] Load BaseSite Success';
/** @type {?} */
const SET_ACTIVE_BASE_SITE = '[Site-context] Set Active BaseSite';
/** @type {?} */
const BASE_SITE_CHANGE = '[Site-context] BaseSite Change';
class LoadBaseSite {
    constructor() {
        this.type = LOAD_BASE_SITE;
    }
}
if (false) {
    /** @type {?} */
    LoadBaseSite.prototype.type;
}
class LoadBaseSiteFail {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        this.payload = payload;
        this.type = LOAD_BASE_SITE_FAIL;
    }
}
if (false) {
    /** @type {?} */
    LoadBaseSiteFail.prototype.type;
    /** @type {?} */
    LoadBaseSiteFail.prototype.payload;
}
class LoadBaseSiteSuccess {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        this.payload = payload;
        this.type = LOAD_BASE_SITE_SUCCESS;
    }
}
if (false) {
    /** @type {?} */
    LoadBaseSiteSuccess.prototype.type;
    /** @type {?} */
    LoadBaseSiteSuccess.prototype.payload;
}
class SetActiveBaseSite {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        this.payload = payload;
        this.type = SET_ACTIVE_BASE_SITE;
    }
}
if (false) {
    /** @type {?} */
    SetActiveBaseSite.prototype.type;
    /** @type {?} */
    SetActiveBaseSite.prototype.payload;
}
class BaseSiteChange {
    constructor() {
        this.type = BASE_SITE_CHANGE;
    }
}
if (false) {
    /** @type {?} */
    BaseSiteChange.prototype.type;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const LOAD_CURRENCIES = '[Site-context] Load Currencies';
/** @type {?} */
const LOAD_CURRENCIES_FAIL = '[Site-context] Load Currencies Fail';
/** @type {?} */
const LOAD_CURRENCIES_SUCCESS = '[Site-context] Load Currencies Success';
/** @type {?} */
const SET_ACTIVE_CURRENCY = '[Site-context] Set Active Currency';
/** @type {?} */
const CURRENCY_CHANGE = '[Site-context] Currency Change';
class LoadCurrencies {
    constructor() {
        this.type = LOAD_CURRENCIES;
    }
}
if (false) {
    /** @type {?} */
    LoadCurrencies.prototype.type;
}
class LoadCurrenciesFail {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        this.payload = payload;
        this.type = LOAD_CURRENCIES_FAIL;
    }
}
if (false) {
    /** @type {?} */
    LoadCurrenciesFail.prototype.type;
    /** @type {?} */
    LoadCurrenciesFail.prototype.payload;
}
class LoadCurrenciesSuccess {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        this.payload = payload;
        this.type = LOAD_CURRENCIES_SUCCESS;
    }
}
if (false) {
    /** @type {?} */
    LoadCurrenciesSuccess.prototype.type;
    /** @type {?} */
    LoadCurrenciesSuccess.prototype.payload;
}
class SetActiveCurrency {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        this.payload = payload;
        this.type = SET_ACTIVE_CURRENCY;
    }
}
if (false) {
    /** @type {?} */
    SetActiveCurrency.prototype.type;
    /** @type {?} */
    SetActiveCurrency.prototype.payload;
}
class CurrencyChange {
    constructor() {
        this.type = CURRENCY_CHANGE;
    }
}
if (false) {
    /** @type {?} */
    CurrencyChange.prototype.type;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const LOAD_LANGUAGES = '[Site-context] Load Languages';
/** @type {?} */
const LOAD_LANGUAGES_FAIL = '[Site-context] Load Languages Fail';
/** @type {?} */
const LOAD_LANGUAGES_SUCCESS = '[Site-context] Load Languages Success';
/** @type {?} */
const SET_ACTIVE_LANGUAGE = '[Site-context] Set Active Language';
/** @type {?} */
const LANGUAGE_CHANGE = '[Site-context] Language Change';
class LoadLanguages {
    constructor() {
        this.type = LOAD_LANGUAGES;
    }
}
if (false) {
    /** @type {?} */
    LoadLanguages.prototype.type;
}
class LoadLanguagesFail {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        this.payload = payload;
        this.type = LOAD_LANGUAGES_FAIL;
    }
}
if (false) {
    /** @type {?} */
    LoadLanguagesFail.prototype.type;
    /** @type {?} */
    LoadLanguagesFail.prototype.payload;
}
class LoadLanguagesSuccess {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        this.payload = payload;
        this.type = LOAD_LANGUAGES_SUCCESS;
    }
}
if (false) {
    /** @type {?} */
    LoadLanguagesSuccess.prototype.type;
    /** @type {?} */
    LoadLanguagesSuccess.prototype.payload;
}
class SetActiveLanguage {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        this.payload = payload;
        this.type = SET_ACTIVE_LANGUAGE;
    }
}
if (false) {
    /** @type {?} */
    SetActiveLanguage.prototype.type;
    /** @type {?} */
    SetActiveLanguage.prototype.payload;
}
class LanguageChange {
    constructor() {
        this.type = LANGUAGE_CHANGE;
    }
}
if (false) {
    /** @type {?} */
    LanguageChange.prototype.type;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

var siteContextGroup_actions = /*#__PURE__*/Object.freeze({
    LOAD_BASE_SITE: LOAD_BASE_SITE,
    LOAD_BASE_SITE_FAIL: LOAD_BASE_SITE_FAIL,
    LOAD_BASE_SITE_SUCCESS: LOAD_BASE_SITE_SUCCESS,
    SET_ACTIVE_BASE_SITE: SET_ACTIVE_BASE_SITE,
    BASE_SITE_CHANGE: BASE_SITE_CHANGE,
    LoadBaseSite: LoadBaseSite,
    LoadBaseSiteFail: LoadBaseSiteFail,
    LoadBaseSiteSuccess: LoadBaseSiteSuccess,
    SetActiveBaseSite: SetActiveBaseSite,
    BaseSiteChange: BaseSiteChange,
    LOAD_CURRENCIES: LOAD_CURRENCIES,
    LOAD_CURRENCIES_FAIL: LOAD_CURRENCIES_FAIL,
    LOAD_CURRENCIES_SUCCESS: LOAD_CURRENCIES_SUCCESS,
    SET_ACTIVE_CURRENCY: SET_ACTIVE_CURRENCY,
    CURRENCY_CHANGE: CURRENCY_CHANGE,
    LoadCurrencies: LoadCurrencies,
    LoadCurrenciesFail: LoadCurrenciesFail,
    LoadCurrenciesSuccess: LoadCurrenciesSuccess,
    SetActiveCurrency: SetActiveCurrency,
    CurrencyChange: CurrencyChange,
    LOAD_LANGUAGES: LOAD_LANGUAGES,
    LOAD_LANGUAGES_FAIL: LOAD_LANGUAGES_FAIL,
    LOAD_LANGUAGES_SUCCESS: LOAD_LANGUAGES_SUCCESS,
    SET_ACTIVE_LANGUAGE: SET_ACTIVE_LANGUAGE,
    LANGUAGE_CHANGE: LANGUAGE_CHANGE,
    LoadLanguages: LoadLanguages,
    LoadLanguagesFail: LoadLanguagesFail,
    LoadLanguagesSuccess: LoadLanguagesSuccess,
    SetActiveLanguage: SetActiveLanguage,
    LanguageChange: LanguageChange
});

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const SITE_CONTEXT_FEATURE = 'siteContext';
/**
 * @record
 */
function StateWithSiteContext() { }
if (false) {
    /* Skipping unnamed member:
    [SITE_CONTEXT_FEATURE]: SiteContextState;*/
}
/**
 * @record
 */
function SiteContextState() { }
if (false) {
    /** @type {?} */
    SiteContextState.prototype.languages;
    /** @type {?} */
    SiteContextState.prototype.currencies;
    /** @type {?} */
    SiteContextState.prototype.baseSite;
}
/**
 * @record
 */
function CurrencyEntities() { }
/**
 * @record
 */
function CurrenciesState() { }
if (false) {
    /** @type {?} */
    CurrenciesState.prototype.entities;
    /** @type {?} */
    CurrenciesState.prototype.activeCurrency;
}
/**
 * @record
 */
function LanguagesEntities() { }
/**
 * @record
 */
function LanguagesState() { }
if (false) {
    /** @type {?} */
    LanguagesState.prototype.entities;
    /** @type {?} */
    LanguagesState.prototype.activeLanguage;
}
/**
 * @record
 */
function BaseSiteState() { }
if (false) {
    /** @type {?} */
    BaseSiteState.prototype.activeSite;
    /** @type {?} */
    BaseSiteState.prototype.details;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const getSiteContextState = createFeatureSelector(SITE_CONTEXT_FEATURE);

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
const ɵ0$3 = /**
 * @param {?} state
 * @return {?}
 */
(state) => state && state.baseSite && state.baseSite.activeSite;
/** @type {?} */
const getActiveBaseSite = createSelector(getSiteContextState, (ɵ0$3));
const ɵ1$2 = /**
 * @param {?} state
 * @return {?}
 */
(state) => state && state.baseSite && state.baseSite.details;
/** @type {?} */
const getBaseSiteData = createSelector(getSiteContextState, (ɵ1$2));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const currenciesEntitiesSelector = (/**
 * @param {?} state
 * @return {?}
 */
(state) => state.entities);
const ɵ0$4 = currenciesEntitiesSelector;
/** @type {?} */
const activeCurrencySelector = (/**
 * @param {?} state
 * @return {?}
 */
(state) => state.activeCurrency);
const ɵ1$3 = activeCurrencySelector;
const ɵ2$1 = /**
 * @param {?} state
 * @return {?}
 */
(state) => state.currencies;
/** @type {?} */
const getCurrenciesState = createSelector(getSiteContextState, (ɵ2$1));
/** @type {?} */
const getCurrenciesEntities = createSelector(getCurrenciesState, currenciesEntitiesSelector);
/** @type {?} */
const getActiveCurrency = createSelector(getCurrenciesState, activeCurrencySelector);
const ɵ3$1 = /**
 * @param {?} entities
 * @return {?}
 */
entities => {
    return entities
        ? Object.keys(entities).map((/**
         * @param {?} isocode
         * @return {?}
         */
        isocode => entities[isocode]))
        : null;
};
/** @type {?} */
const getAllCurrencies = createSelector(getCurrenciesEntities, (ɵ3$1));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const activeLanguageSelector = (/**
 * @param {?} state
 * @return {?}
 */
(state) => state.activeLanguage);
const ɵ0$5 = activeLanguageSelector;
/** @type {?} */
const languagesEntitiesSelector = (/**
 * @param {?} state
 * @return {?}
 */
(state) => state.entities);
const ɵ1$4 = languagesEntitiesSelector;
const ɵ2$2 = /**
 * @param {?} state
 * @return {?}
 */
(state) => state.languages;
/** @type {?} */
const getLanguagesState = createSelector(getSiteContextState, (ɵ2$2));
/** @type {?} */
const getLanguagesEntities = createSelector(getLanguagesState, languagesEntitiesSelector);
/** @type {?} */
const getActiveLanguage = createSelector(getLanguagesState, activeLanguageSelector);
const ɵ3$2 = /**
 * @param {?} entities
 * @return {?}
 */
entities => {
    return entities
        ? Object.keys(entities).map((/**
         * @param {?} isocode
         * @return {?}
         */
        isocode => entities[isocode]))
        : null;
};
/** @type {?} */
const getAllLanguages = createSelector(getLanguagesEntities, (ɵ3$2));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

var siteContextGroup_selectors = /*#__PURE__*/Object.freeze({
    getActiveBaseSite: getActiveBaseSite,
    getBaseSiteData: getBaseSiteData,
    getCurrenciesState: getCurrenciesState,
    getCurrenciesEntities: getCurrenciesEntities,
    getActiveCurrency: getActiveCurrency,
    getAllCurrencies: getAllCurrencies,
    getLanguagesState: getLanguagesState,
    getLanguagesEntities: getLanguagesEntities,
    getActiveLanguage: getActiveLanguage,
    getAllLanguages: getAllLanguages,
    getSiteContextState: getSiteContextState
});

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const LANGUAGE_CONTEXT_ID = 'language';
/** @type {?} */
const CURRENCY_CONTEXT_ID = 'currency';
/** @type {?} */
const BASE_SITE_CONTEXT_ID = 'baseSite';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class BaseSiteService {
    /**
     * @param {?} store
     * @param {?} config
     */
    constructor(store, config) {
        this.store = store;
        this.config = config;
    }
    /**
     * Represents the current baseSite uid.
     * @return {?}
     */
    getActive() {
        return this.store.pipe(select(getActiveBaseSite), filter((/**
         * @param {?} active
         * @return {?}
         */
        active => Boolean(active))));
    }
    /**
     * We currently don't support switching baseSite at run time
     * @return {?}
     */
    getAll() {
        return this.getActive().pipe(map((/**
         * @param {?} baseSite
         * @return {?}
         */
        baseSite => [baseSite])));
    }
    /**
     * @param {?} baseSite
     * @return {?}
     */
    setActive(baseSite) {
        return this.store
            .pipe(select(getActiveBaseSite), take(1))
            .subscribe((/**
         * @param {?} activeBaseSite
         * @return {?}
         */
        activeBaseSite => {
            if (baseSite && activeBaseSite !== baseSite) {
                this.store.dispatch(new SetActiveBaseSite(baseSite));
            }
        }));
    }
    /**
     * Initializes the active baseSite.
     * @return {?}
     */
    initialize() {
        this.setActive(getContextParameterDefault(this.config, BASE_SITE_CONTEXT_ID));
    }
    /**
     * Get the base site details data
     * @return {?}
     */
    getBaseSiteData() {
        return this.store.pipe(select(getBaseSiteData), tap((/**
         * @param {?} baseSite
         * @return {?}
         */
        baseSite => {
            if (Object.keys(baseSite).length === 0) {
                this.store.dispatch(new LoadBaseSite());
            }
        })));
    }
}
BaseSiteService.decorators = [
    { type: Injectable }
];
/** @nocollapse */
BaseSiteService.ctorParameters = () => [
    { type: Store },
    { type: SiteContextConfig }
];
if (false) {
    /**
     * @type {?}
     * @protected
     */
    BaseSiteService.prototype.store;
    /**
     * @type {?}
     * @protected
     */
    BaseSiteService.prototype.config;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class OccEndpointsService {
    /**
     * @param {?} config
     * @param {?} baseSiteService
     */
    constructor(config, baseSiteService) {
        this.config = config;
        this.baseSiteService = baseSiteService;
        this.SCOPE_SUFFIX = '_scopes';
        this.activeBaseSite =
            getContextParameterDefault(this.config, BASE_SITE_CONTEXT_ID) || '';
        if (this.baseSiteService) {
            this.baseSiteService
                .getActive()
                .subscribe((/**
             * @param {?} value
             * @return {?}
             */
            value => (this.activeBaseSite = value)));
        }
    }
    /**
     * Returns and endpoint starting from the OCC baseUrl (no baseSite)
     * @param {?} endpoint Endpoint suffix
     * @return {?}
     */
    getRawEndpoint(endpoint) {
        if (!this.config || !this.config.backend || !this.config.backend.occ) {
            return '';
        }
        endpoint = this.config.backend.occ.endpoints[endpoint];
        if (!endpoint.startsWith('/')) {
            endpoint = '/' + endpoint;
        }
        return this.config.backend.occ.baseUrl + endpoint;
    }
    /**
     * Returns base OCC endpoint (baseUrl + prefix + baseSite)
     * @return {?}
     */
    getBaseEndpoint() {
        if (!this.config || !this.config.backend || !this.config.backend.occ) {
            return '';
        }
        return ((this.config.backend.occ.baseUrl || '') +
            this.config.backend.occ.prefix +
            this.activeBaseSite);
    }
    /**
     * Returns an OCC endpoint including baseUrl and baseSite
     * @param {?} endpoint Endpoint suffix
     * @return {?}
     */
    getEndpoint(endpoint) {
        if (!endpoint.startsWith('/')) {
            endpoint = '/' + endpoint;
        }
        return this.getBaseEndpoint() + endpoint;
    }
    /**
     * Returns a fully qualified OCC Url (including baseUrl and baseSite)
     * @param {?} endpoint Name of the OCC endpoint key config
     * @param {?=} urlParams  URL parameters
     * @param {?=} queryParams Query parameters
     * @param {?=} scope
     * @return {?}
     */
    getUrl(endpoint, urlParams, queryParams, scope = '') {
        endpoint = this.getEndpointForScope(endpoint, scope);
        if (urlParams) {
            Object.keys(urlParams).forEach((/**
             * @param {?} key
             * @return {?}
             */
            key => {
                urlParams[key] = encodeURIComponent(urlParams[key]);
            }));
            endpoint = DynamicTemplate.resolve(endpoint, urlParams);
        }
        if (queryParams) {
            /** @type {?} */
            let httpParamsOptions;
            if (endpoint.includes('?')) {
                /** @type {?} */
                let queryParamsFromEndpoint;
                [endpoint, queryParamsFromEndpoint] = endpoint.split('?');
                httpParamsOptions = { fromString: queryParamsFromEndpoint };
            }
            /** @type {?} */
            let httpParams = new HttpParams(httpParamsOptions);
            Object.keys(queryParams).forEach((/**
             * @param {?} key
             * @return {?}
             */
            key => {
                /** @type {?} */
                const value = queryParams[key];
                if (value !== undefined) {
                    if (value === null) {
                        httpParams = httpParams.delete(key);
                    }
                    else {
                        httpParams = httpParams.set(key, value);
                    }
                }
            }));
            /** @type {?} */
            const params = httpParams.toString();
            if (params.length) {
                endpoint += '?' + params;
            }
        }
        return this.getEndpoint(endpoint);
    }
    /**
     * @private
     * @param {?} endpoint
     * @param {?} scope
     * @return {?}
     */
    getEndpointForScope(endpoint, scope) {
        /** @type {?} */
        const endpointsConfig = this.config.backend &&
            this.config.backend.occ &&
            this.config.backend.occ.endpoints;
        if (scope) {
            /** @type {?} */
            const endpointConfig = endpointsConfig[`${endpoint}${this.SCOPE_SUFFIX}`];
            if (endpointConfig && endpointConfig[scope]) {
                return endpointConfig[scope];
            }
            if (isDevMode()) {
                console.warn(`${endpoint} endpoint configuration missing for scope "${scope}"`);
            }
        }
        return endpointsConfig[endpoint] || endpoint;
    }
}
OccEndpointsService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root',
            },] }
];
/** @nocollapse */
OccEndpointsService.ctorParameters = () => [
    { type: OccConfig },
    { type: BaseSiteService, decorators: [{ type: Optional }] }
];
/** @nocollapse */ OccEndpointsService.ngInjectableDef = ɵɵdefineInjectable({ factory: function OccEndpointsService_Factory() { return new OccEndpointsService(ɵɵinject(OccConfig), ɵɵinject(BaseSiteService, 8)); }, token: OccEndpointsService, providedIn: "root" });
if (false) {
    /**
     * @type {?}
     * @private
     */
    OccEndpointsService.prototype.activeBaseSite;
    /**
     * @type {?}
     * @private
     */
    OccEndpointsService.prototype.SCOPE_SUFFIX;
    /**
     * @type {?}
     * @private
     */
    OccEndpointsService.prototype.config;
    /**
     * @type {?}
     * @private
     */
    OccEndpointsService.prototype.baseSiteService;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ClientTokenInterceptor {
    /**
     * @param {?} authService
     * @param {?} occEndpoints
     */
    constructor(authService, occEndpoints) {
        this.authService = authService;
        this.occEndpoints = occEndpoints;
    }
    /**
     * @param {?} request
     * @param {?} next
     * @return {?}
     */
    intercept(request, next) {
        return this.getClientToken(request).pipe(take(1), switchMap((/**
         * @param {?} token
         * @return {?}
         */
        (token) => {
            if (token &&
                request.url.includes(this.occEndpoints.getBaseEndpoint())) {
                request = request.clone({
                    setHeaders: {
                        Authorization: `${token.token_type} ${token.access_token}`,
                    },
                });
            }
            return next.handle(request);
        })));
    }
    /**
     * @private
     * @param {?} request
     * @return {?}
     */
    getClientToken(request) {
        if (InterceptorUtil.getInterceptorParam(USE_CLIENT_TOKEN, request.headers)) {
            return this.authService.getClientToken();
        }
        return of(null);
    }
}
ClientTokenInterceptor.decorators = [
    { type: Injectable, args: [{ providedIn: 'root' },] }
];
/** @nocollapse */
ClientTokenInterceptor.ctorParameters = () => [
    { type: AuthService },
    { type: OccEndpointsService }
];
/** @nocollapse */ ClientTokenInterceptor.ngInjectableDef = ɵɵdefineInjectable({ factory: function ClientTokenInterceptor_Factory() { return new ClientTokenInterceptor(ɵɵinject(AuthService), ɵɵinject(OccEndpointsService)); }, token: ClientTokenInterceptor, providedIn: "root" });
if (false) {
    /**
     * @type {?}
     * @private
     */
    ClientTokenInterceptor.prototype.authService;
    /**
     * @type {?}
     * @private
     */
    ClientTokenInterceptor.prototype.occEndpoints;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class UserTokenInterceptor {
    /**
     * @param {?} authService
     * @param {?} occEndpoints
     */
    constructor(authService, occEndpoints) {
        this.authService = authService;
        this.occEndpoints = occEndpoints;
    }
    /**
     * @param {?} request
     * @param {?} next
     * @return {?}
     */
    intercept(request, next) {
        return this.authService.getUserToken().pipe(take(1), switchMap((/**
         * @param {?} token
         * @return {?}
         */
        token => {
            if (token &&
                this.isOccUrl(request.url) &&
                !request.headers.get('Authorization')) {
                request = request.clone({
                    setHeaders: {
                        Authorization: `${token.token_type} ${token.access_token}`,
                    },
                });
            }
            return next.handle(request);
        })));
    }
    /**
     * @private
     * @param {?} url
     * @return {?}
     */
    isOccUrl(url) {
        return url.includes(this.occEndpoints.getBaseEndpoint());
    }
}
UserTokenInterceptor.decorators = [
    { type: Injectable, args: [{ providedIn: 'root' },] }
];
/** @nocollapse */
UserTokenInterceptor.ctorParameters = () => [
    { type: AuthService },
    { type: OccEndpointsService }
];
/** @nocollapse */ UserTokenInterceptor.ngInjectableDef = ɵɵdefineInjectable({ factory: function UserTokenInterceptor_Factory() { return new UserTokenInterceptor(ɵɵinject(AuthService), ɵɵinject(OccEndpointsService)); }, token: UserTokenInterceptor, providedIn: "root" });
if (false) {
    /**
     * @type {?}
     * @private
     */
    UserTokenInterceptor.prototype.authService;
    /**
     * @type {?}
     * @private
     */
    UserTokenInterceptor.prototype.occEndpoints;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class TokenRevocationInterceptor {
    constructor() { }
    /**
     * @param {?} request
     * @param {?} next
     * @return {?}
     */
    intercept(request, next) {
        /** @type {?} */
        const isTokenRevocationRequest = this.isTokenRevocationRequest(request);
        if (isTokenRevocationRequest) {
            request = InterceptorUtil.removeHeader(TOKEN_REVOCATION_HEADER, request);
        }
        return next.handle(request).pipe(catchError((/**
         * @param {?} error
         * @return {?}
         */
        (error) => {
            if (isTokenRevocationRequest) {
                return EMPTY;
            }
            return throwError(error);
        })));
    }
    /**
     * @protected
     * @param {?} request
     * @return {?}
     */
    isTokenRevocationRequest(request) {
        /** @type {?} */
        const isTokenRevocationHeaderPresent = InterceptorUtil.getInterceptorParam(TOKEN_REVOCATION_HEADER, request.headers);
        return Boolean(isTokenRevocationHeaderPresent);
    }
}
TokenRevocationInterceptor.decorators = [
    { type: Injectable, args: [{ providedIn: 'root' },] }
];
/** @nocollapse */
TokenRevocationInterceptor.ctorParameters = () => [];
/** @nocollapse */ TokenRevocationInterceptor.ngInjectableDef = ɵɵdefineInjectable({ factory: function TokenRevocationInterceptor_Factory() { return new TokenRevocationInterceptor(); }, token: TokenRevocationInterceptor, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const interceptors = [
    {
        provide: HTTP_INTERCEPTORS,
        useExisting: ClientTokenInterceptor,
        multi: true,
    },
    {
        provide: HTTP_INTERCEPTORS,
        useExisting: UserTokenInterceptor,
        multi: true,
    },
    {
        provide: HTTP_INTERCEPTORS,
        useExisting: AuthErrorInterceptor,
        multi: true,
    },
    {
        provide: HTTP_INTERCEPTORS,
        useExisting: TokenRevocationInterceptor,
        multi: true,
    },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ClientAuthenticationTokenService {
    /**
     * @param {?} config
     * @param {?} http
     * @param {?=} occEndpointsService
     */
    constructor(config, http, occEndpointsService) {
        this.config = config;
        this.http = http;
        this.occEndpointsService = occEndpointsService;
    }
    /**
     * @return {?}
     */
    loadClientAuthenticationToken() {
        /** @type {?} */
        const url = this.occEndpointsService.getRawEndpoint('login');
        /** @type {?} */
        const params = new HttpParams()
            .set('client_id', encodeURIComponent(this.config.authentication.client_id))
            .set('client_secret', encodeURIComponent(this.config.authentication.client_secret))
            .set('grant_type', 'client_credentials');
        /** @type {?} */
        const headers = new HttpHeaders({
            'Content-Type': 'application/x-www-form-urlencoded',
        });
        return this.http.post(url, params, { headers });
    }
}
ClientAuthenticationTokenService.decorators = [
    { type: Injectable }
];
/** @nocollapse */
ClientAuthenticationTokenService.ctorParameters = () => [
    { type: AuthConfig },
    { type: HttpClient },
    { type: OccEndpointsService }
];
if (false) {
    /**
     * @type {?}
     * @protected
     */
    ClientAuthenticationTokenService.prototype.config;
    /**
     * @type {?}
     * @protected
     */
    ClientAuthenticationTokenService.prototype.http;
    /**
     * @type {?}
     * @protected
     */
    ClientAuthenticationTokenService.prototype.occEndpointsService;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class UserAuthenticationTokenService {
    /**
     * @param {?} http
     * @param {?} config
     * @param {?=} occEndpointsService
     */
    constructor(http, config, occEndpointsService) {
        this.http = http;
        this.config = config;
        this.occEndpointsService = occEndpointsService;
    }
    /**
     * @param {?} userId
     * @param {?} password
     * @return {?}
     */
    loadToken(userId, password) {
        /** @type {?} */
        const url = this.occEndpointsService.getRawEndpoint('login');
        /** @type {?} */
        const params = new HttpParams()
            .set('client_id', this.config.authentication.client_id)
            .set('client_secret', this.config.authentication.client_secret)
            .set('grant_type', 'password')
            .set('username', userId)
            .set('password', password);
        /** @type {?} */
        const headers = new HttpHeaders({
            'Content-Type': 'application/x-www-form-urlencoded',
        });
        return this.http
            .post(url, params, { headers })
            .pipe(catchError((/**
         * @param {?} error
         * @return {?}
         */
        (error) => throwError(error))));
    }
    /**
     * @param {?} refreshToken
     * @return {?}
     */
    refreshToken(refreshToken) {
        /** @type {?} */
        const url = this.occEndpointsService.getRawEndpoint('login');
        /** @type {?} */
        const params = new HttpParams()
            .set('client_id', encodeURIComponent(this.config.authentication.client_id))
            .set('client_secret', encodeURIComponent(this.config.authentication.client_secret))
            .set('refresh_token', encodeURI(refreshToken))
            .set('grant_type', 'refresh_token');
        /** @type {?} */
        const headers = new HttpHeaders({
            'Content-Type': 'application/x-www-form-urlencoded',
        });
        return this.http
            .post(url, params, { headers })
            .pipe(catchError((/**
         * @param {?} error
         * @return {?}
         */
        (error) => throwError(error))));
    }
    /**
     * @param {?} userToken
     * @return {?}
     */
    revoke(userToken) {
        /** @type {?} */
        const url = this.occEndpointsService.getRawEndpoint('revoke');
        /** @type {?} */
        const headers = InterceptorUtil.createHeader(TOKEN_REVOCATION_HEADER, true, new HttpHeaders({
            Authorization: `${userToken.token_type} ${userToken.access_token}`,
            'Content-Type': 'application/x-www-form-urlencoded',
        }));
        /** @type {?} */
        const params = new HttpParams().set('token', userToken.access_token);
        return this.http
            .post(url, params, { headers })
            .pipe(catchError((/**
         * @param {?} error
         * @return {?}
         */
        (error) => throwError(error))));
    }
}
UserAuthenticationTokenService.decorators = [
    { type: Injectable }
];
/** @nocollapse */
UserAuthenticationTokenService.ctorParameters = () => [
    { type: HttpClient },
    { type: AuthConfig },
    { type: OccEndpointsService }
];
if (false) {
    /**
     * @type {?}
     * @protected
     */
    UserAuthenticationTokenService.prototype.http;
    /**
     * @type {?}
     * @protected
     */
    UserAuthenticationTokenService.prototype.config;
    /**
     * @type {?}
     * @protected
     */
    UserAuthenticationTokenService.prototype.occEndpointsService;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const AuthServices = [
    ClientAuthenticationTokenService,
    ClientErrorHandlingService,
    UserAuthenticationTokenService,
    UserErrorHandlingService,
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {string} */
const StorageSyncType = {
    NO_STORAGE: 'NO_STORAGE',
    LOCAL_STORAGE: 'LOCAL_STORAGE',
    SESSION_STORAGE: 'SESSION_STORAGE',
};
/** @enum {string} */
const StateTransferType = {
    TRANSFER_STATE: 'SSR',
};
/**
 * @abstract
 */
class StateConfig {
}
if (false) {
    /** @type {?} */
    StateConfig.prototype.state;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const DEFAULT_LOCAL_STORAGE_KEY = 'spartacus-local-data';
/** @type {?} */
const DEFAULT_SESSION_STORAGE_KEY = 'spartacus-session-data';
/** @type {?} */
const defaultStateConfig = {
    state: {
        storageSync: {
            localStorageKeyName: DEFAULT_LOCAL_STORAGE_KEY,
            sessionStorageKeyName: DEFAULT_SESSION_STORAGE_KEY,
            keys: {},
            excludeKeys: {},
        },
    },
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @template T
 * @param {?} winRef
 * @param {?=} config
 * @return {?}
 */
function getStorageSyncReducer(winRef, config) {
    if (!winRef.nativeWindow ||
        !config ||
        !config.state ||
        !config.state.storageSync ||
        !config.state.storageSync.keys) {
        return (/**
         * @param {?} reducer
         * @return {?}
         */
        reducer => reducer);
    }
    /** @type {?} */
    const storageSyncConfig = config.state.storageSync;
    return (/**
     * @param {?} reducer
     * @return {?}
     */
    (reducer) => {
        return (/**
         * @param {?} state
         * @param {?} action
         * @return {?}
         */
        (state, action) => {
            /** @type {?} */
            const newState = reducer(state, action);
            if (action.type === INIT || action.type === UPDATE) {
                /** @type {?} */
                const rehydratedState = rehydrate(config, winRef);
                return deepMerge({}, newState, rehydratedState);
            }
            if (action.type !== INIT) {
                // handle local storage
                /** @type {?} */
                const localStorageKeys = filterKeysByType(storageSyncConfig.keys, StorageSyncType.LOCAL_STORAGE);
                /** @type {?} */
                const localStorageExclusionKeys = filterKeysByType(storageSyncConfig.excludeKeys, StorageSyncType.LOCAL_STORAGE);
                /** @type {?} */
                const localStorageStateSlices = getStateSlice(localStorageKeys, localStorageExclusionKeys, newState);
                persistToStorage(config.state.storageSync.localStorageKeyName, localStorageStateSlices, winRef.localStorage);
                // handle session storage
                /** @type {?} */
                const sessionStorageKeys = filterKeysByType(storageSyncConfig.keys, StorageSyncType.SESSION_STORAGE);
                /** @type {?} */
                const sessionStorageExclusionKeys = filterKeysByType(storageSyncConfig.excludeKeys, StorageSyncType.SESSION_STORAGE);
                /** @type {?} */
                const sessionStorageStateSlices = getStateSlice(sessionStorageKeys, sessionStorageExclusionKeys, newState);
                persistToStorage(config.state.storageSync.sessionStorageKeyName, sessionStorageStateSlices, winRef.sessionStorage);
            }
            return newState;
        });
    });
}
/**
 * @template T
 * @param {?} config
 * @param {?} winRef
 * @return {?}
 */
function rehydrate(config, winRef) {
    /** @type {?} */
    const localStorageValue = readFromStorage(winRef.localStorage, config.state.storageSync.localStorageKeyName);
    /** @type {?} */
    const sessionStorageValue = readFromStorage(winRef.sessionStorage, config.state.storageSync.sessionStorageKeyName);
    return deepMerge(localStorageValue, sessionStorageValue);
}
/**
 * @param {?} value
 * @return {?}
 */
function exists(value) {
    if (value != null) {
        if (typeof value === 'object') {
            return Object.keys(value).length !== 0;
        }
        return value !== '';
    }
    return false;
}
/**
 * @param {?} storageType
 * @param {?} winRef
 * @return {?}
 */
function getStorage(storageType, winRef) {
    /** @type {?} */
    let storage;
    switch (storageType) {
        case StorageSyncType.LOCAL_STORAGE: {
            storage = winRef.localStorage;
            break;
        }
        case StorageSyncType.SESSION_STORAGE: {
            storage = winRef.sessionStorage;
            break;
        }
        case StorageSyncType.NO_STORAGE: {
            storage = undefined;
            break;
        }
        default: {
            storage = winRef.sessionStorage;
        }
    }
    return storage;
}
/**
 * @param {?} configKey
 * @param {?} value
 * @param {?} storage
 * @return {?}
 */
function persistToStorage(configKey, value, storage) {
    if (!isSsr(storage) && value) {
        storage.setItem(configKey, JSON.stringify(value));
    }
}
/**
 * @param {?} storage
 * @param {?} key
 * @return {?}
 */
function readFromStorage(storage, key) {
    if (isSsr(storage)) {
        return;
    }
    /** @type {?} */
    const storageValue = storage.getItem(key);
    if (!storageValue) {
        return;
    }
    return JSON.parse(storageValue);
}
/**
 * @param {?} storage
 * @return {?}
 */
function isSsr(storage) {
    return !Boolean(storage);
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const CX_KEY = makeStateKey('cx-state');
/**
 * @param {?} platformId
 * @param {?=} transferState
 * @param {?=} config
 * @return {?}
 */
function getTransferStateReducer(platformId, transferState, config) {
    if (transferState &&
        config &&
        config.state &&
        config.state.ssrTransfer &&
        config.state.ssrTransfer.keys) {
        if (isPlatformBrowser(platformId)) {
            return getBrowserTransferStateReducer(transferState, config.state.ssrTransfer.keys);
        }
        else if (isPlatformServer(platformId)) {
            return getServerTransferStateReducer(transferState, config.state.ssrTransfer.keys);
        }
    }
    return (/**
     * @param {?} reducer
     * @return {?}
     */
    reducer => reducer);
}
/**
 * @param {?} transferState
 * @param {?} keys
 * @return {?}
 */
function getServerTransferStateReducer(transferState, keys) {
    /** @type {?} */
    const transferStateKeys = filterKeysByType(keys, StateTransferType.TRANSFER_STATE);
    return (/**
     * @param {?} reducer
     * @return {?}
     */
    function (reducer) {
        return (/**
         * @param {?} state
         * @param {?} action
         * @return {?}
         */
        function (state, action) {
            /** @type {?} */
            const newState = reducer(state, action);
            if (newState) {
                /** @type {?} */
                const stateSlice = getStateSlice(transferStateKeys, [], newState);
                transferState.set(CX_KEY, stateSlice);
            }
            return newState;
        });
    });
}
/**
 * @param {?} transferState
 * @param {?} keys
 * @return {?}
 */
function getBrowserTransferStateReducer(transferState, keys) {
    /** @type {?} */
    const transferStateKeys = filterKeysByType(keys, StateTransferType.TRANSFER_STATE);
    return (/**
     * @param {?} reducer
     * @return {?}
     */
    function (reducer) {
        return (/**
         * @param {?} state
         * @param {?} action
         * @return {?}
         */
        function (state, action) {
            if (action.type === INIT) {
                if (!state) {
                    state = reducer(state, action);
                }
                // we should not utilize transfer state if user is logged in
                /** @type {?} */
                const authState = ((/** @type {?} */ (state)))[AUTH_FEATURE];
                /** @type {?} */
                const isLoggedIn = authState && authState.userToken && authState.userToken.token;
                if (!isLoggedIn && transferState.hasKey(CX_KEY)) {
                    /** @type {?} */
                    const cxKey = transferState.get(CX_KEY, {});
                    /** @type {?} */
                    const transferredStateSlice = getStateSlice(transferStateKeys, [], cxKey);
                    state = deepMerge({}, state, transferredStateSlice);
                }
                return state;
            }
            return reducer(state, action);
        });
    });
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const TRANSFER_STATE_META_REDUCER = new InjectionToken('TransferStateMetaReducer');
/** @type {?} */
const STORAGE_SYNC_META_REDUCER = new InjectionToken('StorageSyncMetaReducer');
const ɵ0$6 = getTransferStateReducer, ɵ1$5 = getStorageSyncReducer;
/** @type {?} */
const stateMetaReducers = [
    {
        provide: TRANSFER_STATE_META_REDUCER,
        useFactory: ɵ0$6,
        deps: [
            PLATFORM_ID,
            [new Optional(), TransferState],
            [new Optional(), Config],
        ],
    },
    {
        provide: STORAGE_SYNC_META_REDUCER,
        useFactory: ɵ1$5,
        deps: [WindowRef, [new Optional(), Config]],
    },
    {
        provide: META_REDUCERS,
        useExisting: TRANSFER_STATE_META_REDUCER,
        multi: true,
    },
    {
        provide: META_REDUCERS,
        useExisting: STORAGE_SYNC_META_REDUCER,
        multi: true,
    },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class StateModule {
    /**
     * @return {?}
     */
    static forRoot() {
        return {
            ngModule: StateModule,
            providers: [
                ...stateMetaReducers,
                provideConfig(defaultStateConfig),
                { provide: StateConfig, useExisting: Config },
            ],
        };
    }
}
StateModule.decorators = [
    { type: NgModule, args: [{},] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const UNKNOWN_ERROR = {
    error: 'unknown error',
};
/** @type {?} */
const circularReplacer = (/**
 * @return {?}
 */
() => {
    /** @type {?} */
    const seen = new WeakSet();
    return (/**
     * @param {?} _key
     * @param {?} value
     * @return {?}
     */
    (_key, value) => {
        if (typeof value === 'object' && value !== null) {
            if (seen.has(value)) {
                return;
            }
            seen.add(value);
        }
        return value;
    });
});
const ɵ0$7 = circularReplacer;
/**
 * @param {?} error
 * @return {?}
 */
function makeErrorSerializable(error) {
    if (error instanceof Error) {
        return (/** @type {?} */ ({
            message: error.message,
            type: error.name,
            reason: error.stack,
        }));
    }
    if (error instanceof HttpErrorResponse) {
        /** @type {?} */
        let serializableError = error.error;
        if (isObject(error.error)) {
            serializableError = JSON.stringify(error.error, circularReplacer());
        }
        return (/** @type {?} */ ({
            message: error.message,
            error: serializableError,
            status: error.status,
            statusText: error.statusText,
            url: error.url,
        }));
    }
    return isObject(error) ? UNKNOWN_ERROR : error;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ClientTokenEffect {
    /**
     * @param {?} actions$
     * @param {?} clientAuthenticationTokenService
     */
    constructor(actions$, clientAuthenticationTokenService) {
        this.actions$ = actions$;
        this.clientAuthenticationTokenService = clientAuthenticationTokenService;
        this.loadClientToken$ = this.actions$.pipe(ofType(LOAD_CLIENT_TOKEN), exhaustMap((/**
         * @return {?}
         */
        () => {
            return this.clientAuthenticationTokenService
                .loadClientAuthenticationToken()
                .pipe(map((/**
             * @param {?} token
             * @return {?}
             */
            (token) => {
                return new LoadClientTokenSuccess(token);
            })), catchError((/**
             * @param {?} error
             * @return {?}
             */
            error => of(new LoadClientTokenFail(makeErrorSerializable(error))))));
        })));
    }
}
ClientTokenEffect.decorators = [
    { type: Injectable }
];
/** @nocollapse */
ClientTokenEffect.ctorParameters = () => [
    { type: Actions },
    { type: ClientAuthenticationTokenService }
];
__decorate([
    Effect(),
    __metadata("design:type", Observable)
], ClientTokenEffect.prototype, "loadClientToken$", void 0);
if (false) {
    /** @type {?} */
    ClientTokenEffect.prototype.loadClientToken$;
    /**
     * @type {?}
     * @private
     */
    ClientTokenEffect.prototype.actions$;
    /**
     * @type {?}
     * @private
     */
    ClientTokenEffect.prototype.clientAuthenticationTokenService;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class UserTokenEffects {
    /**
     * @param {?} actions$
     * @param {?} userTokenService
     */
    constructor(actions$, userTokenService) {
        this.actions$ = actions$;
        this.userTokenService = userTokenService;
        this.loadUserToken$ = this.actions$.pipe(ofType(LOAD_USER_TOKEN), map((/**
         * @param {?} action
         * @return {?}
         */
        (action) => action.payload)), mergeMap((/**
         * @param {?} __0
         * @return {?}
         */
        ({ userId, password }) => this.userTokenService.loadToken(userId, password).pipe(map((/**
         * @param {?} token
         * @return {?}
         */
        (token) => {
            /** @type {?} */
            const date = new Date();
            date.setSeconds(date.getSeconds() + token.expires_in);
            token.expiration_time = date.toJSON();
            token.userId = OCC_USER_ID_CURRENT;
            return new LoadUserTokenSuccess(token);
        })), catchError((/**
         * @param {?} error
         * @return {?}
         */
        error => of(new LoadUserTokenFail(makeErrorSerializable(error)))))))));
        this.login$ = this.actions$.pipe(ofType(LOAD_USER_TOKEN_SUCCESS), map((/**
         * @return {?}
         */
        () => new Login())));
        this.refreshUserToken$ = this.actions$.pipe(ofType(REFRESH_USER_TOKEN), map((/**
         * @param {?} action
         * @return {?}
         */
        (action) => action.payload)), exhaustMap((/**
         * @param {?} __0
         * @return {?}
         */
        ({ refreshToken }) => {
            return this.userTokenService.refreshToken(refreshToken).pipe(map((/**
             * @param {?} token
             * @return {?}
             */
            (token) => {
                /** @type {?} */
                const date = new Date();
                date.setSeconds(date.getSeconds() + token.expires_in);
                token.expiration_time = date.toJSON();
                return new RefreshUserTokenSuccess(token);
            }), catchError((/**
             * @param {?} error
             * @return {?}
             */
            error => of(new RefreshUserTokenFail(makeErrorSerializable(error)))))));
        })));
        this.revokeUserToken$ = this.actions$.pipe(ofType(REVOKE_USER_TOKEN), map((/**
         * @param {?} action
         * @return {?}
         */
        (action) => {
            return action.payload;
        })), mergeMap((/**
         * @param {?} userToken
         * @return {?}
         */
        (userToken) => {
            return this.userTokenService.revoke(userToken).pipe(map((/**
             * @return {?}
             */
            () => new RevokeUserTokenSuccess(userToken))), catchError((/**
             * @param {?} error
             * @return {?}
             */
            error => of(new RevokeUserTokenFail(error)))));
        })));
    }
}
UserTokenEffects.decorators = [
    { type: Injectable }
];
/** @nocollapse */
UserTokenEffects.ctorParameters = () => [
    { type: Actions },
    { type: UserAuthenticationTokenService }
];
__decorate([
    Effect(),
    __metadata("design:type", Observable)
], UserTokenEffects.prototype, "loadUserToken$", void 0);
__decorate([
    Effect(),
    __metadata("design:type", Observable)
], UserTokenEffects.prototype, "login$", void 0);
__decorate([
    Effect(),
    __metadata("design:type", Observable)
], UserTokenEffects.prototype, "refreshUserToken$", void 0);
__decorate([
    Effect(),
    __metadata("design:type", Observable)
], UserTokenEffects.prototype, "revokeUserToken$", void 0);
if (false) {
    /** @type {?} */
    UserTokenEffects.prototype.loadUserToken$;
    /** @type {?} */
    UserTokenEffects.prototype.login$;
    /** @type {?} */
    UserTokenEffects.prototype.refreshUserToken$;
    /** @type {?} */
    UserTokenEffects.prototype.revokeUserToken$;
    /**
     * @type {?}
     * @private
     */
    UserTokenEffects.prototype.actions$;
    /**
     * @type {?}
     * @private
     */
    UserTokenEffects.prototype.userTokenService;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const effects = [UserTokenEffects, ClientTokenEffect];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const initialState = (/** @type {?} */ ({}));
/**
 * @param {?=} state
 * @param {?=} action
 * @return {?}
 */
function reducer(state = initialState, action) {
    switch (action.type) {
        case LOAD_USER_TOKEN:
        case REFRESH_USER_TOKEN: {
            return Object.assign({}, state);
        }
        case LOAD_USER_TOKEN_SUCCESS:
        case REFRESH_USER_TOKEN_SUCCESS: {
            return Object.assign({}, state, action.payload);
        }
        case LOAD_USER_TOKEN_FAIL:
        case REFRESH_USER_TOKEN_FAIL: {
            return Object.assign({}, state);
        }
    }
    return state;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @return {?}
 */
function getReducers() {
    return {
        userToken: combineReducers({ token: reducer }),
        clientToken: loaderReducer(CLIENT_TOKEN_DATA),
    };
}
/** @type {?} */
const reducerToken = new InjectionToken('AuthReducers');
/** @type {?} */
const reducerProvider = {
    provide: reducerToken,
    useFactory: getReducers,
};
/**
 * @param {?} reducer
 * @return {?}
 */
function clearAuthState(reducer) {
    return (/**
     * @param {?} state
     * @param {?} action
     * @return {?}
     */
    function (state, action) {
        if (action.type === LOGOUT) {
            state = Object.assign({}, state, { userToken: undefined });
        }
        return reducer(state, action);
    });
}
/** @type {?} */
const metaReducers = [clearAuthState];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @return {?}
 */
function authStoreConfigFactory() {
    // if we want to reuse AUTH_FEATURE const in config, we have to use factory instead of plain object
    /** @type {?} */
    const config = {
        state: {
            storageSync: {
                keys: {
                    'auth.userToken.token.access_token': StorageSyncType.LOCAL_STORAGE,
                    'auth.userToken.token.token_type': StorageSyncType.LOCAL_STORAGE,
                    'auth.userToken.token.expires_in': StorageSyncType.LOCAL_STORAGE,
                    'auth.userToken.token.expiration_time': StorageSyncType.LOCAL_STORAGE,
                    'auth.userToken.token.scope': StorageSyncType.LOCAL_STORAGE,
                    'auth.userToken.token.userId': StorageSyncType.LOCAL_STORAGE,
                },
            },
        },
    };
    return config;
}
class AuthStoreModule {
}
AuthStoreModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    HttpClientModule,
                    StateModule,
                    StoreModule.forFeature(AUTH_FEATURE, reducerToken, { metaReducers }),
                    EffectsModule.forFeature(effects),
                    ConfigModule.withConfigFactory(authStoreConfigFactory),
                ],
                providers: [reducerProvider],
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class AuthModule {
    /**
     * @return {?}
     */
    static forRoot() {
        return {
            ngModule: AuthModule,
            providers: [
                ...interceptors,
                ...AuthServices,
                { provide: AuthConfig, useExisting: Config },
            ],
        };
    }
}
AuthModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    HttpClientModule,
                    AuthStoreModule,
                    ConfigModule.withConfig(defaultAuthConfig),
                ],
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class AuthRedirectService {
    /**
     * This service is responsible for redirecting to the last page before authorization. "The last page" can be:
     * 1. Just the previously opened page; or
     * 2. The page that we just tried to open, but AuthGuard cancelled it
     *
     * For example:
     * 1. The user opens the product page, then clicks /login link and signs in
     *    -> Then we should redirect to the product page; or
     * 2. The user opens the product page, then he clicks /my-account link,
     *    but is automatically redirected to the login page by the AuthGuard, and he signs in
     *    -> Then we should redirect to the my-account page, not the product page
     * @param {?} routing
     * @param {?} router
     */
    constructor(routing, router) {
        this.routing = routing;
        this.router = router;
        this.ignoredUrls = new Set();
    }
    /**
     * @return {?}
     */
    redirect() {
        if (this.redirectUrl === undefined) {
            this.routing.go('/');
        }
        else {
            this.routing.goByUrl(this.redirectUrl);
        }
        this.redirectUrl = undefined;
        this.lastAuthGuardNavigation = undefined;
    }
    /**
     * @return {?}
     */
    reportAuthGuard() {
        const { url, navigationId } = this.getCurrentNavigation();
        this.lastAuthGuardNavigation = { url, navigationId };
        this.redirectUrl = url;
    }
    /**
     * @return {?}
     */
    reportNotAuthGuard() {
        const { url, initialUrl, navigationId } = this.getCurrentNavigation();
        this.ignoredUrls.add(url);
        // Don't save redirect url if you've already come from page with NotAuthGuard (i.e. user has come from login to register)
        if (!this.ignoredUrls.has(initialUrl)) {
            // We compare the navigation id to find out if the url cancelled by AuthGuard (i.e. my-account) is more recent
            // than the last opened page
            if (!this.lastAuthGuardNavigation ||
                this.lastAuthGuardNavigation.navigationId < navigationId - 1) {
                this.redirectUrl = initialUrl;
                this.lastAuthGuardNavigation = undefined;
            }
        }
    }
    /**
     * @private
     * @return {?}
     */
    getCurrentNavigation() {
        /** @type {?} */
        const initialUrl = this.router.url;
        /** @type {?} */
        const navigation = this.router.getCurrentNavigation();
        /** @type {?} */
        const url = this.router.serializeUrl(navigation.finalUrl);
        return {
            navigationId: navigation.id,
            url,
            initialUrl,
        };
    }
}
AuthRedirectService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root',
            },] }
];
/** @nocollapse */
AuthRedirectService.ctorParameters = () => [
    { type: RoutingService },
    { type: Router }
];
/** @nocollapse */ AuthRedirectService.ngInjectableDef = ɵɵdefineInjectable({ factory: function AuthRedirectService_Factory() { return new AuthRedirectService(ɵɵinject(RoutingService), ɵɵinject(Router)); }, token: AuthRedirectService, providedIn: "root" });
if (false) {
    /**
     * @type {?}
     * @private
     */
    AuthRedirectService.prototype.redirectUrl;
    /**
     * @type {?}
     * @private
     */
    AuthRedirectService.prototype.ignoredUrls;
    /**
     * @type {?}
     * @private
     */
    AuthRedirectService.prototype.lastAuthGuardNavigation;
    /**
     * @type {?}
     * @private
     */
    AuthRedirectService.prototype.routing;
    /**
     * @type {?}
     * @private
     */
    AuthRedirectService.prototype.router;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class AuthGuard {
    /**
     * @param {?} routingService
     * @param {?} authService
     * @param {?} authRedirectService
     * @param {?} router
     */
    constructor(routingService, authService, authRedirectService, router) {
        this.routingService = routingService;
        this.authService = authService;
        this.authRedirectService = authRedirectService;
        this.router = router;
    }
    /**
     * @return {?}
     */
    canActivate() {
        return this.authService.getUserToken().pipe(map((/**
         * @param {?} token
         * @return {?}
         */
        (token) => {
            if (!token.access_token) {
                this.authRedirectService.reportAuthGuard();
                this.routingService.go({ cxRoute: 'login' });
            }
            return !!token.access_token;
        })));
    }
}
AuthGuard.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root',
            },] }
];
/** @nocollapse */
AuthGuard.ctorParameters = () => [
    { type: RoutingService },
    { type: AuthService },
    { type: AuthRedirectService },
    { type: Router }
];
/** @nocollapse */ AuthGuard.ngInjectableDef = ɵɵdefineInjectable({ factory: function AuthGuard_Factory() { return new AuthGuard(ɵɵinject(RoutingService), ɵɵinject(AuthService), ɵɵinject(AuthRedirectService), ɵɵinject(Router)); }, token: AuthGuard, providedIn: "root" });
if (false) {
    /**
     * @type {?}
     * @protected
     */
    AuthGuard.prototype.routingService;
    /**
     * @type {?}
     * @protected
     */
    AuthGuard.prototype.authService;
    /**
     * @type {?}
     * @protected
     */
    AuthGuard.prototype.authRedirectService;
    /**
     * @type {?}
     * @protected
     */
    AuthGuard.prototype.router;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NotAuthGuard {
    /**
     * @param {?} routingService
     * @param {?} authService
     * @param {?} authRedirectService
     */
    constructor(routingService, authService, authRedirectService) {
        this.routingService = routingService;
        this.authService = authService;
        this.authRedirectService = authRedirectService;
    }
    /**
     * @return {?}
     */
    canActivate() {
        this.authRedirectService.reportNotAuthGuard();
        // redirect, if user is already logged in:
        return this.authService.getUserToken().pipe(map((/**
         * @param {?} token
         * @return {?}
         */
        token => {
            if (token.access_token) {
                this.routingService.go({ cxRoute: 'home' });
            }
            return !token.access_token;
        })));
    }
}
NotAuthGuard.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root',
            },] }
];
/** @nocollapse */
NotAuthGuard.ctorParameters = () => [
    { type: RoutingService },
    { type: AuthService },
    { type: AuthRedirectService }
];
/** @nocollapse */ NotAuthGuard.ngInjectableDef = ɵɵdefineInjectable({ factory: function NotAuthGuard_Factory() { return new NotAuthGuard(ɵɵinject(RoutingService), ɵɵinject(AuthService), ɵɵinject(AuthRedirectService)); }, token: NotAuthGuard, providedIn: "root" });
if (false) {
    /**
     * @type {?}
     * @protected
     */
    NotAuthGuard.prototype.routingService;
    /**
     * @type {?}
     * @protected
     */
    NotAuthGuard.prototype.authService;
    /**
     * @type {?}
     * @private
     */
    NotAuthGuard.prototype.authRedirectService;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @record
 */
function UserToken() { }
if (false) {
    /** @type {?} */
    UserToken.prototype.access_token;
    /** @type {?} */
    UserToken.prototype.token_type;
    /** @type {?} */
    UserToken.prototype.refresh_token;
    /** @type {?} */
    UserToken.prototype.expires_in;
    /** @type {?} */
    UserToken.prototype.scope;
    /** @type {?} */
    UserToken.prototype.userId;
    /** @type {?|undefined} */
    UserToken.prototype.expiration_time;
}
/**
 * @record
 */
function ClientToken() { }
if (false) {
    /** @type {?} */
    ClientToken.prototype.access_token;
    /** @type {?} */
    ClientToken.prototype.token_type;
    /** @type {?} */
    ClientToken.prototype.expires_in;
    /** @type {?} */
    ClientToken.prototype.scope;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @record
 */
function Country() { }
if (false) {
    /** @type {?|undefined} */
    Country.prototype.isocode;
    /** @type {?|undefined} */
    Country.prototype.name;
}
/** @enum {string} */
const CountryType = {
    BILLING: 'BILLING',
    SHIPPING: 'SHIPPING',
};
/**
 * @record
 */
function Region() { }
if (false) {
    /** @type {?|undefined} */
    Region.prototype.countryIso;
    /** @type {?|undefined} */
    Region.prototype.isocode;
    /** @type {?|undefined} */
    Region.prototype.isocodeShort;
    /** @type {?|undefined} */
    Region.prototype.name;
}
/**
 * @record
 */
function Address() { }
if (false) {
    /** @type {?|undefined} */
    Address.prototype.companyName;
    /** @type {?|undefined} */
    Address.prototype.country;
    /** @type {?|undefined} */
    Address.prototype.defaultAddress;
    /** @type {?|undefined} */
    Address.prototype.email;
    /** @type {?|undefined} */
    Address.prototype.firstName;
    /** @type {?|undefined} */
    Address.prototype.formattedAddress;
    /** @type {?|undefined} */
    Address.prototype.id;
    /** @type {?|undefined} */
    Address.prototype.lastName;
    /** @type {?|undefined} */
    Address.prototype.line1;
    /** @type {?|undefined} */
    Address.prototype.line2;
    /** @type {?|undefined} */
    Address.prototype.phone;
    /** @type {?|undefined} */
    Address.prototype.postalCode;
    /** @type {?|undefined} */
    Address.prototype.region;
    /** @type {?|undefined} */
    Address.prototype.shippingAddress;
    /** @type {?|undefined} */
    Address.prototype.title;
    /** @type {?|undefined} */
    Address.prototype.titleCode;
    /** @type {?|undefined} */
    Address.prototype.town;
    /** @type {?|undefined} */
    Address.prototype.visibleInAddressBook;
}
/**
 * @record
 */
function AddressValidation() { }
if (false) {
    /** @type {?|undefined} */
    AddressValidation.prototype.decision;
    /** @type {?|undefined} */
    AddressValidation.prototype.errors;
    /** @type {?|undefined} */
    AddressValidation.prototype.suggestedAddresses;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @record
 */
function PromotionResult() { }
if (false) {
    /** @type {?|undefined} */
    PromotionResult.prototype.consumedEntries;
    /** @type {?|undefined} */
    PromotionResult.prototype.description;
    /** @type {?|undefined} */
    PromotionResult.prototype.promotion;
}
/** @enum {string} */
const PromotionLocation = {
    ActiveCart: 'CART',
    Checkout: 'CHECKOUT',
    Order: 'ORDER',
};
/**
 * @record
 */
function Voucher() { }
if (false) {
    /** @type {?|undefined} */
    Voucher.prototype.appliedValue;
    /** @type {?|undefined} */
    Voucher.prototype.code;
    /** @type {?|undefined} */
    Voucher.prototype.currency;
    /** @type {?|undefined} */
    Voucher.prototype.description;
    /** @type {?|undefined} */
    Voucher.prototype.freeShipping;
    /** @type {?|undefined} */
    Voucher.prototype.name;
    /** @type {?|undefined} */
    Voucher.prototype.value;
    /** @type {?|undefined} */
    Voucher.prototype.valueFormatted;
    /** @type {?|undefined} */
    Voucher.prototype.valueString;
    /** @type {?|undefined} */
    Voucher.prototype.voucherCode;
}
/**
 * @record
 */
function DeliveryOrderEntryGroup() { }
if (false) {
    /** @type {?|undefined} */
    DeliveryOrderEntryGroup.prototype.deliveryAddress;
    /** @type {?|undefined} */
    DeliveryOrderEntryGroup.prototype.entries;
    /** @type {?|undefined} */
    DeliveryOrderEntryGroup.prototype.quantity;
    /** @type {?|undefined} */
    DeliveryOrderEntryGroup.prototype.totalPriceWithTax;
}
/**
 * @record
 */
function Principal() { }
if (false) {
    /** @type {?|undefined} */
    Principal.prototype.name;
    /** @type {?|undefined} */
    Principal.prototype.uid;
}
/**
 * @record
 */
function CardType() { }
if (false) {
    /** @type {?|undefined} */
    CardType.prototype.code;
    /** @type {?|undefined} */
    CardType.prototype.name;
}
/**
 * @record
 */
function PaymentDetails() { }
if (false) {
    /** @type {?|undefined} */
    PaymentDetails.prototype.accountHolderName;
    /** @type {?|undefined} */
    PaymentDetails.prototype.billingAddress;
    /** @type {?|undefined} */
    PaymentDetails.prototype.cardNumber;
    /** @type {?|undefined} */
    PaymentDetails.prototype.cardType;
    /** @type {?|undefined} */
    PaymentDetails.prototype.cvn;
    /** @type {?|undefined} */
    PaymentDetails.prototype.defaultPayment;
    /** @type {?|undefined} */
    PaymentDetails.prototype.expiryMonth;
    /** @type {?|undefined} */
    PaymentDetails.prototype.expiryYear;
    /** @type {?|undefined} */
    PaymentDetails.prototype.id;
    /** @type {?|undefined} */
    PaymentDetails.prototype.issueNumber;
    /** @type {?|undefined} */
    PaymentDetails.prototype.saved;
    /** @type {?|undefined} */
    PaymentDetails.prototype.startMonth;
    /** @type {?|undefined} */
    PaymentDetails.prototype.startYear;
    /** @type {?|undefined} */
    PaymentDetails.prototype.subscriptionId;
}
/**
 * @record
 */
function SaveCartResult() { }
if (false) {
    /** @type {?|undefined} */
    SaveCartResult.prototype.savedCartData;
}
/**
 * @record
 */
function Cart() { }
if (false) {
    /** @type {?|undefined} */
    Cart.prototype.appliedOrderPromotions;
    /** @type {?|undefined} */
    Cart.prototype.appliedProductPromotions;
    /** @type {?|undefined} */
    Cart.prototype.appliedVouchers;
    /** @type {?|undefined} */
    Cart.prototype.calculated;
    /** @type {?|undefined} */
    Cart.prototype.code;
    /** @type {?|undefined} */
    Cart.prototype.deliveryAddress;
    /** @type {?|undefined} */
    Cart.prototype.deliveryCost;
    /** @type {?|undefined} */
    Cart.prototype.deliveryItemsQuantity;
    /** @type {?|undefined} */
    Cart.prototype.deliveryMode;
    /** @type {?|undefined} */
    Cart.prototype.deliveryOrderGroups;
    /** @type {?|undefined} */
    Cart.prototype.description;
    /** @type {?|undefined} */
    Cart.prototype.entries;
    /** @type {?|undefined} */
    Cart.prototype.expirationTime;
    /** @type {?|undefined} */
    Cart.prototype.guid;
    /** @type {?|undefined} */
    Cart.prototype.name;
    /** @type {?|undefined} */
    Cart.prototype.net;
    /** @type {?|undefined} */
    Cart.prototype.orderDiscounts;
    /** @type {?|undefined} */
    Cart.prototype.paymentInfo;
    /** @type {?|undefined} */
    Cart.prototype.pickupItemsQuantity;
    /** @type {?|undefined} */
    Cart.prototype.pickupOrderGroups;
    /** @type {?|undefined} */
    Cart.prototype.potentialOrderPromotions;
    /** @type {?|undefined} */
    Cart.prototype.potentialProductPromotions;
    /** @type {?|undefined} */
    Cart.prototype.productDiscounts;
    /** @type {?|undefined} */
    Cart.prototype.saveTime;
    /** @type {?|undefined} */
    Cart.prototype.savedBy;
    /** @type {?|undefined} */
    Cart.prototype.site;
    /** @type {?|undefined} */
    Cart.prototype.store;
    /** @type {?|undefined} */
    Cart.prototype.subTotal;
    /** @type {?|undefined} */
    Cart.prototype.totalDiscounts;
    /** @type {?|undefined} */
    Cart.prototype.totalItems;
    /** @type {?|undefined} */
    Cart.prototype.totalPrice;
    /** @type {?|undefined} */
    Cart.prototype.totalPriceWithTax;
    /** @type {?|undefined} */
    Cart.prototype.totalTax;
    /** @type {?|undefined} */
    Cart.prototype.totalUnitCount;
    /** @type {?|undefined} */
    Cart.prototype.user;
}
/**
 * @record
 */
function CartModification() { }
if (false) {
    /** @type {?|undefined} */
    CartModification.prototype.deliveryModeChanged;
    /** @type {?|undefined} */
    CartModification.prototype.entry;
    /** @type {?|undefined} */
    CartModification.prototype.quantity;
    /** @type {?|undefined} */
    CartModification.prototype.quantityAdded;
    /** @type {?|undefined} */
    CartModification.prototype.statusCode;
    /** @type {?|undefined} */
    CartModification.prototype.statusMessage;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @record
 */
function CmsComponent() { }
if (false) {
    /** @type {?|undefined} */
    CmsComponent.prototype.modifiedTime;
    /** @type {?|undefined} */
    CmsComponent.prototype.name;
    /** @type {?|undefined} */
    CmsComponent.prototype.otherProperties;
    /** @type {?|undefined} */
    CmsComponent.prototype.typeCode;
    /** @type {?|undefined} */
    CmsComponent.prototype.uid;
}
/** @enum {string} */
const PageType = {
    CONTENT_PAGE: 'ContentPage',
    PRODUCT_PAGE: 'ProductPage',
    CATEGORY_PAGE: 'CategoryPage',
    CATALOG_PAGE: 'CatalogPage',
};
/**
 * @record
 */
function CmsLinkComponent() { }
if (false) {
    /** @type {?|undefined} */
    CmsLinkComponent.prototype.url;
    /** @type {?|undefined} */
    CmsLinkComponent.prototype.container;
    /** @type {?|undefined} */
    CmsLinkComponent.prototype.external;
    /** @type {?|undefined} */
    CmsLinkComponent.prototype.contentPage;
    /** @type {?|undefined} */
    CmsLinkComponent.prototype.contentPageLabelOrId;
    /** @type {?|undefined} */
    CmsLinkComponent.prototype.linkName;
    /** @type {?|undefined} */
    CmsLinkComponent.prototype.target;
}
/**
 * @record
 */
function CmsSiteContextSelectorComponent() { }
if (false) {
    /** @type {?|undefined} */
    CmsSiteContextSelectorComponent.prototype.context;
}
/**
 * @record
 */
function CmsSearchBoxComponent() { }
if (false) {
    /** @type {?|undefined} */
    CmsSearchBoxComponent.prototype.container;
    /** @type {?|undefined} */
    CmsSearchBoxComponent.prototype.maxSuggestions;
    /** @type {?|undefined} */
    CmsSearchBoxComponent.prototype.maxProducts;
    /** @type {?|undefined} */
    CmsSearchBoxComponent.prototype.displaySuggestions;
    /** @type {?|undefined} */
    CmsSearchBoxComponent.prototype.displayProducts;
    /** @type {?|undefined} */
    CmsSearchBoxComponent.prototype.displayProductImages;
    /** @type {?|undefined} */
    CmsSearchBoxComponent.prototype.waitTimeBeforeRequest;
    /** @type {?|undefined} */
    CmsSearchBoxComponent.prototype.minCharactersBeforeRequest;
}
/**
 * @record
 */
function CmsParagraphComponent() { }
if (false) {
    /** @type {?|undefined} */
    CmsParagraphComponent.prototype.content;
    /** @type {?|undefined} */
    CmsParagraphComponent.prototype.container;
    /** @type {?|undefined} */
    CmsParagraphComponent.prototype.title;
}
/**
 * @record
 */
function CMSTabParagraphContainer() { }
if (false) {
    /** @type {?|undefined} */
    CMSTabParagraphContainer.prototype.container;
    /** @type {?|undefined} */
    CMSTabParagraphContainer.prototype.components;
}
/**
 * @record
 */
function CmsBannerComponentMedia() { }
if (false) {
    /** @type {?|undefined} */
    CmsBannerComponentMedia.prototype.altText;
    /** @type {?|undefined} */
    CmsBannerComponentMedia.prototype.code;
    /** @type {?|undefined} */
    CmsBannerComponentMedia.prototype.mime;
    /** @type {?|undefined} */
    CmsBannerComponentMedia.prototype.url;
}
/**
 * @record
 */
function CmsResponsiveBannerComponentMedia() { }
if (false) {
    /** @type {?|undefined} */
    CmsResponsiveBannerComponentMedia.prototype.desktop;
    /** @type {?|undefined} */
    CmsResponsiveBannerComponentMedia.prototype.mobile;
    /** @type {?|undefined} */
    CmsResponsiveBannerComponentMedia.prototype.tablet;
    /** @type {?|undefined} */
    CmsResponsiveBannerComponentMedia.prototype.widescreen;
}
/**
 * @record
 */
function CmsBannerComponent() { }
if (false) {
    /** @type {?|undefined} */
    CmsBannerComponent.prototype.headline;
    /** @type {?|undefined} */
    CmsBannerComponent.prototype.content;
    /** @type {?|undefined} */
    CmsBannerComponent.prototype.container;
    /** @type {?|undefined} */
    CmsBannerComponent.prototype.media;
    /** @type {?|undefined} */
    CmsBannerComponent.prototype.urlLink;
    /** @type {?|undefined} */
    CmsBannerComponent.prototype.external;
}
/** @enum {string} */
const CmsBannerCarouselEffect = {
    FADE: 'FADE',
    ZOOM: 'ZOOM',
    CURTAIN: 'CURTAINX',
    TURNDOWN: 'TURNDOWN',
};
/**
 * @record
 */
function CmsBannerCarouselComponent() { }
if (false) {
    /** @type {?|undefined} */
    CmsBannerCarouselComponent.prototype.banners;
    /** @type {?|undefined} */
    CmsBannerCarouselComponent.prototype.effect;
}
/**
 * @record
 */
function CmsProductCarouselComponent() { }
if (false) {
    /** @type {?|undefined} */
    CmsProductCarouselComponent.prototype.title;
    /** @type {?|undefined} */
    CmsProductCarouselComponent.prototype.productCodes;
    /** @type {?|undefined} */
    CmsProductCarouselComponent.prototype.container;
    /** @type {?|undefined} */
    CmsProductCarouselComponent.prototype.popup;
    /** @type {?|undefined} */
    CmsProductCarouselComponent.prototype.scroll;
}
/**
 * @record
 */
function CmsProductReferencesComponent() { }
if (false) {
    /** @type {?|undefined} */
    CmsProductReferencesComponent.prototype.title;
    /** @type {?|undefined} */
    CmsProductReferencesComponent.prototype.displayProductTitles;
    /** @type {?|undefined} */
    CmsProductReferencesComponent.prototype.displayProductPrices;
    /** @type {?|undefined} */
    CmsProductReferencesComponent.prototype.maximumNumberProducts;
    /** @type {?|undefined} */
    CmsProductReferencesComponent.prototype.productReferenceTypes;
    /** @type {?|undefined} */
    CmsProductReferencesComponent.prototype.container;
}
/**
 * @record
 */
function CmsMiniCartComponent() { }
if (false) {
    /** @type {?|undefined} */
    CmsMiniCartComponent.prototype.container;
    /** @type {?|undefined} */
    CmsMiniCartComponent.prototype.shownProductCount;
    /** @type {?|undefined} */
    CmsMiniCartComponent.prototype.title;
    /** @type {?|undefined} */
    CmsMiniCartComponent.prototype.totalDisplay;
    /** @type {?|undefined} */
    CmsMiniCartComponent.prototype.lightboxBannerComponent;
}
/**
 * @record
 */
function CmsBreadcrumbsComponent() { }
if (false) {
    /** @type {?|undefined} */
    CmsBreadcrumbsComponent.prototype.container;
}
/**
 * @record
 */
function CmsNavigationNode() { }
if (false) {
    /** @type {?|undefined} */
    CmsNavigationNode.prototype.uid;
    /** @type {?|undefined} */
    CmsNavigationNode.prototype.title;
    /** @type {?|undefined} */
    CmsNavigationNode.prototype.children;
    /** @type {?|undefined} */
    CmsNavigationNode.prototype.entries;
}
/**
 * @record
 */
function CmsNavigationEntry() { }
if (false) {
    /** @type {?|undefined} */
    CmsNavigationEntry.prototype.itemId;
    /** @type {?|undefined} */
    CmsNavigationEntry.prototype.itemSuperType;
    /** @type {?|undefined} */
    CmsNavigationEntry.prototype.itemType;
}
/**
 * @record
 */
function CmsNavigationComponent() { }
if (false) {
    /** @type {?|undefined} */
    CmsNavigationComponent.prototype.container;
    /** @type {?|undefined} */
    CmsNavigationComponent.prototype.styleClass;
    /** @type {?|undefined} */
    CmsNavigationComponent.prototype.wrapAfter;
    /** @type {?|undefined} */
    CmsNavigationComponent.prototype.notice;
    /** @type {?|undefined} */
    CmsNavigationComponent.prototype.showLanguageCurrency;
    /** @type {?|undefined} */
    CmsNavigationComponent.prototype.navigationNode;
}
/**
 * @record
 */
function CmsProductFacetNavigationComponent() { }
if (false) {
    /** @type {?|undefined} */
    CmsProductFacetNavigationComponent.prototype.container;
    /** @type {?|undefined} */
    CmsProductFacetNavigationComponent.prototype.activeFacetValueCode;
    /** @type {?|undefined} */
    CmsProductFacetNavigationComponent.prototype.searchResult;
    /** @type {?|undefined} */
    CmsProductFacetNavigationComponent.prototype.minPerFacet;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @record
 */
function ConsentTemplate() { }
if (false) {
    /** @type {?|undefined} */
    ConsentTemplate.prototype.id;
    /** @type {?|undefined} */
    ConsentTemplate.prototype.name;
    /** @type {?|undefined} */
    ConsentTemplate.prototype.description;
    /** @type {?|undefined} */
    ConsentTemplate.prototype.version;
    /** @type {?|undefined} */
    ConsentTemplate.prototype.currentConsent;
}
/**
 * @record
 */
function Consent() { }
if (false) {
    /** @type {?|undefined} */
    Consent.prototype.code;
    /** @type {?|undefined} */
    Consent.prototype.consentGivenDate;
    /** @type {?|undefined} */
    Consent.prototype.consentWithdrawnDate;
}
/**
 * @record
 */
function AnonymousConsent() { }
if (false) {
    /** @type {?|undefined} */
    AnonymousConsent.prototype.templateCode;
    /** @type {?|undefined} */
    AnonymousConsent.prototype.version;
    /** @type {?|undefined} */
    AnonymousConsent.prototype.consentState;
}
/** @enum {string} */
const ANONYMOUS_CONSENT_STATUS = {
    GIVEN: 'GIVEN',
    WITHDRAWN: 'WITHDRAWN',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @record
 */
function ConsignmentTrackingEvent() { }
if (false) {
    /** @type {?|undefined} */
    ConsignmentTrackingEvent.prototype.eventDate;
    /** @type {?|undefined} */
    ConsignmentTrackingEvent.prototype.detail;
    /** @type {?|undefined} */
    ConsignmentTrackingEvent.prototype.location;
    /** @type {?|undefined} */
    ConsignmentTrackingEvent.prototype.referenceCode;
}
/**
 * @record
 */
function Carrier() { }
if (false) {
    /** @type {?|undefined} */
    Carrier.prototype.code;
    /** @type {?|undefined} */
    Carrier.prototype.name;
}
/**
 * @record
 */
function ConsignmentTracking() { }
if (false) {
    /** @type {?|undefined} */
    ConsignmentTracking.prototype.statusDisplay;
    /** @type {?|undefined} */
    ConsignmentTracking.prototype.carrierDetails;
    /** @type {?|undefined} */
    ConsignmentTracking.prototype.trackingID;
    /** @type {?|undefined} */
    ConsignmentTracking.prototype.trackingUrl;
    /** @type {?|undefined} */
    ConsignmentTracking.prototype.targetArrivalDate;
    /** @type {?|undefined} */
    ConsignmentTracking.prototype.trackingEvents;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @record
 */
function Images() { }
/**
 * @record
 */
function Image() { }
if (false) {
    /** @type {?|undefined} */
    Image.prototype.altText;
    /** @type {?|undefined} */
    Image.prototype.format;
    /** @type {?|undefined} */
    Image.prototype.galleryIndex;
    /** @type {?|undefined} */
    Image.prototype.imageType;
    /** @type {?|undefined} */
    Image.prototype.url;
}
/** @enum {string} */
const ImageType = {
    PRIMARY: 'PRIMARY',
    GALLERY: 'GALLERY',
};
/**
 * @record
 */
function ImageGroup() { }

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @record
 */
function Currency() { }
if (false) {
    /** @type {?|undefined} */
    Currency.prototype.active;
    /** @type {?|undefined} */
    Currency.prototype.isocode;
    /** @type {?|undefined} */
    Currency.prototype.name;
    /** @type {?|undefined} */
    Currency.prototype.symbol;
}
/**
 * @record
 */
function Time() { }
if (false) {
    /** @type {?|undefined} */
    Time.prototype.formattedHour;
    /** @type {?|undefined} */
    Time.prototype.hour;
    /** @type {?|undefined} */
    Time.prototype.minute;
}
/**
 * @record
 */
function GeoPoint() { }
if (false) {
    /** @type {?|undefined} */
    GeoPoint.prototype.latitude;
    /** @type {?|undefined} */
    GeoPoint.prototype.longitude;
}
/**
 * @record
 */
function Language() { }
if (false) {
    /** @type {?|undefined} */
    Language.prototype.active;
    /** @type {?|undefined} */
    Language.prototype.isocode;
    /** @type {?|undefined} */
    Language.prototype.name;
    /** @type {?|undefined} */
    Language.prototype.nativeName;
}
/**
 * @record
 */
function User() { }
if (false) {
    /** @type {?|undefined} */
    User.prototype.currency;
    /** @type {?|undefined} */
    User.prototype.customerId;
    /** @type {?|undefined} */
    User.prototype.deactivationDate;
    /** @type {?|undefined} */
    User.prototype.defaultAddress;
    /** @type {?|undefined} */
    User.prototype.displayUid;
    /** @type {?|undefined} */
    User.prototype.firstName;
    /** @type {?|undefined} */
    User.prototype.language;
    /** @type {?|undefined} */
    User.prototype.lastName;
    /** @type {?|undefined} */
    User.prototype.name;
    /** @type {?|undefined} */
    User.prototype.title;
    /** @type {?|undefined} */
    User.prototype.titleCode;
    /** @type {?|undefined} */
    User.prototype.uid;
}
/**
 * @record
 */
function PaginationModel() { }
if (false) {
    /** @type {?|undefined} */
    PaginationModel.prototype.currentPage;
    /** @type {?|undefined} */
    PaginationModel.prototype.pageSize;
    /** @type {?|undefined} */
    PaginationModel.prototype.sort;
    /** @type {?|undefined} */
    PaginationModel.prototype.totalPages;
    /** @type {?|undefined} */
    PaginationModel.prototype.totalResults;
}
/**
 * @record
 */
function SortModel() { }
if (false) {
    /** @type {?|undefined} */
    SortModel.prototype.code;
    /** @type {?|undefined} */
    SortModel.prototype.name;
    /** @type {?|undefined} */
    SortModel.prototype.selected;
}
/**
 * @record
 */
function Title() { }
if (false) {
    /** @type {?|undefined} */
    Title.prototype.code;
    /** @type {?|undefined} */
    Title.prototype.name;
}
/**
 * @record
 */
function ErrorModel() { }
if (false) {
    /** @type {?|undefined} */
    ErrorModel.prototype.message;
    /** @type {?|undefined} */
    ErrorModel.prototype.reason;
    /** @type {?|undefined} */
    ErrorModel.prototype.subject;
    /** @type {?|undefined} */
    ErrorModel.prototype.subjectType;
    /** @type {?|undefined} */
    ErrorModel.prototype.type;
}
/**
 * @record
 */
function HttpErrorModel() { }
if (false) {
    /** @type {?|undefined} */
    HttpErrorModel.prototype.message;
    /** @type {?|undefined} */
    HttpErrorModel.prototype.error;
    /** @type {?|undefined} */
    HttpErrorModel.prototype.status;
    /** @type {?|undefined} */
    HttpErrorModel.prototype.statusText;
    /** @type {?|undefined} */
    HttpErrorModel.prototype.url;
}
/**
 * @record
 */
function BaseStore() { }
if (false) {
    /** @type {?|undefined} */
    BaseStore.prototype.currencies;
    /** @type {?|undefined} */
    BaseStore.prototype.defaultCurrency;
    /** @type {?|undefined} */
    BaseStore.prototype.languages;
    /** @type {?|undefined} */
    BaseStore.prototype.defaultLanguage;
}
/**
 * @record
 */
function BaseSite() { }
if (false) {
    /** @type {?|undefined} */
    BaseSite.prototype.channel;
    /** @type {?|undefined} */
    BaseSite.prototype.defaultLanguage;
    /** @type {?|undefined} */
    BaseSite.prototype.defaultPreviewCatalogId;
    /** @type {?|undefined} */
    BaseSite.prototype.defaultPreviewCategoryCode;
    /** @type {?|undefined} */
    BaseSite.prototype.defaultPreviewProductCode;
    /** @type {?|undefined} */
    BaseSite.prototype.locale;
    /** @type {?|undefined} */
    BaseSite.prototype.name;
    /** @type {?|undefined} */
    BaseSite.prototype.theme;
    /** @type {?|undefined} */
    BaseSite.prototype.uid;
    /** @type {?|undefined} */
    BaseSite.prototype.stores;
    /** @type {?|undefined} */
    BaseSite.prototype.urlPatterns;
    /** @type {?|undefined} */
    BaseSite.prototype.urlEncodingAttributes;
}
/**
 * @record
 */
function UserSignUp() { }
if (false) {
    /** @type {?|undefined} */
    UserSignUp.prototype.firstName;
    /** @type {?|undefined} */
    UserSignUp.prototype.lastName;
    /** @type {?|undefined} */
    UserSignUp.prototype.password;
    /** @type {?|undefined} */
    UserSignUp.prototype.titleCode;
    /** @type {?|undefined} */
    UserSignUp.prototype.uid;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @record
 */
function DeliveryMode() { }
if (false) {
    /** @type {?|undefined} */
    DeliveryMode.prototype.code;
    /** @type {?|undefined} */
    DeliveryMode.prototype.deliveryCost;
    /** @type {?|undefined} */
    DeliveryMode.prototype.description;
    /** @type {?|undefined} */
    DeliveryMode.prototype.name;
}
/**
 * @record
 */
function OrderEntry() { }
if (false) {
    /** @type {?|undefined} */
    OrderEntry.prototype.basePrice;
    /** @type {?|undefined} */
    OrderEntry.prototype.deliveryMode;
    /** @type {?|undefined} */
    OrderEntry.prototype.deliveryPointOfService;
    /** @type {?|undefined} */
    OrderEntry.prototype.entryNumber;
    /** @type {?|undefined} */
    OrderEntry.prototype.product;
    /** @type {?|undefined} */
    OrderEntry.prototype.quantity;
    /** @type {?|undefined} */
    OrderEntry.prototype.totalPrice;
    /** @type {?|undefined} */
    OrderEntry.prototype.updateable;
    /** @type {?|undefined} */
    OrderEntry.prototype.returnedItemsPrice;
    /** @type {?|undefined} */
    OrderEntry.prototype.returnableQuantity;
    /** @type {?|undefined} */
    OrderEntry.prototype.cancelledItemsPrice;
    /** @type {?|undefined} */
    OrderEntry.prototype.cancellableQuantity;
}
/**
 * @record
 */
function CancelOrReturnRequestEntryInput() { }
if (false) {
    /** @type {?|undefined} */
    CancelOrReturnRequestEntryInput.prototype.orderEntryNumber;
    /** @type {?|undefined} */
    CancelOrReturnRequestEntryInput.prototype.quantity;
}
/**
 * @record
 */
function ReturnRequestEntryInputList() { }
if (false) {
    /** @type {?|undefined} */
    ReturnRequestEntryInputList.prototype.orderCode;
    /** @type {?|undefined} */
    ReturnRequestEntryInputList.prototype.returnRequestEntryInputs;
}
/**
 * @record
 */
function CancellationRequestEntryInputList() { }
if (false) {
    /** @type {?|undefined} */
    CancellationRequestEntryInputList.prototype.cancellationRequestEntryInputs;
}
/**
 * @record
 */
function ReturnRequestEntry() { }
if (false) {
    /** @type {?|undefined} */
    ReturnRequestEntry.prototype.orderEntry;
    /** @type {?|undefined} */
    ReturnRequestEntry.prototype.expectedQuantity;
    /** @type {?|undefined} */
    ReturnRequestEntry.prototype.refundAmount;
}
/**
 * @record
 */
function ReturnRequest() { }
if (false) {
    /** @type {?|undefined} */
    ReturnRequest.prototype.cancellable;
    /** @type {?|undefined} */
    ReturnRequest.prototype.code;
    /** @type {?|undefined} */
    ReturnRequest.prototype.creationTime;
    /** @type {?|undefined} */
    ReturnRequest.prototype.deliveryCost;
    /** @type {?|undefined} */
    ReturnRequest.prototype.order;
    /** @type {?|undefined} */
    ReturnRequest.prototype.refundDeliveryCost;
    /** @type {?|undefined} */
    ReturnRequest.prototype.returnEntries;
    /** @type {?|undefined} */
    ReturnRequest.prototype.returnLabelDownloadUrl;
    /** @type {?|undefined} */
    ReturnRequest.prototype.rma;
    /** @type {?|undefined} */
    ReturnRequest.prototype.status;
    /** @type {?|undefined} */
    ReturnRequest.prototype.subTotal;
    /** @type {?|undefined} */
    ReturnRequest.prototype.totalPrice;
}
/**
 * @record
 */
function ReturnRequestList() { }
if (false) {
    /** @type {?|undefined} */
    ReturnRequestList.prototype.returnRequests;
    /** @type {?|undefined} */
    ReturnRequestList.prototype.pagination;
    /** @type {?|undefined} */
    ReturnRequestList.prototype.sorts;
}
/**
 * @record
 */
function ReturnRequestModification() { }
if (false) {
    /** @type {?|undefined} */
    ReturnRequestModification.prototype.status;
}
/**
 * @record
 */
function PickupOrderEntryGroup() { }
if (false) {
    /** @type {?|undefined} */
    PickupOrderEntryGroup.prototype.deliveryPointOfService;
    /** @type {?|undefined} */
    PickupOrderEntryGroup.prototype.distance;
    /** @type {?|undefined} */
    PickupOrderEntryGroup.prototype.entries;
    /** @type {?|undefined} */
    PickupOrderEntryGroup.prototype.quantity;
    /** @type {?|undefined} */
    PickupOrderEntryGroup.prototype.totalPriceWithTax;
}
/**
 * @record
 */
function PromotionOrderEntryConsumed() { }
if (false) {
    /** @type {?|undefined} */
    PromotionOrderEntryConsumed.prototype.adjustedUnitPrice;
    /** @type {?|undefined} */
    PromotionOrderEntryConsumed.prototype.code;
    /** @type {?|undefined} */
    PromotionOrderEntryConsumed.prototype.orderEntryNumber;
    /** @type {?|undefined} */
    PromotionOrderEntryConsumed.prototype.quantity;
}
/**
 * @record
 */
function ConsignmentEntry() { }
if (false) {
    /** @type {?|undefined} */
    ConsignmentEntry.prototype.orderEntry;
    /** @type {?|undefined} */
    ConsignmentEntry.prototype.quantity;
    /** @type {?|undefined} */
    ConsignmentEntry.prototype.shippedQuantity;
}
/**
 * @record
 */
function Consignment() { }
if (false) {
    /** @type {?|undefined} */
    Consignment.prototype.code;
    /** @type {?|undefined} */
    Consignment.prototype.deliveryPointOfService;
    /** @type {?|undefined} */
    Consignment.prototype.entries;
    /** @type {?|undefined} */
    Consignment.prototype.shippingAddress;
    /** @type {?|undefined} */
    Consignment.prototype.status;
    /** @type {?|undefined} */
    Consignment.prototype.statusDate;
    /** @type {?|undefined} */
    Consignment.prototype.trackingID;
}
/**
 * @record
 */
function OrderHistory() { }
if (false) {
    /** @type {?|undefined} */
    OrderHistory.prototype.code;
    /** @type {?|undefined} */
    OrderHistory.prototype.guid;
    /** @type {?|undefined} */
    OrderHistory.prototype.placed;
    /** @type {?|undefined} */
    OrderHistory.prototype.status;
    /** @type {?|undefined} */
    OrderHistory.prototype.statusDisplay;
    /** @type {?|undefined} */
    OrderHistory.prototype.total;
}
/**
 * @record
 */
function OrderHistoryList() { }
if (false) {
    /** @type {?|undefined} */
    OrderHistoryList.prototype.orders;
    /** @type {?|undefined} */
    OrderHistoryList.prototype.pagination;
    /** @type {?|undefined} */
    OrderHistoryList.prototype.sorts;
}
/**
 * @record
 */
function Order() { }
if (false) {
    /** @type {?|undefined} */
    Order.prototype.appliedOrderPromotions;
    /** @type {?|undefined} */
    Order.prototype.appliedProductPromotions;
    /** @type {?|undefined} */
    Order.prototype.appliedVouchers;
    /** @type {?|undefined} */
    Order.prototype.calculated;
    /** @type {?|undefined} */
    Order.prototype.code;
    /** @type {?|undefined} */
    Order.prototype.consignments;
    /** @type {?|undefined} */
    Order.prototype.created;
    /** @type {?|undefined} */
    Order.prototype.deliveryAddress;
    /** @type {?|undefined} */
    Order.prototype.deliveryCost;
    /** @type {?|undefined} */
    Order.prototype.deliveryItemsQuantity;
    /** @type {?|undefined} */
    Order.prototype.deliveryMode;
    /** @type {?|undefined} */
    Order.prototype.deliveryOrderGroups;
    /** @type {?|undefined} */
    Order.prototype.deliveryStatus;
    /** @type {?|undefined} */
    Order.prototype.deliveryStatusDisplay;
    /** @type {?|undefined} */
    Order.prototype.entries;
    /** @type {?|undefined} */
    Order.prototype.guestCustomer;
    /** @type {?|undefined} */
    Order.prototype.guid;
    /** @type {?|undefined} */
    Order.prototype.net;
    /** @type {?|undefined} */
    Order.prototype.orderDiscounts;
    /** @type {?|undefined} */
    Order.prototype.paymentInfo;
    /** @type {?|undefined} */
    Order.prototype.pickupItemsQuantity;
    /** @type {?|undefined} */
    Order.prototype.pickupOrderGroups;
    /** @type {?|undefined} */
    Order.prototype.productDiscounts;
    /** @type {?|undefined} */
    Order.prototype.site;
    /** @type {?|undefined} */
    Order.prototype.status;
    /** @type {?|undefined} */
    Order.prototype.statusDisplay;
    /** @type {?|undefined} */
    Order.prototype.store;
    /** @type {?|undefined} */
    Order.prototype.subTotal;
    /** @type {?|undefined} */
    Order.prototype.totalDiscounts;
    /** @type {?|undefined} */
    Order.prototype.totalItems;
    /** @type {?|undefined} */
    Order.prototype.totalPrice;
    /** @type {?|undefined} */
    Order.prototype.totalPriceWithTax;
    /** @type {?|undefined} */
    Order.prototype.totalTax;
    /** @type {?|undefined} */
    Order.prototype.unconsignedEntries;
    /** @type {?|undefined} */
    Order.prototype.user;
    /** @type {?|undefined} */
    Order.prototype.returnable;
    /** @type {?|undefined} */
    Order.prototype.cancellable;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @record
 */
function PointOfService() { }
if (false) {
    /** @type {?|undefined} */
    PointOfService.prototype.address;
    /** @type {?|undefined} */
    PointOfService.prototype.description;
    /** @type {?|undefined} */
    PointOfService.prototype.displayName;
    /** @type {?|undefined} */
    PointOfService.prototype.distanceKm;
    /** @type {?|undefined} */
    PointOfService.prototype.features;
    /** @type {?|undefined} */
    PointOfService.prototype.formattedDistance;
    /** @type {?|undefined} */
    PointOfService.prototype.geoPoint;
    /** @type {?|undefined} */
    PointOfService.prototype.mapIcon;
    /** @type {?|undefined} */
    PointOfService.prototype.name;
    /** @type {?|undefined} */
    PointOfService.prototype.openingHours;
    /** @type {?|undefined} */
    PointOfService.prototype.storeContent;
    /** @type {?|undefined} */
    PointOfService.prototype.storeImages;
    /** @type {?|undefined} */
    PointOfService.prototype.url;
}
/**
 * @record
 */
function SpecialOpeningDay() { }
if (false) {
    /** @type {?|undefined} */
    SpecialOpeningDay.prototype.closed;
    /** @type {?|undefined} */
    SpecialOpeningDay.prototype.closingTime;
    /** @type {?|undefined} */
    SpecialOpeningDay.prototype.comment;
    /** @type {?|undefined} */
    SpecialOpeningDay.prototype.date;
    /** @type {?|undefined} */
    SpecialOpeningDay.prototype.formattedDate;
    /** @type {?|undefined} */
    SpecialOpeningDay.prototype.name;
    /** @type {?|undefined} */
    SpecialOpeningDay.prototype.openingTime;
}
/**
 * @record
 */
function WeekdayOpeningDay() { }
if (false) {
    /** @type {?|undefined} */
    WeekdayOpeningDay.prototype.closed;
    /** @type {?|undefined} */
    WeekdayOpeningDay.prototype.closingTime;
    /** @type {?|undefined} */
    WeekdayOpeningDay.prototype.openingTime;
    /** @type {?|undefined} */
    WeekdayOpeningDay.prototype.weekDay;
}
/**
 * @record
 */
function OpeningSchedule() { }
if (false) {
    /** @type {?|undefined} */
    OpeningSchedule.prototype.code;
    /** @type {?|undefined} */
    OpeningSchedule.prototype.name;
    /** @type {?|undefined} */
    OpeningSchedule.prototype.specialDayOpeningList;
    /** @type {?|undefined} */
    OpeningSchedule.prototype.weekDayOpeningList;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @record
 */
function SearchQuery() { }
if (false) {
    /** @type {?|undefined} */
    SearchQuery.prototype.value;
}
/**
 * @record
 */
function SearchState() { }
if (false) {
    /** @type {?|undefined} */
    SearchState.prototype.query;
    /** @type {?|undefined} */
    SearchState.prototype.url;
}
/**
 * @record
 */
function FacetValue() { }
if (false) {
    /** @type {?|undefined} */
    FacetValue.prototype.count;
    /** @type {?|undefined} */
    FacetValue.prototype.name;
    /** @type {?|undefined} */
    FacetValue.prototype.query;
    /** @type {?|undefined} */
    FacetValue.prototype.selected;
}
/**
 * @record
 */
function Breadcrumb() { }
if (false) {
    /** @type {?|undefined} */
    Breadcrumb.prototype.facetCode;
    /** @type {?|undefined} */
    Breadcrumb.prototype.facetName;
    /** @type {?|undefined} */
    Breadcrumb.prototype.facetValueCode;
    /** @type {?|undefined} */
    Breadcrumb.prototype.facetValueName;
    /** @type {?|undefined} */
    Breadcrumb.prototype.removeQuery;
    /** @type {?|undefined} */
    Breadcrumb.prototype.truncateQuery;
}
/**
 * @record
 */
function Facet() { }
if (false) {
    /** @type {?|undefined} */
    Facet.prototype.category;
    /** @type {?|undefined} */
    Facet.prototype.multiSelect;
    /** @type {?|undefined} */
    Facet.prototype.name;
    /** @type {?|undefined} */
    Facet.prototype.priority;
    /** @type {?|undefined} */
    Facet.prototype.topValues;
    /** @type {?|undefined} */
    Facet.prototype.values;
    /** @type {?|undefined} */
    Facet.prototype.visible;
}
/**
 * @record
 */
function SpellingSuggestion() { }
if (false) {
    /** @type {?|undefined} */
    SpellingSuggestion.prototype.query;
    /** @type {?|undefined} */
    SpellingSuggestion.prototype.suggestion;
}
/**
 * @record
 */
function ProductSearchPage() { }
if (false) {
    /** @type {?|undefined} */
    ProductSearchPage.prototype.breadcrumbs;
    /** @type {?|undefined} */
    ProductSearchPage.prototype.categoryCode;
    /** @type {?|undefined} */
    ProductSearchPage.prototype.currentQuery;
    /** @type {?|undefined} */
    ProductSearchPage.prototype.facets;
    /** @type {?|undefined} */
    ProductSearchPage.prototype.freeTextSearch;
    /** @type {?|undefined} */
    ProductSearchPage.prototype.keywordRedirectUrl;
    /** @type {?|undefined} */
    ProductSearchPage.prototype.pagination;
    /** @type {?|undefined} */
    ProductSearchPage.prototype.products;
    /** @type {?|undefined} */
    ProductSearchPage.prototype.sorts;
    /** @type {?|undefined} */
    ProductSearchPage.prototype.spellingSuggestion;
}
/**
 * @record
 */
function Suggestion() { }
if (false) {
    /** @type {?|undefined} */
    Suggestion.prototype.value;
}
/**
 * @record
 */
function ClearSearch() { }
if (false) {
    /** @type {?|undefined} */
    ClearSearch.prototype.clearPageResults;
    /** @type {?|undefined} */
    ClearSearch.prototype.clearSearchboxResults;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @record
 */
function VariantOptionQualifier() { }
if (false) {
    /** @type {?|undefined} */
    VariantOptionQualifier.prototype.image;
    /** @type {?|undefined} */
    VariantOptionQualifier.prototype.name;
    /** @type {?|undefined} */
    VariantOptionQualifier.prototype.qualifier;
    /** @type {?|undefined} */
    VariantOptionQualifier.prototype.value;
}
/**
 * @record
 */
function PromotionRestriction() { }
if (false) {
    /** @type {?|undefined} */
    PromotionRestriction.prototype.description;
    /** @type {?|undefined} */
    PromotionRestriction.prototype.restrictionType;
}
/**
 * @record
 */
function FeatureUnit() { }
if (false) {
    /** @type {?|undefined} */
    FeatureUnit.prototype.name;
    /** @type {?|undefined} */
    FeatureUnit.prototype.symbol;
    /** @type {?|undefined} */
    FeatureUnit.prototype.unitType;
}
/**
 * @record
 */
function FeatureValue() { }
if (false) {
    /** @type {?|undefined} */
    FeatureValue.prototype.value;
}
/**
 * @record
 */
function Feature() { }
if (false) {
    /** @type {?|undefined} */
    Feature.prototype.code;
    /** @type {?|undefined} */
    Feature.prototype.comparable;
    /** @type {?|undefined} */
    Feature.prototype.description;
    /** @type {?|undefined} */
    Feature.prototype.featureUnit;
    /** @type {?|undefined} */
    Feature.prototype.featureValues;
    /** @type {?|undefined} */
    Feature.prototype.name;
    /** @type {?|undefined} */
    Feature.prototype.range;
    /** @type {?|undefined} */
    Feature.prototype.type;
}
/**
 * @record
 */
function VariantCategory() { }
if (false) {
    /** @type {?|undefined} */
    VariantCategory.prototype.hasImage;
    /** @type {?|undefined} */
    VariantCategory.prototype.name;
    /** @type {?|undefined} */
    VariantCategory.prototype.priority;
}
/**
 * @record
 */
function VariantValueCategory() { }
if (false) {
    /** @type {?|undefined} */
    VariantValueCategory.prototype.name;
    /** @type {?|undefined} */
    VariantValueCategory.prototype.sequence;
    /** @type {?|undefined} */
    VariantValueCategory.prototype.superCategories;
}
/** @enum {string} */
const VariantType = {
    SIZE: 'ApparelSizeVariantProduct',
    STYLE: 'ApparelStyleVariantProduct',
    COLOR: 'ElectronicsColorVariantProduct',
};
/** @enum {string} */
const PriceType = {
    BUY: 'BUY',
    FROM: 'FROM',
};
/**
 * @record
 */
function Price() { }
if (false) {
    /** @type {?|undefined} */
    Price.prototype.currencyIso;
    /** @type {?|undefined} */
    Price.prototype.formattedValue;
    /** @type {?|undefined} */
    Price.prototype.maxQuantity;
    /** @type {?|undefined} */
    Price.prototype.minQuantity;
    /** @type {?|undefined} */
    Price.prototype.priceType;
    /** @type {?|undefined} */
    Price.prototype.value;
}
/**
 * @record
 */
function Stock() { }
if (false) {
    /** @type {?|undefined} */
    Stock.prototype.stockLevel;
    /** @type {?|undefined} */
    Stock.prototype.stockLevelStatus;
}
/**
 * @record
 */
function VariantOption() { }
if (false) {
    /** @type {?|undefined} */
    VariantOption.prototype.code;
    /** @type {?|undefined} */
    VariantOption.prototype.priceData;
    /** @type {?|undefined} */
    VariantOption.prototype.stock;
    /** @type {?|undefined} */
    VariantOption.prototype.url;
    /** @type {?|undefined} */
    VariantOption.prototype.variantOptionQualifiers;
}
/**
 * @record
 */
function Promotion() { }
if (false) {
    /** @type {?|undefined} */
    Promotion.prototype.code;
    /** @type {?|undefined} */
    Promotion.prototype.couldFireMessages;
    /** @type {?|undefined} */
    Promotion.prototype.description;
    /** @type {?|undefined} */
    Promotion.prototype.enabled;
    /** @type {?|undefined} */
    Promotion.prototype.endDate;
    /** @type {?|undefined} */
    Promotion.prototype.firedMessages;
    /** @type {?|undefined} */
    Promotion.prototype.priority;
    /** @type {?|undefined} */
    Promotion.prototype.productBanner;
    /** @type {?|undefined} */
    Promotion.prototype.promotionGroup;
    /** @type {?|undefined} */
    Promotion.prototype.promotionType;
    /** @type {?|undefined} */
    Promotion.prototype.restrictions;
    /** @type {?|undefined} */
    Promotion.prototype.startDate;
    /** @type {?|undefined} */
    Promotion.prototype.title;
}
/**
 * @record
 */
function Category() { }
if (false) {
    /** @type {?|undefined} */
    Category.prototype.code;
    /** @type {?|undefined} */
    Category.prototype.name;
    /** @type {?|undefined} */
    Category.prototype.image;
    /** @type {?|undefined} */
    Category.prototype.url;
}
/**
 * @record
 */
function Classification() { }
if (false) {
    /** @type {?|undefined} */
    Classification.prototype.code;
    /** @type {?|undefined} */
    Classification.prototype.features;
    /** @type {?|undefined} */
    Classification.prototype.name;
}
/**
 * @record
 */
function FutureStock() { }
if (false) {
    /** @type {?|undefined} */
    FutureStock.prototype.date;
    /** @type {?|undefined} */
    FutureStock.prototype.formattedDate;
    /** @type {?|undefined} */
    FutureStock.prototype.stock;
}
/**
 * @record
 */
function PriceRange() { }
if (false) {
    /** @type {?|undefined} */
    PriceRange.prototype.maxPrice;
    /** @type {?|undefined} */
    PriceRange.prototype.minPrice;
}
/**
 * @record
 */
function ProductReference() { }
if (false) {
    /** @type {?|undefined} */
    ProductReference.prototype.description;
    /** @type {?|undefined} */
    ProductReference.prototype.preselected;
    /** @type {?|undefined} */
    ProductReference.prototype.quantity;
    /** @type {?|undefined} */
    ProductReference.prototype.referenceType;
    /** @type {?|undefined} */
    ProductReference.prototype.target;
}
/**
 * @record
 */
function Review() { }
if (false) {
    /** @type {?|undefined} */
    Review.prototype.alias;
    /** @type {?|undefined} */
    Review.prototype.comment;
    /** @type {?|undefined} */
    Review.prototype.date;
    /** @type {?|undefined} */
    Review.prototype.headline;
    /** @type {?|undefined} */
    Review.prototype.id;
    /** @type {?|undefined} */
    Review.prototype.principal;
    /** @type {?|undefined} */
    Review.prototype.rating;
}
/**
 * @record
 */
function VariantMatrixElement() { }
if (false) {
    /** @type {?|undefined} */
    VariantMatrixElement.prototype.elements;
    /** @type {?|undefined} */
    VariantMatrixElement.prototype.isLeaf;
    /** @type {?|undefined} */
    VariantMatrixElement.prototype.parentVariantCategory;
    /** @type {?|undefined} */
    VariantMatrixElement.prototype.variantOption;
    /** @type {?|undefined} */
    VariantMatrixElement.prototype.variantValueCategory;
}
/**
 * @record
 */
function ProductReferences() { }
/**
 * @record
 */
function BaseOption() { }
if (false) {
    /** @type {?|undefined} */
    BaseOption.prototype.options;
    /** @type {?|undefined} */
    BaseOption.prototype.selected;
    /** @type {?|undefined} */
    BaseOption.prototype.variantType;
}
/**
 * @record
 */
function Product() { }
if (false) {
    /** @type {?|undefined} */
    Product.prototype.availableForPickup;
    /** @type {?|undefined} */
    Product.prototype.averageRating;
    /** @type {?|undefined} */
    Product.prototype.baseOptions;
    /** @type {?|undefined} */
    Product.prototype.baseProduct;
    /** @type {?|undefined} */
    Product.prototype.categories;
    /** @type {?|undefined} */
    Product.prototype.classifications;
    /** @type {?|undefined} */
    Product.prototype.code;
    /** @type {?|undefined} */
    Product.prototype.description;
    /** @type {?|undefined} */
    Product.prototype.futureStocks;
    /** @type {?|undefined} */
    Product.prototype.images;
    /** @type {?|undefined} */
    Product.prototype.manufacturer;
    /** @type {?|undefined} */
    Product.prototype.multidimensional;
    /** @type {?|undefined} */
    Product.prototype.name;
    /** @type {?|undefined} */
    Product.prototype.nameHtml;
    /** @type {?|undefined} */
    Product.prototype.numberOfReviews;
    /** @type {?|undefined} */
    Product.prototype.potentialPromotions;
    /** @type {?|undefined} */
    Product.prototype.price;
    /** @type {?|undefined} */
    Product.prototype.priceRange;
    /** @type {?|undefined} */
    Product.prototype.productReferences;
    /** @type {?|undefined} */
    Product.prototype.purchasable;
    /** @type {?|undefined} */
    Product.prototype.reviews;
    /** @type {?|undefined} */
    Product.prototype.stock;
    /** @type {?|undefined} */
    Product.prototype.summary;
    /** @type {?|undefined} */
    Product.prototype.url;
    /** @type {?|undefined} */
    Product.prototype.variantMatrix;
    /** @type {?|undefined} */
    Product.prototype.variantOptions;
    /** @type {?|undefined} */
    Product.prototype.variantType;
    /** @type {?|undefined} */
    Product.prototype.volumePrices;
    /** @type {?|undefined} */
    Product.prototype.volumePricesFlag;
}
/** @enum {string} */
const VariantQualifier = {
    SIZE: 'size',
    STYLE: 'style',
    COLOR: 'color',
    THUMBNAIL: 'thumbnail',
    PRODUCT: 'product',
    ROLLUP_PROPERTY: 'rollupProperty',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const testestsd = 'sare';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @record
 */
function StoreFinderSearchPage() { }
if (false) {
    /** @type {?|undefined} */
    StoreFinderSearchPage.prototype.boundEastLongitude;
    /** @type {?|undefined} */
    StoreFinderSearchPage.prototype.boundNorthLatitude;
    /** @type {?|undefined} */
    StoreFinderSearchPage.prototype.boundSouthLatitude;
    /** @type {?|undefined} */
    StoreFinderSearchPage.prototype.boundWestLongitude;
    /** @type {?|undefined} */
    StoreFinderSearchPage.prototype.locationText;
    /** @type {?|undefined} */
    StoreFinderSearchPage.prototype.pagination;
    /** @type {?|undefined} */
    StoreFinderSearchPage.prototype.sorts;
    /** @type {?|undefined} */
    StoreFinderSearchPage.prototype.sourceLatitude;
    /** @type {?|undefined} */
    StoreFinderSearchPage.prototype.sourceLongitude;
    /** @type {?|undefined} */
    StoreFinderSearchPage.prototype.stores;
}
/**
 * @record
 */
function StoreCount() { }
if (false) {
    /** @type {?|undefined} */
    StoreCount.prototype.count;
    /** @type {?|undefined} */
    StoreCount.prototype.isoCode;
    /** @type {?|undefined} */
    StoreCount.prototype.name;
    /** @type {?|undefined} */
    StoreCount.prototype.type;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @record
 */
function CustomerCoupon() { }
if (false) {
    /** @type {?|undefined} */
    CustomerCoupon.prototype.couponId;
    /** @type {?|undefined} */
    CustomerCoupon.prototype.name;
    /** @type {?|undefined} */
    CustomerCoupon.prototype.startDate;
    /** @type {?|undefined} */
    CustomerCoupon.prototype.endDate;
    /** @type {?|undefined} */
    CustomerCoupon.prototype.status;
    /** @type {?|undefined} */
    CustomerCoupon.prototype.description;
    /** @type {?|undefined} */
    CustomerCoupon.prototype.notificationOn;
    /** @type {?|undefined} */
    CustomerCoupon.prototype.allProductsApplicable;
}
/**
 * @record
 */
function CustomerCouponNotification() { }
if (false) {
    /** @type {?|undefined} */
    CustomerCouponNotification.prototype.coupon;
    /** @type {?|undefined} */
    CustomerCouponNotification.prototype.customer;
    /** @type {?|undefined} */
    CustomerCouponNotification.prototype.status;
}
/**
 * @record
 */
function CustomerCouponSearchResult() { }
if (false) {
    /** @type {?|undefined} */
    CustomerCouponSearchResult.prototype.coupons;
    /** @type {?|undefined} */
    CustomerCouponSearchResult.prototype.sorts;
    /** @type {?|undefined} */
    CustomerCouponSearchResult.prototype.pagination;
}
/**
 * @record
 */
function CustomerCoupon2Customer() { }
if (false) {
    /** @type {?|undefined} */
    CustomerCoupon2Customer.prototype.coupon;
    /** @type {?|undefined} */
    CustomerCoupon2Customer.prototype.customer;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Used to envelope data observable together with specified scope
 * @record
 * @template T
 */
function ScopedData() { }
if (false) {
    /** @type {?} */
    ScopedData.prototype.scope;
    /** @type {?|undefined} */
    ScopedData.prototype.data$;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @record
 */
function NotificationPreference() { }
if (false) {
    /** @type {?|undefined} */
    NotificationPreference.prototype.channel;
    /** @type {?|undefined} */
    NotificationPreference.prototype.value;
    /** @type {?|undefined} */
    NotificationPreference.prototype.enabled;
    /** @type {?|undefined} */
    NotificationPreference.prototype.visible;
}
/**
 * @record
 */
function NotificationPreferenceList() { }
if (false) {
    /** @type {?|undefined} */
    NotificationPreferenceList.prototype.preferences;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @record
 */
function ProductInterestEntry() { }
if (false) {
    /** @type {?|undefined} */
    ProductInterestEntry.prototype.interestType;
    /** @type {?|undefined} */
    ProductInterestEntry.prototype.dateAdded;
    /** @type {?|undefined} */
    ProductInterestEntry.prototype.expirationDate;
}
/**
 * @record
 */
function ProductInterestEntryRelation() { }
if (false) {
    /** @type {?|undefined} */
    ProductInterestEntryRelation.prototype.product;
    /** @type {?|undefined} */
    ProductInterestEntryRelation.prototype.productInterestEntry;
}
/**
 * @record
 */
function ProductInterestSearchResult() { }
if (false) {
    /** @type {?|undefined} */
    ProductInterestSearchResult.prototype.results;
    /** @type {?|undefined} */
    ProductInterestSearchResult.prototype.sorts;
    /** @type {?|undefined} */
    ProductInterestSearchResult.prototype.pagination;
}
/** @enum {string} */
const NotificationType = {
    BACK_IN_STOCK: 'BACK_IN_STOCK',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const ANONYMOUS_CONSENTS_STORE_FEATURE = 'anonymous-consents';
/** @type {?} */
const ANONYMOUS_CONSENTS = '[Anonymous Consents] Anonymous Consents';
/**
 * @record
 */
function StateWithAnonymousConsents() { }
if (false) {
    /* Skipping unnamed member:
    [ANONYMOUS_CONSENTS_STORE_FEATURE]: AnonymousConsentsState;*/
}
/**
 * @record
 */
function AnonymousConsentsState() { }
if (false) {
    /** @type {?} */
    AnonymousConsentsState.prototype.templates;
    /** @type {?} */
    AnonymousConsentsState.prototype.consents;
    /** @type {?} */
    AnonymousConsentsState.prototype.ui;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const LOAD_ANONYMOUS_CONSENT_TEMPLATES = '[Anonymous Consents] Load Anonymous Consent Templates';
/** @type {?} */
const LOAD_ANONYMOUS_CONSENT_TEMPLATES_SUCCESS = '[Anonymous Consents] Load Anonymous Consent Templates Success';
/** @type {?} */
const LOAD_ANONYMOUS_CONSENT_TEMPLATES_FAIL = '[Anonymous Consents] Load Anonymous Consent Templates Fail';
/** @type {?} */
const RESET_LOAD_ANONYMOUS_CONSENT_TEMPLATES = '[Anonymous Consents] Reset Load Anonymous Consent Templates';
/** @type {?} */
const GET_ALL_ANONYMOUS_CONSENTS = '[Anonymous Consents] Get All Anonymous Consents';
/** @type {?} */
const GET_ANONYMOUS_CONSENT = '[Anonymous Consents] Get Anonymous Consent';
/** @type {?} */
const SET_ANONYMOUS_CONSENTS = '[Anonymous Consents] Set Anonymous Consents';
/** @type {?} */
const GIVE_ANONYMOUS_CONSENT = '[Anonymous Consents] Give Anonymous Consent';
/** @type {?} */
const WITHDRAW_ANONYMOUS_CONSENT = '[Anonymous Consents] Withdraw Anonymous Consent';
/** @type {?} */
const TOGGLE_ANONYMOUS_CONSENTS_BANNER_DISMISSED = '[Anonymous Consents] Toggle Anonymous Consents Banner Dismissed';
/** @type {?} */
const TOGGLE_ANONYMOUS_CONSENT_TEMPLATES_UPDATED = '[Anonymous Consents] Anonymous Consent Templates Updated';
class LoadAnonymousConsentTemplates extends LoaderLoadAction {
    constructor() {
        super(ANONYMOUS_CONSENTS);
        this.type = LOAD_ANONYMOUS_CONSENT_TEMPLATES;
    }
}
if (false) {
    /** @type {?} */
    LoadAnonymousConsentTemplates.prototype.type;
}
class LoadAnonymousConsentTemplatesSuccess extends LoaderSuccessAction {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        super(ANONYMOUS_CONSENTS);
        this.payload = payload;
        this.type = LOAD_ANONYMOUS_CONSENT_TEMPLATES_SUCCESS;
    }
}
if (false) {
    /** @type {?} */
    LoadAnonymousConsentTemplatesSuccess.prototype.type;
    /** @type {?} */
    LoadAnonymousConsentTemplatesSuccess.prototype.payload;
}
class LoadAnonymousConsentTemplatesFail extends LoaderFailAction {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        super(ANONYMOUS_CONSENTS, payload);
        this.type = LOAD_ANONYMOUS_CONSENT_TEMPLATES_FAIL;
    }
}
if (false) {
    /** @type {?} */
    LoadAnonymousConsentTemplatesFail.prototype.type;
}
class ResetLoadAnonymousConsentTemplates extends LoaderResetAction {
    constructor() {
        super(ANONYMOUS_CONSENTS);
        this.type = RESET_LOAD_ANONYMOUS_CONSENT_TEMPLATES;
    }
}
if (false) {
    /** @type {?} */
    ResetLoadAnonymousConsentTemplates.prototype.type;
}
class GetAllAnonymousConsents {
    constructor() {
        this.type = GET_ALL_ANONYMOUS_CONSENTS;
    }
}
if (false) {
    /** @type {?} */
    GetAllAnonymousConsents.prototype.type;
}
class GetAnonymousConsent {
    /**
     * @param {?} templateCode
     */
    constructor(templateCode) {
        this.templateCode = templateCode;
        this.type = GET_ANONYMOUS_CONSENT;
    }
}
if (false) {
    /** @type {?} */
    GetAnonymousConsent.prototype.type;
    /** @type {?} */
    GetAnonymousConsent.prototype.templateCode;
}
class SetAnonymousConsents {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        this.payload = payload;
        this.type = SET_ANONYMOUS_CONSENTS;
    }
}
if (false) {
    /** @type {?} */
    SetAnonymousConsents.prototype.type;
    /** @type {?} */
    SetAnonymousConsents.prototype.payload;
}
class GiveAnonymousConsent {
    /**
     * @param {?} templateCode
     */
    constructor(templateCode) {
        this.templateCode = templateCode;
        this.type = GIVE_ANONYMOUS_CONSENT;
    }
}
if (false) {
    /** @type {?} */
    GiveAnonymousConsent.prototype.type;
    /** @type {?} */
    GiveAnonymousConsent.prototype.templateCode;
}
class WithdrawAnonymousConsent {
    /**
     * @param {?} templateCode
     */
    constructor(templateCode) {
        this.templateCode = templateCode;
        this.type = WITHDRAW_ANONYMOUS_CONSENT;
    }
}
if (false) {
    /** @type {?} */
    WithdrawAnonymousConsent.prototype.type;
    /** @type {?} */
    WithdrawAnonymousConsent.prototype.templateCode;
}
class ToggleAnonymousConsentsBannerDissmissed {
    /**
     * @param {?} dismissed
     */
    constructor(dismissed) {
        this.dismissed = dismissed;
        this.type = TOGGLE_ANONYMOUS_CONSENTS_BANNER_DISMISSED;
    }
}
if (false) {
    /** @type {?} */
    ToggleAnonymousConsentsBannerDissmissed.prototype.type;
    /** @type {?} */
    ToggleAnonymousConsentsBannerDissmissed.prototype.dismissed;
}
class ToggleAnonymousConsentTemplatesUpdated {
    /**
     * @param {?} updated
     */
    constructor(updated) {
        this.updated = updated;
        this.type = TOGGLE_ANONYMOUS_CONSENT_TEMPLATES_UPDATED;
    }
}
if (false) {
    /** @type {?} */
    ToggleAnonymousConsentTemplatesUpdated.prototype.type;
    /** @type {?} */
    ToggleAnonymousConsentTemplatesUpdated.prototype.updated;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

var anonymousConsentsGroup = /*#__PURE__*/Object.freeze({
    LOAD_ANONYMOUS_CONSENT_TEMPLATES: LOAD_ANONYMOUS_CONSENT_TEMPLATES,
    LOAD_ANONYMOUS_CONSENT_TEMPLATES_SUCCESS: LOAD_ANONYMOUS_CONSENT_TEMPLATES_SUCCESS,
    LOAD_ANONYMOUS_CONSENT_TEMPLATES_FAIL: LOAD_ANONYMOUS_CONSENT_TEMPLATES_FAIL,
    RESET_LOAD_ANONYMOUS_CONSENT_TEMPLATES: RESET_LOAD_ANONYMOUS_CONSENT_TEMPLATES,
    GET_ALL_ANONYMOUS_CONSENTS: GET_ALL_ANONYMOUS_CONSENTS,
    GET_ANONYMOUS_CONSENT: GET_ANONYMOUS_CONSENT,
    SET_ANONYMOUS_CONSENTS: SET_ANONYMOUS_CONSENTS,
    GIVE_ANONYMOUS_CONSENT: GIVE_ANONYMOUS_CONSENT,
    WITHDRAW_ANONYMOUS_CONSENT: WITHDRAW_ANONYMOUS_CONSENT,
    TOGGLE_ANONYMOUS_CONSENTS_BANNER_DISMISSED: TOGGLE_ANONYMOUS_CONSENTS_BANNER_DISMISSED,
    TOGGLE_ANONYMOUS_CONSENT_TEMPLATES_UPDATED: TOGGLE_ANONYMOUS_CONSENT_TEMPLATES_UPDATED,
    LoadAnonymousConsentTemplates: LoadAnonymousConsentTemplates,
    LoadAnonymousConsentTemplatesSuccess: LoadAnonymousConsentTemplatesSuccess,
    LoadAnonymousConsentTemplatesFail: LoadAnonymousConsentTemplatesFail,
    ResetLoadAnonymousConsentTemplates: ResetLoadAnonymousConsentTemplates,
    GetAllAnonymousConsents: GetAllAnonymousConsents,
    GetAnonymousConsent: GetAnonymousConsent,
    SetAnonymousConsents: SetAnonymousConsents,
    GiveAnonymousConsent: GiveAnonymousConsent,
    WithdrawAnonymousConsent: WithdrawAnonymousConsent,
    ToggleAnonymousConsentsBannerDissmissed: ToggleAnonymousConsentsBannerDissmissed,
    ToggleAnonymousConsentTemplatesUpdated: ToggleAnonymousConsentTemplatesUpdated
});

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const getAnonymousConsentState = createFeatureSelector(ANONYMOUS_CONSENTS_STORE_FEATURE);

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
const ɵ0$8 = /**
 * @param {?} state
 * @return {?}
 */
state => state.templates;
/** @type {?} */
const getAnonymousConsentTemplatesState = createSelector(getAnonymousConsentState, (ɵ0$8));
/** @type {?} */
const getAnonymousConsentTemplatesValue = createSelector(getAnonymousConsentTemplatesState, loaderValueSelector);
/** @type {?} */
const getAnonymousConsentTemplatesLoading = createSelector(getAnonymousConsentTemplatesState, loaderLoadingSelector);
/** @type {?} */
const getAnonymousConsentTemplatesSuccess = createSelector(getAnonymousConsentTemplatesState, loaderSuccessSelector);
/** @type {?} */
const getAnonymousConsentTemplatesError = createSelector(getAnonymousConsentTemplatesState, loaderErrorSelector);
/** @type {?} */
const getAnonymousConsentTemplate = (/**
 * @param {?} templateCode
 * @return {?}
 */
(templateCode) => {
    return createSelector(getAnonymousConsentTemplatesValue, (/**
     * @param {?} templates
     * @return {?}
     */
    templates => {
        return templates
            ? templates.find((/**
             * @param {?} template
             * @return {?}
             */
            template => template.id === templateCode))
            : null;
    }));
});

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
const ɵ0$9 = /**
 * @param {?} state
 * @return {?}
 */
state => state.ui.updated;
/** @type {?} */
const getAnonymousConsentTemplatesUpdate = createSelector(getAnonymousConsentState, (ɵ0$9));
const ɵ1$6 = /**
 * @param {?} state
 * @return {?}
 */
state => state.ui.bannerDismissed;
/** @type {?} */
const getAnonymousConsentsBannerDismissed = createSelector(getAnonymousConsentState, (ɵ1$6));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
const ɵ0$a = /**
 * @param {?} state
 * @return {?}
 */
state => state.consents;
/** @type {?} */
const getAnonymousConsents = createSelector(getAnonymousConsentState, (ɵ0$a));
/** @type {?} */
const getAnonymousConsentByTemplateCode = (/**
 * @param {?} templateCode
 * @return {?}
 */
(templateCode) => createSelector(getAnonymousConsents, (/**
 * @param {?} consents
 * @return {?}
 */
consents => consents.find((/**
 * @param {?} consent
 * @return {?}
 */
consent => consent.templateCode === templateCode)))));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

var anonymousConsentsGroup_selectors = /*#__PURE__*/Object.freeze({
    getAnonymousConsentTemplatesState: getAnonymousConsentTemplatesState,
    getAnonymousConsentTemplatesValue: getAnonymousConsentTemplatesValue,
    getAnonymousConsentTemplatesLoading: getAnonymousConsentTemplatesLoading,
    getAnonymousConsentTemplatesSuccess: getAnonymousConsentTemplatesSuccess,
    getAnonymousConsentTemplatesError: getAnonymousConsentTemplatesError,
    getAnonymousConsentTemplate: getAnonymousConsentTemplate,
    getAnonymousConsentTemplatesUpdate: getAnonymousConsentTemplatesUpdate,
    getAnonymousConsentsBannerDismissed: getAnonymousConsentsBannerDismissed,
    getAnonymousConsents: getAnonymousConsents,
    getAnonymousConsentByTemplateCode: getAnonymousConsentByTemplateCode,
    getAnonymousConsentState: getAnonymousConsentState
});

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class AnonymousConsentsService {
    /**
     * @param {?} store
     * @param {?} authService
     */
    constructor(store, authService) {
        this.store = store;
        this.authService = authService;
    }
    /**
     * Retrieves the anonymous consent templates.
     * @return {?}
     */
    loadTemplates() {
        this.store.dispatch(new LoadAnonymousConsentTemplates());
    }
    /**
     * Conditionally triggers the load of the anonymous consent templates if:
     *   - `loadIfMissing` parameter is set to `true`
     *   - the `templates` in the store are `undefined`
     *
     * Othewise it just returns the value from the store.
     *
     * @param {?=} loadIfMissing setting to `true` will trigger the load of the templates if the currently stored templates are `undefined`
     * @return {?}
     */
    getTemplates(loadIfMissing = false) {
        return iif((/**
         * @return {?}
         */
        () => loadIfMissing), this.store.pipe(select(getAnonymousConsentTemplatesValue), withLatestFrom(this.getLoadTemplatesLoading()), filter((/**
         * @param {?} __0
         * @return {?}
         */
        ([_templates, loading]) => !loading)), tap((/**
         * @param {?} __0
         * @return {?}
         */
        ([templates, _loading]) => {
            if (!Boolean(templates)) {
                this.loadTemplates();
            }
        })), filter((/**
         * @param {?} __0
         * @return {?}
         */
        ([templates, _loading]) => Boolean(templates))), map((/**
         * @param {?} __0
         * @return {?}
         */
        ([templates, _loading]) => templates))), this.store.pipe(select(getAnonymousConsentTemplatesValue)));
    }
    /**
     * Returns the anonymous consent templates with the given template code.
     * @param {?} templateCode a template code by which to filter anonymous consent templates.
     * @return {?}
     */
    getTemplate(templateCode) {
        return this.store.pipe(select(getAnonymousConsentTemplate(templateCode)));
    }
    /**
     * Returns an indicator for the loading status for the anonymous consent templates.
     * @return {?}
     */
    getLoadTemplatesLoading() {
        return this.store.pipe(select(getAnonymousConsentTemplatesLoading));
    }
    /**
     * Returns an indicator for the success status for the anonymous consent templates.
     * @return {?}
     */
    getLoadTemplatesSuccess() {
        return this.store.pipe(select(getAnonymousConsentTemplatesSuccess));
    }
    /**
     * Returns an indicator for the error status for the anonymous consent templates.
     * @return {?}
     */
    getLoadTemplatesError() {
        return this.store.pipe(select(getAnonymousConsentTemplatesError));
    }
    /**
     * Resets the loading, success and error indicators for the anonymous consent templates.
     * @return {?}
     */
    resetLoadTemplatesState() {
        this.store.dispatch(new ResetLoadAnonymousConsentTemplates());
    }
    /**
     * Returns all the anonymous consents.
     * @return {?}
     */
    getConsents() {
        return this.store.pipe(select(getAnonymousConsents));
    }
    /**
     * Puts the provided anonymous consents into the store.
     * @param {?} consents
     * @return {?}
     */
    setConsents(consents) {
        return this.store.dispatch(new SetAnonymousConsents(consents));
    }
    /**
     * Returns the anonymous consent for the given template ID.
     *
     * As a side-effect, the method will call `getTemplates(true)` to load the templates if those are not present.
     *
     * @param {?} templateId a template ID by which to filter anonymous consent templates.
     * @return {?}
     */
    getConsent(templateId) {
        return this.authService.isUserLoggedIn().pipe(filter((/**
         * @param {?} authenticated
         * @return {?}
         */
        authenticated => !authenticated)), tap((/**
         * @param {?} _
         * @return {?}
         */
        _ => this.getTemplates(true))), switchMap((/**
         * @param {?} _
         * @return {?}
         */
        _ => this.store.pipe(select(getAnonymousConsentByTemplateCode(templateId))))));
    }
    /**
     * Give a consent for the given `templateCode`
     * @param {?} templateCode for which to give the consent
     * @return {?}
     */
    giveConsent(templateCode) {
        this.store.dispatch(new GiveAnonymousConsent(templateCode));
    }
    /**
     * Sets all the anonymous consents' state to given.
     * @return {?}
     */
    giveAllConsents() {
        return this.getTemplates(true).pipe(tap((/**
         * @param {?} templates
         * @return {?}
         */
        templates => templates.forEach((/**
         * @param {?} template
         * @return {?}
         */
        template => this.giveConsent(template.id))))));
    }
    /**
     * Returns `true` if the provided `consent` is given.
     * @param {?} consent a consent to test
     * @return {?}
     */
    isConsentGiven(consent) {
        return consent && consent.consentState === ANONYMOUS_CONSENT_STATUS.GIVEN;
    }
    /**
     * Withdraw a consent for the given `templateCode`
     * @param {?} templateCode for which to withdraw the consent
     * @return {?}
     */
    withdrawConsent(templateCode) {
        this.store.dispatch(new WithdrawAnonymousConsent(templateCode));
    }
    /**
     * Sets all the anonymous consents' state to withdrawn.
     * @return {?}
     */
    withdrawAllConsents() {
        return this.getTemplates(true).pipe(tap((/**
         * @param {?} templates
         * @return {?}
         */
        templates => templates.forEach((/**
         * @param {?} template
         * @return {?}
         */
        template => this.withdrawConsent(template.id))))));
    }
    /**
     * Returns `true` if the provided `consent` is withdrawn.
     * @param {?} consent a consent to test
     * @return {?}
     */
    isConsentWithdrawn(consent) {
        return (consent && consent.consentState === ANONYMOUS_CONSENT_STATUS.WITHDRAWN);
    }
    /**
     * Toggles the dismissed state of the anonymous consents banner.
     * @param {?} dismissed the banner will be dismissed if `true` is passed, otherwise it will be visible.
     * @return {?}
     */
    toggleBannerDismissed(dismissed) {
        this.store.dispatch(new ToggleAnonymousConsentsBannerDissmissed(dismissed));
        if (dismissed) {
            this.toggleTemplatesUpdated(false);
        }
    }
    /**
     * Returns `true` if the banner was dismissed, `false` otherwise.
     * @return {?}
     */
    isBannerDismissed() {
        return this.store.pipe(select(getAnonymousConsentsBannerDismissed));
    }
    /**
     * Returns `true` if the consent templates were updated on the back-end.
     * If the templates are not present in the store, it triggers the load.
     * @return {?}
     */
    getTemplatesUpdated() {
        return this.getTemplates(true).pipe(switchMap((/**
         * @param {?} _
         * @return {?}
         */
        _ => this.store.pipe(select(getAnonymousConsentTemplatesUpdate)))));
    }
    /**
     * Toggles the `updated` slice of the state
     * @param {?} updated
     * @return {?}
     */
    toggleTemplatesUpdated(updated) {
        this.store.dispatch(new ToggleAnonymousConsentTemplatesUpdated(updated));
    }
    /**
     * Returns `true` if either the banner is not dismissed or if the templates were updated on the back-end.
     * Otherwise, it returns `false`.
     * @return {?}
     */
    isBannerVisible() {
        return combineLatest([
            this.isBannerDismissed(),
            this.getTemplatesUpdated(),
        ]).pipe(map((/**
         * @param {?} __0
         * @return {?}
         */
        ([dismissed, updated]) => !dismissed || updated)));
    }
    /**
     * Returns `true` if there's a missmatch in template versions between the provided `currentTemplates` and `newTemplates`
     * @param {?} currentTemplates current templates to check
     * @param {?} newTemplates new templates to check
     * @return {?}
     */
    detectUpdatedTemplates(currentTemplates, newTemplates) {
        if (newTemplates.length !== currentTemplates.length) {
            return true;
        }
        for (let i = 0; i < newTemplates.length; i++) {
            /** @type {?} */
            const newTemplate = newTemplates[i];
            /** @type {?} */
            const currentTemplate = currentTemplates[i];
            if (newTemplate.version !== currentTemplate.version) {
                return true;
            }
        }
        return false;
    }
    /**
     * Serializes using `JSON.stringify()` and encodes using `encodeURIComponent()` methods
     * @param {?} consents to serialize and encode
     * @return {?}
     */
    serializeAndEncode(consents) {
        if (!consents) {
            return '';
        }
        /** @type {?} */
        const serialized = JSON.stringify(consents);
        /** @type {?} */
        const encoded = encodeURIComponent(serialized);
        return encoded;
    }
    /**
     * Decodes using `decodeURIComponent()` and deserializes using `JSON.parse()`
     * @param {?} rawConsents to decode an deserialize
     * @return {?}
     */
    decodeAndDeserialize(rawConsents) {
        /** @type {?} */
        const decoded = decodeURIComponent(rawConsents);
        /** @type {?} */
        const unserialized = (/** @type {?} */ (JSON.parse(decoded)));
        return unserialized;
    }
    /**
     *
     * Compares the given `newConsents` and `previousConsents` and returns `true` if there are differences (the `newConsents` are updates).
     * Otherwise it returns `false`.
     *
     * @param {?} newConsents new consents to compare
     * @param {?} previousConsents old consents to compare
     * @return {?}
     */
    consentsUpdated(newConsents, previousConsents) {
        /** @type {?} */
        const newRawConsents = this.serializeAndEncode(newConsents);
        /** @type {?} */
        const previousRawConsents = this.serializeAndEncode(previousConsents);
        return newRawConsents !== previousRawConsents;
    }
}
AnonymousConsentsService.decorators = [
    { type: Injectable, args: [{ providedIn: 'root' },] }
];
/** @nocollapse */
AnonymousConsentsService.ctorParameters = () => [
    { type: Store },
    { type: AuthService }
];
/** @nocollapse */ AnonymousConsentsService.ngInjectableDef = ɵɵdefineInjectable({ factory: function AnonymousConsentsService_Factory() { return new AnonymousConsentsService(ɵɵinject(Store), ɵɵinject(AuthService)); }, token: AnonymousConsentsService, providedIn: "root" });
if (false) {
    /**
     * @type {?}
     * @protected
     */
    AnonymousConsentsService.prototype.store;
    /**
     * @type {?}
     * @protected
     */
    AnonymousConsentsService.prototype.authService;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @abstract
 */
class FeaturesConfig {
}
if (false) {
    /** @type {?} */
    FeaturesConfig.prototype.features;
}
/** @type {?} */
const ANONYMOUS_CONSENTS_FEATURE = 'anonymousConsents';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} config
 * @return {?}
 */
function isFeatureConfig(config) {
    return typeof config === 'object' && config.features;
}
/**
 * @param {?} level
 * @param {?} version
 * @return {?}
 */
function isInLevel(level, version) {
    if (level === '*') {
        return true;
    }
    /** @type {?} */
    const levelParts = level.split('.');
    /** @type {?} */
    const versionParts = version.split('.');
    for (let i = 0; i < versionParts.length; i++) {
        /** @type {?} */
        const versionNumberPart = Number(versionParts[i]);
        /** @type {?} */
        const levelNumberPart = Number(levelParts[i]) || 0;
        if (versionNumberPart !== levelNumberPart) {
            return levelNumberPart > versionNumberPart;
        }
    }
    return true;
}
/**
 * @param {?} config
 * @param {?} level
 * @return {?}
 */
function isFeatureLevel(config, level) {
    if (isFeatureConfig(config)) {
        return level[0] === '!'
            ? !isInLevel(config.features.level, level.substr(1, level.length))
            : isInLevel(config.features.level, level);
    }
}
/**
 * @param {?} config
 * @param {?} feature
 * @return {?}
 */
function isFeatureEnabled(config, feature) {
    if (isFeatureConfig(config)) {
        /** @type {?} */
        const featureConfig = feature[0] === '!'
            ? config.features[feature.substr(1, feature.length)]
            : config.features[feature];
        /** @type {?} */
        const result = typeof featureConfig === 'string'
            ? isFeatureLevel(config, featureConfig)
            : featureConfig;
        return feature[0] === '!' ? !result : result;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FeatureConfigService {
    /**
     * @param {?} config
     */
    constructor(config) {
        this.config = config;
    }
    /**
     * @param {?} version
     * @return {?}
     */
    isLevel(version) {
        return isFeatureLevel(this.config, version);
    }
    /**
     * @param {?} feature
     * @return {?}
     */
    isEnabled(feature) {
        return isFeatureEnabled(this.config, feature);
    }
}
FeatureConfigService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root',
            },] }
];
/** @nocollapse */
FeatureConfigService.ctorParameters = () => [
    { type: FeaturesConfig }
];
/** @nocollapse */ FeatureConfigService.ngInjectableDef = ɵɵdefineInjectable({ factory: function FeatureConfigService_Factory() { return new FeatureConfigService(ɵɵinject(FeaturesConfig)); }, token: FeatureConfigService, providedIn: "root" });
if (false) {
    /**
     * @type {?}
     * @protected
     */
    FeatureConfigService.prototype.config;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FeatureLevelDirective {
    /**
     * @param {?} templateRef
     * @param {?} viewContainer
     * @param {?} featureConfig
     */
    constructor(templateRef, viewContainer, featureConfig) {
        this.templateRef = templateRef;
        this.viewContainer = viewContainer;
        this.featureConfig = featureConfig;
        this.hasView = false;
    }
    /**
     * @param {?} level
     * @return {?}
     */
    set cxFeatureLevel(level) {
        if (this.featureConfig.isLevel(level.toString()) && !this.hasView) {
            this.viewContainer.createEmbeddedView(this.templateRef);
            this.hasView = true;
        }
        else if (!this.featureConfig.isLevel(level.toString()) && this.hasView) {
            this.viewContainer.clear();
            this.hasView = false;
        }
    }
}
FeatureLevelDirective.decorators = [
    { type: Directive, args: [{
                selector: '[cxFeatureLevel]',
            },] }
];
/** @nocollapse */
FeatureLevelDirective.ctorParameters = () => [
    { type: TemplateRef },
    { type: ViewContainerRef },
    { type: FeatureConfigService }
];
FeatureLevelDirective.propDecorators = {
    cxFeatureLevel: [{ type: Input }]
};
if (false) {
    /**
     * @type {?}
     * @private
     */
    FeatureLevelDirective.prototype.hasView;
    /**
     * @type {?}
     * @protected
     */
    FeatureLevelDirective.prototype.templateRef;
    /**
     * @type {?}
     * @protected
     */
    FeatureLevelDirective.prototype.viewContainer;
    /**
     * @type {?}
     * @protected
     */
    FeatureLevelDirective.prototype.featureConfig;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FeatureDirective {
    /**
     * @param {?} templateRef
     * @param {?} viewContainer
     * @param {?} featureConfig
     */
    constructor(templateRef, viewContainer, featureConfig) {
        this.templateRef = templateRef;
        this.viewContainer = viewContainer;
        this.featureConfig = featureConfig;
        this.hasView = false;
    }
    /**
     * @param {?} feature
     * @return {?}
     */
    set cxFeature(feature) {
        if (this.featureConfig.isEnabled(feature) && !this.hasView) {
            this.viewContainer.createEmbeddedView(this.templateRef);
            this.hasView = true;
        }
        else if (!this.featureConfig.isEnabled(feature) && this.hasView) {
            this.viewContainer.clear();
            this.hasView = false;
        }
    }
}
FeatureDirective.decorators = [
    { type: Directive, args: [{
                selector: '[cxFeature]',
            },] }
];
/** @nocollapse */
FeatureDirective.ctorParameters = () => [
    { type: TemplateRef },
    { type: ViewContainerRef },
    { type: FeatureConfigService }
];
FeatureDirective.propDecorators = {
    cxFeature: [{ type: Input }]
};
if (false) {
    /**
     * @type {?}
     * @private
     */
    FeatureDirective.prototype.hasView;
    /**
     * @type {?}
     * @protected
     */
    FeatureDirective.prototype.templateRef;
    /**
     * @type {?}
     * @protected
     */
    FeatureDirective.prototype.viewContainer;
    /**
     * @type {?}
     * @protected
     */
    FeatureDirective.prototype.featureConfig;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FeaturesConfigModule {
    /**
     * @param {?=} defaultLevel
     * @return {?}
     */
    static forRoot(defaultLevel) {
        return {
            ngModule: FeaturesConfigModule,
            providers: [
                provideConfig((/** @type {?} */ ({
                    features: {
                        level: defaultLevel || '*',
                    },
                }))),
                {
                    provide: FeaturesConfig,
                    useExisting: Config,
                },
            ],
        };
    }
}
FeaturesConfigModule.decorators = [
    { type: NgModule, args: [{
                declarations: [FeatureLevelDirective, FeatureDirective],
                exports: [FeatureLevelDirective, FeatureDirective],
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @abstract
 */
class AsmAdapter {
}
if (false) {
    /**
     * Abstract function used to search for customers.
     * @abstract
     * @param {?} options
     * @return {?}
     */
    AsmAdapter.prototype.customerSearch = function (options) { };
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const defaultOccAsmConfig = {
    backend: {
        occ: {
            endpoints: {
                asmCustomerSearch: '/assistedservicewebservices/customers/search',
            },
        },
    },
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @abstract
 */
class AsmConfig extends OccConfig {
}
if (false) {
    /** @type {?} */
    AsmConfig.prototype.asm;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const CUSTOMER_SEARCH_PAGE_NORMALIZER = new InjectionToken('CustomerSearchPageNormalizer');

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Converter is used to convert source data model to target data model.
 * By convention, we distinguish two flows:
 *   - *Normalize* is the conversion from backend models to UI models
 *   - *Serialize* is the conversion of UI models to backend models (in case of submitting data to the backend).
 *
 * Converters can be stacked together to to apply decoupled customizations
 * @record
 * @template S, T
 */
function Converter() { }
if (false) {
    /**
     * Convert converts source model to target model. Can use optional target parameter,
     * used in case of stacking multiple converters (for example, to implement populator pattern).
     *
     * @param {?} source Source data model
     * @param {?=} target Optional, partially converted target model
     * @return {?}
     */
    Converter.prototype.convert = function (source, target) { };
}
class ConverterService {
    /**
     * @param {?} injector
     */
    constructor(injector) {
        this.injector = injector;
        this.converters = new Map();
    }
    /**
     * @private
     * @template S, T
     * @param {?} injectionToken
     * @return {?}
     */
    getConverters(injectionToken) {
        if (!this.converters.has(injectionToken)) {
            /** @type {?} */
            const converters = this.injector.get(injectionToken, []);
            if (!Array.isArray(converters)) {
                console.warn('Converter must be multi-provided, please use "multi: true" for', injectionToken.toString());
            }
            this.converters.set(injectionToken, converters);
        }
        return this.converters.get(injectionToken);
    }
    /**
     * Will return true if converters for specified token were provided
     * @template S, T
     * @param {?} injectionToken
     * @return {?}
     */
    hasConverters(injectionToken) {
        /** @type {?} */
        const converters = this.getConverters(injectionToken);
        return Array.isArray(converters) && converters.length > 0;
    }
    /**
     * Pipeable operator to apply converter logic in a observable stream
     * @template S, T
     * @param {?} injectionToken
     * @return {?}
     */
    pipeable(injectionToken) {
        if (this.hasConverters(injectionToken)) {
            return map((/**
             * @param {?} model
             * @return {?}
             */
            (model) => this.convertSource(model, injectionToken)));
        }
        else {
            return (/**
             * @param {?} observable
             * @return {?}
             */
            (observable) => (/** @type {?} */ (observable)));
        }
    }
    /**
     * Pipeable operator to apply converter logic in a observable stream to collection of items
     * @template S, T
     * @param {?} injectionToken
     * @return {?}
     */
    pipeableMany(injectionToken) {
        if (this.hasConverters(injectionToken)) {
            return map((/**
             * @param {?} model
             * @return {?}
             */
            (model) => this.convertMany(model, injectionToken)));
        }
        else {
            return (/**
             * @param {?} observable
             * @return {?}
             */
            (observable) => (/** @type {?} */ (observable)));
        }
    }
    /**
     * Apply converter logic specified by injection token to source data
     * @template S, T
     * @param {?} source
     * @param {?} injectionToken
     * @return {?}
     */
    convert(source, injectionToken) {
        if (this.hasConverters(injectionToken)) {
            return this.convertSource(source, injectionToken);
        }
        else {
            return (/** @type {?} */ (source));
        }
    }
    /**
     * Apply converter logic specified by injection token to a collection
     * @template S, T
     * @param {?} sources
     * @param {?} injectionToken
     * @return {?}
     */
    convertMany(sources, injectionToken) {
        if (this.hasConverters(injectionToken) && Array.isArray(sources)) {
            return sources.map((/**
             * @param {?} source
             * @return {?}
             */
            source => this.convertSource(source, injectionToken)));
        }
        else {
            return (/** @type {?} */ (sources));
        }
    }
    /**
     * @private
     * @template S, T
     * @param {?} source
     * @param {?} injectionToken
     * @return {?}
     */
    convertSource(source, injectionToken) {
        return this.getConverters(injectionToken).reduce((/**
         * @param {?} target
         * @param {?} converter
         * @return {?}
         */
        (target, converter) => {
            return converter.convert(source, target);
        }), (/** @type {?} */ (undefined)));
    }
}
ConverterService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root',
            },] }
];
/** @nocollapse */
ConverterService.ctorParameters = () => [
    { type: Injector }
];
/** @nocollapse */ ConverterService.ngInjectableDef = ɵɵdefineInjectable({ factory: function ConverterService_Factory() { return new ConverterService(ɵɵinject(INJECTOR)); }, token: ConverterService, providedIn: "root" });
if (false) {
    /**
     * @type {?}
     * @private
     */
    ConverterService.prototype.converters;
    /**
     * @type {?}
     * @protected
     */
    ConverterService.prototype.injector;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class OccAsmAdapter {
    /**
     * @param {?} http
     * @param {?} occEndpointsService
     * @param {?} converterService
     * @param {?} config
     * @param {?} baseSiteService
     */
    constructor(http, occEndpointsService, converterService, config, baseSiteService) {
        this.http = http;
        this.occEndpointsService = occEndpointsService;
        this.converterService = converterService;
        this.config = config;
        this.baseSiteService = baseSiteService;
        this.baseSiteService
            .getActive()
            .subscribe((/**
         * @param {?} value
         * @return {?}
         */
        value => (this.activeBaseSite = value)));
    }
    /**
     * @param {?} options
     * @return {?}
     */
    customerSearch(options) {
        /** @type {?} */
        const headers = InterceptorUtil.createHeader(USE_CUSTOMER_SUPPORT_AGENT_TOKEN, true, new HttpHeaders());
        /** @type {?} */
        let params = new HttpParams()
            .set('baseSite', this.activeBaseSite)
            .set('sort', 'byNameAsc');
        if (typeof options['query'] !== 'undefined') {
            params = params.set('query', '' + options.query);
        }
        if (typeof options['pageSize'] !== 'undefined') {
            params = params.set('pageSize', '' + options.pageSize);
        }
        /** @type {?} */
        const url = this.occEndpointsService.getRawEndpoint('asmCustomerSearch');
        return this.http
            .get(url, { headers, params })
            .pipe(this.converterService.pipeable(CUSTOMER_SEARCH_PAGE_NORMALIZER));
    }
}
OccAsmAdapter.decorators = [
    { type: Injectable }
];
/** @nocollapse */
OccAsmAdapter.ctorParameters = () => [
    { type: HttpClient },
    { type: OccEndpointsService },
    { type: ConverterService },
    { type: AsmConfig },
    { type: BaseSiteService }
];
if (false) {
    /**
     * @type {?}
     * @private
     */
    OccAsmAdapter.prototype.activeBaseSite;
    /**
     * @type {?}
     * @protected
     */
    OccAsmAdapter.prototype.http;
    /**
     * @type {?}
     * @protected
     */
    OccAsmAdapter.prototype.occEndpointsService;
    /**
     * @type {?}
     * @protected
     */
    OccAsmAdapter.prototype.converterService;
    /**
     * @type {?}
     * @protected
     */
    OccAsmAdapter.prototype.config;
    /**
     * @type {?}
     * @protected
     */
    OccAsmAdapter.prototype.baseSiteService;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class AsmOccModule {
}
AsmOccModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    HttpClientModule,
                    ConfigModule.withConfig(defaultOccAsmConfig),
                ],
                providers: [
                    {
                        provide: AsmAdapter,
                        useClass: OccAsmAdapter,
                    },
                ],
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @abstract
 */
class CartAdapter {
}
if (false) {
    /**
     * Abstract method used to load all carts
     *
     * @abstract
     * @param {?} userId
     * @return {?}
     */
    CartAdapter.prototype.loadAll = function (userId) { };
    /**
     * Abstract method used to load cart
     *
     * @abstract
     * @param {?} userId
     * @param {?} cartId
     * @return {?}
     */
    CartAdapter.prototype.load = function (userId, cartId) { };
    /**
     * Abstract method used to create cart. If toMergeCartGuid is specified, cart will be merged with existing one
     *
     * @abstract
     * @param {?} userId
     * @param {?=} oldCartId
     * @param {?=} toMergeCartGuid
     * @return {?}
     */
    CartAdapter.prototype.create = function (userId, oldCartId, toMergeCartGuid) { };
    /**
     * Abstract method used to delete cart
     *
     * @abstract
     * @param {?} userId
     * @param {?} cartId
     * @return {?}
     */
    CartAdapter.prototype.delete = function (userId, cartId) { };
    /**
     * Abstract method to assign an email to the cart. This step is required to make a guest checkout
     * @abstract
     * @param {?} userId
     * @param {?} cartId
     * @param {?} email
     * @return {?}
     */
    CartAdapter.prototype.addEmail = function (userId, cartId, email) { };
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const CART_NORMALIZER = new InjectionToken('CartNormalizer');

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @abstract
 */
class CartEntryAdapter {
}
if (false) {
    /**
     * Abstract method used to add entry to cart
     *
     * @abstract
     * @param {?} userId
     * @param {?} cartId
     * @param {?} productCode
     * @param {?=} quantity
     * @return {?}
     */
    CartEntryAdapter.prototype.add = function (userId, cartId, productCode, quantity) { };
    /**
     * Abstract method used to update entry in cart
     * @abstract
     * @param {?} userId
     * @param {?} cartId
     * @param {?} entryNumber
     * @param {?} qty
     * @param {?=} pickupStore
     * @return {?}
     */
    CartEntryAdapter.prototype.update = function (userId, cartId, entryNumber, qty, pickupStore) { };
    /**
     * Abstract method used to remove entry from cart
     *
     * @abstract
     * @param {?} userId
     * @param {?} cartId
     * @param {?} entryNumber
     * @return {?}
     */
    CartEntryAdapter.prototype.remove = function (userId, cartId, entryNumber) { };
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @abstract
 */
class SaveCartAdapter {
}
if (false) {
    /**
     * Abstract method used to save a cart
     *
     * @abstract
     * @param {?} userId
     * @param {?} cartId
     * @param {?=} saveCartName
     * @param {?=} saveCartDescription
     * @return {?}
     */
    SaveCartAdapter.prototype.saveCart = function (userId, cartId, saveCartName, saveCartDescription) { };
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @abstract
 */
class CartVoucherAdapter {
}
if (false) {
    /**
     * Abstract method used to apply voucher to cart
     *
     * @abstract
     * @param {?} userId
     * @param {?} cartId
     * @param {?} voucherId
     * @return {?}
     */
    CartVoucherAdapter.prototype.add = function (userId, cartId, voucherId) { };
    /**
     * Abstract method used to remove voucher from cart
     *
     * @abstract
     * @param {?} userId
     * @param {?} cartId
     * @param {?} voucherId
     * @return {?}
     */
    CartVoucherAdapter.prototype.remove = function (userId, cartId, voucherId) { };
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const PRODUCT_NORMALIZER = new InjectionToken('ProductNormalizer');

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class OccCartNormalizer {
    /**
     * @param {?} converter
     */
    constructor(converter) {
        this.converter = converter;
    }
    /**
     * @param {?} source
     * @param {?=} target
     * @return {?}
     */
    convert(source, target) {
        if (target === undefined) {
            target = Object.assign({}, ((/** @type {?} */ (source))));
        }
        if (source && source.entries) {
            target.entries = source.entries.map((/**
             * @param {?} entry
             * @return {?}
             */
            entry => (Object.assign({}, entry, { product: this.converter.convert(entry.product, PRODUCT_NORMALIZER) }))));
        }
        this.removeDuplicatePromotions(source, target);
        return target;
    }
    /**
     * Remove all duplicate promotions
     * @private
     * @param {?} source
     * @param {?} target
     * @return {?}
     */
    removeDuplicatePromotions(source, target) {
        if (source && source.potentialOrderPromotions) {
            target.potentialOrderPromotions = this.removeDuplicateItems(source.potentialOrderPromotions);
        }
        if (source && source.potentialProductPromotions) {
            target.potentialProductPromotions = this.removeDuplicateItems(source.potentialProductPromotions);
        }
        if (source && source.appliedOrderPromotions) {
            target.appliedOrderPromotions = this.removeDuplicateItems(source.appliedOrderPromotions);
        }
        if (source && source.appliedProductPromotions) {
            target.appliedProductPromotions = this.removeDuplicateItems(source.appliedProductPromotions);
        }
    }
    /**
     * @private
     * @param {?} itemList
     * @return {?}
     */
    removeDuplicateItems(itemList) {
        return itemList.filter((/**
         * @param {?} p
         * @param {?} i
         * @param {?} a
         * @return {?}
         */
        (p, i, a) => {
            /** @type {?} */
            const b = a.map((/**
             * @param {?} el
             * @return {?}
             */
            el => JSON.stringify(el)));
            return i === b.indexOf(JSON.stringify(p));
        }));
    }
}
OccCartNormalizer.decorators = [
    { type: Injectable, args: [{ providedIn: 'root' },] }
];
/** @nocollapse */
OccCartNormalizer.ctorParameters = () => [
    { type: ConverterService }
];
/** @nocollapse */ OccCartNormalizer.ngInjectableDef = ɵɵdefineInjectable({ factory: function OccCartNormalizer_Factory() { return new OccCartNormalizer(ɵɵinject(ConverterService)); }, token: OccCartNormalizer, providedIn: "root" });
if (false) {
    /**
     * @type {?}
     * @private
     */
    OccCartNormalizer.prototype.converter;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const defaultOccCartConfig = {
    backend: {
        occ: {
            endpoints: {
                // tslint:disable:max-line-length
                carts: 'users/${userId}/carts?fields=carts(DEFAULT,potentialProductPromotions,appliedProductPromotions,potentialOrderPromotions,appliedOrderPromotions,entries(totalPrice(formattedValue),product(images(FULL),stock(FULL)),basePrice(formattedValue,value),updateable),totalPrice(formattedValue),totalItems,totalPriceWithTax(formattedValue),totalDiscounts(value,formattedValue),subTotal(formattedValue),deliveryItemsQuantity,deliveryCost(formattedValue),totalTax(formattedValue, value),pickupItemsQuantity,net,appliedVouchers,productDiscounts(formattedValue),saveTime,user,name)',
                cart: 'users/${userId}/carts/${cartId}?fields=DEFAULT,potentialProductPromotions,appliedProductPromotions,potentialOrderPromotions,appliedOrderPromotions,entries(totalPrice(formattedValue),product(images(FULL),stock(FULL)),basePrice(formattedValue,value),updateable),totalPrice(formattedValue),totalItems,totalPriceWithTax(formattedValue),totalDiscounts(value,formattedValue),subTotal(formattedValue),deliveryItemsQuantity,deliveryCost(formattedValue),totalTax(formattedValue, value),pickupItemsQuantity,net,appliedVouchers,productDiscounts(formattedValue),user',
                createCart: 'users/${userId}/carts?fields=DEFAULT,potentialProductPromotions,appliedProductPromotions,potentialOrderPromotions,appliedOrderPromotions,entries(totalPrice(formattedValue),product(images(FULL),stock(FULL)),basePrice(formattedValue,value),updateable),totalPrice(formattedValue),totalItems,totalPriceWithTax(formattedValue),totalDiscounts(value,formattedValue),subTotal(formattedValue),deliveryItemsQuantity,deliveryCost(formattedValue),totalTax(formattedValue, value),pickupItemsQuantity,net,appliedVouchers,productDiscounts(formattedValue),user',
                addEntries: 'users/${userId}/carts/${cartId}/entries',
                updateEntries: 'users/${userId}/carts/${cartId}/entries/${entryNumber}',
                removeEntries: 'users/${userId}/carts/${cartId}/entries/${entryNumber}',
                addEmail: 'users/${userId}/carts/${cartId}/email',
                deleteCart: 'users/${userId}/carts/${cartId}',
                cartVoucher: 'users/${userId}/carts/${cartId}/vouchers',
                saveCart: 'users/${userId}/carts/${cartId}/save',
            },
        },
    },
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const CART_MODIFICATION_NORMALIZER = new InjectionToken('CartModificationNormalizer');

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class OccCartEntryAdapter {
    /**
     * @param {?} http
     * @param {?} occEndpointsService
     * @param {?} converterService
     * @param {?=} featureConfigService
     */
    constructor(http, occEndpointsService, converterService, featureConfigService) {
        this.http = http;
        this.occEndpointsService = occEndpointsService;
        this.converterService = converterService;
        this.featureConfigService = featureConfigService;
    }
    /**
     * @deprecated Since 1.1
     * Use configurable endpoints.
     * Remove issue: #4125
     * @protected
     * @param {?} userId
     * @return {?}
     */
    getCartEndpoint(userId) {
        /** @type {?} */
        const cartEndpoint = 'users/' + userId + '/carts/';
        return this.occEndpointsService.getEndpoint(cartEndpoint);
    }
    /**
     * @param {?} userId
     * @param {?} cartId
     * @param {?} productCode
     * @param {?=} quantity
     * @return {?}
     */
    add(userId, cartId, productCode, quantity = 1) {
        /** @type {?} */
        const toAdd = JSON.stringify({});
        /** @type {?} */
        const headers = new HttpHeaders({
            'Content-Type': 'application/x-www-form-urlencoded',
        });
        // TODO: Deprecated, remove Issue: #4125
        if (!this.featureConfigService.isLevel('1.1')) {
            return this.legacyAdd(userId, cartId, productCode, quantity);
        }
        /** @type {?} */
        const url = this.occEndpointsService.getUrl('addEntries', {
            userId,
            cartId,
        }, { code: productCode, qty: quantity });
        return this.http
            .post(url, toAdd, { headers })
            .pipe(this.converterService.pipeable(CART_MODIFICATION_NORMALIZER));
    }
    /**
     * @param {?} userId
     * @param {?} cartId
     * @param {?} entryNumber
     * @param {?} qty
     * @param {?=} pickupStore
     * @return {?}
     */
    update(userId, cartId, entryNumber, qty, pickupStore) {
        /** @type {?} */
        let params = {};
        if (pickupStore) {
            params = { pickupStore };
        }
        /** @type {?} */
        const headers = new HttpHeaders({
            'Content-Type': 'application/x-www-form-urlencoded',
        });
        // TODO: Deprecated, remove Issue: #4125
        if (!this.featureConfigService.isLevel('1.1')) {
            return this.legacyUpdate(userId, cartId, entryNumber, qty, pickupStore);
        }
        /** @type {?} */
        const url = this.occEndpointsService.getUrl('updateEntries', { userId, cartId, entryNumber }, Object.assign({ qty }, params));
        return this.http
            .patch(url, {}, { headers })
            .pipe(this.converterService.pipeable(CART_MODIFICATION_NORMALIZER));
    }
    /**
     * @param {?} userId
     * @param {?} cartId
     * @param {?} entryNumber
     * @return {?}
     */
    remove(userId, cartId, entryNumber) {
        /** @type {?} */
        const headers = new HttpHeaders({
            'Content-Type': 'application/x-www-form-urlencoded',
        });
        // TODO: Deprecated, remove Issue: #4125
        if (!this.featureConfigService.isLevel('1.1')) {
            return this.legacyRemove(userId, cartId, entryNumber);
        }
        /** @type {?} */
        const url = this.occEndpointsService.getUrl('removeEntries', {
            userId,
            cartId,
            entryNumber,
        });
        return this.http.delete(url, { headers });
    }
    /**
     * @deprecated Since 1.1
     * Use configurable endpoints.
     * Remove issue: #4125
     * @private
     * @param {?} userId
     * @param {?} cartId
     * @param {?} productCode
     * @param {?=} quantity
     * @return {?}
     */
    legacyAdd(userId, cartId, productCode, quantity = 1) {
        /** @type {?} */
        const url = this.getCartEndpoint(userId) + cartId + '/entries';
        /** @type {?} */
        const params = new HttpParams({
            fromString: 'code=' + productCode + '&qty=' + quantity,
        });
        /** @type {?} */
        const toAdd = JSON.stringify({});
        /** @type {?} */
        const headers = new HttpHeaders({
            'Content-Type': 'application/x-www-form-urlencoded',
        });
        return this.http
            .post(url, toAdd, { headers, params })
            .pipe(this.converterService.pipeable(CART_MODIFICATION_NORMALIZER));
    }
    /**
     * @deprecated Since 1.1
     * Use configurable endpoints.
     * Remove issue: #4125
     * @private
     * @param {?} userId
     * @param {?} cartId
     * @param {?} entryNumber
     * @param {?} qty
     * @param {?=} pickupStore
     * @return {?}
     */
    legacyUpdate(userId, cartId, entryNumber, qty, pickupStore) {
        /** @type {?} */
        const url = this.getCartEndpoint(userId) + cartId + '/entries/' + entryNumber;
        /** @type {?} */
        let queryString = 'qty=' + qty;
        if (pickupStore) {
            queryString = queryString + '&pickupStore=' + pickupStore;
        }
        /** @type {?} */
        const params = new HttpParams({
            fromString: queryString,
        });
        /** @type {?} */
        const headers = new HttpHeaders({
            'Content-Type': 'application/x-www-form-urlencoded',
        });
        return this.http
            .patch(url, {}, { headers, params })
            .pipe(this.converterService.pipeable(CART_MODIFICATION_NORMALIZER));
    }
    /**
     * @deprecated Since 1.1
     * Use configurable endpoints.
     * Remove issue: #4125
     * @private
     * @param {?} userId
     * @param {?} cartId
     * @param {?} entryNumber
     * @return {?}
     */
    legacyRemove(userId, cartId, entryNumber) {
        /** @type {?} */
        const url = this.getCartEndpoint(userId) + cartId + '/entries/' + entryNumber;
        /** @type {?} */
        const headers = new HttpHeaders({
            'Content-Type': 'application/x-www-form-urlencoded',
        });
        return this.http.delete(url, { headers });
    }
}
OccCartEntryAdapter.decorators = [
    { type: Injectable }
];
/** @nocollapse */
OccCartEntryAdapter.ctorParameters = () => [
    { type: HttpClient },
    { type: OccEndpointsService },
    { type: ConverterService },
    { type: FeatureConfigService }
];
if (false) {
    /**
     * @type {?}
     * @protected
     */
    OccCartEntryAdapter.prototype.http;
    /**
     * @type {?}
     * @protected
     */
    OccCartEntryAdapter.prototype.occEndpointsService;
    /**
     * @type {?}
     * @protected
     */
    OccCartEntryAdapter.prototype.converterService;
    /**
     * @type {?}
     * @protected
     */
    OccCartEntryAdapter.prototype.featureConfigService;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const CART_VOUCHER_NORMALIZER = new InjectionToken('CartVoucherNormalizer');

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class OccCartVoucherAdapter {
    /**
     * @param {?} http
     * @param {?} occEndpoints
     * @param {?} converter
     */
    constructor(http, occEndpoints, converter) {
        this.http = http;
        this.occEndpoints = occEndpoints;
        this.converter = converter;
    }
    /**
     * @protected
     * @param {?} userId
     * @param {?} cartId
     * @return {?}
     */
    getCartVoucherEndpoint(userId, cartId) {
        return this.occEndpoints.getUrl('cartVoucher', { userId, cartId });
    }
    /**
     * @protected
     * @param {?} userId
     * @return {?}
     */
    getHeaders(userId) {
        /** @type {?} */
        let headers = new HttpHeaders({
            'Content-Type': 'application/json',
        });
        if (userId === OCC_USER_ID_ANONYMOUS) {
            headers = InterceptorUtil.createHeader(USE_CLIENT_TOKEN, true, headers);
        }
        return headers;
    }
    /**
     * @param {?} userId
     * @param {?} cartId
     * @param {?} voucherId
     * @return {?}
     */
    add(userId, cartId, voucherId) {
        /** @type {?} */
        const url = this.getCartVoucherEndpoint(userId, cartId);
        /** @type {?} */
        const toAdd = JSON.stringify({});
        /** @type {?} */
        const params = new HttpParams().set('voucherId', voucherId);
        /** @type {?} */
        const headers = this.getHeaders(userId);
        return this.http.post(url, toAdd, { headers, params }).pipe(catchError((/**
         * @param {?} error
         * @return {?}
         */
        (error) => throwError(error.json()))), this.converter.pipeable(CART_VOUCHER_NORMALIZER));
    }
    /**
     * @param {?} userId
     * @param {?} cartId
     * @param {?} voucherId
     * @return {?}
     */
    remove(userId, cartId, voucherId) {
        /** @type {?} */
        const url = this.getCartVoucherEndpoint(userId, cartId) +
            '/' +
            encodeURIComponent(voucherId);
        /** @type {?} */
        const headers = this.getHeaders(userId);
        return this.http
            .delete(url, { headers })
            .pipe(catchError((/**
         * @param {?} error
         * @return {?}
         */
        (error) => throwError(error))));
    }
}
OccCartVoucherAdapter.decorators = [
    { type: Injectable }
];
/** @nocollapse */
OccCartVoucherAdapter.ctorParameters = () => [
    { type: HttpClient },
    { type: OccEndpointsService },
    { type: ConverterService }
];
if (false) {
    /**
     * @type {?}
     * @protected
     */
    OccCartVoucherAdapter.prototype.http;
    /**
     * @type {?}
     * @protected
     */
    OccCartVoucherAdapter.prototype.occEndpoints;
    /**
     * @type {?}
     * @protected
     */
    OccCartVoucherAdapter.prototype.converter;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// TODO: Deprecated, remove Issue: #4125. Use configurable endpoints.
/** @type {?} */
const DETAILS_PARAMS = 'DEFAULT,potentialProductPromotions,appliedProductPromotions,potentialOrderPromotions,appliedOrderPromotions,' +
    'entries(totalPrice(formattedValue),product(images(FULL),stock(FULL)),basePrice(formattedValue),updateable),' +
    'totalPrice(formattedValue),totalItems,totalPriceWithTax(formattedValue),totalDiscounts(value,formattedValue),subTotal(formattedValue),' +
    'deliveryItemsQuantity,deliveryCost(formattedValue),totalTax(formattedValue),pickupItemsQuantity,net,' +
    'appliedVouchers,productDiscounts(formattedValue),user';
class OccCartAdapter {
    /**
     * @param {?} http
     * @param {?} occEndpointsService
     * @param {?} converterService
     * @param {?=} featureConfigService
     */
    constructor(http, occEndpointsService, converterService, featureConfigService) {
        this.http = http;
        this.occEndpointsService = occEndpointsService;
        this.converterService = converterService;
        this.featureConfigService = featureConfigService;
    }
    /**
     * @deprecated Since 1.1
     * Use configurable endpoints.
     * Remove issue: #4125
     * @protected
     * @param {?} userId
     * @return {?}
     */
    getCartEndpoint(userId) {
        /** @type {?} */
        const cartEndpoint = `users/${userId}/carts/`;
        return this.occEndpointsService.getEndpoint(cartEndpoint);
    }
    /**
     * @param {?} userId
     * @return {?}
     */
    loadAll(userId) {
        // TODO: Deprecated, remove Issue: #4125.
        if (!this.featureConfigService.isLevel('1.1')) {
            return this.legacyLoadAll(userId);
        }
        return this.http
            .get(this.occEndpointsService.getUrl('carts', { userId }))
            .pipe(pluck('carts'), this.converterService.pipeableMany(CART_NORMALIZER));
    }
    /**
     * @param {?} userId
     * @param {?} cartId
     * @return {?}
     */
    load(userId, cartId) {
        if (cartId === OCC_CART_ID_CURRENT) {
            return this.loadAll(userId).pipe(map((/**
             * @param {?} carts
             * @return {?}
             */
            carts => {
                if (carts) {
                    /** @type {?} */
                    const activeCart = carts.find((/**
                     * @param {?} cart
                     * @return {?}
                     */
                    cart => {
                        return cart['saveTime'] === undefined;
                    }));
                    return activeCart;
                }
                else {
                    return null;
                }
            })));
        }
        else {
            // TODO: Deprecated, remove Issue: #4125.
            if (!this.featureConfigService.isLevel('1.1')) {
                return this.legacyLoad(userId, cartId);
            }
            return this.http
                .get(this.occEndpointsService.getUrl('cart', { userId, cartId }))
                .pipe(this.converterService.pipeable(CART_NORMALIZER));
        }
    }
    /**
     * @param {?} userId
     * @param {?=} oldCartId
     * @param {?=} toMergeCartGuid
     * @return {?}
     */
    create(userId, oldCartId, toMergeCartGuid) {
        /** @type {?} */
        const toAdd = JSON.stringify({});
        // TODO: Deprecated, remove Issue: #4125.
        if (!this.featureConfigService.isLevel('1.1')) {
            return this.legacyCreate(userId, toAdd, oldCartId, toMergeCartGuid);
        }
        /** @type {?} */
        let params = {};
        if (oldCartId) {
            params = { oldCartId: oldCartId };
        }
        if (toMergeCartGuid) {
            params['toMergeCartGuid'] = toMergeCartGuid;
        }
        return this.http
            .post(this.occEndpointsService.getUrl('createCart', { userId }, params), toAdd)
            .pipe(this.converterService.pipeable(CART_NORMALIZER));
    }
    /**
     * @param {?} userId
     * @param {?} cartId
     * @return {?}
     */
    delete(userId, cartId) {
        /** @type {?} */
        let headers = new HttpHeaders();
        if (userId === OCC_USER_ID_ANONYMOUS) {
            headers = InterceptorUtil.createHeader(USE_CLIENT_TOKEN, true, headers);
        }
        return this.http.delete(this.occEndpointsService.getUrl('deleteCart', { userId, cartId }), { headers });
    }
    /**
     * @deprecated Since 1.1
     * Use configurable endpoints.
     * Remove issue: #4125
     * @private
     * @param {?} userId
     * @return {?}
     */
    legacyLoadAll(userId) {
        /** @type {?} */
        const url = this.getCartEndpoint(userId);
        /** @type {?} */
        const params = new HttpParams({
            fromString: `fields=carts(${DETAILS_PARAMS},saveTime)`,
        });
        return this.http.get(url, { params }).pipe(pluck('carts'), this.converterService.pipeableMany(CART_NORMALIZER));
    }
    /**
     * @deprecated Since 1.1
     * Use configurable endpoints.
     * Remove issue: #4125
     * @private
     * @param {?} userId
     * @param {?} cartId
     * @return {?}
     */
    legacyLoad(userId, cartId) {
        /** @type {?} */
        const url = this.getCartEndpoint(userId) + cartId;
        /** @type {?} */
        const params = new HttpParams({
            fromString: `fields=${DETAILS_PARAMS}`,
        });
        return this.http
            .get(url, { params })
            .pipe(this.converterService.pipeable(CART_NORMALIZER));
    }
    /**
     * @deprecated Since 1.1
     * Use configurable endpoints.
     * Remove issue: #4125
     * @private
     * @param {?} userId
     * @param {?} toAdd
     * @param {?=} oldCartId
     * @param {?=} toMergeCartGuid
     * @return {?}
     */
    legacyCreate(userId, toAdd, oldCartId, toMergeCartGuid) {
        /** @type {?} */
        const url = this.getCartEndpoint(userId);
        /** @type {?} */
        let queryString = `fields=${DETAILS_PARAMS}`;
        if (oldCartId) {
            queryString = `${queryString}&oldCartId=${oldCartId}`;
        }
        if (toMergeCartGuid) {
            queryString = `${queryString}&toMergeCartGuid=${toMergeCartGuid}`;
        }
        /** @type {?} */
        const params = new HttpParams({
            fromString: queryString,
        });
        return this.http
            .post(url, toAdd, { params })
            .pipe(this.converterService.pipeable(CART_NORMALIZER));
    }
    /**
     * @param {?} userId
     * @param {?} cartId
     * @param {?} email
     * @return {?}
     */
    addEmail(userId, cartId, email) {
        /** @type {?} */
        let headers = new HttpHeaders({
            'Content-Type': 'application/x-www-form-urlencoded',
        });
        headers = InterceptorUtil.createHeader(USE_CLIENT_TOKEN, true, headers);
        /** @type {?} */
        const httpParams = new HttpParams().set('email', email);
        /** @type {?} */
        const url = this.occEndpointsService.getUrl('addEmail', {
            userId,
            cartId,
        });
        return this.http.put(url, httpParams, { headers });
    }
}
OccCartAdapter.decorators = [
    { type: Injectable }
];
/** @nocollapse */
OccCartAdapter.ctorParameters = () => [
    { type: HttpClient },
    { type: OccEndpointsService },
    { type: ConverterService },
    { type: FeatureConfigService }
];
if (false) {
    /**
     * @type {?}
     * @protected
     */
    OccCartAdapter.prototype.http;
    /**
     * @type {?}
     * @protected
     */
    OccCartAdapter.prototype.occEndpointsService;
    /**
     * @type {?}
     * @protected
     */
    OccCartAdapter.prototype.converterService;
    /**
     * @type {?}
     * @protected
     */
    OccCartAdapter.prototype.featureConfigService;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const SAVE_CART_NORMALIZER = new InjectionToken('SaveCartNormalizer');

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class OccSaveCartAdapter {
    /**
     * @param {?} http
     * @param {?} occEndpointsService
     * @param {?} converterService
     */
    constructor(http, occEndpointsService, converterService) {
        this.http = http;
        this.occEndpointsService = occEndpointsService;
        this.converterService = converterService;
    }
    /**
     * @param {?} userId
     * @param {?} cartId
     * @param {?=} saveCartName
     * @param {?=} saveCartDescription
     * @return {?}
     */
    saveCart(userId, cartId, saveCartName, saveCartDescription) {
        /** @type {?} */
        let httpParams = new HttpParams();
        if (Boolean(saveCartName)) {
            httpParams = httpParams.set('saveCartName', saveCartName);
        }
        if (Boolean(saveCartDescription)) {
            httpParams = httpParams.set('saveCartDescription', saveCartDescription);
        }
        /** @type {?} */
        const headers = new HttpHeaders({
            'Content-Type': 'application/x-www-form-urlencoded',
        });
        return this.http
            .patch(this.occEndpointsService.getUrl('saveCart', { userId, cartId }), httpParams, { headers })
            .pipe(this.converterService.pipeable(SAVE_CART_NORMALIZER));
    }
}
OccSaveCartAdapter.decorators = [
    { type: Injectable }
];
/** @nocollapse */
OccSaveCartAdapter.ctorParameters = () => [
    { type: HttpClient },
    { type: OccEndpointsService },
    { type: ConverterService }
];
if (false) {
    /**
     * @type {?}
     * @protected
     */
    OccSaveCartAdapter.prototype.http;
    /**
     * @type {?}
     * @protected
     */
    OccSaveCartAdapter.prototype.occEndpointsService;
    /**
     * @type {?}
     * @protected
     */
    OccSaveCartAdapter.prototype.converterService;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class CartOccModule {
}
CartOccModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    HttpClientModule,
                    ConfigModule.withConfig(defaultOccCartConfig),
                ],
                providers: [
                    {
                        provide: CartAdapter,
                        useClass: OccCartAdapter,
                    },
                    {
                        provide: CART_NORMALIZER,
                        useExisting: OccCartNormalizer,
                        multi: true,
                    },
                    {
                        provide: CartEntryAdapter,
                        useClass: OccCartEntryAdapter,
                    },
                    {
                        provide: CartVoucherAdapter,
                        useClass: OccCartVoucherAdapter,
                    },
                    {
                        provide: SaveCartAdapter,
                        useClass: OccSaveCartAdapter,
                    },
                ],
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const ORDER_NORMALIZER = new InjectionToken('OrderNormalizer');

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// To be changed to a more optimised params after ticket: C3PO-1076
/** @type {?} */
const FULL_PARAMS = 'fields=FULL';
/** @type {?} */
const CHECKOUT_PARAMS = 'deliveryAddress(FULL),deliveryMode,paymentInfo(FULL)';
/** @type {?} */
const ORDERS_ENDPOINT = '/orders';
/** @type {?} */
const CARTS_ENDPOINT = '/carts/';
class OccCheckoutAdapter {
    /**
     * @param {?} http
     * @param {?} occEndpoints
     * @param {?} converter
     */
    constructor(http, occEndpoints, converter) {
        this.http = http;
        this.occEndpoints = occEndpoints;
        this.converter = converter;
    }
    /**
     * @protected
     * @param {?} userId
     * @param {?} subEndpoint
     * @return {?}
     */
    getEndpoint(userId, subEndpoint) {
        /** @type {?} */
        const orderEndpoint = 'users/' + userId + subEndpoint;
        return this.occEndpoints.getEndpoint(orderEndpoint);
    }
    /**
     * @param {?} userId
     * @param {?} cartId
     * @return {?}
     */
    placeOrder(userId, cartId) {
        /** @type {?} */
        const url = this.getEndpoint(userId, ORDERS_ENDPOINT);
        /** @type {?} */
        const params = new HttpParams({
            fromString: 'cartId=' + cartId + '&' + FULL_PARAMS,
        });
        /** @type {?} */
        let headers = new HttpHeaders({
            'Content-Type': 'application/x-www-form-urlencoded',
        });
        if (userId === OCC_USER_ID_ANONYMOUS) {
            headers = InterceptorUtil.createHeader(USE_CLIENT_TOKEN, true, headers);
        }
        return this.http
            .post(url, {}, { headers, params })
            .pipe(this.converter.pipeable(ORDER_NORMALIZER));
    }
    /**
     * @param {?} userId
     * @param {?} cartId
     * @return {?}
     */
    loadCheckoutDetails(userId, cartId) {
        /** @type {?} */
        const url = this.getEndpoint(userId, CARTS_ENDPOINT) + cartId;
        /** @type {?} */
        const params = new HttpParams({
            fromString: `fields=${CHECKOUT_PARAMS}`,
        });
        return this.http.get(url, { params });
    }
    /**
     * @param {?} userId
     * @param {?} cartId
     * @return {?}
     */
    clearCheckoutDeliveryAddress(userId, cartId) {
        /** @type {?} */
        const url = `${this.getEndpoint(userId, CARTS_ENDPOINT)}${cartId}/addresses/delivery`;
        return this.http.delete(url);
    }
    /**
     * @param {?} userId
     * @param {?} cartId
     * @return {?}
     */
    clearCheckoutDeliveryMode(userId, cartId) {
        /** @type {?} */
        const url = `${this.getEndpoint(userId, CARTS_ENDPOINT)}${cartId}/deliverymode`;
        return this.http.delete(url);
    }
}
OccCheckoutAdapter.decorators = [
    { type: Injectable }
];
/** @nocollapse */
OccCheckoutAdapter.ctorParameters = () => [
    { type: HttpClient },
    { type: OccEndpointsService },
    { type: ConverterService }
];
if (false) {
    /**
     * @type {?}
     * @protected
     */
    OccCheckoutAdapter.prototype.http;
    /**
     * @type {?}
     * @protected
     */
    OccCheckoutAdapter.prototype.occEndpoints;
    /**
     * @type {?}
     * @protected
     */
    OccCheckoutAdapter.prototype.converter;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const DELIVERY_MODE_NORMALIZER = new InjectionToken('DeliveryModeNormalizer');

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const ADDRESS_NORMALIZER = new InjectionToken('AddressNormalizer');
/** @type {?} */
const ADDRESS_SERIALIZER = new InjectionToken('AddressSerializer');
/** @type {?} */
const ADDRESS_VALIDATION_NORMALIZER = new InjectionToken('AddressValidationNormalizer');

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class OccCheckoutDeliveryAdapter {
    /**
     * @param {?} http
     * @param {?} occEndpoints
     * @param {?} converter
     */
    constructor(http, occEndpoints, converter) {
        this.http = http;
        this.occEndpoints = occEndpoints;
        this.converter = converter;
    }
    /**
     * @protected
     * @param {?} userId
     * @return {?}
     */
    getCartEndpoint(userId) {
        /** @type {?} */
        const cartEndpoint = 'users/' + userId + '/carts/';
        return this.occEndpoints.getEndpoint(cartEndpoint);
    }
    /**
     * @param {?} userId
     * @param {?} cartId
     * @param {?} address
     * @return {?}
     */
    createAddress(userId, cartId, address) {
        address = this.converter.convert(address, ADDRESS_SERIALIZER);
        return this.http
            .post(this.getCartEndpoint(userId) + cartId + '/addresses/delivery', address, {
            headers: new HttpHeaders().set('Content-Type', 'application/json'),
        })
            .pipe(this.converter.pipeable(ADDRESS_NORMALIZER));
    }
    /**
     * @param {?} userId
     * @param {?} cartId
     * @param {?} addressId
     * @return {?}
     */
    setAddress(userId, cartId, addressId) {
        return this.http.put(this.getCartEndpoint(userId) + cartId + '/addresses/delivery', {}, {
            params: { addressId: addressId },
        });
    }
    /**
     * @param {?} userId
     * @param {?} cartId
     * @param {?} deliveryModeId
     * @return {?}
     */
    setMode(userId, cartId, deliveryModeId) {
        return this.http.put(this.getCartEndpoint(userId) + cartId + '/deliverymode', {}, {
            params: { deliveryModeId: deliveryModeId },
        });
    }
    /**
     * @param {?} userId
     * @param {?} cartId
     * @return {?}
     */
    getMode(userId, cartId) {
        return this.http
            .get(this.getCartEndpoint(userId) + cartId + '/deliverymode')
            .pipe(this.converter.pipeable(DELIVERY_MODE_NORMALIZER));
    }
    /**
     * @param {?} userId
     * @param {?} cartId
     * @return {?}
     */
    getSupportedModes(userId, cartId) {
        return this.http
            .get(this.getCartEndpoint(userId) + cartId + '/deliverymodes')
            .pipe(pluck('deliveryModes'), this.converter.pipeableMany(DELIVERY_MODE_NORMALIZER));
    }
}
OccCheckoutDeliveryAdapter.decorators = [
    { type: Injectable }
];
/** @nocollapse */
OccCheckoutDeliveryAdapter.ctorParameters = () => [
    { type: HttpClient },
    { type: OccEndpointsService },
    { type: ConverterService }
];
if (false) {
    /**
     * @type {?}
     * @protected
     */
    OccCheckoutDeliveryAdapter.prototype.http;
    /**
     * @type {?}
     * @protected
     */
    OccCheckoutDeliveryAdapter.prototype.occEndpoints;
    /**
     * @type {?}
     * @protected
     */
    OccCheckoutDeliveryAdapter.prototype.converter;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const PAYMENT_DETAILS_NORMALIZER = new InjectionToken('PaymentDetailsNormalizer');
/** @type {?} */
const PAYMENT_DETAILS_SERIALIZER = new InjectionToken('PaymentDetailsSerializer');
/** @type {?} */
const CARD_TYPE_NORMALIZER = new InjectionToken('CardTypeNormalizer');

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class CustomEncoder {
    /**
     * @param {?} key
     * @return {?}
     */
    encodeKey(key) {
        return encodeURIComponent(key);
    }
    /**
     * @param {?} value
     * @return {?}
     */
    encodeValue(value) {
        return encodeURIComponent(value);
    }
    /**
     * @param {?} key
     * @return {?}
     */
    decodeKey(key) {
        return decodeURIComponent(key);
    }
    /**
     * @param {?} value
     * @return {?}
     */
    decodeValue(value) {
        return decodeURIComponent(value);
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const ENDPOINT_CARD_TYPES = 'cardtypes';
class OccCheckoutPaymentAdapter {
    /**
     * @param {?} http
     * @param {?} occEndpoints
     * @param {?} converter
     */
    constructor(http, occEndpoints, converter) {
        this.http = http;
        this.occEndpoints = occEndpoints;
        this.converter = converter;
        if (typeof DOMParser !== 'undefined') {
            this.domparser = new DOMParser();
        }
    }
    /**
     * @protected
     * @param {?} userId
     * @return {?}
     */
    getCartEndpoint(userId) {
        /** @type {?} */
        const cartEndpoint = 'users/' + userId + '/carts/';
        return this.occEndpoints.getEndpoint(cartEndpoint);
    }
    /**
     * @param {?} userId
     * @param {?} cartId
     * @param {?} paymentDetails
     * @return {?}
     */
    create(userId, cartId, paymentDetails) {
        paymentDetails = this.converter.convert(paymentDetails, PAYMENT_DETAILS_SERIALIZER);
        return this.getProviderSubInfo(userId, cartId).pipe(map((/**
         * @param {?} data
         * @return {?}
         */
        data => {
            /** @type {?} */
            const labelsMap = this.convertToMap(data.mappingLabels.entry);
            return {
                url: data.postUrl,
                parameters: this.getParamsForPaymentProvider(paymentDetails, data.parameters.entry, labelsMap),
                mappingLabels: labelsMap,
            };
        })), mergeMap((/**
         * @param {?} sub
         * @return {?}
         */
        sub => {
            // create a subscription directly with payment provider
            return this.createSubWithProvider(sub.url, sub.parameters).pipe(map((/**
             * @param {?} response
             * @return {?}
             */
            response => this.extractPaymentDetailsFromHtml(response))), mergeMap((/**
             * @param {?} fromPaymentProvider
             * @return {?}
             */
            fromPaymentProvider => {
                fromPaymentProvider['defaultPayment'] =
                    paymentDetails.defaultPayment;
                fromPaymentProvider['savePaymentInfo'] = true;
                return this.createDetailsWithParameters(userId, cartId, fromPaymentProvider).pipe(this.converter.pipeable(PAYMENT_DETAILS_NORMALIZER));
            })));
        })));
    }
    /**
     * @param {?} userId
     * @param {?} cartId
     * @param {?} paymentDetailsId
     * @return {?}
     */
    set(userId, cartId, paymentDetailsId) {
        return this.http.put(this.getCartEndpoint(userId) + cartId + '/paymentdetails', {}, {
            params: { paymentDetailsId: paymentDetailsId },
        });
    }
    /**
     * @return {?}
     */
    loadCardTypes() {
        return this.http
            .get(this.occEndpoints.getEndpoint(ENDPOINT_CARD_TYPES))
            .pipe(map((/**
         * @param {?} cardTypeList
         * @return {?}
         */
        cardTypeList => cardTypeList.cardTypes)), this.converter.pipeableMany(CARD_TYPE_NORMALIZER));
    }
    /**
     * @protected
     * @param {?} userId
     * @param {?} cartId
     * @return {?}
     */
    getProviderSubInfo(userId, cartId) {
        return this.http.get(this.getCartEndpoint(userId) +
            cartId +
            '/payment/sop/request?responseUrl=sampleUrl');
    }
    /**
     * @protected
     * @param {?} postUrl
     * @param {?} parameters
     * @return {?}
     */
    createSubWithProvider(postUrl, parameters) {
        /** @type {?} */
        const headers = new HttpHeaders({
            'Content-Type': 'application/x-www-form-urlencoded',
            Accept: 'text/html',
        });
        /** @type {?} */
        let httpParams = new HttpParams({ encoder: new CustomEncoder() });
        Object.keys(parameters).forEach((/**
         * @param {?} key
         * @return {?}
         */
        key => {
            httpParams = httpParams.append(key, parameters[key]);
        }));
        return this.http.post(postUrl, httpParams, {
            headers,
            responseType: 'text',
        });
    }
    /**
     * @protected
     * @param {?} userId
     * @param {?} cartId
     * @param {?} parameters
     * @return {?}
     */
    createDetailsWithParameters(userId, cartId, parameters) {
        /** @type {?} */
        let httpParams = new HttpParams({ encoder: new CustomEncoder() });
        Object.keys(parameters).forEach((/**
         * @param {?} key
         * @return {?}
         */
        key => {
            httpParams = httpParams.append(key, parameters[key]);
        }));
        /** @type {?} */
        const headers = new HttpHeaders({
            'Content-Type': 'application/x-www-form-urlencoded',
        });
        return this.http.post(this.getCartEndpoint(userId) + cartId + '/payment/sop/response', httpParams, { headers });
    }
    /**
     * @private
     * @param {?} paymentDetails
     * @param {?} parameters
     * @param {?} mappingLabels
     * @return {?}
     */
    getParamsForPaymentProvider(paymentDetails, parameters, mappingLabels) {
        /** @type {?} */
        const params = this.convertToMap(parameters);
        params[mappingLabels['hybris_account_holder_name']] =
            paymentDetails.accountHolderName;
        params[mappingLabels['hybris_card_type']] = paymentDetails.cardType.code;
        params[mappingLabels['hybris_card_number']] = paymentDetails.cardNumber;
        if (mappingLabels['hybris_combined_expiry_date'] === 'true') {
            params[mappingLabels['hybris_card_expiry_date']] =
                paymentDetails.expiryMonth +
                    mappingLabels['hybris_separator_expiry_date'] +
                    paymentDetails.expiryYear;
        }
        else {
            params[mappingLabels['hybris_card_expiration_month']] =
                paymentDetails.expiryMonth;
            params[mappingLabels['hybris_card_expiration_year']] =
                paymentDetails.expiryYear;
        }
        params[mappingLabels['hybris_card_cvn']] = paymentDetails.cvn;
        // billing address
        params[mappingLabels['hybris_billTo_country']] =
            paymentDetails.billingAddress.country.isocode;
        params[mappingLabels['hybris_billTo_firstname']] =
            paymentDetails.billingAddress.firstName;
        params[mappingLabels['hybris_billTo_lastname']] =
            paymentDetails.billingAddress.lastName;
        params[mappingLabels['hybris_billTo_street1']] =
            paymentDetails.billingAddress.line1 +
                ' ' +
                paymentDetails.billingAddress.line2;
        params[mappingLabels['hybris_billTo_city']] =
            paymentDetails.billingAddress.town;
        if (paymentDetails.billingAddress.region) {
            params[mappingLabels['hybris_billTo_region']] =
                paymentDetails.billingAddress.region.isocodeShort;
        }
        else {
            params[mappingLabels['hybris_billTo_region']] = '';
        }
        params[mappingLabels['hybris_billTo_postalcode']] =
            paymentDetails.billingAddress.postalCode;
        return params;
    }
    /**
     * @private
     * @param {?} html
     * @return {?}
     */
    extractPaymentDetailsFromHtml(html) {
        /** @type {?} */
        const domdoc = this.domparser.parseFromString(html, 'text/xml');
        /** @type {?} */
        const responseForm = domdoc.getElementsByTagName('form')[0];
        /** @type {?} */
        const inputs = responseForm.getElementsByTagName('input');
        /** @type {?} */
        const values = {};
        for (let i = 0; inputs[i]; i++) {
            /** @type {?} */
            const input = inputs[i];
            if (input.getAttribute('name') !== '{}' &&
                input.getAttribute('value') !== '') {
                values[input.getAttribute('name')] = input.getAttribute('value');
            }
        }
        return values;
    }
    /**
     * @private
     * @param {?} paramList
     * @return {?}
     */
    convertToMap(paramList) {
        return paramList.reduce((/**
         * @param {?} result
         * @param {?} item
         * @return {?}
         */
        function (result, item) {
            /** @type {?} */
            const key = item.key;
            result[key] = item.value;
            return result;
        }), {});
    }
}
OccCheckoutPaymentAdapter.decorators = [
    { type: Injectable }
];
/** @nocollapse */
OccCheckoutPaymentAdapter.ctorParameters = () => [
    { type: HttpClient },
    { type: OccEndpointsService },
    { type: ConverterService }
];
if (false) {
    /**
     * @type {?}
     * @private
     */
    OccCheckoutPaymentAdapter.prototype.domparser;
    /**
     * @type {?}
     * @protected
     */
    OccCheckoutPaymentAdapter.prototype.http;
    /**
     * @type {?}
     * @protected
     */
    OccCheckoutPaymentAdapter.prototype.occEndpoints;
    /**
     * @type {?}
     * @protected
     */
    OccCheckoutPaymentAdapter.prototype.converter;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @abstract
 */
class CheckoutAdapter {
}
if (false) {
    /**
     * Abstract method used to place an order.
     *
     * @abstract
     * @param {?} userId The `userId` for given user
     * @param {?} cartId The `cartId` for cart used for placing order
     * @return {?}
     */
    CheckoutAdapter.prototype.placeOrder = function (userId, cartId) { };
    /**
     * Abstract method used to load checkout details
     *
     * @abstract
     * @param {?} userId
     * @param {?} cartId
     * @return {?}
     */
    CheckoutAdapter.prototype.loadCheckoutDetails = function (userId, cartId) { };
    /**
     * Abstract method used to clear checkout delivery address
     *
     * @abstract
     * @param {?} userId
     * @param {?} cartId
     * @return {?}
     */
    CheckoutAdapter.prototype.clearCheckoutDeliveryAddress = function (userId, cartId) { };
    /**
     * Abstract method used to clear checkout delivery mode
     *
     * @abstract
     * @param {?} userId
     * @param {?} cartId
     * @return {?}
     */
    CheckoutAdapter.prototype.clearCheckoutDeliveryMode = function (userId, cartId) { };
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class OccOrderNormalizer {
    /**
     * @param {?} converter
     */
    constructor(converter) {
        this.converter = converter;
    }
    /**
     * @param {?} source
     * @param {?=} target
     * @return {?}
     */
    convert(source, target) {
        if (target === undefined) {
            target = Object.assign({}, ((/** @type {?} */ (source))));
        }
        if (source.entries) {
            target.entries = source.entries.map((/**
             * @param {?} entry
             * @return {?}
             */
            entry => this.convertOrderEntry(entry)));
        }
        if (source.consignments) {
            target.consignments = source.consignments.map((/**
             * @param {?} consignment
             * @return {?}
             */
            consignment => (Object.assign({}, consignment, { entries: consignment.entries.map((/**
                 * @param {?} entry
                 * @return {?}
                 */
                entry => (Object.assign({}, entry, { orderEntry: this.convertOrderEntry(entry.orderEntry) })))) }))));
        }
        if (source.unconsignedEntries) {
            target.unconsignedEntries = source.unconsignedEntries.map((/**
             * @param {?} entry
             * @return {?}
             */
            entry => this.convertOrderEntry(entry)));
        }
        return target;
    }
    /**
     * @private
     * @param {?} source
     * @return {?}
     */
    convertOrderEntry(source) {
        return Object.assign({}, source, { product: this.converter.convert(source.product, PRODUCT_NORMALIZER) });
    }
}
OccOrderNormalizer.decorators = [
    { type: Injectable, args: [{ providedIn: 'root' },] }
];
/** @nocollapse */
OccOrderNormalizer.ctorParameters = () => [
    { type: ConverterService }
];
/** @nocollapse */ OccOrderNormalizer.ngInjectableDef = ɵɵdefineInjectable({ factory: function OccOrderNormalizer_Factory() { return new OccOrderNormalizer(ɵɵinject(ConverterService)); }, token: OccOrderNormalizer, providedIn: "root" });
if (false) {
    /**
     * @type {?}
     * @private
     */
    OccOrderNormalizer.prototype.converter;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @abstract
 */
class CheckoutDeliveryAdapter {
}
if (false) {
    /**
     * Abstract method used to create address in cart
     *
     * @abstract
     * @param {?} userId
     * @param {?} cartId
     * @param {?} address
     * @return {?}
     */
    CheckoutDeliveryAdapter.prototype.createAddress = function (userId, cartId, address) { };
    /**
     * Abstract method used to set adress for delivery
     *
     * @abstract
     * @param {?} userId
     * @param {?} cartId
     * @param {?} addressId
     * @return {?}
     */
    CheckoutDeliveryAdapter.prototype.setAddress = function (userId, cartId, addressId) { };
    /**
     * Abstract method used to set delivery mode on cart
     *
     * @abstract
     * @param {?} userId
     * @param {?} cartId
     * @param {?} deliveryModeId
     * @return {?}
     */
    CheckoutDeliveryAdapter.prototype.setMode = function (userId, cartId, deliveryModeId) { };
    /**
     * Abstract method used to get current delivery mode from cart
     *
     * @abstract
     * @param {?} userId
     * @param {?} cartId
     * @return {?}
     */
    CheckoutDeliveryAdapter.prototype.getMode = function (userId, cartId) { };
    /**
     * Abstract method used to get supported delivery modes for cart
     *
     * @abstract
     * @param {?} userId
     * @param {?} cartId
     * @return {?}
     */
    CheckoutDeliveryAdapter.prototype.getSupportedModes = function (userId, cartId) { };
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @abstract
 */
class CheckoutPaymentAdapter {
}
if (false) {
    /**
     * Abstract method used to create payment details on cart
     *
     * @abstract
     * @param {?} userId
     * @param {?} cartId
     * @param {?} paymentDetails
     * @return {?}
     */
    CheckoutPaymentAdapter.prototype.create = function (userId, cartId, paymentDetails) { };
    /**
     * Abstract method used to set payment details on cart
     *
     * @abstract
     * @param {?} userId
     * @param {?} cartId
     * @param {?} paymentDetailsId
     * @return {?}
     */
    CheckoutPaymentAdapter.prototype.set = function (userId, cartId, paymentDetailsId) { };
    /**
     * Abstract method used to get available cart types
     * @abstract
     * @return {?}
     */
    CheckoutPaymentAdapter.prototype.loadCardTypes = function () { };
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class CheckoutOccModule {
}
CheckoutOccModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule, HttpClientModule],
                providers: [
                    {
                        provide: CheckoutAdapter,
                        useClass: OccCheckoutAdapter,
                    },
                    { provide: ORDER_NORMALIZER, useExisting: OccOrderNormalizer, multi: true },
                    {
                        provide: CheckoutDeliveryAdapter,
                        useClass: OccCheckoutDeliveryAdapter,
                    },
                    {
                        provide: CheckoutPaymentAdapter,
                        useClass: OccCheckoutPaymentAdapter,
                    },
                ],
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const CMS_PAGE_NORMALIZER = new InjectionToken('CmsPageNormalizer');

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class OccCmsPageAdapter {
    /**
     * @param {?} http
     * @param {?} occEndpoints
     * @param {?} converter
     */
    constructor(http, occEndpoints, converter) {
        this.http = http;
        this.occEndpoints = occEndpoints;
        this.converter = converter;
        this.headers = new HttpHeaders().set('Content-Type', 'application/json');
    }
    /**
     * @param {?} pageContext
     * @param {?=} fields
     * @return {?}
     */
    load(pageContext, fields) {
        // load page by Id
        if (pageContext.type === undefined) {
            return this.http
                .get(this.occEndpoints.getUrl('page', {
                id: pageContext.id,
            }, { fields: fields ? fields : 'DEFAULT' }), {
                headers: this.headers,
            })
                .pipe(this.converter.pipeable(CMS_PAGE_NORMALIZER));
        }
        // load page by PageContext
        /** @type {?} */
        const httpParams = this.getPagesRequestParams(pageContext);
        return this.http
            .get(this.getPagesEndpoint(httpParams, fields), {
            headers: this.headers,
        })
            .pipe(this.converter.pipeable(CMS_PAGE_NORMALIZER));
    }
    /**
     * @private
     * @param {?} params
     * @param {?=} fields
     * @return {?}
     */
    getPagesEndpoint(params, fields) {
        fields = fields ? fields : 'DEFAULT';
        return this.occEndpoints.getUrl('pages', {}, Object.assign({ fields }, params));
    }
    /**
     * @private
     * @param {?} pageContext
     * @return {?}
     */
    getPagesRequestParams(pageContext) {
        /** @type {?} */
        let httpParams = {};
        // smartedit preview page is loaded by previewToken which added by interceptor
        if (pageContext.id !== 'smartedit-preview') {
            httpParams = { pageType: pageContext.type };
            if (pageContext.type === PageType.CONTENT_PAGE) {
                httpParams['pageLabelOrId'] = pageContext.id;
            }
            else {
                httpParams['code'] = pageContext.id;
            }
        }
        return httpParams;
    }
}
OccCmsPageAdapter.decorators = [
    { type: Injectable }
];
/** @nocollapse */
OccCmsPageAdapter.ctorParameters = () => [
    { type: HttpClient },
    { type: OccEndpointsService },
    { type: ConverterService }
];
if (false) {
    /**
     * @type {?}
     * @protected
     */
    OccCmsPageAdapter.prototype.headers;
    /**
     * @type {?}
     * @private
     */
    OccCmsPageAdapter.prototype.http;
    /**
     * @type {?}
     * @private
     */
    OccCmsPageAdapter.prototype.occEndpoints;
    /**
     * @type {?}
     * @protected
     */
    OccCmsPageAdapter.prototype.converter;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const CMS_COMPONENT_NORMALIZER = new InjectionToken('CmsComponentNormalizer');

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class OccCmsComponentAdapter {
    /**
     * @param {?} http
     * @param {?} occEndpoints
     * @param {?} converter
     */
    constructor(http, occEndpoints, converter) {
        this.http = http;
        this.occEndpoints = occEndpoints;
        this.converter = converter;
        this.headers = new HttpHeaders().set('Content-Type', 'application/json');
    }
    /**
     * @template T
     * @param {?} id
     * @param {?} pageContext
     * @return {?}
     */
    load(id, pageContext) {
        return this.http
            .get(this.getComponentEndPoint(id, pageContext), {
            headers: this.headers,
        })
            .pipe(this.converter.pipeable(CMS_COMPONENT_NORMALIZER));
    }
    /**
     * @param {?} ids
     * @param {?} pageContext
     * @param {?=} fields
     * @param {?=} currentPage
     * @param {?=} pageSize
     * @param {?=} sort
     * @return {?}
     */
    findComponentsByIds(ids, pageContext, fields = 'DEFAULT', currentPage = 0, pageSize = ids.length, sort) {
        /** @type {?} */
        const requestParams = Object.assign({}, this.getContextParams(pageContext), this.getPaginationParams(currentPage, pageSize, sort));
        requestParams['componentIds'] = ids.toString();
        return this.http
            .get(this.getComponentsEndpoint(requestParams, fields), {
            headers: this.headers,
        })
            .pipe(pluck('component'), this.converter.pipeableMany(CMS_COMPONENT_NORMALIZER));
    }
    /**
     * @param {?} ids
     * @param {?} pageContext
     * @param {?=} fields
     * @param {?=} currentPage
     * @param {?=} pageSize
     * @param {?=} sort
     * @return {?}
     */
    findComponentsByIdsLegacy(ids, pageContext, fields = 'DEFAULT', currentPage = 0, pageSize = ids.length, sort) {
        /** @type {?} */
        const idList = { idList: ids };
        /** @type {?} */
        const requestParams = Object.assign({}, this.getContextParams(pageContext), this.getPaginationParams(currentPage, pageSize, sort));
        return this.http
            .post(this.getComponentsEndpoint(requestParams, fields), idList, {
            headers: this.headers,
        })
            .pipe(pluck('component'), this.converter.pipeableMany(CMS_COMPONENT_NORMALIZER));
    }
    /**
     * @protected
     * @param {?} id
     * @param {?} pageContext
     * @return {?}
     */
    getComponentEndPoint(id, pageContext) {
        return this.occEndpoints.getUrl('component', { id }, this.getContextParams(pageContext));
    }
    /**
     * @protected
     * @param {?} requestParams
     * @param {?} fields
     * @return {?}
     */
    getComponentsEndpoint(requestParams, fields) {
        return this.occEndpoints.getUrl('components', {}, Object.assign({ fields }, requestParams));
    }
    /**
     * @private
     * @param {?=} currentPage
     * @param {?=} pageSize
     * @param {?=} sort
     * @return {?}
     */
    getPaginationParams(currentPage, pageSize, sort) {
        /** @type {?} */
        const requestParams = {};
        if (currentPage !== undefined) {
            requestParams['currentPage'] = currentPage.toString();
        }
        if (pageSize !== undefined) {
            requestParams['pageSize'] = pageSize.toString();
        }
        if (sort !== undefined) {
            requestParams['sort'] = sort;
        }
        return requestParams;
    }
    /**
     * @private
     * @param {?} pageContext
     * @return {?}
     */
    getContextParams(pageContext) {
        /** @type {?} */
        let requestParams = {};
        switch (pageContext.type) {
            case PageType.PRODUCT_PAGE: {
                requestParams = { productCode: pageContext.id };
                break;
            }
            case PageType.CATEGORY_PAGE: {
                requestParams = { categoryCode: pageContext.id };
                break;
            }
            case PageType.CATALOG_PAGE: {
                requestParams = { catalogCode: pageContext.id };
                break;
            }
        }
        return requestParams;
    }
}
OccCmsComponentAdapter.decorators = [
    { type: Injectable }
];
/** @nocollapse */
OccCmsComponentAdapter.ctorParameters = () => [
    { type: HttpClient },
    { type: OccEndpointsService },
    { type: ConverterService }
];
if (false) {
    /**
     * @type {?}
     * @protected
     */
    OccCmsComponentAdapter.prototype.headers;
    /**
     * @type {?}
     * @private
     */
    OccCmsComponentAdapter.prototype.http;
    /**
     * @type {?}
     * @private
     */
    OccCmsComponentAdapter.prototype.occEndpoints;
    /**
     * @type {?}
     * @protected
     */
    OccCmsComponentAdapter.prototype.converter;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @record
 */
function StandardCmsComponentConfig() { }
if (false) {
    /** @type {?|undefined} */
    StandardCmsComponentConfig.prototype.CMSSiteContextComponent;
    /** @type {?|undefined} */
    StandardCmsComponentConfig.prototype.CMSLinkComponent;
    /** @type {?|undefined} */
    StandardCmsComponentConfig.prototype.SimpleResponsiveBannerComponent;
    /** @type {?|undefined} */
    StandardCmsComponentConfig.prototype.SimpleBannerComponent;
    /** @type {?|undefined} */
    StandardCmsComponentConfig.prototype.BannerComponent;
    /** @type {?|undefined} */
    StandardCmsComponentConfig.prototype.CMSParagraphComponent;
    /** @type {?|undefined} */
    StandardCmsComponentConfig.prototype.BreadcrumbComponent;
    /** @type {?|undefined} */
    StandardCmsComponentConfig.prototype.NavigationComponent;
    /** @type {?|undefined} */
    StandardCmsComponentConfig.prototype.FooterNavigationComponent;
    /** @type {?|undefined} */
    StandardCmsComponentConfig.prototype.CategoryNavigationComponent;
    /** @type {?|undefined} */
    StandardCmsComponentConfig.prototype.ProductAddToCartComponent;
    /** @type {?|undefined} */
    StandardCmsComponentConfig.prototype.MiniCartComponent;
    /** @type {?|undefined} */
    StandardCmsComponentConfig.prototype.ProductCarouselComponent;
    /** @type {?|undefined} */
    StandardCmsComponentConfig.prototype.SearchBoxComponent;
    /** @type {?|undefined} */
    StandardCmsComponentConfig.prototype.ProductReferencesComponent;
    /** @type {?|undefined} */
    StandardCmsComponentConfig.prototype.CMSTabParagraphComponent;
    /** @type {?|undefined} */
    StandardCmsComponentConfig.prototype.LoginComponent;
}
/**
 * @record
 */
function JspIncludeCmsComponentConfig() { }
if (false) {
    /** @type {?|undefined} */
    JspIncludeCmsComponentConfig.prototype.AccountAddressBookComponent;
    /** @type {?|undefined} */
    JspIncludeCmsComponentConfig.prototype.ForgotPasswordComponent;
    /** @type {?|undefined} */
    JspIncludeCmsComponentConfig.prototype.ResetPasswordComponent;
    /** @type {?|undefined} */
    JspIncludeCmsComponentConfig.prototype.ProductDetailsTabComponent;
    /** @type {?|undefined} */
    JspIncludeCmsComponentConfig.prototype.ProductSpecsTabComponent;
    /** @type {?|undefined} */
    JspIncludeCmsComponentConfig.prototype.ProductReviewsTabComponent;
}
/** @type {?} */
const JSP_INCLUDE_CMS_COMPONENT_TYPE = 'JspIncludeComponent';
/** @type {?} */
const CMS_FLEX_COMPONENT_TYPE = 'CMSFlexComponent';
/**
 * @record
 */
function CmsComponentMapping() { }
if (false) {
    /** @type {?|undefined} */
    CmsComponentMapping.prototype.component;
    /** @type {?|undefined} */
    CmsComponentMapping.prototype.providers;
    /** @type {?|undefined} */
    CmsComponentMapping.prototype.childRoutes;
    /** @type {?|undefined} */
    CmsComponentMapping.prototype.disableSSR;
    /** @type {?|undefined} */
    CmsComponentMapping.prototype.i18nKeys;
    /** @type {?|undefined} */
    CmsComponentMapping.prototype.guards;
    /**
     * DeferLoading can be specified globally, but also per component.
     * Some components require direct loading while it's not initially
     * in the viewport.
     * @type {?|undefined}
     */
    CmsComponentMapping.prototype.deferLoading;
}
/** @enum {string} */
const DeferLoadingStrategy = {
    /** Defers loading of DOM elements until element is near/in the users view port */
    DEFER: 'DEFERRED-LOADING',
    /** Renders the DOM instantly without being concerned with the view port */
    INSTANT: 'INSTANT-LOADING',
};
/**
 * @record
 */
function CMSComponentConfig() { }
/**
 * @abstract
 */
class CmsConfig extends OccConfig {
}
if (false) {
    /** @type {?} */
    CmsConfig.prototype.authentication;
    /** @type {?} */
    CmsConfig.prototype.cmsComponents;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class OccCmsPageNormalizer {
    /**
     * @param {?} source
     * @param {?=} target
     * @return {?}
     */
    convert(source, target = {}) {
        this.normalizePageData(source, target);
        this.normalizePageSlotData(source, target);
        this.normalizePageComponentData(source, target);
        this.normalizeComponentData(source, target);
        return target;
    }
    /**
     * @private
     * @param {?} source
     * @param {?} target
     * @return {?}
     */
    normalizePageData(source, target) {
        target.page = {
            loadTime: Date.now(),
            name: source.name,
            type: source.typeCode,
            title: source.title,
            pageId: source.uid,
            template: source.template,
            slots: {},
            properties: source.properties,
            label: source.label,
        };
    }
    /**
     * @private
     * @param {?} source
     * @param {?} target
     * @return {?}
     */
    normalizePageSlotData(source, target) {
        for (const slot of source.contentSlots.contentSlot) {
            target.page.slots[slot.position] = (/** @type {?} */ ({
                components: [],
                properties: slot.properties,
            }));
        }
    }
    /**
     * @private
     * @param {?} source
     * @param {?} target
     * @return {?}
     */
    normalizePageComponentData(source, target) {
        for (const slot of source.contentSlots.contentSlot) {
            if (slot.components.component &&
                Array.isArray(slot.components.component)) {
                for (const component of slot.components.component) {
                    /** @type {?} */
                    const comp = {
                        uid: component.uid,
                        typeCode: component.typeCode,
                        properties: component.properties,
                    };
                    if (component.typeCode === CMS_FLEX_COMPONENT_TYPE) {
                        comp.flexType = component.flexType;
                    }
                    else if (component.typeCode === JSP_INCLUDE_CMS_COMPONENT_TYPE) {
                        comp.flexType = component.uid;
                    }
                    else {
                        comp.flexType = component.typeCode;
                    }
                    target.page.slots[slot.position].components.push(comp);
                }
            }
        }
    }
    /**
     * @private
     * @param {?} source
     * @param {?} target
     * @return {?}
     */
    normalizeComponentData(source, target) {
        target.components = [];
        for (const slot of source.contentSlots.contentSlot) {
            if (slot.components.component &&
                Array.isArray(slot.components.component)) {
                for (const component of (/** @type {?} */ (slot.components.component))) {
                    // we dont put properties into component state
                    if (component.properties) {
                        component.properties = undefined;
                    }
                    target.components.push(component);
                }
            }
        }
    }
}
OccCmsPageNormalizer.decorators = [
    { type: Injectable, args: [{ providedIn: 'root' },] }
];
/** @nocollapse */ OccCmsPageNormalizer.ngInjectableDef = ɵɵdefineInjectable({ factory: function OccCmsPageNormalizer_Factory() { return new OccCmsPageNormalizer(); }, token: OccCmsPageNormalizer, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Abstract class that can be used to implement custom loader logic
 * in order to load CMS structure from third-party CMS system.
 * @abstract
 */
class CmsPageAdapter {
}
if (false) {
    /**
     * Abstract method must be used to load the page structure for a given `PageContext`.
     * The page can be loaded from alternative sources, as long as the structure
     * converts to the `CmsStructureModel`.
     *
     * @abstract
     * @param {?} pageContext The `PageContext` holding the page Id.
     * @return {?}
     */
    CmsPageAdapter.prototype.load = function (pageContext) { };
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @abstract
 */
class CmsComponentAdapter {
}
if (false) {
    /**
     * Abstract method must be used to load the component for a given `id` and `PageContext`.
     * The component can be loaded from alternative backend, as long as the structure
     * converts to the `CmsStructureModel`.
     *
     * @abstract
     * @template T
     * @param {?} id
     * @param {?} pageContext The `PageContext` holding the page Id.
     * @param {?=} fields
     * @return {?}
     */
    CmsComponentAdapter.prototype.load = function (id, pageContext, fields) { };
    /**
     * @abstract
     * @param {?} ids
     * @param {?} pageContext
     * @return {?}
     */
    CmsComponentAdapter.prototype.findComponentsByIds = function (ids, pageContext) { };
    /**
     * @abstract
     * @param {?} ids
     * @param {?} pageContext
     * @return {?}
     */
    CmsComponentAdapter.prototype.findComponentsByIdsLegacy = function (ids, pageContext) { };
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class CmsOccModule {
}
CmsOccModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule, HttpClientModule],
                providers: [
                    {
                        provide: CmsPageAdapter,
                        useClass: OccCmsPageAdapter,
                    },
                    {
                        provide: CMS_PAGE_NORMALIZER,
                        useExisting: OccCmsPageNormalizer,
                        multi: true,
                    },
                    {
                        provide: CmsComponentAdapter,
                        useClass: OccCmsComponentAdapter,
                    },
                ],
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ProductImageNormalizer {
    /**
     * @param {?} config
     */
    constructor(config) {
        this.config = config;
    }
    /**
     * @param {?} source
     * @param {?=} target
     * @return {?}
     */
    convert(source, target) {
        if (target === undefined) {
            target = Object.assign({}, ((/** @type {?} */ (source))));
        }
        if (source.images) {
            target.images = this.normalize(source.images);
        }
        return target;
    }
    /**
     * @desc
     * Creates the image structure we'd like to have. Instead of
     * having a single list with all images despite type and format
     * we create a proper structure. With that we can do:
     * - images.primary.thumnail.url
     * - images.GALLERY[0].thumnail.url
     * @param {?} source
     * @return {?}
     */
    normalize(source) {
        /** @type {?} */
        const images = {};
        if (source) {
            for (const image of source) {
                /** @type {?} */
                const isList = image.hasOwnProperty('galleryIndex');
                if (!images.hasOwnProperty(image.imageType)) {
                    images[image.imageType] = isList ? [] : {};
                }
                /** @type {?} */
                let imageContainer;
                if (isList && !images[image.imageType][image.galleryIndex]) {
                    images[image.imageType][image.galleryIndex] = {};
                }
                if (isList) {
                    imageContainer = images[image.imageType][image.galleryIndex];
                }
                else {
                    imageContainer = images[image.imageType];
                }
                /** @type {?} */
                const targetImage = Object.assign({}, image);
                targetImage.url = this.normalizeImageUrl(targetImage.url);
                imageContainer[image.format] = targetImage;
            }
        }
        return images;
    }
    /**
     * Traditionally, in an on-prem world, medias and other backend related calls
     * are hosted at the same platform, but in a cloud setup, applications are are
     * typically distributed cross different environments. For media, we use the
     * `backend.media.baseUrl` by default, but fallback to `backend.occ.baseUrl`
     * if none provided.
     * @private
     * @param {?} url
     * @return {?}
     */
    normalizeImageUrl(url) {
        if (new RegExp(/^(http|data:image|\/\/)/i).test(url)) {
            return url;
        }
        return ((this.config.backend.media.baseUrl ||
            this.config.backend.occ.baseUrl ||
            '') + url);
    }
}
ProductImageNormalizer.decorators = [
    { type: Injectable, args: [{ providedIn: 'root' },] }
];
/** @nocollapse */
ProductImageNormalizer.ctorParameters = () => [
    { type: OccConfig }
];
/** @nocollapse */ ProductImageNormalizer.ngInjectableDef = ɵɵdefineInjectable({ factory: function ProductImageNormalizer_Factory() { return new ProductImageNormalizer(ɵɵinject(OccConfig)); }, token: ProductImageNormalizer, providedIn: "root" });
if (false) {
    /**
     * @type {?}
     * @protected
     */
    ProductImageNormalizer.prototype.config;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ProductReferenceNormalizer {
    /**
     * @param {?} source
     * @param {?=} target
     * @return {?}
     */
    convert(source, target) {
        if (target === undefined) {
            target = Object.assign({}, ((/** @type {?} */ (source))));
        }
        if (source.productReferences) {
            target.productReferences = this.normalize(source.productReferences);
        }
        return target;
    }
    /**
     * @desc
     * Creates the reference structure we'd like to have. Instead of
     * having a single list with all references we create a proper structure.
     * With that we have a semantic API for the clients
     * - product.references.SIMILAR[0].code
     * @protected
     * @param {?} source
     * @return {?}
     */
    normalize(source) {
        /** @type {?} */
        const references = {};
        if (source) {
            for (const reference of source) {
                if (!references.hasOwnProperty(reference.referenceType)) {
                    references[reference.referenceType] = [];
                }
                references[reference.referenceType].push(reference);
            }
        }
        return references;
    }
}
ProductReferenceNormalizer.decorators = [
    { type: Injectable }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class OccProductSearchPageNormalizer {
    /**
     * @param {?} converterService
     */
    constructor(converterService) {
        this.converterService = converterService;
    }
    /**
     * @param {?} source
     * @param {?=} target
     * @return {?}
     */
    convert(source, target = {}) {
        target = Object.assign({}, target, ((/** @type {?} */ (source))));
        if (source.products) {
            target.products = source.products.map((/**
             * @param {?} product
             * @return {?}
             */
            product => this.converterService.convert(product, PRODUCT_NORMALIZER)));
        }
        return target;
    }
}
OccProductSearchPageNormalizer.decorators = [
    { type: Injectable, args: [{ providedIn: 'root' },] }
];
/** @nocollapse */
OccProductSearchPageNormalizer.ctorParameters = () => [
    { type: ConverterService }
];
/** @nocollapse */ OccProductSearchPageNormalizer.ngInjectableDef = ɵɵdefineInjectable({ factory: function OccProductSearchPageNormalizer_Factory() { return new OccProductSearchPageNormalizer(ɵɵinject(ConverterService)); }, token: OccProductSearchPageNormalizer, providedIn: "root" });
if (false) {
    /**
     * @type {?}
     * @private
     */
    OccProductSearchPageNormalizer.prototype.converterService;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class OccProductReferencesListNormalizer {
    /**
     * @param {?} converter
     */
    constructor(converter) {
        this.converter = converter;
    }
    /**
     * @param {?} source
     * @param {?=} target
     * @return {?}
     */
    convert(source, target = []) {
        if (target === undefined) {
            target = Object.assign({}, ((/** @type {?} */ (source))));
        }
        if (source && source.references) {
            target = source.references.map((/**
             * @param {?} reference
             * @return {?}
             */
            reference => (Object.assign({}, reference, { target: this.converter.convert(reference.target, PRODUCT_NORMALIZER) }))));
            return target;
        }
    }
}
OccProductReferencesListNormalizer.decorators = [
    { type: Injectable, args: [{ providedIn: 'root' },] }
];
/** @nocollapse */
OccProductReferencesListNormalizer.ctorParameters = () => [
    { type: ConverterService }
];
/** @nocollapse */ OccProductReferencesListNormalizer.ngInjectableDef = ɵɵdefineInjectable({ factory: function OccProductReferencesListNormalizer_Factory() { return new OccProductReferencesListNormalizer(ɵɵinject(ConverterService)); }, token: OccProductReferencesListNormalizer, providedIn: "root" });
if (false) {
    /**
     * @type {?}
     * @private
     */
    OccProductReferencesListNormalizer.prototype.converter;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ProductNameNormalizer {
    /**
     * @param {?} config
     */
    constructor(config) {
        this.config = config;
    }
    /**
     * @param {?} source
     * @param {?=} target
     * @return {?}
     */
    convert(source, target) {
        if (target === undefined) {
            target = Object.assign({}, ((/** @type {?} */ (source))));
        }
        if (source.name) {
            target.name = this.normalize(source.name);
            target.nameHtml = source.name;
        }
        return target;
    }
    /**
     * @protected
     * @param {?} name
     * @return {?}
     */
    normalize(name) {
        return name.replace(/<[^>]*>/g, '');
    }
}
ProductNameNormalizer.decorators = [
    { type: Injectable, args: [{ providedIn: 'root' },] }
];
/** @nocollapse */
ProductNameNormalizer.ctorParameters = () => [
    { type: OccConfig }
];
/** @nocollapse */ ProductNameNormalizer.ngInjectableDef = ɵɵdefineInjectable({ factory: function ProductNameNormalizer_Factory() { return new ProductNameNormalizer(ɵɵinject(OccConfig)); }, token: ProductNameNormalizer, providedIn: "root" });
if (false) {
    /**
     * @type {?}
     * @protected
     */
    ProductNameNormalizer.prototype.config;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const PRODUCT_REFERENCES_NORMALIZER = new InjectionToken('ProductReferencesListNormalizer');

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class OccProductReferencesAdapter {
    /**
     * @param {?} http
     * @param {?} occEndpoints
     * @param {?} converter
     */
    constructor(http, occEndpoints, converter) {
        this.http = http;
        this.occEndpoints = occEndpoints;
        this.converter = converter;
    }
    /**
     * @param {?} productCode
     * @param {?=} referenceType
     * @param {?=} pageSize
     * @return {?}
     */
    load(productCode, referenceType, pageSize) {
        return this.http
            .get(this.getEndpoint(productCode, referenceType, pageSize))
            .pipe(this.converter.pipeable(PRODUCT_REFERENCES_NORMALIZER));
    }
    /**
     * @protected
     * @param {?} code
     * @param {?=} reference
     * @param {?=} pageSize
     * @return {?}
     */
    getEndpoint(code, reference, pageSize) {
        return this.occEndpoints.getUrl('productReferences', {
            productCode: code,
        }, { referenceType: reference, pageSize });
    }
}
OccProductReferencesAdapter.decorators = [
    { type: Injectable }
];
/** @nocollapse */
OccProductReferencesAdapter.ctorParameters = () => [
    { type: HttpClient },
    { type: OccEndpointsService },
    { type: ConverterService }
];
if (false) {
    /**
     * @type {?}
     * @protected
     */
    OccProductReferencesAdapter.prototype.http;
    /**
     * @type {?}
     * @protected
     */
    OccProductReferencesAdapter.prototype.occEndpoints;
    /**
     * @type {?}
     * @protected
     */
    OccProductReferencesAdapter.prototype.converter;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const PRODUCT_REVIEW_NORMALIZER = new InjectionToken('ProductReviewNormalizer');
/** @type {?} */
const PRODUCT_REVIEW_SERIALIZER = new InjectionToken('ProductReviewSerializer');

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class OccProductReviewsAdapter {
    /**
     * @param {?} http
     * @param {?} occEndpoints
     * @param {?} converter
     */
    constructor(http, occEndpoints, converter) {
        this.http = http;
        this.occEndpoints = occEndpoints;
        this.converter = converter;
    }
    /**
     * @param {?} productCode
     * @param {?=} maxCount
     * @return {?}
     */
    load(productCode, maxCount) {
        return this.http.get(this.getEndpoint(productCode, maxCount)).pipe(pluck('reviews'), this.converter.pipeableMany(PRODUCT_REVIEW_NORMALIZER));
    }
    /**
     * @param {?} productCode
     * @param {?} review
     * @return {?}
     */
    post(productCode, review) {
        review = this.converter.convert(review, PRODUCT_REVIEW_SERIALIZER);
        /** @type {?} */
        const headers = new HttpHeaders({
            'Content-Type': 'application/x-www-form-urlencoded',
        });
        /** @type {?} */
        const body = new URLSearchParams();
        body.append('headline', review.headline);
        body.append('comment', review.comment);
        body.append('rating', review.rating.toString());
        body.append('alias', review.alias);
        return this.http.post(this.getEndpoint(productCode), body.toString(), {
            headers,
        });
    }
    /**
     * @protected
     * @param {?} code
     * @param {?=} maxCount
     * @return {?}
     */
    getEndpoint(code, maxCount) {
        return this.occEndpoints.getUrl('productReviews', {
            productCode: code,
        }, { maxCount });
    }
}
OccProductReviewsAdapter.decorators = [
    { type: Injectable }
];
/** @nocollapse */
OccProductReviewsAdapter.ctorParameters = () => [
    { type: HttpClient },
    { type: OccEndpointsService },
    { type: ConverterService }
];
if (false) {
    /**
     * @type {?}
     * @protected
     */
    OccProductReviewsAdapter.prototype.http;
    /**
     * @type {?}
     * @protected
     */
    OccProductReviewsAdapter.prototype.occEndpoints;
    /**
     * @type {?}
     * @protected
     */
    OccProductReviewsAdapter.prototype.converter;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const PRODUCT_SEARCH_PAGE_NORMALIZER = new InjectionToken('ProductSearchPageNormalizer');
/** @type {?} */
const PRODUCT_SUGGESTION_NORMALIZER = new InjectionToken('ProductSuggestionNormalizer');

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const DEFAULT_SEARCH_CONFIG = {
    pageSize: 20,
};
class OccProductSearchAdapter {
    /**
     * @param {?} http
     * @param {?} occEndpoints
     * @param {?} converter
     */
    constructor(http, occEndpoints, converter) {
        this.http = http;
        this.occEndpoints = occEndpoints;
        this.converter = converter;
    }
    /**
     * @param {?} query
     * @param {?=} searchConfig
     * @return {?}
     */
    search(query, searchConfig = DEFAULT_SEARCH_CONFIG) {
        return this.http
            .get(this.getSearchEndpoint(query, searchConfig))
            .pipe(this.converter.pipeable(PRODUCT_SEARCH_PAGE_NORMALIZER));
    }
    /**
     * @param {?} term
     * @param {?=} pageSize
     * @return {?}
     */
    loadSuggestions(term, pageSize = 3) {
        return this.http
            .get(this.getSuggestionEndpoint(term, pageSize.toString()))
            .pipe(pluck('suggestions'), this.converter.pipeableMany(PRODUCT_SUGGESTION_NORMALIZER));
    }
    /**
     * @protected
     * @param {?} query
     * @param {?} searchConfig
     * @return {?}
     */
    getSearchEndpoint(query, searchConfig) {
        return this.occEndpoints.getUrl('productSearch', {}, {
            query,
            pageSize: searchConfig.pageSize,
            currentPage: searchConfig.currentPage,
            sort: searchConfig.sortCode,
        });
    }
    /**
     * @protected
     * @param {?} term
     * @param {?} max
     * @return {?}
     */
    getSuggestionEndpoint(term, max) {
        return this.occEndpoints.getUrl('productSuggestions', {}, { term, max });
    }
}
OccProductSearchAdapter.decorators = [
    { type: Injectable }
];
/** @nocollapse */
OccProductSearchAdapter.ctorParameters = () => [
    { type: HttpClient },
    { type: OccEndpointsService },
    { type: ConverterService }
];
if (false) {
    /**
     * @type {?}
     * @protected
     */
    OccProductSearchAdapter.prototype.http;
    /**
     * @type {?}
     * @protected
     */
    OccProductSearchAdapter.prototype.occEndpoints;
    /**
     * @type {?}
     * @protected
     */
    OccProductSearchAdapter.prototype.converter;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Merge occ fields parameters
 *
 * @param {?} fields Fields definition as string or object
 * @return {?}
 */
function mergeFields(fields) {
    /** @type {?} */
    const parsedFields = fields.map((/**
     * @param {?} f
     * @return {?}
     */
    f => typeof f === 'string' ? parseFields(f) : f));
    /** @type {?} */
    const mergedFields = optimizeFields(deepMerge({}, ...parsedFields));
    return stringifyFields(mergedFields);
}
/**
 * Optimize fields definition by removing not needed groups
 *
 * @param {?=} fields
 * @return {?}
 */
function optimizeFields(fields = {}) {
    /** @type {?} */
    const keys = Object.keys(fields);
    if (keys.includes('FULL')) {
        delete fields['DEFAULT'];
        delete fields['BASIC'];
    }
    else if (keys.includes('DEFAULT')) {
        delete fields['BASIC'];
    }
    Object.keys(fields).forEach((/**
     * @param {?} key
     * @return {?}
     */
    key => {
        fields[key] = optimizeFields(fields[key]);
    }));
    return fields;
}
/**
 * Parse string field definition to an AST object
 *
 * @param {?} fields Fields string definition
 * @param {?=} startIndex Used for recurrence
 * @return {?}
 */
function parseFields(fields, startIndex = 0) {
    /** @type {?} */
    const parsedFields = {};
    /** @type {?} */
    let i = startIndex;
    while (i < fields.length) {
        if (fields[i] === ',') {
            if (i > startIndex) {
                parsedFields[fields.substr(startIndex, i - startIndex)] = {};
            }
            startIndex = i + 1;
        }
        else if (fields[i] === '(') {
            /** @type {?} */
            const subFields = parseFields(fields, i + 1);
            if (Array.isArray(subFields)) {
                parsedFields[fields.substr(startIndex, i - startIndex)] = subFields[0];
                startIndex = subFields[1];
                i = startIndex - 1;
            }
            else {
                return parsedFields;
            }
        }
        else if (fields[i] === ')') {
            if (i > startIndex) {
                parsedFields[fields.substr(startIndex, i - startIndex)] = {};
            }
            return [parsedFields, i + 1];
        }
        i++;
    }
    if (startIndex < fields.length) {
        parsedFields[fields.substr(startIndex, i - startIndex)] = {};
    }
    return parsedFields;
}
/**
 * Convert AST object fields definition to string representation
 *
 * @param {?} fields
 * @return {?}
 */
function stringifyFields(fields) {
    return Object.keys(fields)
        .map((/**
     * @param {?} key
     * @return {?}
     */
    key => {
        /** @type {?} */
        const subFields = stringifyFields(fields[key]);
        return subFields ? `${key}(${subFields})` : key;
    }))
        .join(',');
}
/**
 * Extract part of the object described by fields definition
 *
 * @template T
 * @param {?} data
 * @param {?} fields
 * @return {?}
 */
function extractFields(data, fields) {
    /** @type {?} */
    const parsedFields = typeof fields === 'string' ? parseFields(fields) : fields;
    return getObjectPart(data, parsedFields);
}
/**
 * @template T
 * @param {?} data
 * @param {?} fields
 * @return {?}
 */
function getObjectPart(data, fields) {
    if (!isObject(data)) {
        return data;
    }
    /** @type {?} */
    const keys = Object.keys(fields);
    if (keys.length === 0 ||
        // we should not extract parts of the object with ambiguous fields definitions
        keys.find((/**
         * @param {?} el
         * @return {?}
         */
        el => el === 'BASIC' || el === 'DEFAULT' || el === 'FULL'))) {
        return data;
    }
    /** @type {?} */
    const result = (/** @type {?} */ ({}));
    keys.forEach((/**
     * @param {?} key
     * @return {?}
     */
    key => {
        if (data.hasOwnProperty(key)) {
            result[key] = getObjectPart(data[key], fields[key]);
        }
    }));
    return result;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @record
 */
function ScopedDataWithUrl() { }
if (false) {
    /**
     * Url (with fields) to load scoped data
     * @type {?|undefined}
     */
    ScopedDataWithUrl.prototype.url;
    /**
     * scoped data model
     * @type {?}
     */
    ScopedDataWithUrl.prototype.scopedData;
}
/**
 * Intermediate model to accommodate all data needed to perform occ fields optimizations
 * wrapping ScopedData with url and fields
 * @record
 */
function OccFieldsModel() { }
if (false) {
    /**
     * extracted fields object, used to extract data from broader model
     * @type {?|undefined}
     */
    OccFieldsModel.prototype.fields;
}
/**
 * Grouped rest calls with optimal urls
 *
 * One url groups all scopes it covers with related occFieldsModels
 * @record
 */
function OccOptimimalUrlGroups() { }
/**
 * Helper service for optimizing endpoint calls to occ backend
 */
class OccFieldsService {
    /**
     * @param {?} http
     */
    constructor(http) {
        this.http = http;
        this.FIELDS_PARAM = 'fields';
    }
    /**
     * Merge similar occ endpoints calls by merging fields parameter
     *
     * We assume that different scopes are defined by different fields parameters,
     * so we are grouping all requests with the same urls (except fields definition)
     * and merging into one request with fields that will satisfy all separate ones.
     *
     * @param {?} models
     * @return {?}
     */
    getOptimalUrlGroups(models) {
        /** @type {?} */
        const groupedByUrls = {};
        for (const model of (/** @type {?} */ (models))) {
            const [urlPart, fields] = this.splitFields(model.url);
            if (!groupedByUrls[urlPart]) {
                groupedByUrls[urlPart] = {};
            }
            model.fields = fields ? parseFields(fields) : {};
            groupedByUrls[urlPart][model.scopedData.scope] = model;
        }
        /** @type {?} */
        const mergedUrls = {};
        for (const [url, group] of Object.entries(groupedByUrls)) {
            /** @type {?} */
            const urlWithFields = this.getUrlWithFields(url, Object.values(group).map((/**
             * @param {?} lo
             * @return {?}
             */
            lo => lo.fields)));
            mergedUrls[urlWithFields] = group;
        }
        return mergedUrls;
    }
    /**
     * Extract fields parameter from occ endpoint url
     *
     * @private
     * @param {?} urlWithFields
     * @return {?}
     */
    splitFields(urlWithFields) {
        const [url, params] = urlWithFields.split('?');
        /** @type {?} */
        const paramsMap = {};
        if (params) {
            params.split('&').map((/**
             * @param {?} param
             * @return {?}
             */
            param => {
                /** @type {?} */
                const keyValue = param.split('=');
                paramsMap[keyValue[0]] = keyValue[1];
            }));
        }
        /** @type {?} */
        const nonFieldsParams = Object.keys(paramsMap)
            .sort()
            .reduce((/**
         * @param {?} id
         * @param {?} par
         * @return {?}
         */
        (id, par) => {
            if (par !== this.FIELDS_PARAM) {
                id.push(paramsMap[par] ? `${par}=${paramsMap[par]}` : par);
            }
            return id;
        }), []);
        /** @type {?} */
        const nonFields = nonFieldsParams.join('&');
        return [
            nonFields ? `${url}?${nonFields}` : url,
            paramsMap[this.FIELDS_PARAM],
        ];
    }
    /**
     * Combine url with field parameters
     *
     * @private
     * @param {?} url
     * @param {?} fields
     * @return {?}
     */
    getUrlWithFields(url, fields) {
        /** @type {?} */
        const mergedFields = mergeFields(fields);
        if (mergedFields) {
            url += url.includes('?') ? '&' : '?';
            url += `${this.FIELDS_PARAM}=${mergedFields}`;
        }
        return url;
    }
}
OccFieldsService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root',
            },] }
];
/** @nocollapse */
OccFieldsService.ctorParameters = () => [
    { type: HttpClient }
];
/** @nocollapse */ OccFieldsService.ngInjectableDef = ɵɵdefineInjectable({ factory: function OccFieldsService_Factory() { return new OccFieldsService(ɵɵinject(HttpClient)); }, token: OccFieldsService, providedIn: "root" });
if (false) {
    /**
     * @type {?}
     * @protected
     */
    OccFieldsService.prototype.FIELDS_PARAM;
    /**
     * @type {?}
     * @protected
     */
    OccFieldsService.prototype.http;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class OccRequestsOptimizerService {
    /**
     * @param {?} http
     * @param {?} occFields
     */
    constructor(http, occFields) {
        this.http = http;
        this.occFields = occFields;
    }
    /**
     * Optimize occ endpoint calls merging requests to the same url by merging field parameters
     *
     * @template T
     * @param {?} scopedDataWithUrls
     * @param {?=} dataFactory
     * @return {?}
     */
    scopedDataLoad(scopedDataWithUrls, dataFactory) {
        /** @type {?} */
        const result = [];
        if (!dataFactory) {
            dataFactory = (/**
             * @param {?} url
             * @return {?}
             */
            url => this.http.get(url));
        }
        /** @type {?} */
        const mergedUrls = this.occFields.getOptimalUrlGroups(scopedDataWithUrls);
        Object.entries(mergedUrls).forEach((/**
         * @param {?} __0
         * @return {?}
         */
        ([url, groupedModelsSet]) => {
            /** @type {?} */
            const groupedModels = Object.values(groupedModelsSet);
            if (groupedModels.length === 1) {
                // only one scope for url, we can pass the data straightaway
                result.push(Object.assign({}, groupedModels[0].scopedData, { data$: dataFactory(url) }));
            }
            else {
                // multiple scopes per url
                // we have to split the model per each scope
                /** @type {?} */
                const data$ = dataFactory(url).pipe(shareReplay(1), 
                // TODO deprecated since 1.4, remove
                map((/**
                 * @param {?} data
                 * @return {?}
                 */
                data => JSON.parse(JSON.stringify(data)))));
                groupedModels.forEach((/**
                 * @param {?} modelData
                 * @return {?}
                 */
                modelData => {
                    result.push(Object.assign({}, modelData.scopedData, { data$: data$.pipe(map((/**
                         * @param {?} data
                         * @return {?}
                         */
                        data => extractFields(data, modelData.fields)))) }));
                }));
            }
        }));
        return result;
    }
}
OccRequestsOptimizerService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root',
            },] }
];
/** @nocollapse */
OccRequestsOptimizerService.ctorParameters = () => [
    { type: HttpClient },
    { type: OccFieldsService }
];
/** @nocollapse */ OccRequestsOptimizerService.ngInjectableDef = ɵɵdefineInjectable({ factory: function OccRequestsOptimizerService_Factory() { return new OccRequestsOptimizerService(ɵɵinject(HttpClient), ɵɵinject(OccFieldsService)); }, token: OccRequestsOptimizerService, providedIn: "root" });
if (false) {
    /**
     * @type {?}
     * @protected
     */
    OccRequestsOptimizerService.prototype.http;
    /**
     * @type {?}
     * @protected
     */
    OccRequestsOptimizerService.prototype.occFields;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class OccProductAdapter {
    /**
     * @param {?} http
     * @param {?} occEndpoints
     * @param {?} converter
     * @param {?} requestsOptimizer
     */
    constructor(http, occEndpoints, converter, requestsOptimizer) {
        this.http = http;
        this.occEndpoints = occEndpoints;
        this.converter = converter;
        this.requestsOptimizer = requestsOptimizer;
    }
    /**
     * @param {?} productCode
     * @param {?=} scope
     * @return {?}
     */
    load(productCode, scope) {
        return this.http
            .get(this.getEndpoint(productCode, scope))
            .pipe(this.converter.pipeable(PRODUCT_NORMALIZER));
    }
    /**
     * @param {?} products
     * @return {?}
     */
    loadMany(products) {
        /** @type {?} */
        const scopedDataWithUrls = products.map((/**
         * @param {?} model
         * @return {?}
         */
        model => ({
            scopedData: model,
            url: this.getEndpoint(model.code, model.scope),
        })));
        return this.requestsOptimizer
            .scopedDataLoad(scopedDataWithUrls)
            .map((/**
         * @param {?} scopedProduct
         * @return {?}
         */
        scopedProduct => ((/** @type {?} */ (Object.assign({}, scopedProduct, { data$: scopedProduct.data$.pipe(this.converter.pipeable(PRODUCT_NORMALIZER)) }))))));
    }
    /**
     * @protected
     * @param {?} code
     * @param {?=} scope
     * @return {?}
     */
    getEndpoint(code, scope) {
        return this.occEndpoints.getUrl('product', {
            productCode: code,
        }, undefined, scope);
    }
}
OccProductAdapter.decorators = [
    { type: Injectable }
];
/** @nocollapse */
OccProductAdapter.ctorParameters = () => [
    { type: HttpClient },
    { type: OccEndpointsService },
    { type: ConverterService },
    { type: OccRequestsOptimizerService }
];
if (false) {
    /**
     * @type {?}
     * @protected
     */
    OccProductAdapter.prototype.http;
    /**
     * @type {?}
     * @protected
     */
    OccProductAdapter.prototype.occEndpoints;
    /**
     * @type {?}
     * @protected
     */
    OccProductAdapter.prototype.converter;
    /**
     * @type {?}
     * @protected
     */
    OccProductAdapter.prototype.requestsOptimizer;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @abstract
 */
class ProductAdapter {
}
if (false) {
    /**
     * Abstract method used to load product's details data.
     * Product's data can be loaded from alternative sources, as long as the structure
     * converts to the `Product`.
     *
     * @abstract
     * @param {?} productCode The `productCode` for given product
     * @param {?=} scope The product scope to load
     * @return {?}
     */
    ProductAdapter.prototype.load = function (productCode, scope) { };
    /**
     * Abstract method used to load data for multiple product and scopes
     * Adapter is able to optimize necessary backend calls and load
     * products in the most efficient way possible.
     *
     * @abstract
     * @param {?} products
     * @return {?}
     */
    ProductAdapter.prototype.loadMany = function (products) { };
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @abstract
 */
class ProductReferencesAdapter {
}
if (false) {
    /**
     * Abstract method used to load product references for a given product.
     * References can be loaded from alternative sources, as long as the structure
     * converts to the `ProductReference[]`.
     *
     * @abstract
     * @param {?} productCode The `productCode` for given product
     * @param {?=} referenceType Reference type according to enum ProductReferenceTypeEnum
     * @param {?=} pageSize Maximum number of product refrence to load
     * @return {?}
     */
    ProductReferencesAdapter.prototype.load = function (productCode, referenceType, pageSize) { };
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @abstract
 */
class ProductReviewsAdapter {
}
if (false) {
    /**
     * Abstract method used to load reviews for a given product.
     * Reviews can be loaded from alternative sources, as long as the structure
     * converts to the `Review[]`.
     *
     * @abstract
     * @param {?} productCode The `productCode` for given product
     * @param {?=} maxCount Maximum number of review to load
     * @return {?}
     */
    ProductReviewsAdapter.prototype.load = function (productCode, maxCount) { };
    /**
     * Abstract method used to post review for a given product.
     *
     * @abstract
     * @param {?} productCode The `productCode` for given product
     * @param {?} review Review to post
     * @return {?}
     */
    ProductReviewsAdapter.prototype.post = function (productCode, review) { };
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @abstract
 */
class ProductSearchAdapter {
}
if (false) {
    /**
     * @abstract
     * @param {?} query
     * @param {?=} searchConfig
     * @return {?}
     */
    ProductSearchAdapter.prototype.search = function (query, searchConfig) { };
    /**
     * @abstract
     * @param {?} term
     * @param {?=} pageSize
     * @return {?}
     */
    ProductSearchAdapter.prototype.loadSuggestions = function (term, pageSize) { };
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {string} */
const ProductScope = {
    LIST: 'list',
    DETAILS: 'details',
    ATTRIBUTES: 'attributes',
    VARIANTS: 'variants',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const defaultOccProductConfig = {
    backend: {
        occ: {
            endpoints: {
                product: 'products/${productCode}?fields=DEFAULT,averageRating,images(FULL),classifications,manufacturer,numberOfReviews,categories(FULL),baseOptions,baseProduct,variantOptions,variantType',
                product_scopes: {
                    list: 'products/${productCode}?fields=code,name,summary,price(formattedValue),images(DEFAULT,galleryIndex)',
                    details: 'products/${productCode}?fields=averageRating,stock(DEFAULT),description,availableForPickup,code,url,price(DEFAULT),numberOfReviews,manufacturer,categories(FULL),priceRange,multidimensional,configuratorType,configurable,tags,images(FULL)',
                    attributes: 'products/${productCode}?fields=classifications',
                    variants: 'products/${productCode}?fields=name,purchasable,baseOptions(DEFAULT),baseProduct,variantOptions(DEFAULT),variantType',
                },
                productReviews: 'products/${productCode}/reviews',
                // Uncomment this when occ gets configured
                // productReferences:
                //   'products/${productCode}/references?fields=DEFAULT,references(target(images(FULL)))&referenceType=${referenceType}',
                productReferences: 'products/${productCode}/references?fields=DEFAULT,references(target(images(FULL)))',
                // tslint:disable:max-line-length
                productSearch: 'products/search?fields=products(code,name,summary,price(FULL),images(DEFAULT),stock(FULL),averageRating,variantOptions),facets,breadcrumbs,pagination(DEFAULT),sorts(DEFAULT),freeTextSearch',
                // tslint:enable
                productSuggestions: 'products/suggestions',
            },
        },
        loadingScopes: {
            product: {
                details: {
                    include: [ProductScope.LIST, ProductScope.VARIANTS],
                },
            },
        },
    },
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @record
 */
function ProductScopesConfig() { }
if (false) {
    /** @type {?|undefined} */
    ProductScopesConfig.prototype.list;
    /** @type {?|undefined} */
    ProductScopesConfig.prototype.details;
    /** @type {?|undefined} */
    ProductScopesConfig.prototype.attributes;
    /** @type {?|undefined} */
    ProductScopesConfig.prototype.variants;
    /* Skipping unhandled member: [scope: string]: ProductLoadingScopeConfig;*/
}
/**
 * @record
 */
function ProductLoadingScopeConfig() { }
if (false) {
    /** @type {?|undefined} */
    ProductLoadingScopeConfig.prototype.include;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ProductOccModule {
}
ProductOccModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    HttpClientModule,
                    ConfigModule.withConfig(defaultOccProductConfig),
                ],
                providers: [
                    {
                        provide: ProductAdapter,
                        useClass: OccProductAdapter,
                    },
                    {
                        provide: PRODUCT_NORMALIZER,
                        useExisting: ProductImageNormalizer,
                        multi: true,
                    },
                    {
                        provide: PRODUCT_NORMALIZER,
                        useExisting: ProductNameNormalizer,
                        multi: true,
                    },
                    {
                        provide: ProductReferencesAdapter,
                        useClass: OccProductReferencesAdapter,
                    },
                    {
                        provide: PRODUCT_REFERENCES_NORMALIZER,
                        useExisting: OccProductReferencesListNormalizer,
                        multi: true,
                    },
                    {
                        provide: ProductSearchAdapter,
                        useClass: OccProductSearchAdapter,
                    },
                    {
                        provide: PRODUCT_SEARCH_PAGE_NORMALIZER,
                        useExisting: OccProductSearchPageNormalizer,
                        multi: true,
                    },
                    {
                        provide: ProductReviewsAdapter,
                        useClass: OccProductReviewsAdapter,
                    },
                ],
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const LANGUAGE_NORMALIZER = new InjectionToken('LanguageNormalizer');
/** @type {?} */
const CURRENCY_NORMALIZER = new InjectionToken('CurrencyNormalizer');
/** @type {?} */
const COUNTRY_NORMALIZER = new InjectionToken('CountryNormalizer');
/** @type {?} */
const REGION_NORMALIZER = new InjectionToken('RegionNormalizer');

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class OccSiteAdapter {
    /**
     * @param {?} http
     * @param {?} occEndpointsService
     * @param {?} converterService
     */
    constructor(http, occEndpointsService, converterService) {
        this.http = http;
        this.occEndpointsService = occEndpointsService;
        this.converterService = converterService;
    }
    /**
     * @return {?}
     */
    loadLanguages() {
        return this.http
            .get(this.occEndpointsService.getUrl('languages'))
            .pipe(map((/**
         * @param {?} languageList
         * @return {?}
         */
        languageList => languageList.languages)), this.converterService.pipeableMany(LANGUAGE_NORMALIZER));
    }
    /**
     * @return {?}
     */
    loadCurrencies() {
        return this.http
            .get(this.occEndpointsService.getUrl('currencies'))
            .pipe(map((/**
         * @param {?} currencyList
         * @return {?}
         */
        currencyList => currencyList.currencies)), this.converterService.pipeableMany(CURRENCY_NORMALIZER));
    }
    /**
     * @param {?=} type
     * @return {?}
     */
    loadCountries(type) {
        return this.http
            .get(this.occEndpointsService.getUrl('countries', undefined, type ? { type } : undefined))
            .pipe(map((/**
         * @param {?} countryList
         * @return {?}
         */
        countryList => countryList.countries)), this.converterService.pipeableMany(COUNTRY_NORMALIZER));
    }
    /**
     * @param {?} countryIsoCode
     * @return {?}
     */
    loadRegions(countryIsoCode) {
        return this.http
            .get(this.occEndpointsService.getUrl('regions', { isoCode: countryIsoCode }))
            .pipe(map((/**
         * @param {?} regionList
         * @return {?}
         */
        regionList => regionList.regions)), this.converterService.pipeableMany(REGION_NORMALIZER));
    }
    /**
     * @return {?}
     */
    loadBaseSite() {
        /** @type {?} */
        const baseUrl = this.occEndpointsService.getBaseEndpoint();
        /** @type {?} */
        const urlSplits = baseUrl.split('/');
        /** @type {?} */
        const activeSite = urlSplits.pop();
        /** @type {?} */
        const url = urlSplits.join('/') + '/basesites';
        /** @type {?} */
        const params = new HttpParams({
            fromString: 'fields=FULL',
        });
        return this.http
            .get(url, { params: params })
            .pipe(map((/**
         * @param {?} siteList
         * @return {?}
         */
        siteList => {
            return siteList.baseSites.find((/**
             * @param {?} site
             * @return {?}
             */
            site => site.uid === activeSite));
        })));
    }
}
OccSiteAdapter.decorators = [
    { type: Injectable }
];
/** @nocollapse */
OccSiteAdapter.ctorParameters = () => [
    { type: HttpClient },
    { type: OccEndpointsService },
    { type: ConverterService }
];
if (false) {
    /**
     * @type {?}
     * @protected
     */
    OccSiteAdapter.prototype.http;
    /**
     * @type {?}
     * @protected
     */
    OccSiteAdapter.prototype.occEndpointsService;
    /**
     * @type {?}
     * @protected
     */
    OccSiteAdapter.prototype.converterService;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @abstract
 */
class SiteAdapter {
}
if (false) {
    /**
     * Abstract method used to load languages.
     * @abstract
     * @return {?}
     */
    SiteAdapter.prototype.loadLanguages = function () { };
    /**
     * Abstract method used to load currencies.
     * @abstract
     * @return {?}
     */
    SiteAdapter.prototype.loadCurrencies = function () { };
    /**
     * Abstract method used to get countries with optional type.
     * @abstract
     * @param {?=} type
     * @return {?}
     */
    SiteAdapter.prototype.loadCountries = function (type) { };
    /**
     * Abstract method used to get regions for a country.
     * @abstract
     * @param {?} countryIsoCode
     * @return {?}
     */
    SiteAdapter.prototype.loadRegions = function (countryIsoCode) { };
    /**
     * Abstract method used to get base site data.
     * @abstract
     * @return {?}
     */
    SiteAdapter.prototype.loadBaseSite = function () { };
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const defaultOccSiteContextConfig = {
    backend: {
        occ: {
            endpoints: {
                languages: 'languages',
                currencies: 'currencies',
                countries: 'countries',
                regions: 'countries/${isoCode}/regions?fields=regions(name,isocode,isocodeShort)',
            },
        },
    },
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Facade that provides easy access to curreny state, actions and selectors.
 */
class CurrencyService {
    /**
     * @param {?} store
     * @param {?} winRef
     * @param {?} config
     */
    constructor(store, winRef, config) {
        this.store = store;
        this.config = config;
        this.sessionStorage = winRef.sessionStorage;
    }
    /**
     * Represents all the currencies supported by the current store.
     * @return {?}
     */
    getAll() {
        return this.store.pipe(select(getAllCurrencies), tap((/**
         * @param {?} currencies
         * @return {?}
         */
        currencies => {
            if (!currencies) {
                this.store.dispatch(new LoadCurrencies());
            }
        })), filter((/**
         * @param {?} currenies
         * @return {?}
         */
        currenies => Boolean(currenies))));
    }
    /**
     * Represents the isocode of the active currency.
     * @return {?}
     */
    getActive() {
        return this.store.pipe(select(getActiveCurrency), filter((/**
         * @param {?} active
         * @return {?}
         */
        active => Boolean(active))));
    }
    /**
     * Sets the active language.
     * @param {?} isocode
     * @return {?}
     */
    setActive(isocode) {
        return this.store
            .pipe(select(getActiveCurrency), take(1))
            .subscribe((/**
         * @param {?} activeCurrency
         * @return {?}
         */
        activeCurrency => {
            if (activeCurrency !== isocode) {
                this.store.dispatch(new SetActiveCurrency(isocode));
            }
        }));
    }
    /**
     * Initials the active currency. The active currency is either given
     * by the last visit (stored in session storage) or by the
     * default session currency of the store.
     * @return {?}
     */
    initialize() {
        /** @type {?} */
        const sessionCurrency = this.sessionStorage && this.sessionStorage.getItem('currency');
        if (sessionCurrency &&
            getContextParameterValues(this.config, CURRENCY_CONTEXT_ID).includes(sessionCurrency)) {
            this.setActive(sessionCurrency);
        }
        else {
            this.setActive(getContextParameterDefault(this.config, CURRENCY_CONTEXT_ID));
        }
    }
}
CurrencyService.decorators = [
    { type: Injectable }
];
/** @nocollapse */
CurrencyService.ctorParameters = () => [
    { type: Store },
    { type: WindowRef },
    { type: SiteContextConfig }
];
if (false) {
    /**
     * @type {?}
     * @private
     */
    CurrencyService.prototype.sessionStorage;
    /**
     * @type {?}
     * @protected
     */
    CurrencyService.prototype.store;
    /**
     * @type {?}
     * @protected
     */
    CurrencyService.prototype.config;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Facade that provides easy access to language state, actions and selectors.
 */
class LanguageService {
    /**
     * @param {?} store
     * @param {?} winRef
     * @param {?} config
     */
    constructor(store, winRef, config) {
        this.store = store;
        this.config = config;
        this.sessionStorage = winRef.sessionStorage;
    }
    /**
     * Represents all the languages supported by the current store.
     * @return {?}
     */
    getAll() {
        return this.store.pipe(select(getAllLanguages), tap((/**
         * @param {?} languages
         * @return {?}
         */
        languages => {
            if (!languages) {
                this.store.dispatch(new LoadLanguages());
            }
        })), filter((/**
         * @param {?} languages
         * @return {?}
         */
        languages => Boolean(languages))));
    }
    /**
     * Represents the isocode of the active language.
     * @return {?}
     */
    getActive() {
        return this.store.pipe(select(getActiveLanguage), filter((/**
         * @param {?} active
         * @return {?}
         */
        active => Boolean(active))));
    }
    /**
     * Sets the active language.
     * @param {?} isocode
     * @return {?}
     */
    setActive(isocode) {
        return this.store
            .pipe(select(getActiveLanguage), take(1))
            .subscribe((/**
         * @param {?} activeLanguage
         * @return {?}
         */
        activeLanguage => {
            if (activeLanguage !== isocode) {
                this.store.dispatch(new SetActiveLanguage(isocode));
            }
        }));
    }
    /**
     * Initials the active language. The active language is either given
     * by the last visit (stored in session storage) or by the
     * default session language of the store.
     * @return {?}
     */
    initialize() {
        /** @type {?} */
        const sessionLanguage = this.sessionStorage && this.sessionStorage.getItem('language');
        if (sessionLanguage &&
            getContextParameterValues(this.config, LANGUAGE_CONTEXT_ID).includes(sessionLanguage)) {
            this.setActive(sessionLanguage);
        }
        else {
            this.setActive(getContextParameterDefault(this.config, LANGUAGE_CONTEXT_ID));
        }
    }
}
LanguageService.decorators = [
    { type: Injectable }
];
/** @nocollapse */
LanguageService.ctorParameters = () => [
    { type: Store },
    { type: WindowRef },
    { type: SiteContextConfig }
];
if (false) {
    /**
     * @type {?}
     * @private
     */
    LanguageService.prototype.sessionStorage;
    /**
     * @type {?}
     * @protected
     */
    LanguageService.prototype.store;
    /**
     * @type {?}
     * @protected
     */
    LanguageService.prototype.config;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SiteContextInterceptor {
    /**
     * @param {?} languageService
     * @param {?} currencyService
     * @param {?} occEndpoints
     * @param {?} config
     */
    constructor(languageService, currencyService, occEndpoints, config) {
        this.languageService = languageService;
        this.currencyService = currencyService;
        this.occEndpoints = occEndpoints;
        this.config = config;
        this.activeLang = getContextParameterDefault(this.config, LANGUAGE_CONTEXT_ID);
        this.activeCurr = getContextParameterDefault(this.config, CURRENCY_CONTEXT_ID);
        this.languageService
            .getActive()
            .subscribe((/**
         * @param {?} data
         * @return {?}
         */
        data => (this.activeLang = data)));
        this.currencyService.getActive().subscribe((/**
         * @param {?} data
         * @return {?}
         */
        data => {
            this.activeCurr = data;
        }));
    }
    /**
     * @param {?} request
     * @param {?} next
     * @return {?}
     */
    intercept(request, next) {
        if (request.url.includes(this.occEndpoints.getBaseEndpoint())) {
            request = request.clone({
                setParams: {
                    lang: this.activeLang,
                    curr: this.activeCurr,
                },
            });
        }
        return next.handle(request);
    }
}
SiteContextInterceptor.decorators = [
    { type: Injectable, args: [{ providedIn: 'root' },] }
];
/** @nocollapse */
SiteContextInterceptor.ctorParameters = () => [
    { type: LanguageService },
    { type: CurrencyService },
    { type: OccEndpointsService },
    { type: SiteContextConfig }
];
/** @nocollapse */ SiteContextInterceptor.ngInjectableDef = ɵɵdefineInjectable({ factory: function SiteContextInterceptor_Factory() { return new SiteContextInterceptor(ɵɵinject(LanguageService), ɵɵinject(CurrencyService), ɵɵinject(OccEndpointsService), ɵɵinject(SiteContextConfig)); }, token: SiteContextInterceptor, providedIn: "root" });
if (false) {
    /** @type {?} */
    SiteContextInterceptor.prototype.activeLang;
    /** @type {?} */
    SiteContextInterceptor.prototype.activeCurr;
    /**
     * @type {?}
     * @private
     */
    SiteContextInterceptor.prototype.languageService;
    /**
     * @type {?}
     * @private
     */
    SiteContextInterceptor.prototype.currencyService;
    /**
     * @type {?}
     * @private
     */
    SiteContextInterceptor.prototype.occEndpoints;
    /**
     * @type {?}
     * @private
     */
    SiteContextInterceptor.prototype.config;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SiteContextOccModule {
}
SiteContextOccModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    HttpClientModule,
                    ConfigModule.withConfig(defaultOccSiteContextConfig),
                ],
                providers: [
                    {
                        provide: SiteAdapter,
                        useClass: OccSiteAdapter,
                    },
                    {
                        provide: HTTP_INTERCEPTORS,
                        useExisting: SiteContextInterceptor,
                        multi: true,
                    },
                ],
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @abstract
 */
class StoreFinderAdapter {
}
if (false) {
    /**
     * @abstract
     * @param {?} query
     * @param {?} searchConfig
     * @param {?=} longitudeLatitude
     * @return {?}
     */
    StoreFinderAdapter.prototype.search = function (query, searchConfig, longitudeLatitude) { };
    /**
     * @abstract
     * @return {?}
     */
    StoreFinderAdapter.prototype.loadCounts = function () { };
    /**
     * @abstract
     * @param {?} storeId
     * @return {?}
     */
    StoreFinderAdapter.prototype.load = function (storeId) { };
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const defaultOccStoreFinderConfig = {
    backend: {
        occ: {
            endpoints: {
                store: 'stores/${storeId}?fields=FULL',
                stores: 'stores?fields=stores(name,displayName,formattedDistance,openingHours(weekDayOpeningList(FULL),specialDayOpeningList(FULL)),geoPoint(latitude,longitude),address(line1,line2,town,region(FULL),postalCode,phone,country,email), features),pagination(DEFAULT),sorts(DEFAULT)',
                storescounts: 'stores/storescounts',
            },
        },
    },
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class StoreFinderConnector {
    /**
     * @param {?} adapter
     */
    constructor(adapter) {
        this.adapter = adapter;
    }
    /**
     * @param {?} query
     * @param {?} searchConfig
     * @param {?=} longitudeLatitude
     * @return {?}
     */
    search(query, searchConfig, longitudeLatitude) {
        return this.adapter.search(query, searchConfig, longitudeLatitude);
    }
    /**
     * @return {?}
     */
    getCounts() {
        return this.adapter.loadCounts();
    }
    /**
     * @param {?} storeId
     * @return {?}
     */
    get(storeId) {
        return this.adapter.load(storeId);
    }
}
StoreFinderConnector.decorators = [
    { type: Injectable, args: [{ providedIn: 'root' },] }
];
/** @nocollapse */
StoreFinderConnector.ctorParameters = () => [
    { type: StoreFinderAdapter }
];
/** @nocollapse */ StoreFinderConnector.ngInjectableDef = ɵɵdefineInjectable({ factory: function StoreFinderConnector_Factory() { return new StoreFinderConnector(ɵɵinject(StoreFinderAdapter)); }, token: StoreFinderConnector, providedIn: "root" });
if (false) {
    /**
     * @type {?}
     * @protected
     */
    StoreFinderConnector.prototype.adapter;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const POINT_OF_SERVICE_NORMALIZER = new InjectionToken('PointOfServiceNormalizer');
/** @type {?} */
const STORE_FINDER_SEARCH_PAGE_NORMALIZER = new InjectionToken('StoreFinderSearchPageNormalizer');
/** @type {?} */
const STORE_COUNT_NORMALIZER = new InjectionToken('StoreCountNormalizer');

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class OccStoreFinderAdapter {
    /**
     * @param {?} http
     * @param {?} occEndpointsService
     * @param {?} converterService
     */
    constructor(http, occEndpointsService, converterService) {
        this.http = http;
        this.occEndpointsService = occEndpointsService;
        this.converterService = converterService;
    }
    /**
     * @param {?} query
     * @param {?} searchConfig
     * @param {?=} longitudeLatitude
     * @return {?}
     */
    search(query, searchConfig, longitudeLatitude) {
        return this.callOccFindStores(query, searchConfig, longitudeLatitude).pipe(this.converterService.pipeable(STORE_FINDER_SEARCH_PAGE_NORMALIZER));
    }
    /**
     * @return {?}
     */
    loadCounts() {
        return this.http
            .get(this.occEndpointsService.getUrl('storescounts'))
            .pipe(map((/**
         * @param {?} __0
         * @return {?}
         */
        ({ countriesAndRegionsStoreCount }) => countriesAndRegionsStoreCount)), this.converterService.pipeableMany(STORE_COUNT_NORMALIZER));
    }
    /**
     * @param {?} storeId
     * @return {?}
     */
    load(storeId) {
        return this.http
            .get(this.occEndpointsService.getUrl('store', { storeId }))
            .pipe(this.converterService.pipeable(POINT_OF_SERVICE_NORMALIZER));
    }
    /**
     * @protected
     * @param {?} query
     * @param {?} searchConfig
     * @param {?=} longitudeLatitude
     * @return {?}
     */
    callOccFindStores(query, searchConfig, longitudeLatitude) {
        /** @type {?} */
        const params = {};
        if (longitudeLatitude) {
            params['longitude'] = String(longitudeLatitude.longitude);
            params['latitude'] = String(longitudeLatitude.latitude);
            params['radius'] = String('10000000');
        }
        else {
            params['query'] = query;
        }
        if (searchConfig.pageSize) {
            params['pageSize'] = String(searchConfig.pageSize);
        }
        if (searchConfig.currentPage) {
            params['currentPage'] = String(searchConfig.currentPage);
        }
        if (searchConfig.sort) {
            params['sort'] = searchConfig.sort;
        }
        return this.http.get(this.occEndpointsService.getUrl('stores', undefined, params));
    }
}
OccStoreFinderAdapter.decorators = [
    { type: Injectable }
];
/** @nocollapse */
OccStoreFinderAdapter.ctorParameters = () => [
    { type: HttpClient },
    { type: OccEndpointsService },
    { type: ConverterService }
];
if (false) {
    /**
     * @type {?}
     * @protected
     */
    OccStoreFinderAdapter.prototype.http;
    /**
     * @type {?}
     * @protected
     */
    OccStoreFinderAdapter.prototype.occEndpointsService;
    /**
     * @type {?}
     * @protected
     */
    OccStoreFinderAdapter.prototype.converterService;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class StoreFinderOccModule {
}
StoreFinderOccModule.decorators = [
    { type: NgModule, args: [{
                imports: [ConfigModule.withConfig(defaultOccStoreFinderConfig)],
                providers: [{ provide: StoreFinderAdapter, useClass: OccStoreFinderAdapter }],
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const CONSENT_TEMPLATE_NORMALIZER = new InjectionToken('ConsentTemplateNormalizer');

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class OccAnonymousConsentTemplatesAdapter {
    /**
     * @param {?} http
     * @param {?} occEndpoints
     * @param {?} converter
     */
    constructor(http, occEndpoints, converter) {
        this.http = http;
        this.occEndpoints = occEndpoints;
        this.converter = converter;
    }
    /**
     * @return {?}
     */
    loadAnonymousConsentTemplates() {
        /** @type {?} */
        const url = this.occEndpoints.getUrl('anonymousConsentTemplates');
        return this.http.get(url).pipe(catchError((/**
         * @param {?} error
         * @return {?}
         */
        error => throwError(error))), map((/**
         * @param {?} consentList
         * @return {?}
         */
        consentList => consentList.consentTemplates)), this.converter.pipeableMany(CONSENT_TEMPLATE_NORMALIZER));
    }
}
OccAnonymousConsentTemplatesAdapter.decorators = [
    { type: Injectable }
];
/** @nocollapse */
OccAnonymousConsentTemplatesAdapter.ctorParameters = () => [
    { type: HttpClient },
    { type: OccEndpointsService },
    { type: ConverterService }
];
if (false) {
    /**
     * @type {?}
     * @protected
     */
    OccAnonymousConsentTemplatesAdapter.prototype.http;
    /**
     * @type {?}
     * @protected
     */
    OccAnonymousConsentTemplatesAdapter.prototype.occEndpoints;
    /**
     * @type {?}
     * @protected
     */
    OccAnonymousConsentTemplatesAdapter.prototype.converter;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class OccUserAddressAdapter {
    /**
     * @param {?} http
     * @param {?} occEndpoints
     * @param {?} converter
     */
    constructor(http, occEndpoints, converter) {
        this.http = http;
        this.occEndpoints = occEndpoints;
        this.converter = converter;
    }
    /**
     * @param {?} userId
     * @return {?}
     */
    loadAll(userId) {
        /** @type {?} */
        const url = this.occEndpoints.getUrl('addresses', { userId });
        /** @type {?} */
        const headers = new HttpHeaders({
            'Content-Type': 'application/json',
        });
        return this.http.get(url, { headers }).pipe(catchError((/**
         * @param {?} error
         * @return {?}
         */
        (error) => throwError(error))), map((/**
         * @param {?} addressList
         * @return {?}
         */
        addressList => addressList.addresses)), this.converter.pipeableMany(ADDRESS_NORMALIZER));
    }
    /**
     * @param {?} userId
     * @param {?} address
     * @return {?}
     */
    add(userId, address) {
        /** @type {?} */
        const url = this.occEndpoints.getUrl('addresses', { userId });
        /** @type {?} */
        const headers = new HttpHeaders({
            'Content-Type': 'application/json',
        });
        address = this.converter.convert(address, ADDRESS_SERIALIZER);
        return this.http
            .post(url, address, { headers })
            .pipe(catchError((/**
         * @param {?} error
         * @return {?}
         */
        (error) => throwError(error))));
    }
    /**
     * @param {?} userId
     * @param {?} addressId
     * @param {?} address
     * @return {?}
     */
    update(userId, addressId, address) {
        /** @type {?} */
        const url = this.occEndpoints.getUrl('addressDetail', {
            userId,
            addressId,
        });
        /** @type {?} */
        const headers = new HttpHeaders({
            'Content-Type': 'application/json',
        });
        address = this.converter.convert(address, ADDRESS_SERIALIZER);
        return this.http
            .patch(url, address, { headers })
            .pipe(catchError((/**
         * @param {?} error
         * @return {?}
         */
        (error) => throwError(error))));
    }
    /**
     * @param {?} userId
     * @param {?} address
     * @return {?}
     */
    verify(userId, address) {
        /** @type {?} */
        const url = this.occEndpoints.getUrl('addressVerification', { userId });
        /** @type {?} */
        let headers = new HttpHeaders({
            'Content-Type': 'application/json',
        });
        if (userId === OCC_USER_ID_ANONYMOUS) {
            headers = InterceptorUtil.createHeader(USE_CLIENT_TOKEN, true, headers);
        }
        address = this.converter.convert(address, ADDRESS_SERIALIZER);
        return this.http.post(url, address, { headers }).pipe(catchError((/**
         * @param {?} error
         * @return {?}
         */
        (error) => throwError(error))), this.converter.pipeable(ADDRESS_VALIDATION_NORMALIZER));
    }
    /**
     * @param {?} userId
     * @param {?} addressId
     * @return {?}
     */
    delete(userId, addressId) {
        /** @type {?} */
        const url = this.occEndpoints.getUrl('addressDetail', {
            userId,
            addressId,
        });
        /** @type {?} */
        const headers = new HttpHeaders({
            'Content-Type': 'application/json',
        });
        return this.http
            .delete(url, { headers })
            .pipe(catchError((/**
         * @param {?} error
         * @return {?}
         */
        (error) => throwError(error))));
    }
}
OccUserAddressAdapter.decorators = [
    { type: Injectable }
];
/** @nocollapse */
OccUserAddressAdapter.ctorParameters = () => [
    { type: HttpClient },
    { type: OccEndpointsService },
    { type: ConverterService }
];
if (false) {
    /**
     * @type {?}
     * @protected
     */
    OccUserAddressAdapter.prototype.http;
    /**
     * @type {?}
     * @protected
     */
    OccUserAddressAdapter.prototype.occEndpoints;
    /**
     * @type {?}
     * @protected
     */
    OccUserAddressAdapter.prototype.converter;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class OccUserConsentAdapter {
    /**
     * @param {?} http
     * @param {?} occEndpoints
     * @param {?} converter
     */
    constructor(http, occEndpoints, converter) {
        this.http = http;
        this.occEndpoints = occEndpoints;
        this.converter = converter;
    }
    /**
     * @param {?} userId
     * @return {?}
     */
    loadConsents(userId) {
        /** @type {?} */
        const url = this.occEndpoints.getUrl('consentTemplates', { userId });
        /** @type {?} */
        const headers = new HttpHeaders({ 'Cache-Control': 'no-cache' });
        return this.http.get(url, { headers }).pipe(catchError((/**
         * @param {?} error
         * @return {?}
         */
        (error) => throwError(error))), map((/**
         * @param {?} consentList
         * @return {?}
         */
        consentList => consentList.consentTemplates)), this.converter.pipeableMany(CONSENT_TEMPLATE_NORMALIZER));
    }
    /**
     * @param {?} userId
     * @param {?} consentTemplateId
     * @param {?} consentTemplateVersion
     * @return {?}
     */
    giveConsent(userId, consentTemplateId, consentTemplateVersion) {
        /** @type {?} */
        const url = this.occEndpoints.getUrl('consents', { userId });
        /** @type {?} */
        const httpParams = new HttpParams()
            .set('consentTemplateId', consentTemplateId)
            .set('consentTemplateVersion', consentTemplateVersion.toString());
        /** @type {?} */
        const headers = new HttpHeaders({
            'Content-Type': 'application/x-www-form-urlencoded',
            'Cache-Control': 'no-cache',
        });
        return this.http
            .post(url, httpParams, { headers })
            .pipe(catchError((/**
         * @param {?} error
         * @return {?}
         */
        error => throwError(error))), this.converter.pipeable(CONSENT_TEMPLATE_NORMALIZER));
    }
    /**
     * @param {?} userId
     * @param {?} consentCode
     * @return {?}
     */
    withdrawConsent(userId, consentCode) {
        /** @type {?} */
        const headers = new HttpHeaders({
            'Cache-Control': 'no-cache',
        });
        /** @type {?} */
        const url = this.occEndpoints.getUrl('consentDetail', {
            userId,
            consentId: consentCode,
        });
        return this.http.delete(url, { headers });
    }
}
OccUserConsentAdapter.decorators = [
    { type: Injectable }
];
/** @nocollapse */
OccUserConsentAdapter.ctorParameters = () => [
    { type: HttpClient },
    { type: OccEndpointsService },
    { type: ConverterService }
];
if (false) {
    /**
     * @type {?}
     * @protected
     */
    OccUserConsentAdapter.prototype.http;
    /**
     * @type {?}
     * @protected
     */
    OccUserConsentAdapter.prototype.occEndpoints;
    /**
     * @type {?}
     * @protected
     */
    OccUserConsentAdapter.prototype.converter;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const ORDER_HISTORY_NORMALIZER = new InjectionToken('OrderHistoryNormalizer');
/** @type {?} */
const CONSIGNMENT_TRACKING_NORMALIZER = new InjectionToken('ConsignmentTrackingNormalizer');
/** @type {?} */
const ORDER_RETURN_REQUEST_NORMALIZER = new InjectionToken('OrderReturnRequestNormalizer');
/** @type {?} */
const ORDER_RETURN_REQUEST_INPUT_SERIALIZER = new InjectionToken('OrderReturnRequestInputSerializer');
/** @type {?} */
const ORDER_RETURNS_NORMALIZER = new InjectionToken('OrderReturnsNormalizer');

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class OccUserOrderAdapter {
    /**
     * @param {?} http
     * @param {?} occEndpoints
     * @param {?} converter
     * @param {?=} featureConfigService
     */
    constructor(http, occEndpoints, converter, featureConfigService) {
        this.http = http;
        this.occEndpoints = occEndpoints;
        this.converter = converter;
        this.featureConfigService = featureConfigService;
    }
    /**
     * @deprecated Since 1.1
     * Use configurable endpoints.
     * Remove issue: #4125
     * @protected
     * @param {?} userId
     * @return {?}
     */
    getOrderEndpoint(userId) {
        /** @type {?} */
        const orderEndpoint = 'users/' + userId + '/orders';
        return this.occEndpoints.getEndpoint(orderEndpoint);
    }
    /**
     * @param {?} userId
     * @param {?} orderCode
     * @return {?}
     */
    load(userId, orderCode) {
        // TODO: Deprecated, remove Issue #4125
        if (!this.featureConfigService.isLevel('1.1')) {
            return this.legacyLoad(userId, orderCode);
        }
        /** @type {?} */
        const url = this.occEndpoints.getUrl('orderDetail', {
            userId,
            orderId: orderCode,
        });
        /** @type {?} */
        let headers = new HttpHeaders();
        if (userId === OCC_USER_ID_ANONYMOUS) {
            headers = InterceptorUtil.createHeader(USE_CLIENT_TOKEN, true, headers);
        }
        return this.http
            .get(url, { headers })
            .pipe(this.converter.pipeable(ORDER_NORMALIZER));
    }
    /**
     * @param {?} userId
     * @param {?=} pageSize
     * @param {?=} currentPage
     * @param {?=} sort
     * @return {?}
     */
    loadHistory(userId, pageSize, currentPage, sort) {
        // TODO: Deprecated, remove Issue #4125
        if (!this.featureConfigService.isLevel('1.1')) {
            return this.legacyLoadHistory(userId, pageSize, currentPage, sort);
        }
        /** @type {?} */
        const params = {};
        if (pageSize) {
            params['pageSize'] = pageSize.toString();
        }
        if (currentPage) {
            params['currentPage'] = currentPage.toString();
        }
        if (sort) {
            params['sort'] = sort.toString();
        }
        /** @type {?} */
        const url = this.occEndpoints.getUrl('orderHistory', { userId }, params);
        return this.http
            .get(url)
            .pipe(this.converter.pipeable(ORDER_HISTORY_NORMALIZER));
    }
    /**
     * @deprecated Since 1.1
     * Use configurable endpoints.
     * Remove issue: #4125
     * @private
     * @param {?} userId
     * @param {?} orderCode
     * @return {?}
     */
    legacyLoad(userId, orderCode) {
        /** @type {?} */
        const url = this.getOrderEndpoint(userId) + '/' + orderCode;
        /** @type {?} */
        const params = new HttpParams({
            fromString: 'fields=FULL',
        });
        return this.http
            .get(url, {
            params,
        })
            .pipe(this.converter.pipeable(ORDER_NORMALIZER));
    }
    /**
     * @deprecated Since 1.1
     * Use configurable endpoints.
     * Remove issue: #4125
     * @private
     * @param {?} userId
     * @param {?=} pageSize
     * @param {?=} currentPage
     * @param {?=} sort
     * @return {?}
     */
    legacyLoadHistory(userId, pageSize, currentPage, sort) {
        /** @type {?} */
        const url = this.getOrderEndpoint(userId);
        /** @type {?} */
        let params = new HttpParams();
        if (pageSize) {
            params = params.set('pageSize', pageSize.toString());
        }
        if (currentPage) {
            params = params.set('currentPage', currentPage.toString());
        }
        if (sort) {
            params = params.set('sort', sort);
        }
        return this.http
            .get(url, { params: params })
            .pipe(this.converter.pipeable(ORDER_HISTORY_NORMALIZER));
    }
    /**
     * @param {?} orderCode
     * @param {?} consignmentCode
     * @param {?=} userId
     * @return {?}
     */
    getConsignmentTracking(orderCode, consignmentCode, userId = OCC_USER_ID_CURRENT) {
        /** @type {?} */
        const url = this.occEndpoints.getUrl('consignmentTracking', {
            userId,
            orderCode,
            consignmentCode,
        });
        return this.http
            .get(url)
            .pipe(this.converter.pipeable(CONSIGNMENT_TRACKING_NORMALIZER));
    }
    /**
     * @param {?} userId
     * @param {?} orderCode
     * @param {?} cancelRequestInput
     * @return {?}
     */
    cancel(userId, orderCode, cancelRequestInput) {
        /** @type {?} */
        const url = this.occEndpoints.getUrl('cancelOrder', {
            userId,
            orderId: orderCode,
        });
        /** @type {?} */
        const headers = new HttpHeaders({
            'Content-Type': 'application/json',
        });
        return this.http
            .post(url, cancelRequestInput, { headers })
            .pipe(catchError((/**
         * @param {?} error
         * @return {?}
         */
        (error) => throwError(error))));
    }
    /**
     * @param {?} userId
     * @param {?} returnRequestInput
     * @return {?}
     */
    createReturnRequest(userId, returnRequestInput) {
        /** @type {?} */
        const url = this.occEndpoints.getUrl('returnOrder', {
            userId,
        });
        /** @type {?} */
        const headers = new HttpHeaders({
            'Content-Type': 'application/json',
        });
        returnRequestInput = this.converter.convert(returnRequestInput, ORDER_RETURN_REQUEST_INPUT_SERIALIZER);
        return this.http.post(url, returnRequestInput, { headers }).pipe(catchError((/**
         * @param {?} error
         * @return {?}
         */
        (error) => throwError(error))), this.converter.pipeable(ORDER_RETURN_REQUEST_NORMALIZER));
    }
    /**
     * @param {?} userId
     * @param {?=} pageSize
     * @param {?=} currentPage
     * @param {?=} sort
     * @return {?}
     */
    loadReturnRequestList(userId, pageSize, currentPage, sort) {
        /** @type {?} */
        const params = {};
        if (pageSize) {
            params['pageSize'] = pageSize.toString();
        }
        if (currentPage) {
            params['currentPage'] = currentPage.toString();
        }
        if (sort) {
            params['sort'] = sort.toString();
        }
        /** @type {?} */
        const url = this.occEndpoints.getUrl('orderReturns', { userId }, params);
        return this.http
            .get(url)
            .pipe(this.converter.pipeable(ORDER_RETURNS_NORMALIZER));
    }
    /**
     * @param {?} userId
     * @param {?} returnRequestCode
     * @return {?}
     */
    loadReturnRequestDetail(userId, returnRequestCode) {
        /** @type {?} */
        const url = this.occEndpoints.getUrl('orderReturnDetail', {
            userId,
            returnRequestCode,
        });
        return this.http
            .get(url)
            .pipe(this.converter.pipeable(ORDER_RETURN_REQUEST_NORMALIZER));
    }
    /**
     * @param {?} userId
     * @param {?} returnRequestCode
     * @param {?} returnRequestModification
     * @return {?}
     */
    cancelReturnRequest(userId, returnRequestCode, returnRequestModification) {
        /** @type {?} */
        const url = this.occEndpoints.getUrl('cancelReturn', {
            userId,
            returnRequestCode,
        });
        /** @type {?} */
        const headers = new HttpHeaders({
            'Content-Type': 'application/json',
        });
        return this.http
            .patch(url, returnRequestModification, { headers })
            .pipe(catchError((/**
         * @param {?} error
         * @return {?}
         */
        (error) => throwError(error))));
    }
}
OccUserOrderAdapter.decorators = [
    { type: Injectable }
];
/** @nocollapse */
OccUserOrderAdapter.ctorParameters = () => [
    { type: HttpClient },
    { type: OccEndpointsService },
    { type: ConverterService },
    { type: FeatureConfigService }
];
if (false) {
    /**
     * @type {?}
     * @protected
     */
    OccUserOrderAdapter.prototype.http;
    /**
     * @type {?}
     * @protected
     */
    OccUserOrderAdapter.prototype.occEndpoints;
    /**
     * @type {?}
     * @protected
     */
    OccUserOrderAdapter.prototype.converter;
    /**
     * @type {?}
     * @protected
     */
    OccUserOrderAdapter.prototype.featureConfigService;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class OccUserPaymentAdapter {
    /**
     * @param {?} http
     * @param {?} occEndpoints
     * @param {?} converter
     */
    constructor(http, occEndpoints, converter) {
        this.http = http;
        this.occEndpoints = occEndpoints;
        this.converter = converter;
    }
    /**
     * @param {?} userId
     * @return {?}
     */
    loadAll(userId) {
        /** @type {?} */
        const url = this.occEndpoints.getUrl('paymentDetailsAll', { userId }) + '?saved=true';
        /** @type {?} */
        const headers = new HttpHeaders({
            'Content-Type': 'application/json',
        });
        return this.http.get(url, { headers }).pipe(catchError((/**
         * @param {?} error
         * @return {?}
         */
        (error) => throwError(error))), map((/**
         * @param {?} methodList
         * @return {?}
         */
        methodList => methodList.payments)), this.converter.pipeableMany(PAYMENT_DETAILS_NORMALIZER));
    }
    /**
     * @param {?} userId
     * @param {?} paymentMethodID
     * @return {?}
     */
    delete(userId, paymentMethodID) {
        /** @type {?} */
        const url = this.occEndpoints.getUrl('paymentDetail', {
            userId,
            paymentDetailId: paymentMethodID,
        });
        /** @type {?} */
        const headers = new HttpHeaders({
            'Content-Type': 'application/json',
        });
        return this.http
            .delete(url, { headers })
            .pipe(catchError((/**
         * @param {?} error
         * @return {?}
         */
        (error) => throwError(error))));
    }
    /**
     * @param {?} userId
     * @param {?} paymentMethodID
     * @return {?}
     */
    setDefault(userId, paymentMethodID) {
        /** @type {?} */
        const url = this.occEndpoints.getUrl('paymentDetail', {
            userId,
            paymentDetailId: paymentMethodID,
        });
        /** @type {?} */
        const headers = new HttpHeaders({
            'Content-Type': 'application/json',
        });
        return this.http
            .patch(url, 
        // TODO: Remove billingAddress property
        { billingAddress: { titleCode: 'mr' }, defaultPayment: true }, { headers })
            .pipe(catchError((/**
         * @param {?} error
         * @return {?}
         */
        (error) => throwError(error))));
    }
}
OccUserPaymentAdapter.decorators = [
    { type: Injectable }
];
/** @nocollapse */
OccUserPaymentAdapter.ctorParameters = () => [
    { type: HttpClient },
    { type: OccEndpointsService },
    { type: ConverterService }
];
if (false) {
    /**
     * @type {?}
     * @protected
     */
    OccUserPaymentAdapter.prototype.http;
    /**
     * @type {?}
     * @protected
     */
    OccUserPaymentAdapter.prototype.occEndpoints;
    /**
     * @type {?}
     * @protected
     */
    OccUserPaymentAdapter.prototype.converter;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const USER_NORMALIZER = new InjectionToken('UserNormalizer');
/** @type {?} */
const USER_SERIALIZER = new InjectionToken('UserSerializer');
/** @type {?} */
const USER_SIGN_UP_SERIALIZER = new InjectionToken('UserSignUpSerializer');
/** @type {?} */
const TITLE_NORMALIZER = new InjectionToken('TitleNormalizer');

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class OccUserAdapter {
    /**
     * @param {?} http
     * @param {?} occEndpoints
     * @param {?} converter
     */
    constructor(http, occEndpoints, converter) {
        this.http = http;
        this.occEndpoints = occEndpoints;
        this.converter = converter;
    }
    /**
     * @param {?} userId
     * @return {?}
     */
    load(userId) {
        /** @type {?} */
        const url = this.occEndpoints.getUrl('user', { userId });
        return this.http
            .get(url)
            .pipe(this.converter.pipeable(USER_NORMALIZER));
    }
    /**
     * @param {?} userId
     * @param {?} user
     * @return {?}
     */
    update(userId, user) {
        /** @type {?} */
        const url = this.occEndpoints.getUrl('user', { userId });
        user = this.converter.convert(user, USER_SERIALIZER);
        return this.http.patch(url, user);
    }
    /**
     * @param {?} user
     * @return {?}
     */
    register(user) {
        /** @type {?} */
        const url = this.occEndpoints.getUrl('userRegister');
        /** @type {?} */
        let headers = new HttpHeaders({
            'Content-Type': 'application/json',
        });
        headers = InterceptorUtil.createHeader(USE_CLIENT_TOKEN, true, headers);
        user = this.converter.convert(user, USER_SIGN_UP_SERIALIZER);
        return this.http
            .post(url, user, { headers })
            .pipe(this.converter.pipeable(USER_NORMALIZER));
    }
    /**
     * @param {?} guid
     * @param {?} password
     * @return {?}
     */
    registerGuest(guid, password) {
        /** @type {?} */
        const url = this.occEndpoints.getUrl('userRegister');
        /** @type {?} */
        let headers = new HttpHeaders({
            'Content-Type': 'application/x-www-form-urlencoded',
        });
        headers = InterceptorUtil.createHeader(USE_CLIENT_TOKEN, true, headers);
        /** @type {?} */
        const httpParams = new HttpParams()
            .set('guid', guid)
            .set('password', password);
        return this.http
            .post(url, httpParams, { headers })
            .pipe(this.converter.pipeable(USER_NORMALIZER));
    }
    /**
     * @param {?} userEmailAddress
     * @return {?}
     */
    requestForgotPasswordEmail(userEmailAddress) {
        /** @type {?} */
        const url = this.occEndpoints.getUrl('userForgotPassword');
        /** @type {?} */
        const httpParams = new HttpParams().set('userId', userEmailAddress);
        /** @type {?} */
        let headers = new HttpHeaders({
            'Content-Type': 'application/x-www-form-urlencoded',
        });
        headers = InterceptorUtil.createHeader(USE_CLIENT_TOKEN, true, headers);
        return this.http.post(url, httpParams, { headers });
    }
    /**
     * @param {?} token
     * @param {?} newPassword
     * @return {?}
     */
    resetPassword(token, newPassword) {
        /** @type {?} */
        const url = this.occEndpoints.getUrl('userResetPassword');
        /** @type {?} */
        let headers = new HttpHeaders({
            'Content-Type': 'application/json',
        });
        headers = InterceptorUtil.createHeader(USE_CLIENT_TOKEN, true, headers);
        return this.http.post(url, { token, newPassword }, { headers });
    }
    /**
     * @param {?} userId
     * @param {?} currentPassword
     * @param {?} newUserId
     * @return {?}
     */
    updateEmail(userId, currentPassword, newUserId) {
        /** @type {?} */
        const url = this.occEndpoints.getUrl('userUpdateLoginId', { userId });
        /** @type {?} */
        const httpParams = new HttpParams()
            .set('password', currentPassword)
            .set('newLogin', newUserId);
        /** @type {?} */
        const headers = new HttpHeaders({
            'Content-Type': 'application/x-www-form-urlencoded',
        });
        return this.http.put(url, httpParams, { headers });
    }
    /**
     * @param {?} userId
     * @param {?} oldPassword
     * @param {?} newPassword
     * @return {?}
     */
    updatePassword(userId, oldPassword, newPassword) {
        /** @type {?} */
        const url = this.occEndpoints.getUrl('userUpdatePassword', { userId });
        /** @type {?} */
        const httpParams = new HttpParams()
            .set('old', oldPassword)
            .set('new', newPassword);
        /** @type {?} */
        const headers = new HttpHeaders({
            'Content-Type': 'application/x-www-form-urlencoded',
        });
        return this.http.put(url, httpParams, { headers });
    }
    /**
     * @param {?} userId
     * @return {?}
     */
    remove(userId) {
        /** @type {?} */
        const url = this.occEndpoints.getUrl('user', { userId });
        return this.http.delete(url);
    }
    /**
     * @return {?}
     */
    loadTitles() {
        /** @type {?} */
        const url = this.occEndpoints.getUrl('titles');
        return this.http.get(url).pipe(map((/**
         * @param {?} titleList
         * @return {?}
         */
        titleList => titleList.titles)), this.converter.pipeableMany(TITLE_NORMALIZER));
    }
}
OccUserAdapter.decorators = [
    { type: Injectable }
];
/** @nocollapse */
OccUserAdapter.ctorParameters = () => [
    { type: HttpClient },
    { type: OccEndpointsService },
    { type: ConverterService }
];
if (false) {
    /**
     * @type {?}
     * @protected
     */
    OccUserAdapter.prototype.http;
    /**
     * @type {?}
     * @protected
     */
    OccUserAdapter.prototype.occEndpoints;
    /**
     * @type {?}
     * @protected
     */
    OccUserAdapter.prototype.converter;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @abstract
 */
class AnonymousConsentTemplatesAdapter {
}
if (false) {
    /**
     * Abstract method used to load anonymous consents.
     * @abstract
     * @return {?}
     */
    AnonymousConsentTemplatesAdapter.prototype.loadAnonymousConsentTemplates = function () { };
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @abstract
 */
class UserAddressAdapter {
}
if (false) {
    /**
     * @abstract
     * @param {?} userId
     * @return {?}
     */
    UserAddressAdapter.prototype.loadAll = function (userId) { };
    /**
     * @abstract
     * @param {?} userId
     * @param {?} address
     * @return {?}
     */
    UserAddressAdapter.prototype.add = function (userId, address) { };
    /**
     * @abstract
     * @param {?} userId
     * @param {?} addressId
     * @param {?} address
     * @return {?}
     */
    UserAddressAdapter.prototype.update = function (userId, addressId, address) { };
    /**
     * @abstract
     * @param {?} userId
     * @param {?} address
     * @return {?}
     */
    UserAddressAdapter.prototype.verify = function (userId, address) { };
    /**
     * @abstract
     * @param {?} userId
     * @param {?} addressId
     * @return {?}
     */
    UserAddressAdapter.prototype.delete = function (userId, addressId) { };
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @abstract
 */
class UserConsentAdapter {
}
if (false) {
    /**
     * @abstract
     * @param {?} userId
     * @return {?}
     */
    UserConsentAdapter.prototype.loadConsents = function (userId) { };
    /**
     * @abstract
     * @param {?} userId
     * @param {?} consentTemplateId
     * @param {?} consentTemplateVersion
     * @return {?}
     */
    UserConsentAdapter.prototype.giveConsent = function (userId, consentTemplateId, consentTemplateVersion) { };
    /**
     * @abstract
     * @param {?} userId
     * @param {?} consentCode
     * @return {?}
     */
    UserConsentAdapter.prototype.withdrawConsent = function (userId, consentCode) { };
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @abstract
 */
class UserOrderAdapter {
}
if (false) {
    /**
     * Abstract method used to load order data.
     *
     * @abstract
     * @param {?} userId The `userId` for given user
     * @param {?} orderCode The `orderCode` for given order
     * @return {?}
     */
    UserOrderAdapter.prototype.load = function (userId, orderCode) { };
    /**
     * Abstract method used to load order history for an user.
     *
     * @abstract
     * @param {?} userId The `userId` for given user
     * @param {?} pageSize
     * @param {?} currentPage
     * @param {?} sort Sorting method
     * @return {?}
     */
    UserOrderAdapter.prototype.loadHistory = function (userId, pageSize, currentPage, sort) { };
    /**
     * Abstract method used to get consignment tracking details
     * @abstract
     * @param {?} orderCode an order code
     * @param {?} consignmentCode a consignment code
     * @param {?=} userId user id related to order
     * @return {?}
     */
    UserOrderAdapter.prototype.getConsignmentTracking = function (orderCode, consignmentCode, userId) { };
    /**
     * Abstract method used to create return request
     * @abstract
     * @param {?} userId The `userId` for given user
     * @param {?} returnRequestInput Return request entry input list
     * @return {?}
     */
    UserOrderAdapter.prototype.createReturnRequest = function (userId, returnRequestInput) { };
    /**
     * Abstract method used to load order return request details
     * @abstract
     * @param {?} userId
     * @param {?} returnRequestCode
     * @return {?}
     */
    UserOrderAdapter.prototype.loadReturnRequestDetail = function (userId, returnRequestCode) { };
    /**
     * Abstract method used to load order return request list for an user.
     * @abstract
     * @param {?} userId
     * @param {?} pageSize
     * @param {?} currentPage
     * @param {?} sort
     * @return {?}
     */
    UserOrderAdapter.prototype.loadReturnRequestList = function (userId, pageSize, currentPage, sort) { };
    /**
     * Abstract method used to cancel order
     * @abstract
     * @param {?} userId
     * @param {?} orderCode
     * @param {?} cancelRequestInput Cancel request entry input list
     * @return {?}
     */
    UserOrderAdapter.prototype.cancel = function (userId, orderCode, cancelRequestInput) { };
    /**
     * Abstract method used to cancel one return request
     * @abstract
     * @param {?} userId
     * @param {?} returnRequestCode
     * @param {?} returnRequestModification
     * @return {?}
     */
    UserOrderAdapter.prototype.cancelReturnRequest = function (userId, returnRequestCode, returnRequestModification) { };
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @abstract
 */
class UserPaymentAdapter {
}
if (false) {
    /**
     * @abstract
     * @param {?} userId
     * @return {?}
     */
    UserPaymentAdapter.prototype.loadAll = function (userId) { };
    /**
     * @abstract
     * @param {?} userId
     * @param {?} paymentMethodID
     * @return {?}
     */
    UserPaymentAdapter.prototype.delete = function (userId, paymentMethodID) { };
    /**
     * @abstract
     * @param {?} userId
     * @param {?} paymentMethodID
     * @return {?}
     */
    UserPaymentAdapter.prototype.setDefault = function (userId, paymentMethodID) { };
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @abstract
 */
class UserAdapter {
}
if (false) {
    /**
     * @abstract
     * @param {?} userId
     * @return {?}
     */
    UserAdapter.prototype.load = function (userId) { };
    /**
     * @abstract
     * @param {?} username
     * @param {?} user
     * @return {?}
     */
    UserAdapter.prototype.update = function (username, user) { };
    /**
     * @abstract
     * @param {?} user
     * @return {?}
     */
    UserAdapter.prototype.register = function (user) { };
    /**
     * @abstract
     * @param {?} guid
     * @param {?} password
     * @return {?}
     */
    UserAdapter.prototype.registerGuest = function (guid, password) { };
    /**
     * @abstract
     * @param {?} userEmailAddress
     * @return {?}
     */
    UserAdapter.prototype.requestForgotPasswordEmail = function (userEmailAddress) { };
    /**
     * @abstract
     * @param {?} token
     * @param {?} newPassword
     * @return {?}
     */
    UserAdapter.prototype.resetPassword = function (token, newPassword) { };
    /**
     * @abstract
     * @param {?} userId
     * @param {?} currentPassword
     * @param {?} newUserId
     * @return {?}
     */
    UserAdapter.prototype.updateEmail = function (userId, currentPassword, newUserId) { };
    /**
     * @abstract
     * @param {?} userId
     * @param {?} oldPassword
     * @param {?} newPassword
     * @return {?}
     */
    UserAdapter.prototype.updatePassword = function (userId, oldPassword, newPassword) { };
    /**
     * @abstract
     * @param {?} userId
     * @return {?}
     */
    UserAdapter.prototype.remove = function (userId) { };
    /**
     * @abstract
     * @return {?}
     */
    UserAdapter.prototype.loadTitles = function () { };
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const defaultOccUserConfig = {
    backend: {
        occ: {
            endpoints: {
                // tslint:disable:max-line-length
                user: 'users/${userId}',
                userRegister: 'users',
                userForgotPassword: 'forgottenpasswordtokens',
                userResetPassword: 'resetpassword',
                userUpdateLoginId: 'users/${userId}/login',
                userUpdatePassword: 'users/${userId}/password',
                titles: 'titles',
                paymentDetailsAll: 'users/${userId}/paymentdetails',
                paymentDetail: 'users/${userId}/paymentdetails/${paymentDetailId}',
                orderHistory: 'users/${userId}/orders',
                orderDetail: 'users/${userId}/orders/${orderId}?fields=FULL',
                anonymousConsentTemplates: 'users/anonymous/consenttemplates',
                consentTemplates: 'users/${userId}/consenttemplates',
                consents: 'users/${userId}/consents',
                consentDetail: 'users/${userId}/consents/${consentId}',
                addresses: 'users/${userId}/addresses',
                addressDetail: 'users/${userId}/addresses/${addressId}',
                addressVerification: 'users/${userId}/addresses/verification',
                consignmentTracking: 'users/${userId}/orders/${orderCode}/consignments/${consignmentCode}/tracking',
                customerCoupons: 'users/${userId}/customercoupons',
                claimCoupon: 'users/${userId}/customercoupons/${couponCode}/claim',
                couponNotification: 'users/${userId}/customercoupons/${couponCode}/notification',
                notificationPreference: 'users/${userId}/notificationpreferences',
                productInterests: 'users/${userId}/productinterests',
                getProductInterests: 'users/${userId}/productinterests?fields=sorts,pagination,results(productInterestEntry,product(code))',
                cancelOrder: 'users/${userId}/orders/${orderId}/cancellation',
                returnOrder: 'users/${userId}/orderReturns?fields=BASIC,returnEntries(BASIC,refundAmount(formattedValue),orderEntry(basePrice(formattedValue),product(name,code,baseOptions,images(DEFAULT,galleryIndex)))),deliveryCost(formattedValue),totalPrice(formattedValue),subTotal(formattedValue)',
                orderReturns: 'users/${userId}/orderReturns?fields=BASIC',
                orderReturnDetail: 'users/${userId}/orderReturns/${returnRequestCode}?fields=BASIC,returnEntries(BASIC,refundAmount(formattedValue),orderEntry(basePrice(formattedValue),product(name,code,baseOptions,images(DEFAULT,galleryIndex)))),deliveryCost(formattedValue),totalPrice(formattedValue),subTotal(formattedValue)',
                cancelReturn: 'users/${userId}/orderReturns/${returnRequestCode}',
            },
        },
    },
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @abstract
 */
class CustomerCouponAdapter {
}
if (false) {
    /**
     * @abstract
     * @param {?} userId
     * @param {?} pageSize
     * @param {?} currentPage
     * @param {?} sort
     * @return {?}
     */
    CustomerCouponAdapter.prototype.getCustomerCoupons = function (userId, pageSize, currentPage, sort) { };
    /**
     * @abstract
     * @param {?} userId
     * @param {?} couponCode
     * @return {?}
     */
    CustomerCouponAdapter.prototype.turnOnNotification = function (userId, couponCode) { };
    /**
     * @abstract
     * @param {?} userId
     * @param {?} couponCode
     * @return {?}
     */
    CustomerCouponAdapter.prototype.turnOffNotification = function (userId, couponCode) { };
    /**
     * @abstract
     * @param {?} userId
     * @param {?} couponCode
     * @return {?}
     */
    CustomerCouponAdapter.prototype.claimCustomerCoupon = function (userId, couponCode) { };
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const CUSTOMER_COUPON_SEARCH_RESULT_NORMALIZER = new InjectionToken('CustomerCouponSearchResultNormalizer');

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class OccCustomerCouponAdapter {
    /**
     * @param {?} http
     * @param {?} occEndpoints
     * @param {?} converter
     */
    constructor(http, occEndpoints, converter) {
        this.http = http;
        this.occEndpoints = occEndpoints;
        this.converter = converter;
    }
    /**
     * @param {?} userId
     * @param {?} pageSize
     * @param {?} currentPage
     * @param {?} sort
     * @return {?}
     */
    getCustomerCoupons(userId, pageSize, currentPage, sort) {
        /** @type {?} */
        const url = this.occEndpoints.getUrl('customerCoupons', { userId });
        /** @type {?} */
        let params = new HttpParams().set('sort', sort ? sort : 'startDate:asc');
        if (pageSize) {
            params = params.set('pageSize', pageSize.toString());
        }
        if (currentPage) {
            params = params.set('currentPage', currentPage.toString());
        }
        /** @type {?} */
        const headers = this.newHttpHeader();
        return this.http
            .get(url, { headers, params })
            .pipe(this.converter.pipeable(CUSTOMER_COUPON_SEARCH_RESULT_NORMALIZER));
    }
    /**
     * @param {?} userId
     * @param {?} couponCode
     * @return {?}
     */
    turnOffNotification(userId, couponCode) {
        /** @type {?} */
        const url = this.occEndpoints.getUrl('couponNotification', {
            userId,
            couponCode,
        });
        /** @type {?} */
        const headers = this.newHttpHeader();
        return this.http.delete(url, { headers });
    }
    /**
     * @param {?} userId
     * @param {?} couponCode
     * @return {?}
     */
    turnOnNotification(userId, couponCode) {
        /** @type {?} */
        const url = this.occEndpoints.getUrl('couponNotification', {
            userId,
            couponCode,
        });
        /** @type {?} */
        const headers = this.newHttpHeader();
        return this.http.post(url, { headers });
    }
    /**
     * @param {?} userId
     * @param {?} couponCode
     * @return {?}
     */
    claimCustomerCoupon(userId, couponCode) {
        /** @type {?} */
        const url = this.occEndpoints.getUrl('claimCoupon', {
            userId,
            couponCode,
        });
        /** @type {?} */
        const headers = this.newHttpHeader();
        return this.http.post(url, { headers });
    }
    /**
     * @private
     * @return {?}
     */
    newHttpHeader() {
        return new HttpHeaders({
            'Content-Type': 'application/json',
        });
    }
}
OccCustomerCouponAdapter.decorators = [
    { type: Injectable }
];
/** @nocollapse */
OccCustomerCouponAdapter.ctorParameters = () => [
    { type: HttpClient },
    { type: OccEndpointsService },
    { type: ConverterService }
];
if (false) {
    /**
     * @type {?}
     * @protected
     */
    OccCustomerCouponAdapter.prototype.http;
    /**
     * @type {?}
     * @protected
     */
    OccCustomerCouponAdapter.prototype.occEndpoints;
    /**
     * @type {?}
     * @protected
     */
    OccCustomerCouponAdapter.prototype.converter;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @abstract
 */
class UserNotificationPreferenceAdapter {
}
if (false) {
    /**
     * Abstract method used to load notification preferences for an user.
     *
     * @abstract
     * @param {?} userId The `userId` for given user
     * @return {?}
     */
    UserNotificationPreferenceAdapter.prototype.loadAll = function (userId) { };
    /**
     * Abstract method used to update notification preferences for an user.
     *
     * @abstract
     * @param {?} userId The `userId` for given user
     * @param {?} preferences The notification preferences to be updated.
     * @return {?}
     */
    UserNotificationPreferenceAdapter.prototype.update = function (userId, preferences) { };
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const NOTIFICATION_PREFERENCE_SERIALIZER = new InjectionToken('NotificationPreferenceSerializer');
/** @type {?} */
const NOTIFICATION_PREFERENCE_NORMALIZER = new InjectionToken('NotificationPreferenceNormalizer');

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class UserNotificationPreferenceConnector {
    /**
     * @param {?} adapter
     */
    constructor(adapter) {
        this.adapter = adapter;
    }
    /**
     * @param {?} userId
     * @return {?}
     */
    loadAll(userId) {
        return this.adapter.loadAll(userId);
    }
    /**
     * @param {?} userId
     * @param {?} preferences
     * @return {?}
     */
    update(userId, preferences) {
        return this.adapter.update(userId, preferences);
    }
}
UserNotificationPreferenceConnector.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root',
            },] }
];
/** @nocollapse */
UserNotificationPreferenceConnector.ctorParameters = () => [
    { type: UserNotificationPreferenceAdapter }
];
/** @nocollapse */ UserNotificationPreferenceConnector.ngInjectableDef = ɵɵdefineInjectable({ factory: function UserNotificationPreferenceConnector_Factory() { return new UserNotificationPreferenceConnector(ɵɵinject(UserNotificationPreferenceAdapter)); }, token: UserNotificationPreferenceConnector, providedIn: "root" });
if (false) {
    /**
     * @type {?}
     * @protected
     */
    UserNotificationPreferenceConnector.prototype.adapter;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const headers = new HttpHeaders({
    'Content-Type': 'application/json',
});
class OccUserNotificationPreferenceAdapter {
    /**
     * @param {?} http
     * @param {?} converter
     * @param {?} occEndpoints
     */
    constructor(http, converter, occEndpoints) {
        this.http = http;
        this.converter = converter;
        this.occEndpoints = occEndpoints;
    }
    /**
     * @param {?} userId
     * @return {?}
     */
    loadAll(userId) {
        return this.http
            .get(this.occEndpoints.getUrl('notificationPreference', { userId }), {
            headers,
        })
            .pipe(map((/**
         * @param {?} list
         * @return {?}
         */
        list => list.preferences)), this.converter.pipeableMany(NOTIFICATION_PREFERENCE_NORMALIZER), catchError((/**
         * @param {?} error
         * @return {?}
         */
        (error) => throwError(error))));
    }
    /**
     * @param {?} userId
     * @param {?} preferences
     * @return {?}
     */
    update(userId, preferences) {
        preferences = this.converter.convert(preferences, NOTIFICATION_PREFERENCE_SERIALIZER);
        return this.http
            .patch(this.occEndpoints.getUrl('notificationPreference', { userId }), { preferences: preferences }, { headers })
            .pipe(catchError((/**
         * @param {?} error
         * @return {?}
         */
        (error) => throwError(error))));
    }
}
OccUserNotificationPreferenceAdapter.decorators = [
    { type: Injectable }
];
/** @nocollapse */
OccUserNotificationPreferenceAdapter.ctorParameters = () => [
    { type: HttpClient },
    { type: ConverterService },
    { type: OccEndpointsService }
];
if (false) {
    /**
     * @type {?}
     * @protected
     */
    OccUserNotificationPreferenceAdapter.prototype.http;
    /**
     * @type {?}
     * @protected
     */
    OccUserNotificationPreferenceAdapter.prototype.converter;
    /**
     * @type {?}
     * @protected
     */
    OccUserNotificationPreferenceAdapter.prototype.occEndpoints;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const PRODUCT_INTERESTS_NORMALIZER = new InjectionToken('ProductInterestsNormalizer');

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const headers$1 = new HttpHeaders({
    'Content-Type': 'application/json',
});
class OccUserInterestsAdapter {
    /**
     * @param {?} http
     * @param {?} occEndpoints
     * @param {?} config
     * @param {?} converter
     */
    constructor(http, occEndpoints, config, converter) {
        this.http = http;
        this.occEndpoints = occEndpoints;
        this.config = config;
        this.converter = converter;
    }
    /**
     * @param {?} userId
     * @param {?=} pageSize
     * @param {?=} currentPage
     * @param {?=} sort
     * @param {?=} productCode
     * @param {?=} notificationType
     * @return {?}
     */
    getInterests(userId, pageSize, currentPage, sort, productCode, notificationType) {
        /** @type {?} */
        let params = new HttpParams().set('sort', sort ? sort : 'name:asc');
        if (pageSize) {
            params = params.set('pageSize', pageSize.toString());
        }
        if (currentPage) {
            params = params.set('currentPage', currentPage.toString());
        }
        if (productCode) {
            params = params.set('productCode', productCode);
        }
        if (notificationType) {
            params = params.set('notificationType', notificationType.toString());
        }
        return this.http
            .get(this.occEndpoints.getUrl('getProductInterests', { userId }), {
            headers: headers$1,
            params,
        })
            .pipe(this.converter.pipeable(PRODUCT_INTERESTS_NORMALIZER), catchError((/**
         * @param {?} error
         * @return {?}
         */
        (error) => throwError(error))));
    }
    /**
     * @param {?} userId
     * @param {?} item
     * @return {?}
     */
    removeInterest(userId, item) {
        /** @type {?} */
        const r = [];
        item.productInterestEntry.forEach((/**
         * @param {?} entry
         * @return {?}
         */
        (entry) => {
            /** @type {?} */
            const params = new HttpParams()
                .set('productCode', item.product.code)
                .set('notificationType', entry.interestType);
            r.push(this.http
                .delete(this.occEndpoints.getUrl('productInterests', { userId }), {
                params: params,
            })
                .pipe(catchError((/**
             * @param {?} error
             * @return {?}
             */
            (error) => throwError(error)))));
        }));
        return forkJoin(r);
    }
    /**
     * @param {?} userId
     * @param {?} productCode
     * @param {?} notificationType
     * @return {?}
     */
    addInterest(userId, productCode, notificationType) {
        /** @type {?} */
        const params = new HttpParams()
            .set('productCode', productCode)
            .set('notificationType', notificationType.toString());
        return this.http
            .post(this.occEndpoints.getUrl('productInterests', { userId }), {}, {
            headers: headers$1,
            params,
        })
            .pipe(catchError((/**
         * @param {?} error
         * @return {?}
         */
        (error) => throwError(error))));
    }
}
OccUserInterestsAdapter.decorators = [
    { type: Injectable }
];
/** @nocollapse */
OccUserInterestsAdapter.ctorParameters = () => [
    { type: HttpClient },
    { type: OccEndpointsService },
    { type: OccConfig },
    { type: ConverterService }
];
if (false) {
    /**
     * @type {?}
     * @protected
     */
    OccUserInterestsAdapter.prototype.http;
    /**
     * @type {?}
     * @protected
     */
    OccUserInterestsAdapter.prototype.occEndpoints;
    /**
     * @type {?}
     * @protected
     */
    OccUserInterestsAdapter.prototype.config;
    /**
     * @type {?}
     * @protected
     */
    OccUserInterestsAdapter.prototype.converter;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @abstract
 */
class UserInterestsAdapter {
}
if (false) {
    /**
     * Abstract method used to load product interests for an user.
     *
     * @abstract
     * @param {?} userId The `userId` for given user
     * @param {?=} pageSize
     * @param {?=} currentPage
     * @param {?=} sort Sorting method
     * @param {?=} productCode The product code
     * @param {?=} notificationType The notification type
     * @return {?}
     */
    UserInterestsAdapter.prototype.getInterests = function (userId, pageSize, currentPage, sort, productCode, notificationType) { };
    /**
     * Abstract method used to remove product interest for an user.
     *
     * @abstract
     * @param {?} userId The `userId` for given user
     * @param {?} item
     * @return {?}
     */
    UserInterestsAdapter.prototype.removeInterest = function (userId, item) { };
    /**
     * Abstract method to add a product interest for an user.
     *
     * @abstract
     * @param {?} userId The `userId` for given user
     * @param {?} productCode The product code
     * @param {?} notificationType The notification type
     * @return {?}
     */
    UserInterestsAdapter.prototype.addInterest = function (userId, productCode, notificationType) { };
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class OccUserInterestsNormalizer {
    /**
     * @param {?} converter
     */
    constructor(converter) {
        this.converter = converter;
    }
    /**
     * @param {?} source
     * @param {?=} target
     * @return {?}
     */
    convert(source, target) {
        if (target === undefined) {
            target = Object.assign({}, ((/** @type {?} */ (source))));
        }
        if (source && source.results) {
            target.results = source.results.map((/**
             * @param {?} result
             * @return {?}
             */
            result => (Object.assign({}, result, { product: this.converter.convert(result.product, PRODUCT_NORMALIZER) }))));
        }
        return target;
    }
}
OccUserInterestsNormalizer.decorators = [
    { type: Injectable, args: [{ providedIn: 'root' },] }
];
/** @nocollapse */
OccUserInterestsNormalizer.ctorParameters = () => [
    { type: ConverterService }
];
/** @nocollapse */ OccUserInterestsNormalizer.ngInjectableDef = ɵɵdefineInjectable({ factory: function OccUserInterestsNormalizer_Factory() { return new OccUserInterestsNormalizer(ɵɵinject(ConverterService)); }, token: OccUserInterestsNormalizer, providedIn: "root" });
if (false) {
    /**
     * @type {?}
     * @private
     */
    OccUserInterestsNormalizer.prototype.converter;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class OccReturnRequestNormalizer {
    /**
     * @param {?} converter
     */
    constructor(converter) {
        this.converter = converter;
    }
    /**
     * @param {?} source
     * @param {?=} target
     * @return {?}
     */
    convert(source, target) {
        if (target === undefined) {
            target = Object.assign({}, ((/** @type {?} */ (source))));
        }
        if (source.returnEntries) {
            target.returnEntries = source.returnEntries.map((/**
             * @param {?} entry
             * @return {?}
             */
            entry => (Object.assign({}, entry, { orderEntry: this.convertOrderEntry(entry.orderEntry) }))));
        }
        return target;
    }
    /**
     * @private
     * @param {?} source
     * @return {?}
     */
    convertOrderEntry(source) {
        return Object.assign({}, source, { product: this.converter.convert(source.product, PRODUCT_NORMALIZER) });
    }
}
OccReturnRequestNormalizer.decorators = [
    { type: Injectable, args: [{ providedIn: 'root' },] }
];
/** @nocollapse */
OccReturnRequestNormalizer.ctorParameters = () => [
    { type: ConverterService }
];
/** @nocollapse */ OccReturnRequestNormalizer.ngInjectableDef = ɵɵdefineInjectable({ factory: function OccReturnRequestNormalizer_Factory() { return new OccReturnRequestNormalizer(ɵɵinject(ConverterService)); }, token: OccReturnRequestNormalizer, providedIn: "root" });
if (false) {
    /**
     * @type {?}
     * @private
     */
    OccReturnRequestNormalizer.prototype.converter;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class UserOccModule {
}
UserOccModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    HttpClientModule,
                    ConfigModule.withConfig(defaultOccUserConfig),
                ],
                providers: [
                    { provide: UserAdapter, useClass: OccUserAdapter },
                    { provide: UserAddressAdapter, useClass: OccUserAddressAdapter },
                    { provide: UserConsentAdapter, useClass: OccUserConsentAdapter },
                    {
                        provide: AnonymousConsentTemplatesAdapter,
                        useClass: OccAnonymousConsentTemplatesAdapter,
                    },
                    {
                        provide: UserPaymentAdapter,
                        useClass: OccUserPaymentAdapter,
                    },
                    { provide: UserOrderAdapter, useClass: OccUserOrderAdapter },
                    { provide: CustomerCouponAdapter, useClass: OccCustomerCouponAdapter },
                    {
                        provide: UserNotificationPreferenceAdapter,
                        useClass: OccUserNotificationPreferenceAdapter,
                    },
                    { provide: UserInterestsAdapter, useClass: OccUserInterestsAdapter },
                    {
                        provide: PRODUCT_INTERESTS_NORMALIZER,
                        useExisting: OccUserInterestsNormalizer,
                        multi: true,
                    },
                    {
                        provide: ORDER_RETURN_REQUEST_NORMALIZER,
                        useExisting: OccReturnRequestNormalizer,
                        multi: true,
                    },
                ],
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class JavaRegExpConverter {
    constructor() {
        /**
         * Pattern that extracts modifiers from the Java regexp.
         *
         * Java regexps MAY start with ONE or MANY modifiers like `(?MODIFIERS)PATTERN`. Examples:
         * - `(?i)` for Case Insensitive Mode: `(?i)PATTERN`
         * - `(?u)` for Unicode-Aware Case Folding; `(?u)PATTERN`
         * - or multiple combined:  `(?iu)PATTERN`
         * - (more modifiers in the official Java docs https://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html)
         *
         * This pattern extracts 3 parts from the input string, i.e. for `(?iu)PATTERN`:
         *    1. original modifiers syntax, i.e. `(?iu)` (or undefined if no modifiers present)
         *    2. extracted modifiers, i.e. `iu` (or undefined if no modifiers present)
         *    3. the rest of the regexp, i.e. `PATTERN`
         */
        this.EXTRACT_JAVA_REGEXP_MODIFIERS = /^(\(\?([a-z]+)\))?(.*)/;
    }
    /**
     * Converts RegExp from Java syntax to Javascript, by recognizing Java regexp modifiers
     * and converting them to the Javascript ones (i.e. case insensitive mode: `(?i)PATTERN` -> `/pattern/i`)
     *
     * **CAUTION!** Not all features and modifiers of Java regexps are valid in Javascript!
     * If unsupported feature or modifier is used, then `null` will be returned instead of Javascript RegExp.
     *
     * See differences between Java and Javascript regexps:
     * - https://stackoverflow.com/questions/8754444/convert-javascript-regular-expression-to-java-syntax
     * - https://en.wikipedia.org/wiki/Comparison_of_regular_expression_engines#Language_features
     * @param {?} javaSyntax
     * @return {?}
     */
    toJsRegExp(javaSyntax) {
        /** @type {?} */
        const parts = javaSyntax.match(this.EXTRACT_JAVA_REGEXP_MODIFIERS);
        if (!parts) {
            return null;
        }
        const [, , modifiers, jsSyntax] = parts;
        try {
            return new RegExp(jsSyntax, modifiers);
        }
        catch (error) {
            if (isDevMode()) {
                console.warn(`WARNING: Could not convert Java regexp into Javascript. Original regexp: ${javaSyntax} \nMessage: ${error}`);
            }
            return null;
        }
    }
}
JavaRegExpConverter.decorators = [
    { type: Injectable, args: [{ providedIn: 'root' },] }
];
/** @nocollapse */ JavaRegExpConverter.ngInjectableDef = ɵɵdefineInjectable({ factory: function JavaRegExpConverter_Factory() { return new JavaRegExpConverter(); }, token: JavaRegExpConverter, providedIn: "root" });
if (false) {
    /**
     * Pattern that extracts modifiers from the Java regexp.
     *
     * Java regexps MAY start with ONE or MANY modifiers like `(?MODIFIERS)PATTERN`. Examples:
     * - `(?i)` for Case Insensitive Mode: `(?i)PATTERN`
     * - `(?u)` for Unicode-Aware Case Folding; `(?u)PATTERN`
     * - or multiple combined:  `(?iu)PATTERN`
     * - (more modifiers in the official Java docs https://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html)
     *
     * This pattern extracts 3 parts from the input string, i.e. for `(?iu)PATTERN`:
     *    1. original modifiers syntax, i.e. `(?iu)` (or undefined if no modifiers present)
     *    2. extracted modifiers, i.e. `iu` (or undefined if no modifiers present)
     *    3. the rest of the regexp, i.e. `PATTERN`
     * @type {?}
     * @private
     */
    JavaRegExpConverter.prototype.EXTRACT_JAVA_REGEXP_MODIFIERS;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * The url of the server request when running SSR
 *
 * @type {?}
 */
const SERVER_REQUEST_URL = new InjectionToken('SERVER_REQUEST_URL');
/**
 * The url of the server request host when running SSR
 *
 * @type {?}
 */
const SERVER_REQUEST_ORIGIN = new InjectionToken('SERVER_REQUEST_ORIGIN');

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class OccLoadedConfigConverter {
    /**
     * @param {?} javaRegExpConverter
     */
    constructor(javaRegExpConverter) {
        this.javaRegExpConverter = javaRegExpConverter;
    }
    /**
     * @param {?} baseSites
     * @param {?} currentUrl
     * @return {?}
     */
    fromOccBaseSites(baseSites, currentUrl) {
        /** @type {?} */
        const baseSite = baseSites.find((/**
         * @param {?} site
         * @return {?}
         */
        site => this.isCurrentBaseSite(site, currentUrl)));
        if (!baseSite) {
            throw this.getError(`Current url (${currentUrl}) doesn't match with any of url patterns of any base site.`);
        }
        // Although `stores` property is an array, typically there is only one store. So we return the first store from the list.
        /** @type {?} */
        const baseStore = baseSite.stores && baseSite.stores[0];
        if (!baseStore) {
            throw this.getError(`Current base site (${baseSite.uid}) doesn't have any base store.`);
        }
        return {
            baseSite: baseSite.uid,
            languages: this.getIsoCodes(baseStore.languages, baseSite.defaultLanguage || baseStore.defaultLanguage),
            currencies: this.getIsoCodes(baseStore.currencies, baseStore.defaultCurrency),
            urlParameters: this.getUrlParams(baseSite.urlEncodingAttributes),
        };
    }
    /**
     * @param {?} __0
     * @return {?}
     */
    toSiteContextConfig({ baseSite, languages, currencies, urlParameters: urlEncodingAttributes, }) {
        /** @type {?} */
        const result = {
            context: {
                urlParameters: urlEncodingAttributes,
                [BASE_SITE_CONTEXT_ID]: [baseSite],
                [LANGUAGE_CONTEXT_ID]: languages,
                [CURRENCY_CONTEXT_ID]: currencies,
            },
        };
        return result;
    }
    /**
     * @param {?} __0
     * @return {?}
     */
    toI18nConfig({ languages }) {
        return { i18n: { fallbackLang: languages[0] } };
    }
    /**
     * @private
     * @param {?} site
     * @param {?} currentUrl
     * @return {?}
     */
    isCurrentBaseSite(site, currentUrl) {
        /** @type {?} */
        const index = (site.urlPatterns || []).findIndex((/**
         * @param {?} javaRegexp
         * @return {?}
         */
        javaRegexp => {
            /** @type {?} */
            const jsRegexp = this.javaRegExpConverter.toJsRegExp(javaRegexp);
            if (jsRegexp) {
                /** @type {?} */
                const result = jsRegexp.test(currentUrl);
                return result;
            }
        }));
        return index !== -1;
    }
    /**
     * Returns an array of url encoded site context parameters.
     *
     * It maps the string "storefront" (used in OCC) to the "baseSite" (used in Spartacus)
     * @private
     * @param {?} params
     * @return {?}
     */
    getUrlParams(params) {
        /** @type {?} */
        const STOREFRONT_PARAM = 'storefront';
        return (params || []).map((/**
         * @param {?} param
         * @return {?}
         */
        param => param === STOREFRONT_PARAM ? BASE_SITE_CONTEXT_ID : param));
    }
    /**
     * Returns iso codes in a array, where the first element is the default iso code.
     * @private
     * @param {?} elements
     * @param {?} defaultElement
     * @return {?}
     */
    getIsoCodes(elements, defaultElement) {
        /** @type {?} */
        const result = this.moveToFirst(elements, (/**
         * @param {?} el
         * @return {?}
         */
        el => el.isocode === defaultElement.isocode)).map((/**
         * @param {?} el
         * @return {?}
         */
        el => el.isocode));
        return result;
    }
    /**
     * Moves to the start of the array the first element that satisfies the given predicate.
     *
     * @private
     * @param {?} array array to modify
     * @param {?} predicate function called on elements
     * @return {?}
     */
    moveToFirst(array, predicate) {
        array = [...array];
        /** @type {?} */
        const index = array.findIndex(predicate);
        if (index !== -1) {
            const [el] = array.splice(index, 1);
            array.unshift(el);
        }
        return array;
    }
    /**
     * @private
     * @param {?} message
     * @return {?}
     */
    getError(message) {
        return new Error(`Error: Cannot get base site config! ${message}`);
    }
}
OccLoadedConfigConverter.decorators = [
    { type: Injectable, args: [{ providedIn: 'root' },] }
];
/** @nocollapse */
OccLoadedConfigConverter.ctorParameters = () => [
    { type: JavaRegExpConverter }
];
/** @nocollapse */ OccLoadedConfigConverter.ngInjectableDef = ɵɵdefineInjectable({ factory: function OccLoadedConfigConverter_Factory() { return new OccLoadedConfigConverter(ɵɵinject(JavaRegExpConverter)); }, token: OccLoadedConfigConverter, providedIn: "root" });
if (false) {
    /**
     * @type {?}
     * @private
     */
    OccLoadedConfigConverter.prototype.javaRegExpConverter;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class OccSitesConfigLoader {
    /**
     * @param {?} config
     * @param {?} http
     */
    constructor(config, http) {
        this.config = config;
        this.http = http;
        this.endpoint = 'basesites?fields=baseSites(uid,defaultLanguage(isocode),urlEncodingAttributes,urlPatterns,stores(currencies(isocode),defaultCurrency(isocode),languages(isocode),defaultLanguage(isocode)))';
    }
    /**
     * @private
     * @return {?}
     */
    get baseEndpoint() {
        return ((this.config.backend.occ.baseUrl || '') + this.config.backend.occ.prefix);
    }
    /**
     * @private
     * @return {?}
     */
    get url() {
        return `${this.baseEndpoint}${this.endpoint}`;
    }
    /**
     * @return {?}
     */
    load() {
        if (!this.config || !this.config.backend || !this.config.backend.occ) {
            return throwError(new Error(`Missing config for OCC backend!`));
        }
        return this.http
            .get(this.url)
            .pipe(map((/**
         * @param {?} __0
         * @return {?}
         */
        ({ baseSites }) => baseSites)));
    }
}
OccSitesConfigLoader.decorators = [
    { type: Injectable, args: [{ providedIn: 'root' },] }
];
/** @nocollapse */
OccSitesConfigLoader.ctorParameters = () => [
    { type: OccConfig },
    { type: HttpClient }
];
/** @nocollapse */ OccSitesConfigLoader.ngInjectableDef = ɵɵdefineInjectable({ factory: function OccSitesConfigLoader_Factory() { return new OccSitesConfigLoader(ɵɵinject(OccConfig), ɵɵinject(HttpClient)); }, token: OccSitesConfigLoader, providedIn: "root" });
if (false) {
    /**
     * @type {?}
     * @protected
     */
    OccSitesConfigLoader.prototype.endpoint;
    /**
     * @type {?}
     * @protected
     */
    OccSitesConfigLoader.prototype.config;
    /**
     * @type {?}
     * @protected
     */
    OccSitesConfigLoader.prototype.http;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const EXTERNAL_CONFIG_TRANSFER_ID = makeStateKey('cx-external-config');
class OccConfigLoaderService {
    /**
     * @param {?} platform
     * @param {?} document
     * @param {?} config
     * @param {?} sitesConfigLoader
     * @param {?} converter
     * @param {?} transferState
     * @param {?=} serverRequestUrl
     */
    constructor(platform, document, config, sitesConfigLoader, converter, transferState, serverRequestUrl) {
        this.platform = platform;
        this.document = document;
        this.config = config;
        this.sitesConfigLoader = sitesConfigLoader;
        this.converter = converter;
        this.transferState = transferState;
        this.serverRequestUrl = serverRequestUrl;
    }
    /**
     * @private
     * @return {?}
     */
    get currentUrl() {
        if (isPlatformBrowser(this.platform)) {
            return this.document.location.href;
        }
        if (this.serverRequestUrl) {
            return this.serverRequestUrl;
        }
        if (isDevMode()) {
            console.error(`Please provide token 'SERVER_REQUEST_URL' with the requested URL for SSR`);
        }
    }
    /**
     * Initializes the Spartacus config asynchronously basing on the external config
     * @return {?}
     */
    loadConfig() {
        return this.get()
            .pipe(tap((/**
         * @param {?} externalConfig
         * @return {?}
         */
        externalConfig => this.transfer(externalConfig))), map((/**
         * @param {?} externalConfig
         * @return {?}
         */
        externalConfig => deepMerge({}, ...this.getConfigChunks(externalConfig)))))
            .toPromise();
    }
    /**
     * Returns the external config
     * @protected
     * @return {?}
     */
    get() {
        /** @type {?} */
        const rehydratedExternalConfig = this.rehydrate();
        return rehydratedExternalConfig
            ? of(rehydratedExternalConfig)
            : this.load();
    }
    /**
     * Loads the external config from backend
     * @protected
     * @return {?}
     */
    load() {
        return this.sitesConfigLoader
            .load()
            .pipe(map((/**
         * @param {?} baseSites
         * @return {?}
         */
        baseSites => this.converter.fromOccBaseSites(baseSites, this.currentUrl))));
    }
    /**
     * Tries to rehydrate external config in the browser from SSR
     * @protected
     * @return {?}
     */
    rehydrate() {
        if (this.transferState && isPlatformBrowser(this.platform)) {
            return this.transferState.get(EXTERNAL_CONFIG_TRANSFER_ID, undefined);
        }
    }
    /**
     * Transfers the given external config in SSR to the browser
     *
     * @protected
     * @param {?} externalConfig
     * @return {?}
     */
    transfer(externalConfig) {
        if (this.transferState &&
            isPlatformServer(this.platform) &&
            externalConfig) {
            this.transferState.set(EXTERNAL_CONFIG_TRANSFER_ID, externalConfig);
        }
    }
    /**
     * @protected
     * @param {?} externalConfig
     * @return {?}
     */
    getConfigChunks(externalConfig) {
        /** @type {?} */
        const chunks = [this.converter.toSiteContextConfig(externalConfig)];
        if (this.shouldReturnI18nChunk()) {
            chunks.push(this.converter.toI18nConfig(externalConfig));
        }
        return chunks;
    }
    /**
     * @private
     * @return {?}
     */
    shouldReturnI18nChunk() {
        /** @type {?} */
        const fallbackLangExists = typeof (this.config &&
            this.config.i18n &&
            this.config.i18n.fallbackLang) !== 'undefined';
        if (fallbackLangExists && isDevMode()) {
            console.warn(`There is an already provided static config for 'i18n.fallbackLang', so the value from OCC loaded config is ignored.`);
        }
        return !fallbackLangExists;
    }
}
OccConfigLoaderService.decorators = [
    { type: Injectable, args: [{ providedIn: 'root' },] }
];
/** @nocollapse */
OccConfigLoaderService.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [PLATFORM_ID,] }] },
    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] },
    { type: undefined, decorators: [{ type: Inject, args: [Config,] }] },
    { type: OccSitesConfigLoader },
    { type: OccLoadedConfigConverter },
    { type: TransferState, decorators: [{ type: Optional }] },
    { type: String, decorators: [{ type: Optional }, { type: Inject, args: [SERVER_REQUEST_URL,] }] }
];
/** @nocollapse */ OccConfigLoaderService.ngInjectableDef = ɵɵdefineInjectable({ factory: function OccConfigLoaderService_Factory() { return new OccConfigLoaderService(ɵɵinject(PLATFORM_ID), ɵɵinject(DOCUMENT), ɵɵinject(Config), ɵɵinject(OccSitesConfigLoader), ɵɵinject(OccLoadedConfigConverter), ɵɵinject(TransferState, 8), ɵɵinject(SERVER_REQUEST_URL, 8)); }, token: OccConfigLoaderService, providedIn: "root" });
if (false) {
    /**
     * @type {?}
     * @protected
     */
    OccConfigLoaderService.prototype.platform;
    /**
     * @type {?}
     * @protected
     */
    OccConfigLoaderService.prototype.document;
    /**
     * @type {?}
     * @protected
     */
    OccConfigLoaderService.prototype.config;
    /**
     * @type {?}
     * @protected
     */
    OccConfigLoaderService.prototype.sitesConfigLoader;
    /**
     * @type {?}
     * @protected
     */
    OccConfigLoaderService.prototype.converter;
    /**
     * @type {?}
     * @protected
     */
    OccConfigLoaderService.prototype.transferState;
    /**
     * @type {?}
     * @protected
     */
    OccConfigLoaderService.prototype.serverRequestUrl;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Initializes the Spartacus config asynchronously basing on the external config
 * @param {?} configLoader
 * @param {?} config
 * @return {?}
 */
function initConfig(configLoader, config) {
    /**
     * Load config for `context` from backend only when there is no static config for `context.baseSite`
     */
    if (!config.context || !config.context[BASE_SITE_CONTEXT_ID]) {
        return {
            scopes: ['context', 'i18n.fallbackLang'],
            configFactory: (/**
             * @return {?}
             */
            () => configLoader.loadConfig()),
        };
    }
    return null;
}
/**
 * Re-provides the external config chunk given before Angular bootstrap
 */
class OccConfigLoaderModule {
    /**
     * @return {?}
     */
    static forRoot() {
        return {
            ngModule: OccConfigLoaderModule,
            providers: [
                {
                    provide: CONFIG_INITIALIZER,
                    useFactory: initConfig,
                    deps: [OccConfigLoaderService, SiteContextConfig],
                    multi: true,
                },
            ],
        };
    }
}
OccConfigLoaderModule.decorators = [
    { type: NgModule }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @record
 */
function OccLoadedConfig() { }
if (false) {
    /**
     * Uid of the base site
     * @type {?|undefined}
     */
    OccLoadedConfig.prototype.baseSite;
    /**
     * List of languages, where the first language is the default one
     * @type {?|undefined}
     */
    OccLoadedConfig.prototype.languages;
    /**
     * List of currencies, where the first currency is the default one
     * @type {?|undefined}
     */
    OccLoadedConfig.prototype.currencies;
    /**
     * Site context parameters to persist in the route
     * @type {?|undefined}
     */
    OccLoadedConfig.prototype.urlParameters;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const OCC_BASE_URL_META_TAG_NAME = 'occ-backend-base-url';
/** @type {?} */
const OCC_BASE_URL_META_TAG_PLACEHOLDER = 'OCC_BACKEND_BASE_URL_VALUE';
/** @type {?} */
const MEDIA_BASE_URL_META_TAG_NAME = 'media-backend-base-url';
/** @type {?} */
const MEDIA_BASE_URL_META_TAG_PLACEHOLDER = 'MEDIA_BACKEND_BASE_URL_VALUE';
/**
 * @param {?} meta
 * @return {?}
 */
function occServerConfigFromMetaTagFactory(meta) {
    /** @type {?} */
    const baseUrl = getMetaTagContent(OCC_BASE_URL_META_TAG_NAME, meta);
    return baseUrl && baseUrl !== OCC_BASE_URL_META_TAG_PLACEHOLDER
        ? { backend: { occ: { baseUrl } } }
        : {};
}
/**
 * @param {?} meta
 * @return {?}
 */
function mediaServerConfigFromMetaTagFactory(meta) {
    /** @type {?} */
    const baseUrl = getMetaTagContent(MEDIA_BASE_URL_META_TAG_NAME, meta);
    return baseUrl && baseUrl !== MEDIA_BASE_URL_META_TAG_PLACEHOLDER
        ? { backend: { media: { baseUrl } } }
        : {};
}
/**
 * @param {?} name
 * @param {?} meta
 * @return {?}
 */
function getMetaTagContent(name, meta) {
    /** @type {?} */
    const metaTag = meta.getTag(`name="${name}"`);
    return metaTag && metaTag.content;
}
/**
 * @return {?}
 */
function provideConfigFromMetaTags() {
    return [
        provideConfigFactory(occServerConfigFromMetaTagFactory, [Meta]),
        provideConfigFactory(mediaServerConfigFromMetaTagFactory, [Meta]),
    ];
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const defaultOccConfig = {
    backend: {
        occ: {
            prefix: '/rest/v2/',
        },
        media: {},
    },
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} config
 * @return {?}
 */
function occConfigValidator(config) {
    if (config.backend === undefined ||
        config.backend.occ === undefined ||
        config.backend.occ.baseUrl === undefined) {
        return 'Please configure backend.occ.baseUrl before using storefront library!';
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Http interceptor to add cookies to all cross-site requests.
 */
class WithCredentialsInterceptor {
    /**
     * @param {?} config
     */
    constructor(config) {
        this.config = config;
    }
    /**
     * Intercepts each request and adds the `withCredential` flag to it
     * if it hasn't been added already.
     * @param {?} request
     * @param {?} next
     * @return {?}
     */
    intercept(request, next) {
        if (this.requiresWithCredentials(request)) {
            request = request.clone({
                withCredentials: true,
            });
        }
        return next.handle(request);
    }
    /**
     * Indicates whether this is an OCC request.
     * @protected
     * @param {?} request
     * @return {?}
     */
    requiresWithCredentials(request) {
        return (
        /**
         * This `occConfig?.useWithCredentials` flag has only been introduced in
         * version 2.0. Customers must provide this interceptors manually in their
         * app to opt-in to use this feature, as we don't backport the configuration.
         */
        // this.occConfig?.useWithCredentials &&
        request.url.indexOf(this.occConfig.prefix) > -1);
    }
    /**
     * @private
     * @return {?}
     */
    get occConfig() {
        return this.config && this.config.backend && this.config.backend.occ
            ? this.config.backend.occ
            : {};
    }
}
WithCredentialsInterceptor.decorators = [
    { type: Injectable, args: [{ providedIn: 'root' },] }
];
/** @nocollapse */
WithCredentialsInterceptor.ctorParameters = () => [
    { type: OccConfig }
];
/** @nocollapse */ WithCredentialsInterceptor.ngInjectableDef = ɵɵdefineInjectable({ factory: function WithCredentialsInterceptor_Factory() { return new WithCredentialsInterceptor(ɵɵinject(OccConfig)); }, token: WithCredentialsInterceptor, providedIn: "root" });
if (false) {
    /**
     * @type {?}
     * @protected
     */
    WithCredentialsInterceptor.prototype.config;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @deprecated since 1.4.0
 *
 * In version 2.0 this provider will be removed, as you no longer need to
 * manually provide this interceptor as it will be provided in the `OccModule`.
 * @type {?}
 */
const withCredentialsInterceptorProvider = {
    provide: HTTP_INTERCEPTORS,
    useExisting: WithCredentialsInterceptor,
    multi: true,
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @record
 */
function OccEndpoints() { }
if (false) {
    /**
     * Client login (get authorization token)
     *
     * \@member {string}
     * @type {?|undefined}
     */
    OccEndpoints.prototype.login;
    /**
     * Client logout (revoke authorization token)
     *
     * \@member {string}
     * @type {?|undefined}
     */
    OccEndpoints.prototype.revoke;
    /**
     * Get product details
     *
     * \@member string
     * @type {?|undefined}
     */
    OccEndpoints.prototype.product;
    /**
     * Get product details for scope
     *
     * \@member Object
     * @type {?|undefined}
     */
    OccEndpoints.prototype.product_scopes;
    /**
     * Get reviews for a product
     *
     * \@member {string}
     * @type {?|undefined}
     */
    OccEndpoints.prototype.productReviews;
    /**
     * Get a list of product references
     *
     * \@member {string}
     * @type {?|undefined}
     */
    OccEndpoints.prototype.productReferences;
    /**
     * Get a list of products and additional data
     *
     * \@member {string}
     * @type {?|undefined}
     */
    OccEndpoints.prototype.productSearch;
    /**
     * Get a list of available suggestions
     *
     * \@member {string}
     * @type {?|undefined}
     */
    OccEndpoints.prototype.productSuggestions;
    /**
     * Get CMS component details
     *
     * \@member {string}
     * @type {?|undefined}
     */
    OccEndpoints.prototype.component;
    /**
     * Get a list of CMS component details
     *
     * \@member {string}
     * @type {?|undefined}
     */
    OccEndpoints.prototype.components;
    /**
     * Get page data with list of cms content slots
     *
     * \@member {string}
     * @type {?|undefined}
     */
    OccEndpoints.prototype.pages;
    /**
     * Get page data with list of cms content slots
     *
     * \@member {string}
     * @type {?|undefined}
     */
    OccEndpoints.prototype.page;
    /**
     * Get all carts
     *
     * \@member {string} [carts]
     * @type {?|undefined}
     */
    OccEndpoints.prototype.carts;
    /**
     * Get a cart with a given identifier
     *
     * \@member {string} [cart]
     * @type {?|undefined}
     */
    OccEndpoints.prototype.cart;
    /**
     * Creates or restore a cart for a user
     *
     * \@member {string} [createCart]
     * @type {?|undefined}
     */
    OccEndpoints.prototype.createCart;
    /**
     * Deletes a cart with a given cart id
     *
     * \@member {string} [deleteCart]
     * @type {?|undefined}
     */
    OccEndpoints.prototype.deleteCart;
    /**
     * Adds a product to the cart
     *
     * \@member {string} [addEntries]
     * @type {?|undefined}
     */
    OccEndpoints.prototype.addEntries;
    /**
     * Update quantity and store the details of a cart entry
     *
     * \@member {string} [updateEntries]
     * @type {?|undefined}
     */
    OccEndpoints.prototype.updateEntries;
    /**
     * Deletes cart entry
     *
     * \@member {string} [removeEntries]
     * @type {?|undefined}
     */
    OccEndpoints.prototype.removeEntries;
    /**
     * Assign email to cart
     *
     * \@member {string} [addEmail]
     * @type {?|undefined}
     */
    OccEndpoints.prototype.addEmail;
    /**
     * Get a store location
     *
     * \@member {string} [page]
     * @type {?|undefined}
     */
    OccEndpoints.prototype.store;
    /**
     * Get a list of store locations
     *
     * \@member {string} [page]
     * @type {?|undefined}
     */
    OccEndpoints.prototype.stores;
    /**
     * Gets a store location count per country and regions
     *
     * \@member {string} [page]
     * @type {?|undefined}
     */
    OccEndpoints.prototype.storescounts;
    /**
     * Get a list of available languages
     *
     * \@member {string}
     * @type {?|undefined}
     */
    OccEndpoints.prototype.languages;
    /**
     * Get a list of available currencies
     *
     * \@member {string}
     * @type {?|undefined}
     */
    OccEndpoints.prototype.currencies;
    /**
     * Get a list of countries
     *
     * \@member {string}
     * @type {?|undefined}
     */
    OccEndpoints.prototype.countries;
    /**
     * Fetch the list of regions for the provided country
     *
     * \@member {string}
     * @type {?|undefined}
     */
    OccEndpoints.prototype.regions;
    /**
     * Titles used for user's personal info.
     *
     * \@member {string}
     * @type {?|undefined}
     */
    OccEndpoints.prototype.titles;
    /**
     * Get user details
     *
     * \@member {string}
     * @type {?|undefined}
     */
    OccEndpoints.prototype.user;
    /**
     * Register a new user.
     *
     * \@member {string}
     * @type {?|undefined}
     */
    OccEndpoints.prototype.userRegister;
    /**
     * Request an email to reset the password
     *
     * \@member {string}
     * @type {?|undefined}
     */
    OccEndpoints.prototype.userForgotPassword;
    /**
     * Reset the password once the email is recieved.
     *
     * \@member {string}
     * @type {?|undefined}
     */
    OccEndpoints.prototype.userResetPassword;
    /**
     * Update the user id with which the user authenticates.
     *
     * \@member {string}
     * @type {?|undefined}
     */
    OccEndpoints.prototype.userUpdateLoginId;
    /**
     * Update the user's password
     *
     * \@member {string}
     * @type {?|undefined}
     */
    OccEndpoints.prototype.userUpdatePassword;
    /**
     * Payment details root endpoint.
     *
     * \@member {string}
     * @type {?|undefined}
     */
    OccEndpoints.prototype.paymentDetailsAll;
    /**
     * Endpoint for a specific payment method.
     *
     * \@member {string}
     * @type {?|undefined}
     */
    OccEndpoints.prototype.paymentDetail;
    /**
     * Endpoint for the list of one user's orders
     *
     * \@member {string}
     * @type {?|undefined}
     */
    OccEndpoints.prototype.orderHistory;
    /**
     * Endpoint for the details of one user's order
     *
     * \@member {string}
     * @type {?|undefined}
     */
    OccEndpoints.prototype.orderDetail;
    /**
     * Endpoint for anonymous consent templates
     *
     * \@member {string}
     * @type {?|undefined}
     */
    OccEndpoints.prototype.anonymousConsentTemplates;
    /**
     * Endpoint for consent templates
     *
     * \@member {string}
     * @type {?|undefined}
     */
    OccEndpoints.prototype.consentTemplates;
    /**
     * Endpoint for a user's consents
     *
     * \@member {string}
     * @type {?|undefined}
     */
    OccEndpoints.prototype.consents;
    /**
     * Endpoint for a user's specific previously given consent.
     *
     * \@member {string}
     * @type {?|undefined}
     */
    OccEndpoints.prototype.consentDetail;
    /**
     * Endpoint for a user's addresses
     *
     * \@member {string}
     * @type {?|undefined}
     */
    OccEndpoints.prototype.addresses;
    /**
     * Endpoint for a user's specific address
     *
     * \@member {string}
     * @type {?|undefined}
     */
    OccEndpoints.prototype.addressDetail;
    /**
     * Endpoint for address verification
     *
     * \@member {string}
     * @type {?|undefined}
     */
    OccEndpoints.prototype.addressVerification;
    /**
     * Endpoint for consignment tracking
     *
     * \@member {string}
     * @type {?|undefined}
     */
    OccEndpoints.prototype.consignmentTracking;
    /**
     * Endpoint for asm customer search
     *
     * \@member {string}
     * @type {?|undefined}
     */
    OccEndpoints.prototype.asmCustomerSearch;
    /**
     * Endpoint for cart voucher
     *
     * \@member {string}
     * @type {?|undefined}
     */
    OccEndpoints.prototype.cartVoucher;
    /**
     * Endpoint for coupons
     *
     * \@member {string}
     * @type {?|undefined}
     */
    OccEndpoints.prototype.customerCoupons;
    /**
     * Endpoint for claiming coupon
     *
     * \@member {string}
     * @type {?|undefined}
     */
    OccEndpoints.prototype.claimCoupon;
    /**
     * Endpoint for coupons
     *
     * \@member {string}
     * @type {?|undefined}
     */
    OccEndpoints.prototype.couponNotification;
    /**
     * Explicitly saves a cart
     *
     * \@member {string}
     * @type {?|undefined}
     */
    OccEndpoints.prototype.saveCart;
    /**
     * Endpoint for notification preference
     *
     * \@member {string}
     * @type {?|undefined}
     */
    OccEndpoints.prototype.notificationPreference;
    /**
     * Endpoint for product interests
     *
     * \@member {string}
     * @type {?|undefined}
     */
    OccEndpoints.prototype.productInterests;
    /**
     * Endpoint for getting product interests
     *
     * \@member {string}
     * @type {?|undefined}
     */
    OccEndpoints.prototype.getProductInterests;
    /**
     * Endpoint for cancel an order
     * @type {?|undefined}
     */
    OccEndpoints.prototype.cancelOrder;
    /**
     * Endpoint for creating order return request
     * @type {?|undefined}
     */
    OccEndpoints.prototype.returnOrder;
    /**
     * Endpoint for user's order return requests
     * @type {?|undefined}
     */
    OccEndpoints.prototype.orderReturns;
    /**
     * Endpoint for order return request details
     * @type {?|undefined}
     */
    OccEndpoints.prototype.orderReturnDetail;
    /**
     * Endpoint for cancelling return request
     * @type {?|undefined}
     */
    OccEndpoints.prototype.cancelReturn;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var Occ;
(function (Occ) {
    /**
     *
     * An interface representing Country.
     * @record
     */
    function Country() { }
    Occ.Country = Country;
    if (false) {
        /**
         * \@member {string} [isocode]
         * @type {?|undefined}
         */
        Country.prototype.isocode;
        /**
         * \@member {string} [name]
         * @type {?|undefined}
         */
        Country.prototype.name;
    }
    /**
     *
     * An interface representing Region.
     * @record
     */
    function Region() { }
    Occ.Region = Region;
    if (false) {
        /**
         * \@member {string} [countryIso]
         * @type {?|undefined}
         */
        Region.prototype.countryIso;
        /**
         * \@member {string} [isocode]
         * @type {?|undefined}
         */
        Region.prototype.isocode;
        /**
         * \@member {string} [isocodeShort]
         * @type {?|undefined}
         */
        Region.prototype.isocodeShort;
        /**
         * \@member {string} [name]
         * @type {?|undefined}
         */
        Region.prototype.name;
    }
    /**
     *
     * An interface representing RegionList.
     * @record
     */
    function RegionList() { }
    Occ.RegionList = RegionList;
    if (false) {
        /**
         * \@member {Region[]} [regions]
         * @type {?|undefined}
         */
        RegionList.prototype.regions;
    }
    /**
     *
     * An interface representing Address.
     * @record
     */
    function Address() { }
    Occ.Address = Address;
    if (false) {
        /**
         * \@member {string} [companyName]
         * @type {?|undefined}
         */
        Address.prototype.companyName;
        /**
         * \@member {Country} [country]
         * @type {?|undefined}
         */
        Address.prototype.country;
        /**
         * \@member {boolean} [defaultAddress]
         * @type {?|undefined}
         */
        Address.prototype.defaultAddress;
        /**
         * \@member {string} [email]
         * @type {?|undefined}
         */
        Address.prototype.email;
        /**
         * \@member {string} [firstName]
         * @type {?|undefined}
         */
        Address.prototype.firstName;
        /**
         * \@member {string} [formattedAddress]
         * @type {?|undefined}
         */
        Address.prototype.formattedAddress;
        /**
         * \@member {string} [id]
         * @type {?|undefined}
         */
        Address.prototype.id;
        /**
         * \@member {string} [lastName]
         * @type {?|undefined}
         */
        Address.prototype.lastName;
        /**
         * \@member {string} [line1]
         * @type {?|undefined}
         */
        Address.prototype.line1;
        /**
         * \@member {string} [line2]
         * @type {?|undefined}
         */
        Address.prototype.line2;
        /**
         * \@member {string} [phone]
         * @type {?|undefined}
         */
        Address.prototype.phone;
        /**
         * \@member {string} [postalCode]
         * @type {?|undefined}
         */
        Address.prototype.postalCode;
        /**
         * \@member {Region} [region]
         * @type {?|undefined}
         */
        Address.prototype.region;
        /**
         * \@member {boolean} [shippingAddress]
         * @type {?|undefined}
         */
        Address.prototype.shippingAddress;
        /**
         * \@member {string} [title]
         * @type {?|undefined}
         */
        Address.prototype.title;
        /**
         * \@member {string} [titleCode]
         * @type {?|undefined}
         */
        Address.prototype.titleCode;
        /**
         * \@member {string} [town]
         * @type {?|undefined}
         */
        Address.prototype.town;
        /**
         * \@member {boolean} [visibleInAddressBook]
         * @type {?|undefined}
         */
        Address.prototype.visibleInAddressBook;
    }
    /**
     *
     * An interface representing AddressList.
     * @record
     */
    function AddressList() { }
    Occ.AddressList = AddressList;
    if (false) {
        /**
         * \@member {Address[]} [addresses]
         * @type {?|undefined}
         */
        AddressList.prototype.addresses;
    }
    /**
     *
     * An interface representing ErrorModel.
     * Error message
     *
     * @record
     */
    function ErrorModel() { }
    Occ.ErrorModel = ErrorModel;
    if (false) {
        /**
         * \@member {string} [message] Descriptive, human readable error message.
         * @type {?|undefined}
         */
        ErrorModel.prototype.message;
        /**
         * \@member {string} [reason] Additional classification specific for each
         * error type e.g. 'noStock'.
         * @type {?|undefined}
         */
        ErrorModel.prototype.reason;
        /**
         * \@member {string} [subject] Identifier of the related object e.g. '1'.
         * @type {?|undefined}
         */
        ErrorModel.prototype.subject;
        /**
         * \@member {string} [subjectType] Type of the object related to the error
         * e.g. 'entry'.
         * @type {?|undefined}
         */
        ErrorModel.prototype.subjectType;
        /**
         * \@member {string} [type] Type of the error e.g. 'LowStockError'.
         * @type {?|undefined}
         */
        ErrorModel.prototype.type;
    }
    /**
     *
     * An interface representing ErrorList.
     * List of errors
     *
     * @record
     */
    function ErrorList() { }
    Occ.ErrorList = ErrorList;
    if (false) {
        /**
         * \@member {ErrorModel[]} [errors]
         * @type {?|undefined}
         */
        ErrorList.prototype.errors;
    }
    /**
     *
     * An interface representing AddressValidation.
     * @record
     */
    function AddressValidation() { }
    Occ.AddressValidation = AddressValidation;
    if (false) {
        /**
         * \@member {string} [decision]
         * @type {?|undefined}
         */
        AddressValidation.prototype.decision;
        /**
         * \@member {ErrorList} [errors]
         * @type {?|undefined}
         */
        AddressValidation.prototype.errors;
        /**
         * \@member {Address[]} [suggestedAddresses]
         * @type {?|undefined}
         */
        AddressValidation.prototype.suggestedAddresses;
    }
    /**
     *
     * An interface representing Price.
     * @record
     */
    function Price() { }
    Occ.Price = Price;
    if (false) {
        /**
         * \@member {string} [currencyIso]
         * @type {?|undefined}
         */
        Price.prototype.currencyIso;
        /**
         * \@member {string} [formattedValue]
         * @type {?|undefined}
         */
        Price.prototype.formattedValue;
        /**
         * \@member {number} [maxQuantity]
         * @type {?|undefined}
         */
        Price.prototype.maxQuantity;
        /**
         * \@member {number} [minQuantity]
         * @type {?|undefined}
         */
        Price.prototype.minQuantity;
        /**
         * \@member {PriceType} [priceType] Possible values include: 'BUY', 'FROM'
         * @type {?|undefined}
         */
        Price.prototype.priceType;
        /**
         * \@member {number} [value]
         * @type {?|undefined}
         */
        Price.prototype.value;
    }
    /**
     *
     * An interface representing Stock.
     * @record
     */
    function Stock() { }
    Occ.Stock = Stock;
    if (false) {
        /**
         * \@member {number} [stockLevel]
         * @type {?|undefined}
         */
        Stock.prototype.stockLevel;
        /**
         * \@member {string} [stockLevelStatus]
         * @type {?|undefined}
         */
        Stock.prototype.stockLevelStatus;
    }
    /**
     *
     * An interface representing Image.
     * @record
     */
    function Image() { }
    Occ.Image = Image;
    if (false) {
        /**
         * \@member {string} [altText]
         * @type {?|undefined}
         */
        Image.prototype.altText;
        /**
         * \@member {string} [format]
         * @type {?|undefined}
         */
        Image.prototype.format;
        /**
         * \@member {number} [galleryIndex]
         * @type {?|undefined}
         */
        Image.prototype.galleryIndex;
        /**
         * \@member {ImageType} [imageType] Possible values include: 'PRIMARY',
         * 'GALLERY'
         * @type {?|undefined}
         */
        Image.prototype.imageType;
        /**
         * \@member {string} [url]
         * @type {?|undefined}
         */
        Image.prototype.url;
    }
    /**
     *
     * An interface representing VariantOptionQualifier.
     * @record
     */
    function VariantOptionQualifier() { }
    Occ.VariantOptionQualifier = VariantOptionQualifier;
    if (false) {
        /**
         * \@member {Image} [image]
         * @type {?|undefined}
         */
        VariantOptionQualifier.prototype.image;
        /**
         * \@member {string} [name]
         * @type {?|undefined}
         */
        VariantOptionQualifier.prototype.name;
        /**
         * \@member {string} [qualifier]
         * @type {?|undefined}
         */
        VariantOptionQualifier.prototype.qualifier;
        /**
         * \@member {string} [value]
         * @type {?|undefined}
         */
        VariantOptionQualifier.prototype.value;
    }
    /**
     *
     * An interface representing VariantOption.
     * @record
     */
    function VariantOption() { }
    Occ.VariantOption = VariantOption;
    if (false) {
        /**
         * \@member {string} [code]
         * @type {?|undefined}
         */
        VariantOption.prototype.code;
        /**
         * \@member {Price} [priceData]
         * @type {?|undefined}
         */
        VariantOption.prototype.priceData;
        /**
         * \@member {Stock} [stock]
         * @type {?|undefined}
         */
        VariantOption.prototype.stock;
        /**
         * \@member {string} [url]
         * @type {?|undefined}
         */
        VariantOption.prototype.url;
        /**
         * \@member {VariantOptionQualifier[]} [variantOptionQualifiers]
         * @type {?|undefined}
         */
        VariantOption.prototype.variantOptionQualifiers;
    }
    /**
     *
     * An interface representing BaseOption.
     * @record
     */
    function BaseOption() { }
    Occ.BaseOption = BaseOption;
    if (false) {
        /**
         * \@member {VariantOption[]} [options]
         * @type {?|undefined}
         */
        BaseOption.prototype.options;
        /**
         * \@member {VariantOption} [selected]
         * @type {?|undefined}
         */
        BaseOption.prototype.selected;
        /**
         * \@member {string} [variantType]
         * @type {?|undefined}
         */
        BaseOption.prototype.variantType;
    }
    /**
     *
     * An interface representing SearchQuery.
     * @record
     */
    function SearchQuery() { }
    Occ.SearchQuery = SearchQuery;
    if (false) {
        /**
         * \@member {string} [value]
         * @type {?|undefined}
         */
        SearchQuery.prototype.value;
    }
    /**
     *
     * An interface representing SearchState.
     * @record
     */
    function SearchState() { }
    Occ.SearchState = SearchState;
    if (false) {
        /**
         * \@member {SearchQuery} [query]
         * @type {?|undefined}
         */
        SearchState.prototype.query;
        /**
         * \@member {string} [url]
         * @type {?|undefined}
         */
        SearchState.prototype.url;
    }
    /**
     *
     * An interface representing Breadcrumb.
     * @record
     */
    function Breadcrumb() { }
    Occ.Breadcrumb = Breadcrumb;
    if (false) {
        /**
         * \@member {string} [facetCode]
         * @type {?|undefined}
         */
        Breadcrumb.prototype.facetCode;
        /**
         * \@member {string} [facetName]
         * @type {?|undefined}
         */
        Breadcrumb.prototype.facetName;
        /**
         * \@member {string} [facetValueCode]
         * @type {?|undefined}
         */
        Breadcrumb.prototype.facetValueCode;
        /**
         * \@member {string} [facetValueName]
         * @type {?|undefined}
         */
        Breadcrumb.prototype.facetValueName;
        /**
         * \@member {SearchState} [removeQuery]
         * @type {?|undefined}
         */
        Breadcrumb.prototype.removeQuery;
        /**
         * \@member {SearchState} [truncateQuery]
         * @type {?|undefined}
         */
        Breadcrumb.prototype.truncateQuery;
    }
    /**
     *
     * An interface representing Component.
     * @record
     */
    function Component() { }
    Occ.Component = Component;
    if (false) {
        /**
         * \@member {Date} [modifiedTime]
         * @type {?|undefined}
         */
        Component.prototype.modifiedTime;
        /**
         * \@member {string} [name]
         * @type {?|undefined}
         */
        Component.prototype.name;
        /**
         * \@member {any} [otherProperties]
         * @type {?|undefined}
         */
        Component.prototype.otherProperties;
        /**
         * \@member {string} [typeCode]
         * @type {?|undefined}
         */
        Component.prototype.typeCode;
        /**
         * \@member {string} [uid]
         * @type {?|undefined}
         */
        Component.prototype.uid;
    }
    /**
     *
     * An interface representing ComponentList.
     * @record
     */
    function ComponentList() { }
    Occ.ComponentList = ComponentList;
    if (false) {
        /**
         * \@member {Component[]} [component]
         * @type {?|undefined}
         */
        ComponentList.prototype.component;
    }
    /**
     *
     * An interface representing ContentSlot.
     * @record
     */
    function ContentSlot() { }
    Occ.ContentSlot = ContentSlot;
    if (false) {
        /**
         * \@member {ComponentList} [components]
         * @type {?|undefined}
         */
        ContentSlot.prototype.components;
        /**
         * \@member {string} [name]
         * @type {?|undefined}
         */
        ContentSlot.prototype.name;
        /**
         * \@member {string} [position]
         * @type {?|undefined}
         */
        ContentSlot.prototype.position;
        /**
         * \@member {string} [slotId]
         * @type {?|undefined}
         */
        ContentSlot.prototype.slotId;
        /**
         * \@member {boolean} [slotShared]
         * @type {?|undefined}
         */
        ContentSlot.prototype.slotShared;
        /**
         * \@member {string} [slotStatus]
         * @type {?|undefined}
         */
        ContentSlot.prototype.slotStatus;
    }
    /**
     *
     * An interface representing ContentSlotList.
     * @record
     */
    function ContentSlotList() { }
    Occ.ContentSlotList = ContentSlotList;
    if (false) {
        /**
         * \@member {ContentSlot[]} [contentSlot]
         * @type {?|undefined}
         */
        ContentSlotList.prototype.contentSlot;
    }
    /**
     *
     * An interface representing CMSPage.
     * @record
     */
    function CMSPage() { }
    Occ.CMSPage = CMSPage;
    if (false) {
        /**
         * \@member {ContentSlotList} [contentSlots]
         * @type {?|undefined}
         */
        CMSPage.prototype.contentSlots;
        /**
         * \@member {boolean} [defaultPage]
         * @type {?|undefined}
         */
        CMSPage.prototype.defaultPage;
        /**
         * \@member {string} [name]
         * @type {?|undefined}
         */
        CMSPage.prototype.name;
        /**
         * \@member {string} [template]
         * @type {?|undefined}
         */
        CMSPage.prototype.template;
        /**
         * \@member {string} [title]
         * @type {?|undefined}
         */
        CMSPage.prototype.title;
        /**
         * \@member {string} [typeCode]
         * @type {?|undefined}
         */
        CMSPage.prototype.typeCode;
        /**
         * \@member {string} [uid]
         * @type {?|undefined}
         */
        CMSPage.prototype.uid;
    }
    /**
     *
     * An interface representing CardType.
     * @record
     */
    function CardType() { }
    Occ.CardType = CardType;
    if (false) {
        /**
         * \@member {string} [code]
         * @type {?|undefined}
         */
        CardType.prototype.code;
        /**
         * \@member {string} [name]
         * @type {?|undefined}
         */
        CardType.prototype.name;
    }
    /**
     *
     * An interface representing CardTypeList.
     * @record
     */
    function CardTypeList() { }
    Occ.CardTypeList = CardTypeList;
    if (false) {
        /**
         * \@member {CardType[]} [cardTypes]
         * @type {?|undefined}
         */
        CardTypeList.prototype.cardTypes;
    }
    /**
     *
     * An interface representing PromotionOrderEntryConsumed.
     * @record
     */
    function PromotionOrderEntryConsumed() { }
    Occ.PromotionOrderEntryConsumed = PromotionOrderEntryConsumed;
    if (false) {
        /**
         * \@member {number} [adjustedUnitPrice]
         * @type {?|undefined}
         */
        PromotionOrderEntryConsumed.prototype.adjustedUnitPrice;
        /**
         * \@member {string} [code]
         * @type {?|undefined}
         */
        PromotionOrderEntryConsumed.prototype.code;
        /**
         * \@member {number} [orderEntryNumber]
         * @type {?|undefined}
         */
        PromotionOrderEntryConsumed.prototype.orderEntryNumber;
        /**
         * \@member {number} [quantity]
         * @type {?|undefined}
         */
        PromotionOrderEntryConsumed.prototype.quantity;
    }
    /**
     *
     * An interface representing PromotionRestriction.
     * @record
     */
    function PromotionRestriction() { }
    Occ.PromotionRestriction = PromotionRestriction;
    if (false) {
        /**
         * \@member {string} [description]
         * @type {?|undefined}
         */
        PromotionRestriction.prototype.description;
        /**
         * \@member {string} [restrictionType]
         * @type {?|undefined}
         */
        PromotionRestriction.prototype.restrictionType;
    }
    /**
     *
     * An interface representing Promotion.
     * @record
     */
    function Promotion() { }
    Occ.Promotion = Promotion;
    if (false) {
        /**
         * \@member {string} [code]
         * @type {?|undefined}
         */
        Promotion.prototype.code;
        /**
         * \@member {string[]} [couldFireMessages]
         * @type {?|undefined}
         */
        Promotion.prototype.couldFireMessages;
        /**
         * \@member {string} [description]
         * @type {?|undefined}
         */
        Promotion.prototype.description;
        /**
         * \@member {boolean} [enabled]
         * @type {?|undefined}
         */
        Promotion.prototype.enabled;
        /**
         * \@member {Date} [endDate]
         * @type {?|undefined}
         */
        Promotion.prototype.endDate;
        /**
         * \@member {string[]} [firedMessages]
         * @type {?|undefined}
         */
        Promotion.prototype.firedMessages;
        /**
         * \@member {number} [priority]
         * @type {?|undefined}
         */
        Promotion.prototype.priority;
        /**
         * \@member {Image} [productBanner]
         * @type {?|undefined}
         */
        Promotion.prototype.productBanner;
        /**
         * \@member {string} [promotionGroup]
         * @type {?|undefined}
         */
        Promotion.prototype.promotionGroup;
        /**
         * \@member {string} [promotionType]
         * @type {?|undefined}
         */
        Promotion.prototype.promotionType;
        /**
         * \@member {PromotionRestriction[]} [restrictions]
         * @type {?|undefined}
         */
        Promotion.prototype.restrictions;
        /**
         * \@member {Date} [startDate]
         * @type {?|undefined}
         */
        Promotion.prototype.startDate;
        /**
         * \@member {string} [title]
         * @type {?|undefined}
         */
        Promotion.prototype.title;
    }
    /**
     *
     * An interface representing PromotionResult.
     * @record
     */
    function PromotionResult() { }
    Occ.PromotionResult = PromotionResult;
    if (false) {
        /**
         * \@member {PromotionOrderEntryConsumed[]} [consumedEntries]
         * @type {?|undefined}
         */
        PromotionResult.prototype.consumedEntries;
        /**
         * \@member {string} [description]
         * @type {?|undefined}
         */
        PromotionResult.prototype.description;
        /**
         * \@member {Promotion} [promotion]
         * @type {?|undefined}
         */
        PromotionResult.prototype.promotion;
    }
    /**
     *
     * An interface representing Currency.
     * @record
     */
    function Currency() { }
    Occ.Currency = Currency;
    if (false) {
        /**
         * \@member {boolean} [active]
         * @type {?|undefined}
         */
        Currency.prototype.active;
        /**
         * \@member {string} [isocode]
         * @type {?|undefined}
         */
        Currency.prototype.isocode;
        /**
         * \@member {string} [name]
         * @type {?|undefined}
         */
        Currency.prototype.name;
        /**
         * \@member {string} [symbol]
         * @type {?|undefined}
         */
        Currency.prototype.symbol;
    }
    /**
     *
     * An interface representing Voucher.
     * @record
     */
    function Voucher() { }
    Occ.Voucher = Voucher;
    if (false) {
        /**
         * \@member {Price} [appliedValue]
         * @type {?|undefined}
         */
        Voucher.prototype.appliedValue;
        /**
         * \@member {string} [code]
         * @type {?|undefined}
         */
        Voucher.prototype.code;
        /**
         * \@member {Currency} [currency]
         * @type {?|undefined}
         */
        Voucher.prototype.currency;
        /**
         * \@member {string} [description]
         * @type {?|undefined}
         */
        Voucher.prototype.description;
        /**
         * \@member {boolean} [freeShipping]
         * @type {?|undefined}
         */
        Voucher.prototype.freeShipping;
        /**
         * \@member {string} [name]
         * @type {?|undefined}
         */
        Voucher.prototype.name;
        /**
         * \@member {number} [value]
         * @type {?|undefined}
         */
        Voucher.prototype.value;
        /**
         * \@member {string} [valueFormatted]
         * @type {?|undefined}
         */
        Voucher.prototype.valueFormatted;
        /**
         * \@member {string} [valueString]
         * @type {?|undefined}
         */
        Voucher.prototype.valueString;
        /**
         * \@member {string} [voucherCode]
         * @type {?|undefined}
         */
        Voucher.prototype.voucherCode;
    }
    /**
     *
     * An interface representing DeliveryMode.
     * @record
     */
    function DeliveryMode() { }
    Occ.DeliveryMode = DeliveryMode;
    if (false) {
        /**
         * \@member {string} [code]
         * @type {?|undefined}
         */
        DeliveryMode.prototype.code;
        /**
         * \@member {Price} [deliveryCost]
         * @type {?|undefined}
         */
        DeliveryMode.prototype.deliveryCost;
        /**
         * \@member {string} [description]
         * @type {?|undefined}
         */
        DeliveryMode.prototype.description;
        /**
         * \@member {string} [name]
         * @type {?|undefined}
         */
        DeliveryMode.prototype.name;
    }
    /**
     *
     * An interface representing GeoPoint.
     * @record
     */
    function GeoPoint() { }
    Occ.GeoPoint = GeoPoint;
    if (false) {
        /**
         * \@member {number} [latitude]
         * @type {?|undefined}
         */
        GeoPoint.prototype.latitude;
        /**
         * \@member {number} [longitude]
         * @type {?|undefined}
         */
        GeoPoint.prototype.longitude;
    }
    /**
     *
     * An interface representing Time.
     * @record
     */
    function Time() { }
    Occ.Time = Time;
    if (false) {
        /**
         * \@member {string} [formattedHour]
         * @type {?|undefined}
         */
        Time.prototype.formattedHour;
        /**
         * \@member {number} [hour]
         * @type {?|undefined}
         */
        Time.prototype.hour;
        /**
         * \@member {number} [minute]
         * @type {?|undefined}
         */
        Time.prototype.minute;
    }
    /**
     *
     * An interface representing SpecialOpeningDay.
     * @record
     */
    function SpecialOpeningDay() { }
    Occ.SpecialOpeningDay = SpecialOpeningDay;
    if (false) {
        /**
         * \@member {boolean} [closed]
         * @type {?|undefined}
         */
        SpecialOpeningDay.prototype.closed;
        /**
         * \@member {Time} [closingTime]
         * @type {?|undefined}
         */
        SpecialOpeningDay.prototype.closingTime;
        /**
         * \@member {string} [comment]
         * @type {?|undefined}
         */
        SpecialOpeningDay.prototype.comment;
        /**
         * \@member {Date} [date]
         * @type {?|undefined}
         */
        SpecialOpeningDay.prototype.date;
        /**
         * \@member {string} [formattedDate]
         * @type {?|undefined}
         */
        SpecialOpeningDay.prototype.formattedDate;
        /**
         * \@member {string} [name]
         * @type {?|undefined}
         */
        SpecialOpeningDay.prototype.name;
        /**
         * \@member {Time} [openingTime]
         * @type {?|undefined}
         */
        SpecialOpeningDay.prototype.openingTime;
    }
    /**
     *
     * An interface representing WeekdayOpeningDay.
     * @record
     */
    function WeekdayOpeningDay() { }
    Occ.WeekdayOpeningDay = WeekdayOpeningDay;
    if (false) {
        /**
         * \@member {boolean} [closed]
         * @type {?|undefined}
         */
        WeekdayOpeningDay.prototype.closed;
        /**
         * \@member {Time} [closingTime]
         * @type {?|undefined}
         */
        WeekdayOpeningDay.prototype.closingTime;
        /**
         * \@member {Time} [openingTime]
         * @type {?|undefined}
         */
        WeekdayOpeningDay.prototype.openingTime;
        /**
         * \@member {string} [weekDay]
         * @type {?|undefined}
         */
        WeekdayOpeningDay.prototype.weekDay;
    }
    /**
     *
     * An interface representing OpeningSchedule.
     * @record
     */
    function OpeningSchedule() { }
    Occ.OpeningSchedule = OpeningSchedule;
    if (false) {
        /**
         * \@member {string} [code]
         * @type {?|undefined}
         */
        OpeningSchedule.prototype.code;
        /**
         * \@member {string} [name]
         * @type {?|undefined}
         */
        OpeningSchedule.prototype.name;
        /**
         * \@member {SpecialOpeningDay[]} [specialDayOpeningList]
         * @type {?|undefined}
         */
        OpeningSchedule.prototype.specialDayOpeningList;
        /**
         * \@member {WeekdayOpeningDay[]} [weekDayOpeningList]
         * @type {?|undefined}
         */
        OpeningSchedule.prototype.weekDayOpeningList;
    }
    /**
     *
     * An interface representing PointOfService.
     * @record
     */
    function PointOfService() { }
    Occ.PointOfService = PointOfService;
    if (false) {
        /**
         * \@member {Address} [address]
         * @type {?|undefined}
         */
        PointOfService.prototype.address;
        /**
         * \@member {string} [description]
         * @type {?|undefined}
         */
        PointOfService.prototype.description;
        /**
         * \@member {string} [displayName]
         * @type {?|undefined}
         */
        PointOfService.prototype.displayName;
        /**
         * \@member {number} [distanceKm]
         * @type {?|undefined}
         */
        PointOfService.prototype.distanceKm;
        /**
         * \@member {{ [propertyName: string]: string }} [features]
         * @type {?|undefined}
         */
        PointOfService.prototype.features;
        /**
         * \@member {string} [formattedDistance]
         * @type {?|undefined}
         */
        PointOfService.prototype.formattedDistance;
        /**
         * \@member {GeoPoint} [geoPoint]
         * @type {?|undefined}
         */
        PointOfService.prototype.geoPoint;
        /**
         * \@member {Image} [mapIcon]
         * @type {?|undefined}
         */
        PointOfService.prototype.mapIcon;
        /**
         * \@member {string} [name]
         * @type {?|undefined}
         */
        PointOfService.prototype.name;
        /**
         * \@member {OpeningSchedule} [openingHours]
         * @type {?|undefined}
         */
        PointOfService.prototype.openingHours;
        /**
         * \@member {string} [storeContent]
         * @type {?|undefined}
         */
        PointOfService.prototype.storeContent;
        /**
         * \@member {Image[]} [storeImages]
         * @type {?|undefined}
         */
        PointOfService.prototype.storeImages;
        /**
         * \@member {string} [url]
         * @type {?|undefined}
         */
        PointOfService.prototype.url;
    }
    /**
     *
     * An interface representing Category.
     * @record
     */
    function Category() { }
    Occ.Category = Category;
    if (false) {
        /**
         * \@member {string} [code]
         * @type {?|undefined}
         */
        Category.prototype.code;
        /**
         * \@member {string} [code]
         * @type {?|undefined}
         */
        Category.prototype.name;
        /**
         * \@member {Image} [image]
         * @type {?|undefined}
         */
        Category.prototype.image;
        /**
         * \@member {string} [url]
         * @type {?|undefined}
         */
        Category.prototype.url;
    }
    /**
     *
     * An interface representing FeatureUnit.
     * @record
     */
    function FeatureUnit() { }
    Occ.FeatureUnit = FeatureUnit;
    if (false) {
        /**
         * \@member {string} [name]
         * @type {?|undefined}
         */
        FeatureUnit.prototype.name;
        /**
         * \@member {string} [symbol]
         * @type {?|undefined}
         */
        FeatureUnit.prototype.symbol;
        /**
         * \@member {string} [unitType]
         * @type {?|undefined}
         */
        FeatureUnit.prototype.unitType;
    }
    /**
     *
     * An interface representing FeatureValue.
     * @record
     */
    function FeatureValue() { }
    Occ.FeatureValue = FeatureValue;
    if (false) {
        /**
         * \@member {string} [value]
         * @type {?|undefined}
         */
        FeatureValue.prototype.value;
    }
    /**
     *
     * An interface representing Feature.
     * @record
     */
    function Feature() { }
    Occ.Feature = Feature;
    if (false) {
        /**
         * \@member {string} [code]
         * @type {?|undefined}
         */
        Feature.prototype.code;
        /**
         * \@member {boolean} [comparable]
         * @type {?|undefined}
         */
        Feature.prototype.comparable;
        /**
         * \@member {string} [description]
         * @type {?|undefined}
         */
        Feature.prototype.description;
        /**
         * \@member {FeatureUnit} [featureUnit]
         * @type {?|undefined}
         */
        Feature.prototype.featureUnit;
        /**
         * \@member {FeatureValue[]} [featureValues]
         * @type {?|undefined}
         */
        Feature.prototype.featureValues;
        /**
         * \@member {string} [name]
         * @type {?|undefined}
         */
        Feature.prototype.name;
        /**
         * \@member {boolean} [range]
         * @type {?|undefined}
         */
        Feature.prototype.range;
        /**
         * \@member {string} [type]
         * @type {?|undefined}
         */
        Feature.prototype.type;
    }
    /**
     *
     * An interface representing Classification.
     * @record
     */
    function Classification() { }
    Occ.Classification = Classification;
    if (false) {
        /**
         * \@member {string} [code]
         * @type {?|undefined}
         */
        Classification.prototype.code;
        /**
         * \@member {Feature[]} [features]
         * @type {?|undefined}
         */
        Classification.prototype.features;
        /**
         * \@member {string} [name]
         * @type {?|undefined}
         */
        Classification.prototype.name;
    }
    /**
     *
     * An interface representing FutureStock.
     * @record
     */
    function FutureStock() { }
    Occ.FutureStock = FutureStock;
    if (false) {
        /**
         * \@member {Date} [date]
         * @type {?|undefined}
         */
        FutureStock.prototype.date;
        /**
         * \@member {string} [formattedDate]
         * @type {?|undefined}
         */
        FutureStock.prototype.formattedDate;
        /**
         * \@member {Stock} [stock]
         * @type {?|undefined}
         */
        FutureStock.prototype.stock;
    }
    /**
     *
     * An interface representing PriceRange.
     * @record
     */
    function PriceRange() { }
    Occ.PriceRange = PriceRange;
    if (false) {
        /**
         * \@member {Price} [maxPrice]
         * @type {?|undefined}
         */
        PriceRange.prototype.maxPrice;
        /**
         * \@member {Price} [minPrice]
         * @type {?|undefined}
         */
        PriceRange.prototype.minPrice;
    }
    /**
     *
     * An interface representing ProductReference.
     * @record
     */
    function ProductReference() { }
    Occ.ProductReference = ProductReference;
    if (false) {
        /**
         * \@member {string} [description]
         * @type {?|undefined}
         */
        ProductReference.prototype.description;
        /**
         * \@member {boolean} [preselected]
         * @type {?|undefined}
         */
        ProductReference.prototype.preselected;
        /**
         * \@member {number} [quantity]
         * @type {?|undefined}
         */
        ProductReference.prototype.quantity;
        /**
         * \@member {string} [referenceType]
         * @type {?|undefined}
         */
        ProductReference.prototype.referenceType;
        /**
         * \@member {Product} [target]
         * @type {?|undefined}
         */
        ProductReference.prototype.target;
    }
    /**
     *
     * An interface representing Language.
     * @record
     */
    function Language() { }
    Occ.Language = Language;
    if (false) {
        /**
         * \@member {boolean} [active]
         * @type {?|undefined}
         */
        Language.prototype.active;
        /**
         * \@member {string} [isocode]
         * @type {?|undefined}
         */
        Language.prototype.isocode;
        /**
         * \@member {string} [name]
         * @type {?|undefined}
         */
        Language.prototype.name;
        /**
         * \@member {string} [nativeName]
         * @type {?|undefined}
         */
        Language.prototype.nativeName;
    }
    /**
     *
     * An interface representing User.
     * @record
     */
    function User() { }
    Occ.User = User;
    if (false) {
        /**
         * \@member {Currency} [currency]
         * @type {?|undefined}
         */
        User.prototype.currency;
        /**
         * \@member {string} [customerId]
         * @type {?|undefined}
         */
        User.prototype.customerId;
        /**
         * \@member {Date} [deactivationDate]
         * @type {?|undefined}
         */
        User.prototype.deactivationDate;
        /**
         * \@member {Address} [defaultAddress]
         * @type {?|undefined}
         */
        User.prototype.defaultAddress;
        /**
         * \@member {string} [displayUid]
         * @type {?|undefined}
         */
        User.prototype.displayUid;
        /**
         * \@member {string} [firstName]
         * @type {?|undefined}
         */
        User.prototype.firstName;
        /**
         * \@member {Language} [language]
         * @type {?|undefined}
         */
        User.prototype.language;
        /**
         * \@member {string} [lastName]
         * @type {?|undefined}
         */
        User.prototype.lastName;
        /**
         * \@member {string} [name]
         * @type {?|undefined}
         */
        User.prototype.name;
        /**
         * \@member {string} [title]
         * @type {?|undefined}
         */
        User.prototype.title;
        /**
         * \@member {string} [titleCode]
         * @type {?|undefined}
         */
        User.prototype.titleCode;
        /**
         * \@member {string} [uid]
         * @type {?|undefined}
         */
        User.prototype.uid;
    }
    /**
     *
     * An interface representing Review.
     * @record
     */
    function Review() { }
    Occ.Review = Review;
    if (false) {
        /**
         * \@member {string} [alias]
         * @type {?|undefined}
         */
        Review.prototype.alias;
        /**
         * \@member {string} [comment]
         * @type {?|undefined}
         */
        Review.prototype.comment;
        /**
         * \@member {Date} [date]
         * @type {?|undefined}
         */
        Review.prototype.date;
        /**
         * \@member {string} [headline]
         * @type {?|undefined}
         */
        Review.prototype.headline;
        /**
         * \@member {string} [id]
         * @type {?|undefined}
         */
        Review.prototype.id;
        /**
         * \@member {User} [principal]
         * @type {?|undefined}
         */
        Review.prototype.principal;
        /**
         * \@member {number} [rating]
         * @type {?|undefined}
         */
        Review.prototype.rating;
    }
    /**
     *
     * An interface representing VariantCategory.
     * @record
     */
    function VariantCategory() { }
    Occ.VariantCategory = VariantCategory;
    if (false) {
        /**
         * \@member {boolean} [hasImage]
         * @type {?|undefined}
         */
        VariantCategory.prototype.hasImage;
        /**
         * \@member {string} [name]
         * @type {?|undefined}
         */
        VariantCategory.prototype.name;
        /**
         * \@member {number} [priority]
         * @type {?|undefined}
         */
        VariantCategory.prototype.priority;
    }
    /**
     *
     * An interface representing VariantValueCategory.
     * @record
     */
    function VariantValueCategory() { }
    Occ.VariantValueCategory = VariantValueCategory;
    if (false) {
        /**
         * \@member {string} [name]
         * @type {?|undefined}
         */
        VariantValueCategory.prototype.name;
        /**
         * \@member {number} [sequence]
         * @type {?|undefined}
         */
        VariantValueCategory.prototype.sequence;
        /**
         * \@member {VariantCategory[]} [superCategories]
         * @type {?|undefined}
         */
        VariantValueCategory.prototype.superCategories;
    }
    /**
     *
     * An interface representing VariantMatrixElement.
     * @record
     */
    function VariantMatrixElement() { }
    Occ.VariantMatrixElement = VariantMatrixElement;
    if (false) {
        /**
         * \@member {VariantMatrixElement[]} [elements]
         * @type {?|undefined}
         */
        VariantMatrixElement.prototype.elements;
        /**
         * \@member {boolean} [isLeaf]
         * @type {?|undefined}
         */
        VariantMatrixElement.prototype.isLeaf;
        /**
         * \@member {VariantCategory} [parentVariantCategory]
         * @type {?|undefined}
         */
        VariantMatrixElement.prototype.parentVariantCategory;
        /**
         * \@member {VariantOption} [variantOption]
         * @type {?|undefined}
         */
        VariantMatrixElement.prototype.variantOption;
        /**
         * \@member {VariantValueCategory} [variantValueCategory]
         * @type {?|undefined}
         */
        VariantMatrixElement.prototype.variantValueCategory;
    }
    /**
     *
     * An interface representing Product.
     * @record
     */
    function Product() { }
    Occ.Product = Product;
    if (false) {
        /**
         * \@member {boolean} [availableForPickup]
         * @type {?|undefined}
         */
        Product.prototype.availableForPickup;
        /**
         * \@member {number} [averageRating]
         * @type {?|undefined}
         */
        Product.prototype.averageRating;
        /**
         * \@member {BaseOption[]} [baseOptions]
         * @type {?|undefined}
         */
        Product.prototype.baseOptions;
        /**
         * \@member {string} [baseProduct]
         * @type {?|undefined}
         */
        Product.prototype.baseProduct;
        /**
         * \@member {Category[]} [categories]
         * @type {?|undefined}
         */
        Product.prototype.categories;
        /**
         * \@member {Classification[]} [classifications]
         * @type {?|undefined}
         */
        Product.prototype.classifications;
        /**
         * \@member {string} [code]
         * @type {?|undefined}
         */
        Product.prototype.code;
        /**
         * \@member {string} [description]
         * @type {?|undefined}
         */
        Product.prototype.description;
        /**
         * \@member {FutureStock[]} [futureStocks]
         * @type {?|undefined}
         */
        Product.prototype.futureStocks;
        /**
         * \@member {Image[]} [images]
         * @type {?|undefined}
         */
        Product.prototype.images;
        /**
         * \@member {string} [manufacturer]
         * @type {?|undefined}
         */
        Product.prototype.manufacturer;
        /**
         * \@member {boolean} [multidimensional]
         * @type {?|undefined}
         */
        Product.prototype.multidimensional;
        /**
         * \@member {string} [name]
         * @type {?|undefined}
         */
        Product.prototype.name;
        /**
         * \@member {number} [numberOfReviews]
         * @type {?|undefined}
         */
        Product.prototype.numberOfReviews;
        /**
         * \@member {Promotion[]} [potentialPromotions]
         * @type {?|undefined}
         */
        Product.prototype.potentialPromotions;
        /**
         * \@member {Price} [price]
         * @type {?|undefined}
         */
        Product.prototype.price;
        /**
         * \@member {PriceRange} [priceRange]
         * @type {?|undefined}
         */
        Product.prototype.priceRange;
        /**
         * \@member {ProductReference[]} [productReferences]
         * @type {?|undefined}
         */
        Product.prototype.productReferences;
        /**
         * \@member {boolean} [purchasable]
         * @type {?|undefined}
         */
        Product.prototype.purchasable;
        /**
         * \@member {Review[]} [reviews]
         * @type {?|undefined}
         */
        Product.prototype.reviews;
        /**
         * \@member {Stock} [stock]
         * @type {?|undefined}
         */
        Product.prototype.stock;
        /**
         * \@member {string} [summary]
         * @type {?|undefined}
         */
        Product.prototype.summary;
        /**
         * \@member {string} [url]
         * @type {?|undefined}
         */
        Product.prototype.url;
        /**
         * \@member {VariantMatrixElement[]} [variantMatrix]
         * @type {?|undefined}
         */
        Product.prototype.variantMatrix;
        /**
         * \@member {VariantOption[]} [variantOptions]
         * @type {?|undefined}
         */
        Product.prototype.variantOptions;
        /**
         * \@member {string} [variantType]
         * @type {?|undefined}
         */
        Product.prototype.variantType;
        /**
         * \@member {Price[]} [volumePrices]
         * @type {?|undefined}
         */
        Product.prototype.volumePrices;
        /**
         * \@member {boolean} [volumePricesFlag]
         * @type {?|undefined}
         */
        Product.prototype.volumePricesFlag;
    }
    /**
     *
     * An interface representing OrderEntry.
     * @record
     */
    function OrderEntry() { }
    Occ.OrderEntry = OrderEntry;
    if (false) {
        /**
         * \@member {Price} [basePrice]
         * @type {?|undefined}
         */
        OrderEntry.prototype.basePrice;
        /**
         * \@member {DeliveryMode} [deliveryMode]
         * @type {?|undefined}
         */
        OrderEntry.prototype.deliveryMode;
        /**
         * \@member {PointOfService} [deliveryPointOfService]
         * @type {?|undefined}
         */
        OrderEntry.prototype.deliveryPointOfService;
        /**
         * \@member {number} [entryNumber]
         * @type {?|undefined}
         */
        OrderEntry.prototype.entryNumber;
        /**
         * \@member {Product} [product]
         * @type {?|undefined}
         */
        OrderEntry.prototype.product;
        /**
         * \@member {number} [quantity]
         * @type {?|undefined}
         */
        OrderEntry.prototype.quantity;
        /**
         * \@member {Price} [totalPrice]
         * @type {?|undefined}
         */
        OrderEntry.prototype.totalPrice;
        /**
         * \@member {boolean} [updateable]
         * @type {?|undefined}
         */
        OrderEntry.prototype.updateable;
    }
    /**
     *
     * An interface representing DeliveryOrderEntryGroup.
     * @record
     */
    function DeliveryOrderEntryGroup() { }
    Occ.DeliveryOrderEntryGroup = DeliveryOrderEntryGroup;
    if (false) {
        /**
         * \@member {Address} [deliveryAddress]
         * @type {?|undefined}
         */
        DeliveryOrderEntryGroup.prototype.deliveryAddress;
        /**
         * \@member {OrderEntry[]} [entries]
         * @type {?|undefined}
         */
        DeliveryOrderEntryGroup.prototype.entries;
        /**
         * \@member {number} [quantity]
         * @type {?|undefined}
         */
        DeliveryOrderEntryGroup.prototype.quantity;
        /**
         * \@member {Price} [totalPriceWithTax]
         * @type {?|undefined}
         */
        DeliveryOrderEntryGroup.prototype.totalPriceWithTax;
    }
    /**
     *
     * An interface representing PaymentDetails.
     * @record
     */
    function PaymentDetails() { }
    Occ.PaymentDetails = PaymentDetails;
    if (false) {
        /**
         * \@member {string} [accountHolderName]
         * @type {?|undefined}
         */
        PaymentDetails.prototype.accountHolderName;
        /**
         * \@member {Address} [billingAddress]
         * @type {?|undefined}
         */
        PaymentDetails.prototype.billingAddress;
        /**
         * \@member {string} [cardNumber]
         * @type {?|undefined}
         */
        PaymentDetails.prototype.cardNumber;
        /**
         * \@member {CardType} [cardType]
         * @type {?|undefined}
         */
        PaymentDetails.prototype.cardType;
        /**
         * \@member {string} [cvn]
         * @type {?|undefined}
         */
        PaymentDetails.prototype.cvn;
        /**
         * \@member {boolean} [defaultPayment]
         * @type {?|undefined}
         */
        PaymentDetails.prototype.defaultPayment;
        /**
         * \@member {string} [expiryMonth]
         * @type {?|undefined}
         */
        PaymentDetails.prototype.expiryMonth;
        /**
         * \@member {string} [expiryYear]
         * @type {?|undefined}
         */
        PaymentDetails.prototype.expiryYear;
        /**
         * \@member {string} [id]
         * @type {?|undefined}
         */
        PaymentDetails.prototype.id;
        /**
         * \@member {string} [issueNumber]
         * @type {?|undefined}
         */
        PaymentDetails.prototype.issueNumber;
        /**
         * \@member {boolean} [saved]
         * @type {?|undefined}
         */
        PaymentDetails.prototype.saved;
        /**
         * \@member {string} [startMonth]
         * @type {?|undefined}
         */
        PaymentDetails.prototype.startMonth;
        /**
         * \@member {string} [startYear]
         * @type {?|undefined}
         */
        PaymentDetails.prototype.startYear;
        /**
         * \@member {string} [subscriptionId]
         * @type {?|undefined}
         */
        PaymentDetails.prototype.subscriptionId;
    }
    /**
     *
     * An interface representing PickupOrderEntryGroup.
     * @record
     */
    function PickupOrderEntryGroup() { }
    Occ.PickupOrderEntryGroup = PickupOrderEntryGroup;
    if (false) {
        /**
         * \@member {PointOfService} [deliveryPointOfService]
         * @type {?|undefined}
         */
        PickupOrderEntryGroup.prototype.deliveryPointOfService;
        /**
         * \@member {number} [distance]
         * @type {?|undefined}
         */
        PickupOrderEntryGroup.prototype.distance;
        /**
         * \@member {OrderEntry[]} [entries]
         * @type {?|undefined}
         */
        PickupOrderEntryGroup.prototype.entries;
        /**
         * \@member {number} [quantity]
         * @type {?|undefined}
         */
        PickupOrderEntryGroup.prototype.quantity;
        /**
         * \@member {Price} [totalPriceWithTax]
         * @type {?|undefined}
         */
        PickupOrderEntryGroup.prototype.totalPriceWithTax;
    }
    /**
     *
     * An interface representing Principal.
     * @record
     */
    function Principal() { }
    Occ.Principal = Principal;
    if (false) {
        /**
         * \@member {string} [name]
         * @type {?|undefined}
         */
        Principal.prototype.name;
        /**
         * \@member {string} [uid]
         * @type {?|undefined}
         */
        Principal.prototype.uid;
    }
    /**
     *
     * An interface representing Cart.
     * @record
     */
    function Cart() { }
    Occ.Cart = Cart;
    if (false) {
        /**
         * \@member {PromotionResult[]} [appliedOrderPromotions]
         * @type {?|undefined}
         */
        Cart.prototype.appliedOrderPromotions;
        /**
         * \@member {PromotionResult[]} [appliedProductPromotions]
         * @type {?|undefined}
         */
        Cart.prototype.appliedProductPromotions;
        /**
         * \@member {Voucher[]} [appliedVouchers]
         * @type {?|undefined}
         */
        Cart.prototype.appliedVouchers;
        /**
         * \@member {boolean} [calculated]
         * @type {?|undefined}
         */
        Cart.prototype.calculated;
        /**
         * \@member {string} [code]
         * @type {?|undefined}
         */
        Cart.prototype.code;
        /**
         * \@member {Address} [deliveryAddress]
         * @type {?|undefined}
         */
        Cart.prototype.deliveryAddress;
        /**
         * \@member {Price} [deliveryCost]
         * @type {?|undefined}
         */
        Cart.prototype.deliveryCost;
        /**
         * \@member {number} [deliveryItemsQuantity]
         * @type {?|undefined}
         */
        Cart.prototype.deliveryItemsQuantity;
        /**
         * \@member {DeliveryMode} [deliveryMode]
         * @type {?|undefined}
         */
        Cart.prototype.deliveryMode;
        /**
         * \@member {DeliveryOrderEntryGroup[]} [deliveryOrderGroups]
         * @type {?|undefined}
         */
        Cart.prototype.deliveryOrderGroups;
        /**
         * \@member {string} [description]
         * @type {?|undefined}
         */
        Cart.prototype.description;
        /**
         * \@member {OrderEntry[]} [entries]
         * @type {?|undefined}
         */
        Cart.prototype.entries;
        /**
         * \@member {Date} [expirationTime]
         * @type {?|undefined}
         */
        Cart.prototype.expirationTime;
        /**
         * \@member {string} [guid]
         * @type {?|undefined}
         */
        Cart.prototype.guid;
        /**
         * \@member {string} [name]
         * @type {?|undefined}
         */
        Cart.prototype.name;
        /**
         * \@member {boolean} [net]
         * @type {?|undefined}
         */
        Cart.prototype.net;
        /**
         * \@member {Price} [orderDiscounts]
         * @type {?|undefined}
         */
        Cart.prototype.orderDiscounts;
        /**
         * \@member {PaymentDetails} [paymentInfo]
         * @type {?|undefined}
         */
        Cart.prototype.paymentInfo;
        /**
         * \@member {number} [pickupItemsQuantity]
         * @type {?|undefined}
         */
        Cart.prototype.pickupItemsQuantity;
        /**
         * \@member {PickupOrderEntryGroup[]} [pickupOrderGroups]
         * @type {?|undefined}
         */
        Cart.prototype.pickupOrderGroups;
        /**
         * \@member {PromotionResult[]} [potentialOrderPromotions]
         * @type {?|undefined}
         */
        Cart.prototype.potentialOrderPromotions;
        /**
         * \@member {PromotionResult[]} [potentialProductPromotions]
         * @type {?|undefined}
         */
        Cart.prototype.potentialProductPromotions;
        /**
         * \@member {Price} [productDiscounts]
         * @type {?|undefined}
         */
        Cart.prototype.productDiscounts;
        /**
         * \@member {Date} [saveTime]
         * @type {?|undefined}
         */
        Cart.prototype.saveTime;
        /**
         * \@member {Principal} [savedBy]
         * @type {?|undefined}
         */
        Cart.prototype.savedBy;
        /**
         * \@member {string} [site]
         * @type {?|undefined}
         */
        Cart.prototype.site;
        /**
         * \@member {string} [store]
         * @type {?|undefined}
         */
        Cart.prototype.store;
        /**
         * \@member {Price} [subTotal]
         * @type {?|undefined}
         */
        Cart.prototype.subTotal;
        /**
         * \@member {Price} [totalDiscounts]
         * @type {?|undefined}
         */
        Cart.prototype.totalDiscounts;
        /**
         * \@member {number} [totalItems]
         * @type {?|undefined}
         */
        Cart.prototype.totalItems;
        /**
         * \@member {Price} [totalPrice]
         * @type {?|undefined}
         */
        Cart.prototype.totalPrice;
        /**
         * \@member {Price} [totalPriceWithTax]
         * @type {?|undefined}
         */
        Cart.prototype.totalPriceWithTax;
        /**
         * \@member {Price} [totalTax]
         * @type {?|undefined}
         */
        Cart.prototype.totalTax;
        /**
         * \@member {number} [totalUnitCount]
         * @type {?|undefined}
         */
        Cart.prototype.totalUnitCount;
        /**
         * \@member {Principal} [user]
         * @type {?|undefined}
         */
        Cart.prototype.user;
    }
    /**
     *
     * An interface representing CartList.
     * @record
     */
    function CartList() { }
    Occ.CartList = CartList;
    if (false) {
        /**
         * \@member {Cart[]} [carts]
         * @type {?|undefined}
         */
        CartList.prototype.carts;
    }
    /**
     *
     * An interface representing CartModification.
     * @record
     */
    function CartModification() { }
    Occ.CartModification = CartModification;
    if (false) {
        /**
         * \@member {boolean} [deliveryModeChanged]
         * @type {?|undefined}
         */
        CartModification.prototype.deliveryModeChanged;
        /**
         * \@member {OrderEntry} [entry]
         * @type {?|undefined}
         */
        CartModification.prototype.entry;
        /**
         * \@member {number} [quantity]
         * @type {?|undefined}
         */
        CartModification.prototype.quantity;
        /**
         * \@member {number} [quantityAdded]
         * @type {?|undefined}
         */
        CartModification.prototype.quantityAdded;
        /**
         * \@member {string} [statusCode]
         * @type {?|undefined}
         */
        CartModification.prototype.statusCode;
        /**
         * \@member {string} [statusMessage]
         * @type {?|undefined}
         */
        CartModification.prototype.statusMessage;
    }
    /**
     *
     * An interface representing CategoryHierarchy.
     * @record
     */
    function CategoryHierarchy() { }
    Occ.CategoryHierarchy = CategoryHierarchy;
    if (false) {
        /**
         * \@member {string} [id]
         * @type {?|undefined}
         */
        CategoryHierarchy.prototype.id;
        /**
         * \@member {Date} [lastModified]
         * @type {?|undefined}
         */
        CategoryHierarchy.prototype.lastModified;
        /**
         * \@member {string} [name]
         * @type {?|undefined}
         */
        CategoryHierarchy.prototype.name;
        /**
         * \@member {CategoryHierarchy[]} [subcategories]
         * @type {?|undefined}
         */
        CategoryHierarchy.prototype.subcategories;
        /**
         * \@member {string} [url]
         * @type {?|undefined}
         */
        CategoryHierarchy.prototype.url;
    }
    /**
     *
     * An interface representing CatalogVersion.
     * @record
     */
    function CatalogVersion() { }
    Occ.CatalogVersion = CatalogVersion;
    if (false) {
        /**
         * \@member {CategoryHierarchy[]} [categories]
         * @type {?|undefined}
         */
        CatalogVersion.prototype.categories;
        /**
         * \@member {string} [id]
         * @type {?|undefined}
         */
        CatalogVersion.prototype.id;
        /**
         * \@member {Date} [lastModified]
         * @type {?|undefined}
         */
        CatalogVersion.prototype.lastModified;
        /**
         * \@member {string} [name]
         * @type {?|undefined}
         */
        CatalogVersion.prototype.name;
        /**
         * \@member {string} [url]
         * @type {?|undefined}
         */
        CatalogVersion.prototype.url;
    }
    /**
     *
     * An interface representing Catalog.
     * @record
     */
    function Catalog() { }
    Occ.Catalog = Catalog;
    if (false) {
        /**
         * \@member {CatalogVersion[]} [catalogVersions]
         * @type {?|undefined}
         */
        Catalog.prototype.catalogVersions;
        /**
         * \@member {string} [id]
         * @type {?|undefined}
         */
        Catalog.prototype.id;
        /**
         * \@member {Date} [lastModified]
         * @type {?|undefined}
         */
        Catalog.prototype.lastModified;
        /**
         * \@member {string} [name]
         * @type {?|undefined}
         */
        Catalog.prototype.name;
        /**
         * \@member {string} [url]
         * @type {?|undefined}
         */
        Catalog.prototype.url;
    }
    /**
     *
     * An interface representing CatalogList.
     * @record
     */
    function CatalogList() { }
    Occ.CatalogList = CatalogList;
    if (false) {
        /**
         * \@member {Catalog[]} [catalogs]
         * @type {?|undefined}
         */
        CatalogList.prototype.catalogs;
    }
    /**
     *
     * An interface representing ComponentIDList.
     * @record
     */
    function ComponentIDList() { }
    Occ.ComponentIDList = ComponentIDList;
    if (false) {
        /**
         * \@member {string[]} [idList]
         * @type {?|undefined}
         */
        ComponentIDList.prototype.idList;
    }
    /**
     *
     * An interface representing ConsignmentEntry.
     * @record
     */
    function ConsignmentEntry() { }
    Occ.ConsignmentEntry = ConsignmentEntry;
    if (false) {
        /**
         * \@member {OrderEntry} [orderEntry]
         * @type {?|undefined}
         */
        ConsignmentEntry.prototype.orderEntry;
        /**
         * \@member {number} [quantity]
         * @type {?|undefined}
         */
        ConsignmentEntry.prototype.quantity;
        /**
         * \@member {number} [shippedQuantity]
         * @type {?|undefined}
         */
        ConsignmentEntry.prototype.shippedQuantity;
    }
    /**
     *
     * An interface representing Consignment.
     * @record
     */
    function Consignment() { }
    Occ.Consignment = Consignment;
    if (false) {
        /**
         * \@member {string} [code]
         * @type {?|undefined}
         */
        Consignment.prototype.code;
        /**
         * \@member {PointOfService} [deliveryPointOfService]
         * @type {?|undefined}
         */
        Consignment.prototype.deliveryPointOfService;
        /**
         * \@member {ConsignmentEntry[]} [entries]
         * @type {?|undefined}
         */
        Consignment.prototype.entries;
        /**
         * \@member {Address} [shippingAddress]
         * @type {?|undefined}
         */
        Consignment.prototype.shippingAddress;
        /**
         * \@member {string} [status]
         * @type {?|undefined}
         */
        Consignment.prototype.status;
        /**
         * \@member {Date} [statusDate]
         * @type {?|undefined}
         */
        Consignment.prototype.statusDate;
        /**
         * \@member {string} [trackingID]
         * @type {?|undefined}
         */
        Consignment.prototype.trackingID;
    }
    /**
     *
     * An interface representing CountryList.
     * @record
     */
    function CountryList() { }
    Occ.CountryList = CountryList;
    if (false) {
        /**
         * \@member {Country[]} [countries]
         * @type {?|undefined}
         */
        CountryList.prototype.countries;
    }
    /**
     *
     * An interface representing CurrencyList.
     * @record
     */
    function CurrencyList() { }
    Occ.CurrencyList = CurrencyList;
    if (false) {
        /**
         * \@member {Currency[]} [currencies]
         * @type {?|undefined}
         */
        CurrencyList.prototype.currencies;
    }
    /**
     * An interface representing CustomerCoupon
     * @record
     */
    function CustomerCoupon() { }
    Occ.CustomerCoupon = CustomerCoupon;
    if (false) {
        /**
         * \@member {string} [couponId]
         * @type {?|undefined}
         */
        CustomerCoupon.prototype.couponId;
        /**
         * \@member {string} [name]
         * @type {?|undefined}
         */
        CustomerCoupon.prototype.name;
        /**
         * \@member {string} [startDate]
         * @type {?|undefined}
         */
        CustomerCoupon.prototype.startDate;
        /**
         * \@member {string} [endDate]
         * @type {?|undefined}
         */
        CustomerCoupon.prototype.endDate;
        /**
         * \@member {string} [endDate]
         * @type {?|undefined}
         */
        CustomerCoupon.prototype.status;
        /**
         * \@member {string} [description]
         * @type {?|undefined}
         */
        CustomerCoupon.prototype.description;
        /**
         * \@member {boolean} [notificationOn]
         * @type {?|undefined}
         */
        CustomerCoupon.prototype.notificationOn;
        /**
         * \@member {boolean} [allProductsApplicable]
         * @type {?|undefined}
         */
        CustomerCoupon.prototype.allProductsApplicable;
    }
    /**
     * An interface representing CustomerCouponSearchResult
     * @record
     */
    function CustomerCouponSearchResult() { }
    Occ.CustomerCouponSearchResult = CustomerCouponSearchResult;
    if (false) {
        /**
         * \@member {CustomerCoupon[]} [coupons]
         * @type {?|undefined}
         */
        CustomerCouponSearchResult.prototype.coupons;
        /**
         * \@member {Sort[]} [sorts]
         * @type {?|undefined}
         */
        CustomerCouponSearchResult.prototype.sorts;
        /**
         * \@member {Pagination} [pagination]
         * @type {?|undefined}
         */
        CustomerCouponSearchResult.prototype.pagination;
    }
    /**
     *
     * An interface representing DeliveryModeList.
     * @record
     */
    function DeliveryModeList() { }
    Occ.DeliveryModeList = DeliveryModeList;
    if (false) {
        /**
         * \@member {DeliveryMode[]} [deliveryModes]
         * @type {?|undefined}
         */
        DeliveryModeList.prototype.deliveryModes;
    }
    /**
     *
     * An interface representing FacetValue.
     * @record
     */
    function FacetValue() { }
    Occ.FacetValue = FacetValue;
    if (false) {
        /**
         * \@member {number} [count]
         * @type {?|undefined}
         */
        FacetValue.prototype.count;
        /**
         * \@member {string} [name]
         * @type {?|undefined}
         */
        FacetValue.prototype.name;
        /**
         * \@member {SearchState} [query]
         * @type {?|undefined}
         */
        FacetValue.prototype.query;
        /**
         * \@member {boolean} [selected]
         * @type {?|undefined}
         */
        FacetValue.prototype.selected;
    }
    /**
     *
     * An interface representing Facet.
     * @record
     */
    function Facet() { }
    Occ.Facet = Facet;
    if (false) {
        /**
         * \@member {boolean} [category]
         * @type {?|undefined}
         */
        Facet.prototype.category;
        /**
         * \@member {boolean} [multiSelect]
         * @type {?|undefined}
         */
        Facet.prototype.multiSelect;
        /**
         * \@member {string} [name]
         * @type {?|undefined}
         */
        Facet.prototype.name;
        /**
         * \@member {number} [priority]
         * @type {?|undefined}
         */
        Facet.prototype.priority;
        /**
         * \@member {FacetValue[]} [topValues]
         * @type {?|undefined}
         */
        Facet.prototype.topValues;
        /**
         * \@member {FacetValue[]} [values]
         * @type {?|undefined}
         */
        Facet.prototype.values;
        /**
         * \@member {boolean} [visible]
         * @type {?|undefined}
         */
        Facet.prototype.visible;
    }
    /**
     *
     * An interface representing LanguageList.
     * @record
     */
    function LanguageList() { }
    Occ.LanguageList = LanguageList;
    if (false) {
        /**
         * \@member {Language[]} [languages]
         * @type {?|undefined}
         */
        LanguageList.prototype.languages;
    }
    /**
     *
     * An interface representing Pagination.
     * Pagination info
     *
     * @record
     */
    function Pagination() { }
    Occ.Pagination = Pagination;
    if (false) {
        /**
         * \@member {number} [count] Number of elements on this page
         * @type {?|undefined}
         */
        Pagination.prototype.count;
        /**
         * \@member {number} [page] Current page number
         * @type {?|undefined}
         */
        Pagination.prototype.page;
        /**
         * \@member {number} [totalCount] Total number of elements
         * @type {?|undefined}
         */
        Pagination.prototype.totalCount;
        /**
         * \@member {number} [totalPages] Total number of pages
         * @type {?|undefined}
         */
        Pagination.prototype.totalPages;
    }
    /**
     *
     * An interface representing Sort.
     * Sort option
     *
     * @record
     */
    function Sort() { }
    Occ.Sort = Sort;
    if (false) {
        /**
         * \@member {boolean} [asc]
         * @type {?|undefined}
         */
        Sort.prototype.asc;
        /**
         * \@member {string} [code]
         * @type {?|undefined}
         */
        Sort.prototype.code;
    }
    /**
     *
     * An interface representing ListAdaptedComponents.
     * @record
     */
    function ListAdaptedComponents() { }
    Occ.ListAdaptedComponents = ListAdaptedComponents;
    if (false) {
        /**
         * \@member {any[]} [components]
         * @type {?|undefined}
         */
        ListAdaptedComponents.prototype.components;
        /**
         * \@member {Pagination} [pagination]
         * @type {?|undefined}
         */
        ListAdaptedComponents.prototype.pagination;
        /**
         * \@member {Sort[]} [sorts]
         * @type {?|undefined}
         */
        ListAdaptedComponents.prototype.sorts;
    }
    /**
     *
     * An interface representing MemberList.
     * @record
     */
    function MemberList() { }
    Occ.MemberList = MemberList;
    if (false) {
        /**
         * \@member {Principal[]} [members]
         * @type {?|undefined}
         */
        MemberList.prototype.members;
    }
    /**
     *
     * An interface representing OrderEntryList.
     * @record
     */
    function OrderEntryList() { }
    Occ.OrderEntryList = OrderEntryList;
    if (false) {
        /**
         * \@member {OrderEntry[]} [orderEntries]
         * @type {?|undefined}
         */
        OrderEntryList.prototype.orderEntries;
    }
    /**
     *
     * An interface representing OrderHistory.
     * @record
     */
    function OrderHistory() { }
    Occ.OrderHistory = OrderHistory;
    if (false) {
        /**
         * \@member {string} [code]
         * @type {?|undefined}
         */
        OrderHistory.prototype.code;
        /**
         * \@member {string} [guid]
         * @type {?|undefined}
         */
        OrderHistory.prototype.guid;
        /**
         * \@member {Date} [placed]
         * @type {?|undefined}
         */
        OrderHistory.prototype.placed;
        /**
         * \@member {string} [status]
         * @type {?|undefined}
         */
        OrderHistory.prototype.status;
        /**
         * \@member {string} [statusDisplay]
         * @type {?|undefined}
         */
        OrderHistory.prototype.statusDisplay;
        /**
         * \@member {Price} [total]
         * @type {?|undefined}
         */
        OrderHistory.prototype.total;
    }
    /**
     *
     * An interface representing PaginationModel.
     * @record
     */
    function PaginationModel() { }
    Occ.PaginationModel = PaginationModel;
    if (false) {
        /**
         * \@member {number} [currentPage]
         * @type {?|undefined}
         */
        PaginationModel.prototype.currentPage;
        /**
         * \@member {number} [pageSize]
         * @type {?|undefined}
         */
        PaginationModel.prototype.pageSize;
        /**
         * \@member {string} [sort]
         * @type {?|undefined}
         */
        PaginationModel.prototype.sort;
        /**
         * \@member {number} [totalPages]
         * @type {?|undefined}
         */
        PaginationModel.prototype.totalPages;
        /**
         * \@member {number} [totalResults]
         * @type {?|undefined}
         */
        PaginationModel.prototype.totalResults;
    }
    /**
     *
     * An interface representing SortModel.
     * @record
     */
    function SortModel() { }
    Occ.SortModel = SortModel;
    if (false) {
        /**
         * \@member {string} [code]
         * @type {?|undefined}
         */
        SortModel.prototype.code;
        /**
         * \@member {string} [name]
         * @type {?|undefined}
         */
        SortModel.prototype.name;
        /**
         * \@member {boolean} [selected]
         * @type {?|undefined}
         */
        SortModel.prototype.selected;
    }
    /**
     *
     * An interface representing OrderHistoryList.
     * @record
     */
    function OrderHistoryList() { }
    Occ.OrderHistoryList = OrderHistoryList;
    if (false) {
        /**
         * \@member {OrderHistory[]} [orders]
         * @type {?|undefined}
         */
        OrderHistoryList.prototype.orders;
        /**
         * \@member {PaginationModel} [pagination]
         * @type {?|undefined}
         */
        OrderHistoryList.prototype.pagination;
        /**
         * \@member {SortModel[]} [sorts]
         * @type {?|undefined}
         */
        OrderHistoryList.prototype.sorts;
    }
    /**
     *
     * An interface representing OrderStatusUpdateElement.
     * @record
     */
    function OrderStatusUpdateElement() { }
    Occ.OrderStatusUpdateElement = OrderStatusUpdateElement;
    if (false) {
        /**
         * \@member {string} [baseSiteId]
         * @type {?|undefined}
         */
        OrderStatusUpdateElement.prototype.baseSiteId;
        /**
         * \@member {string} [code]
         * @type {?|undefined}
         */
        OrderStatusUpdateElement.prototype.code;
        /**
         * \@member {string} [status]
         * @type {?|undefined}
         */
        OrderStatusUpdateElement.prototype.status;
    }
    /**
     *
     * An interface representing OrderStatusUpdateElementList.
     * @record
     */
    function OrderStatusUpdateElementList() { }
    Occ.OrderStatusUpdateElementList = OrderStatusUpdateElementList;
    if (false) {
        /**
         * \@member {OrderStatusUpdateElement[]} [orderStatusUpdateElements]
         * @type {?|undefined}
         */
        OrderStatusUpdateElementList.prototype.orderStatusUpdateElements;
    }
    /**
     *
     * An interface representing Order.
     * @record
     */
    function Order() { }
    Occ.Order = Order;
    if (false) {
        /**
         * \@member {PromotionResult[]} [appliedOrderPromotions]
         * @type {?|undefined}
         */
        Order.prototype.appliedOrderPromotions;
        /**
         * \@member {PromotionResult[]} [appliedProductPromotions]
         * @type {?|undefined}
         */
        Order.prototype.appliedProductPromotions;
        /**
         * \@member {Voucher[]} [appliedVouchers]
         * @type {?|undefined}
         */
        Order.prototype.appliedVouchers;
        /**
         * \@member {boolean} [calculated]
         * @type {?|undefined}
         */
        Order.prototype.calculated;
        /**
         * \@member {string} [code]
         * @type {?|undefined}
         */
        Order.prototype.code;
        /**
         * \@member {Consignment[]} [consignments]
         * @type {?|undefined}
         */
        Order.prototype.consignments;
        /**
         * \@member {Date} [created]
         * @type {?|undefined}
         */
        Order.prototype.created;
        /**
         * \@member {Address} [deliveryAddress]
         * @type {?|undefined}
         */
        Order.prototype.deliveryAddress;
        /**
         * \@member {Price} [deliveryCost]
         * @type {?|undefined}
         */
        Order.prototype.deliveryCost;
        /**
         * \@member {number} [deliveryItemsQuantity]
         * @type {?|undefined}
         */
        Order.prototype.deliveryItemsQuantity;
        /**
         * \@member {DeliveryMode} [deliveryMode]
         * @type {?|undefined}
         */
        Order.prototype.deliveryMode;
        /**
         * \@member {DeliveryOrderEntryGroup[]} [deliveryOrderGroups]
         * @type {?|undefined}
         */
        Order.prototype.deliveryOrderGroups;
        /**
         * \@member {string} [deliveryStatus]
         * @type {?|undefined}
         */
        Order.prototype.deliveryStatus;
        /**
         * \@member {string} [deliveryStatusDisplay]
         * @type {?|undefined}
         */
        Order.prototype.deliveryStatusDisplay;
        /**
         * \@member {OrderEntry[]} [entries]
         * @type {?|undefined}
         */
        Order.prototype.entries;
        /**
         * \@member {boolean} [guestCustomer]
         * @type {?|undefined}
         */
        Order.prototype.guestCustomer;
        /**
         * \@member {string} [guid]
         * @type {?|undefined}
         */
        Order.prototype.guid;
        /**
         * \@member {boolean} [net]
         * @type {?|undefined}
         */
        Order.prototype.net;
        /**
         * \@member {Price} [orderDiscounts]
         * @type {?|undefined}
         */
        Order.prototype.orderDiscounts;
        /**
         * \@member {PaymentDetails} [paymentInfo]
         * @type {?|undefined}
         */
        Order.prototype.paymentInfo;
        /**
         * \@member {number} [pickupItemsQuantity]
         * @type {?|undefined}
         */
        Order.prototype.pickupItemsQuantity;
        /**
         * \@member {PickupOrderEntryGroup[]} [pickupOrderGroups]
         * @type {?|undefined}
         */
        Order.prototype.pickupOrderGroups;
        /**
         * \@member {Price} [productDiscounts]
         * @type {?|undefined}
         */
        Order.prototype.productDiscounts;
        /**
         * \@member {string} [site]
         * @type {?|undefined}
         */
        Order.prototype.site;
        /**
         * \@member {string} [status]
         * @type {?|undefined}
         */
        Order.prototype.status;
        /**
         * \@member {string} [statusDisplay]
         * @type {?|undefined}
         */
        Order.prototype.statusDisplay;
        /**
         * \@member {string} [store]
         * @type {?|undefined}
         */
        Order.prototype.store;
        /**
         * \@member {Price} [subTotal]
         * @type {?|undefined}
         */
        Order.prototype.subTotal;
        /**
         * \@member {Price} [totalDiscounts]
         * @type {?|undefined}
         */
        Order.prototype.totalDiscounts;
        /**
         * \@member {number} [totalItems]
         * @type {?|undefined}
         */
        Order.prototype.totalItems;
        /**
         * \@member {Price} [totalPrice]
         * @type {?|undefined}
         */
        Order.prototype.totalPrice;
        /**
         * \@member {Price} [totalPriceWithTax]
         * @type {?|undefined}
         */
        Order.prototype.totalPriceWithTax;
        /**
         * \@member {Price} [totalTax]
         * @type {?|undefined}
         */
        Order.prototype.totalTax;
        /**
         * \@member {OrderEntry[]} [unconsignedEntries]
         * @type {?|undefined}
         */
        Order.prototype.unconsignedEntries;
        /**
         * \@member {Principal} [user]
         * @type {?|undefined}
         */
        Order.prototype.user;
    }
    /**
     *
     * An interface representing ReturnRequest.
     * @record
     */
    function ReturnRequest() { }
    Occ.ReturnRequest = ReturnRequest;
    if (false) {
        /**
         * \@member {boolean} [cancellable]
         * @type {?|undefined}
         */
        ReturnRequest.prototype.cancellable;
        /**
         * \@member {string} [code]
         * @type {?|undefined}
         */
        ReturnRequest.prototype.code;
        /**
         * \@member {Date} [creationTime]
         * @type {?|undefined}
         */
        ReturnRequest.prototype.creationTime;
        /**
         * \@member {Price} [deliveryCost]
         * @type {?|undefined}
         */
        ReturnRequest.prototype.deliveryCost;
        /**
         * \@member {order} [order]
         * @type {?|undefined}
         */
        ReturnRequest.prototype.order;
        /**
         * \@member {boolean} [refundDeliveryCost]
         * @type {?|undefined}
         */
        ReturnRequest.prototype.refundDeliveryCost;
        /**
         * \@member {ReturnRequestEntry[]} [returnEntries]
         * @type {?|undefined}
         */
        ReturnRequest.prototype.returnEntries;
        /**
         * \@member {string} [returnLabelDownloadUrl]
         * @type {?|undefined}
         */
        ReturnRequest.prototype.returnLabelDownloadUrl;
        /**
         * \@member {string} [rma]
         * @type {?|undefined}
         */
        ReturnRequest.prototype.rma;
        /**
         * \@member {string} [status]
         * @type {?|undefined}
         */
        ReturnRequest.prototype.status;
        /**
         * \@member {Price} [subTotal]
         * @type {?|undefined}
         */
        ReturnRequest.prototype.subTotal;
        /**
         * \@member {Price} [totalPrice]
         * @type {?|undefined}
         */
        ReturnRequest.prototype.totalPrice;
    }
    /**
     *
     * An interface representing ReturnRequestEntry.
     * @record
     */
    function ReturnRequestEntry() { }
    Occ.ReturnRequestEntry = ReturnRequestEntry;
    if (false) {
        /**
         * \@member {OrderEntry} [orderEntry]
         * @type {?|undefined}
         */
        ReturnRequestEntry.prototype.orderEntry;
        /**
         * \@member {number} [expectedQuantity]
         * @type {?|undefined}
         */
        ReturnRequestEntry.prototype.expectedQuantity;
        /**
         * \@member {Price} [refundAmount]
         * @type {?|undefined}
         */
        ReturnRequestEntry.prototype.refundAmount;
    }
    /**
     *
     * An interface representing PaymentDetailsList.
     * @record
     */
    function PaymentDetailsList() { }
    Occ.PaymentDetailsList = PaymentDetailsList;
    if (false) {
        /**
         * \@member {PaymentDetails[]} [payments]
         * @type {?|undefined}
         */
        PaymentDetailsList.prototype.payments;
    }
    /**
     *
     * An interface representing PointOfServiceStock.
     * @record
     */
    function PointOfServiceStock() { }
    Occ.PointOfServiceStock = PointOfServiceStock;
    if (false) {
        /**
         * \@member {Address} [address]
         * @type {?|undefined}
         */
        PointOfServiceStock.prototype.address;
        /**
         * \@member {string} [description]
         * @type {?|undefined}
         */
        PointOfServiceStock.prototype.description;
        /**
         * \@member {string} [displayName]
         * @type {?|undefined}
         */
        PointOfServiceStock.prototype.displayName;
        /**
         * \@member {number} [distanceKm]
         * @type {?|undefined}
         */
        PointOfServiceStock.prototype.distanceKm;
        /**
         * \@member {{ [propertyName: string]: string }} [features]
         * @type {?|undefined}
         */
        PointOfServiceStock.prototype.features;
        /**
         * \@member {string} [formattedDistance]
         * @type {?|undefined}
         */
        PointOfServiceStock.prototype.formattedDistance;
        /**
         * \@member {GeoPoint} [geoPoint]
         * @type {?|undefined}
         */
        PointOfServiceStock.prototype.geoPoint;
        /**
         * \@member {Image} [mapIcon]
         * @type {?|undefined}
         */
        PointOfServiceStock.prototype.mapIcon;
        /**
         * \@member {string} [name]
         * @type {?|undefined}
         */
        PointOfServiceStock.prototype.name;
        /**
         * \@member {OpeningSchedule} [openingHours]
         * @type {?|undefined}
         */
        PointOfServiceStock.prototype.openingHours;
        /**
         * \@member {Stock} [stockInfo]
         * @type {?|undefined}
         */
        PointOfServiceStock.prototype.stockInfo;
        /**
         * \@member {string} [storeContent]
         * @type {?|undefined}
         */
        PointOfServiceStock.prototype.storeContent;
        /**
         * \@member {Image[]} [storeImages]
         * @type {?|undefined}
         */
        PointOfServiceStock.prototype.storeImages;
        /**
         * \@member {string} [url]
         * @type {?|undefined}
         */
        PointOfServiceStock.prototype.url;
    }
    /**
     *
     * An interface representing ProductExpressUpdateElement.
     * @record
     */
    function ProductExpressUpdateElement() { }
    Occ.ProductExpressUpdateElement = ProductExpressUpdateElement;
    if (false) {
        /**
         * \@member {string} [catalogId]
         * @type {?|undefined}
         */
        ProductExpressUpdateElement.prototype.catalogId;
        /**
         * \@member {string} [catalogVersion]
         * @type {?|undefined}
         */
        ProductExpressUpdateElement.prototype.catalogVersion;
        /**
         * \@member {string} [code]
         * @type {?|undefined}
         */
        ProductExpressUpdateElement.prototype.code;
    }
    /**
     *
     * An interface representing ProductExpressUpdateElementList.
     * @record
     */
    function ProductExpressUpdateElementList() { }
    Occ.ProductExpressUpdateElementList = ProductExpressUpdateElementList;
    if (false) {
        /**
         * \@member {ProductExpressUpdateElement[]} [productExpressUpdateElements]
         * @type {?|undefined}
         */
        ProductExpressUpdateElementList.prototype.productExpressUpdateElements;
    }
    /**
     *
     * An interface representing ProductList.
     * @record
     */
    function ProductList() { }
    Occ.ProductList = ProductList;
    if (false) {
        /**
         * \@member {string} [catalog]
         * @type {?|undefined}
         */
        ProductList.prototype.catalog;
        /**
         * \@member {number} [currentPage]
         * @type {?|undefined}
         */
        ProductList.prototype.currentPage;
        /**
         * \@member {Product[]} [products]
         * @type {?|undefined}
         */
        ProductList.prototype.products;
        /**
         * \@member {number} [totalPageCount]
         * @type {?|undefined}
         */
        ProductList.prototype.totalPageCount;
        /**
         * \@member {number} [totalProductCount]
         * @type {?|undefined}
         */
        ProductList.prototype.totalProductCount;
        /**
         * \@member {string} [version]
         * @type {?|undefined}
         */
        ProductList.prototype.version;
    }
    /**
     *
     * An interface representing ProductReferenceList.
     * @record
     */
    function ProductReferenceList() { }
    Occ.ProductReferenceList = ProductReferenceList;
    if (false) {
        /**
         * \@member {ProductReference[]} [references]
         * @type {?|undefined}
         */
        ProductReferenceList.prototype.references;
    }
    /**
     *
     * An interface representing SpellingSuggestion.
     * @record
     */
    function SpellingSuggestion() { }
    Occ.SpellingSuggestion = SpellingSuggestion;
    if (false) {
        /**
         * \@member {string} [query]
         * @type {?|undefined}
         */
        SpellingSuggestion.prototype.query;
        /**
         * \@member {string} [suggestion]
         * @type {?|undefined}
         */
        SpellingSuggestion.prototype.suggestion;
    }
    /**
     *
     * An interface representing ProductSearchPage.
     * @record
     */
    function ProductSearchPage() { }
    Occ.ProductSearchPage = ProductSearchPage;
    if (false) {
        /**
         * \@member {Breadcrumb[]} [breadcrumbs]
         * @type {?|undefined}
         */
        ProductSearchPage.prototype.breadcrumbs;
        /**
         * \@member {string} [categoryCode]
         * @type {?|undefined}
         */
        ProductSearchPage.prototype.categoryCode;
        /**
         * \@member {SearchState} [currentQuery]
         * @type {?|undefined}
         */
        ProductSearchPage.prototype.currentQuery;
        /**
         * \@member {Facet[]} [facets]
         * @type {?|undefined}
         */
        ProductSearchPage.prototype.facets;
        /**
         * \@member {string} [freeTextSearch]
         * @type {?|undefined}
         */
        ProductSearchPage.prototype.freeTextSearch;
        /**
         * \@member {string} [keywordRedirectUrl]
         * @type {?|undefined}
         */
        ProductSearchPage.prototype.keywordRedirectUrl;
        /**
         * \@member {PaginationModel} [pagination]
         * @type {?|undefined}
         */
        ProductSearchPage.prototype.pagination;
        /**
         * \@member {Product[]} [products]
         * @type {?|undefined}
         */
        ProductSearchPage.prototype.products;
        /**
         * \@member {SortModel[]} [sorts]
         * @type {?|undefined}
         */
        ProductSearchPage.prototype.sorts;
        /**
         * \@member {SpellingSuggestion} [spellingSuggestion]
         * @type {?|undefined}
         */
        ProductSearchPage.prototype.spellingSuggestion;
    }
    /**
     *
     * An interface representing PromotionList.
     * @record
     */
    function PromotionList() { }
    Occ.PromotionList = PromotionList;
    if (false) {
        /**
         * \@member {Promotion[]} [promotions]
         * @type {?|undefined}
         */
        PromotionList.prototype.promotions;
    }
    /**
     *
     * An interface representing PromotionResultList.
     * @record
     */
    function PromotionResultList() { }
    Occ.PromotionResultList = PromotionResultList;
    if (false) {
        /**
         * \@member {PromotionResult[]} [promotions]
         * @type {?|undefined}
         */
        PromotionResultList.prototype.promotions;
    }
    /**
     *
     * An interface representing ReviewList.
     * @record
     */
    function ReviewList() { }
    Occ.ReviewList = ReviewList;
    if (false) {
        /**
         * \@member {Review[]} [reviews]
         * @type {?|undefined}
         */
        ReviewList.prototype.reviews;
    }
    /**
     *
     * An interface representing SaveCartResult.
     * @record
     */
    function SaveCartResult() { }
    Occ.SaveCartResult = SaveCartResult;
    if (false) {
        /**
         * \@member {Cart} [savedCartData]
         * @type {?|undefined}
         */
        SaveCartResult.prototype.savedCartData;
    }
    /**
     *
     * An interface representing StoreFinderSearchPage.
     * @record
     */
    function StoreFinderSearchPage() { }
    Occ.StoreFinderSearchPage = StoreFinderSearchPage;
    if (false) {
        /**
         * \@member {number} [boundEastLongitude]
         * @type {?|undefined}
         */
        StoreFinderSearchPage.prototype.boundEastLongitude;
        /**
         * \@member {number} [boundNorthLatitude]
         * @type {?|undefined}
         */
        StoreFinderSearchPage.prototype.boundNorthLatitude;
        /**
         * \@member {number} [boundSouthLatitude]
         * @type {?|undefined}
         */
        StoreFinderSearchPage.prototype.boundSouthLatitude;
        /**
         * \@member {number} [boundWestLongitude]
         * @type {?|undefined}
         */
        StoreFinderSearchPage.prototype.boundWestLongitude;
        /**
         * \@member {string} [locationText]
         * @type {?|undefined}
         */
        StoreFinderSearchPage.prototype.locationText;
        /**
         * \@member {PaginationModel} [pagination]
         * @type {?|undefined}
         */
        StoreFinderSearchPage.prototype.pagination;
        /**
         * \@member {SortModel[]} [sorts]
         * @type {?|undefined}
         */
        StoreFinderSearchPage.prototype.sorts;
        /**
         * \@member {number} [sourceLatitude]
         * @type {?|undefined}
         */
        StoreFinderSearchPage.prototype.sourceLatitude;
        /**
         * \@member {number} [sourceLongitude]
         * @type {?|undefined}
         */
        StoreFinderSearchPage.prototype.sourceLongitude;
        /**
         * \@member {PointOfService[]} [stores]
         * @type {?|undefined}
         */
        StoreFinderSearchPage.prototype.stores;
    }
    /**
     *
     * An interface representing StoreFinderStockSearchPage.
     * @record
     */
    function StoreFinderStockSearchPage() { }
    Occ.StoreFinderStockSearchPage = StoreFinderStockSearchPage;
    if (false) {
        /**
         * \@member {number} [boundEastLongitude]
         * @type {?|undefined}
         */
        StoreFinderStockSearchPage.prototype.boundEastLongitude;
        /**
         * \@member {number} [boundNorthLatitude]
         * @type {?|undefined}
         */
        StoreFinderStockSearchPage.prototype.boundNorthLatitude;
        /**
         * \@member {number} [boundSouthLatitude]
         * @type {?|undefined}
         */
        StoreFinderStockSearchPage.prototype.boundSouthLatitude;
        /**
         * \@member {number} [boundWestLongitude]
         * @type {?|undefined}
         */
        StoreFinderStockSearchPage.prototype.boundWestLongitude;
        /**
         * \@member {string} [locationText]
         * @type {?|undefined}
         */
        StoreFinderStockSearchPage.prototype.locationText;
        /**
         * \@member {PaginationModel} [pagination]
         * @type {?|undefined}
         */
        StoreFinderStockSearchPage.prototype.pagination;
        /**
         * \@member {Product} [product]
         * @type {?|undefined}
         */
        StoreFinderStockSearchPage.prototype.product;
        /**
         * \@member {SortModel[]} [sorts]
         * @type {?|undefined}
         */
        StoreFinderStockSearchPage.prototype.sorts;
        /**
         * \@member {number} [sourceLatitude]
         * @type {?|undefined}
         */
        StoreFinderStockSearchPage.prototype.sourceLatitude;
        /**
         * \@member {number} [sourceLongitude]
         * @type {?|undefined}
         */
        StoreFinderStockSearchPage.prototype.sourceLongitude;
        /**
         * \@member {PointOfServiceStock[]} [stores]
         * @type {?|undefined}
         */
        StoreFinderStockSearchPage.prototype.stores;
    }
    /**
     *
     * An interface representing Suggestion.
     * @record
     */
    function Suggestion() { }
    Occ.Suggestion = Suggestion;
    if (false) {
        /**
         * \@member {string} [value]
         * @type {?|undefined}
         */
        Suggestion.prototype.value;
    }
    /**
     *
     * An interface representing SuggestionList.
     * @record
     */
    function SuggestionList() { }
    Occ.SuggestionList = SuggestionList;
    if (false) {
        /**
         * \@member {Suggestion[]} [suggestions]
         * @type {?|undefined}
         */
        SuggestionList.prototype.suggestions;
    }
    /**
     *
     * An interface representing Title.
     * @record
     */
    function Title() { }
    Occ.Title = Title;
    if (false) {
        /**
         * \@member {string} [code]
         * @type {?|undefined}
         */
        Title.prototype.code;
        /**
         * \@member {string} [name]
         * @type {?|undefined}
         */
        Title.prototype.name;
    }
    /**
     *
     * An interface representing TitleList.
     * @record
     */
    function TitleList() { }
    Occ.TitleList = TitleList;
    if (false) {
        /**
         * \@member {Title[]} [titles]
         * @type {?|undefined}
         */
        TitleList.prototype.titles;
    }
    /**
     *
     * An interface representing UserGroup.
     * @record
     */
    function UserGroup() { }
    Occ.UserGroup = UserGroup;
    if (false) {
        /**
         * \@member {Principal[]} [members]
         * @type {?|undefined}
         */
        UserGroup.prototype.members;
        /**
         * \@member {number} [membersCount]
         * @type {?|undefined}
         */
        UserGroup.prototype.membersCount;
        /**
         * \@member {string} [name]
         * @type {?|undefined}
         */
        UserGroup.prototype.name;
        /**
         * \@member {UserGroup[]} [subGroups]
         * @type {?|undefined}
         */
        UserGroup.prototype.subGroups;
        /**
         * \@member {string} [uid]
         * @type {?|undefined}
         */
        UserGroup.prototype.uid;
    }
    /**
     *
     * An interface representing UserGroupList.
     * @record
     */
    function UserGroupList() { }
    Occ.UserGroupList = UserGroupList;
    if (false) {
        /**
         * \@member {number} [currentPage]
         * @type {?|undefined}
         */
        UserGroupList.prototype.currentPage;
        /**
         * \@member {number} [numberOfPages]
         * @type {?|undefined}
         */
        UserGroupList.prototype.numberOfPages;
        /**
         * \@member {number} [pageSize]
         * @type {?|undefined}
         */
        UserGroupList.prototype.pageSize;
        /**
         * \@member {number} [totalNumber]
         * @type {?|undefined}
         */
        UserGroupList.prototype.totalNumber;
        /**
         * \@member {UserGroup[]} [userGroups]
         * @type {?|undefined}
         */
        UserGroupList.prototype.userGroups;
    }
    /**
     *
     * An interface representing UserSignUp.
     * @record
     */
    function UserSignUp() { }
    Occ.UserSignUp = UserSignUp;
    if (false) {
        /**
         * \@member {string} [firstName]
         * @type {?|undefined}
         */
        UserSignUp.prototype.firstName;
        /**
         * \@member {string} [lastName]
         * @type {?|undefined}
         */
        UserSignUp.prototype.lastName;
        /**
         * \@member {string} [password]
         * @type {?|undefined}
         */
        UserSignUp.prototype.password;
        /**
         * \@member {string} [titleCode]
         * @type {?|undefined}
         */
        UserSignUp.prototype.titleCode;
        /**
         * \@member {string} [uid]
         * @type {?|undefined}
         */
        UserSignUp.prototype.uid;
    }
    /**
     * @record
     */
    function StoreCount() { }
    Occ.StoreCount = StoreCount;
    if (false) {
        /** @type {?|undefined} */
        StoreCount.prototype.count;
        /** @type {?|undefined} */
        StoreCount.prototype.isoCode;
        /** @type {?|undefined} */
        StoreCount.prototype.name;
        /** @type {?|undefined} */
        StoreCount.prototype.type;
    }
    /**
     * @record
     */
    function StoreCountList() { }
    Occ.StoreCountList = StoreCountList;
    if (false) {
        /** @type {?|undefined} */
        StoreCountList.prototype.countriesAndRegionsStoreCount;
    }
    /**
     *
     * An interface representing VoucherList.
     * @record
     */
    function VoucherList() { }
    Occ.VoucherList = VoucherList;
    if (false) {
        /**
         * \@member {Voucher[]} [vouchers]
         * @type {?|undefined}
         */
        VoucherList.prototype.vouchers;
    }
    /**
     * Defines values for PriceType.
     * Possible values include: 'BUY', 'FROM'
     * There could be more values for this enum apart from the ones defined here.If
     * you want to set a value that is not from the known values then you can do
     * the following:
     * let param: PriceType = <PriceType>"someUnknownValueThatWillStillBeValid";
     * @readonly
     * @enum {string}
     */
    let PriceType;
    (function (PriceType) {
        PriceType["BUY"] = "BUY";
        PriceType["FROM"] = "FROM";
    })(PriceType = Occ.PriceType || (Occ.PriceType = {}));
    /**
     * Defines values for ImageType.
     * Possible values include: 'PRIMARY', 'GALLERY'
     * There could be more values for this enum apart from the ones defined here.If
     * you want to set a value that is not from the known values then you can do
     * the following:
     * let param: ImageType = <ImageType>"someUnknownValueThatWillStillBeValid";
     * @readonly
     * @enum {string}
     */
    let ImageType;
    (function (ImageType) {
        ImageType["PRIMARY"] = "PRIMARY";
        ImageType["GALLERY"] = "GALLERY";
    })(ImageType = Occ.ImageType || (Occ.ImageType = {}));
    /**
     * Defines values for Fields.
     * Possible values include: 'BASIC', 'DEFAULT', 'FULL'
     * There could be more values for this enum apart from the ones defined here.If
     * you want to set a value that is not from the known values then you can do
     * the following:
     * let param: Fields = <Fields>"someUnknownValueThatWillStillBeValid";
     * @readonly
     * @enum {string}
     */
    let Fields;
    (function (Fields) {
        Fields["BASIC"] = "BASIC";
        Fields["DEFAULT"] = "DEFAULT";
        Fields["FULL"] = "FULL";
    })(Fields = Occ.Fields || (Occ.Fields = {}));
    /**
     * Defines values for Fields1.
     * Possible values include: 'BASIC', 'DEFAULT', 'FULL'
     * There could be more values for this enum apart from the ones defined here.If
     * you want to set a value that is not from the known values then you can do
     * the following:
     * let param: Fields1 = <Fields1>"someUnknownValueThatWillStillBeValid";
     * @readonly
     * @enum {string}
     */
    let Fields1;
    (function (Fields1) {
        Fields1["BASIC"] = "BASIC";
        Fields1["DEFAULT"] = "DEFAULT";
        Fields1["FULL"] = "FULL";
    })(Fields1 = Occ.Fields1 || (Occ.Fields1 = {}));
    /**
     * Defines values for Fields2.
     * Possible values include: 'BASIC', 'DEFAULT', 'FULL'
     * There could be more values for this enum apart from the ones defined here.If
     * you want to set a value that is not from the known values then you can do
     * the following:
     * let param: Fields2 = <Fields2>"someUnknownValueThatWillStillBeValid";
     * @readonly
     * @enum {string}
     */
    let Fields2;
    (function (Fields2) {
        Fields2["BASIC"] = "BASIC";
        Fields2["DEFAULT"] = "DEFAULT";
        Fields2["FULL"] = "FULL";
    })(Fields2 = Occ.Fields2 || (Occ.Fields2 = {}));
    /**
     * Defines values for Fields3.
     * Possible values include: 'BASIC', 'DEFAULT', 'FULL'
     * There could be more values for this enum apart from the ones defined here.If
     * you want to set a value that is not from the known values then you can do
     * the following:
     * let param: Fields3 = <Fields3>"someUnknownValueThatWillStillBeValid";
     * @readonly
     * @enum {string}
     */
    let Fields3;
    (function (Fields3) {
        Fields3["BASIC"] = "BASIC";
        Fields3["DEFAULT"] = "DEFAULT";
        Fields3["FULL"] = "FULL";
    })(Fields3 = Occ.Fields3 || (Occ.Fields3 = {}));
    /**
     * Defines values for Fields4.
     * Possible values include: 'BASIC', 'DEFAULT', 'FULL'
     * There could be more values for this enum apart from the ones defined here.If
     * you want to set a value that is not from the known values then you can do
     * the following:
     * let param: Fields4 = <Fields4>"someUnknownValueThatWillStillBeValid";
     * @readonly
     * @enum {string}
     */
    let Fields4;
    (function (Fields4) {
        Fields4["BASIC"] = "BASIC";
        Fields4["DEFAULT"] = "DEFAULT";
        Fields4["FULL"] = "FULL";
    })(Fields4 = Occ.Fields4 || (Occ.Fields4 = {}));
    /**
     * Defines values for Fields5.
     * Possible values include: 'BASIC', 'DEFAULT', 'FULL'
     * There could be more values for this enum apart from the ones defined here.If
     * you want to set a value that is not from the known values then you can do
     * the following:
     * let param: Fields5 = <Fields5>"someUnknownValueThatWillStillBeValid";
     * @readonly
     * @enum {string}
     */
    let Fields5;
    (function (Fields5) {
        Fields5["BASIC"] = "BASIC";
        Fields5["DEFAULT"] = "DEFAULT";
        Fields5["FULL"] = "FULL";
    })(Fields5 = Occ.Fields5 || (Occ.Fields5 = {}));
    /**
     * Defines values for Fields6.
     * Possible values include: 'BASIC', 'DEFAULT', 'FULL'
     * There could be more values for this enum apart from the ones defined here.If
     * you want to set a value that is not from the known values then you can do
     * the following:
     * let param: Fields6 = <Fields6>"someUnknownValueThatWillStillBeValid";
     * @readonly
     * @enum {string}
     */
    let Fields6;
    (function (Fields6) {
        Fields6["BASIC"] = "BASIC";
        Fields6["DEFAULT"] = "DEFAULT";
        Fields6["FULL"] = "FULL";
    })(Fields6 = Occ.Fields6 || (Occ.Fields6 = {}));
    /**
     * Defines values for PageType.
     * Possible values include: 'ContentPage', 'ProductPage', 'CategoryPage',
     * 'CatalogPage'
     * There could be more values for this enum apart from the ones defined here.If
     * you want to set a value that is not from the known values then you can do
     * the following:
     * let param: PageType = <PageType>"someUnknownValueThatWillStillBeValid";
     * @readonly
     * @enum {string}
     */
    let PageType;
    (function (PageType) {
        PageType["CONTENT_PAGE"] = "ContentPage";
        PageType["PRODUCT_PAGE"] = "ProductPage";
        PageType["CATEGORY_PAGE"] = "CategoryPage";
        PageType["CATALOG_PAGE"] = "CatalogPage";
    })(PageType = Occ.PageType || (Occ.PageType = {}));
    /**
     * Defines values for Fields7.
     * Possible values include: 'BASIC', 'DEFAULT', 'FULL'
     * There could be more values for this enum apart from the ones defined here.If
     * you want to set a value that is not from the known values then you can do
     * the following:
     * let param: Fields7 = <Fields7>"someUnknownValueThatWillStillBeValid";
     * @readonly
     * @enum {string}
     */
    let Fields7;
    (function (Fields7) {
        Fields7["BASIC"] = "BASIC";
        Fields7["DEFAULT"] = "DEFAULT";
        Fields7["FULL"] = "FULL";
    })(Fields7 = Occ.Fields7 || (Occ.Fields7 = {}));
    /**
     * Defines values for Fields8.
     * Possible values include: 'BASIC', 'DEFAULT', 'FULL'
     * There could be more values for this enum apart from the ones defined here.If
     * you want to set a value that is not from the known values then you can do
     * the following:
     * let param: Fields8 = <Fields8>"someUnknownValueThatWillStillBeValid";
     * @readonly
     * @enum {string}
     */
    let Fields8;
    (function (Fields8) {
        Fields8["BASIC"] = "BASIC";
        Fields8["DEFAULT"] = "DEFAULT";
        Fields8["FULL"] = "FULL";
    })(Fields8 = Occ.Fields8 || (Occ.Fields8 = {}));
    /**
     * Defines values for Fields9.
     * Possible values include: 'BASIC', 'DEFAULT', 'FULL'
     * There could be more values for this enum apart from the ones defined here.If
     * you want to set a value that is not from the known values then you can do
     * the following:
     * let param: Fields9 = <Fields9>"someUnknownValueThatWillStillBeValid";
     * @readonly
     * @enum {string}
     */
    let Fields9;
    (function (Fields9) {
        Fields9["BASIC"] = "BASIC";
        Fields9["DEFAULT"] = "DEFAULT";
        Fields9["FULL"] = "FULL";
    })(Fields9 = Occ.Fields9 || (Occ.Fields9 = {}));
    /**
     * Defines values for Fields10.
     * Possible values include: 'BASIC', 'DEFAULT', 'FULL'
     * There could be more values for this enum apart from the ones defined here.If
     * you want to set a value that is not from the known values then you can do
     * the following:
     * let param: Fields10 = <Fields10>"someUnknownValueThatWillStillBeValid";
     * @readonly
     * @enum {string}
     */
    let Fields10;
    (function (Fields10) {
        Fields10["BASIC"] = "BASIC";
        Fields10["DEFAULT"] = "DEFAULT";
        Fields10["FULL"] = "FULL";
    })(Fields10 = Occ.Fields10 || (Occ.Fields10 = {}));
    /**
     * Defines values for Fields11.
     * Possible values include: 'BASIC', 'DEFAULT', 'FULL'
     * There could be more values for this enum apart from the ones defined here.If
     * you want to set a value that is not from the known values then you can do
     * the following:
     * let param: Fields11 = <Fields11>"someUnknownValueThatWillStillBeValid";
     * @readonly
     * @enum {string}
     */
    let Fields11;
    (function (Fields11) {
        Fields11["BASIC"] = "BASIC";
        Fields11["DEFAULT"] = "DEFAULT";
        Fields11["FULL"] = "FULL";
    })(Fields11 = Occ.Fields11 || (Occ.Fields11 = {}));
    /**
     * Defines values for Fields12.
     * Possible values include: 'BASIC', 'DEFAULT', 'FULL'
     * There could be more values for this enum apart from the ones defined here.If
     * you want to set a value that is not from the known values then you can do
     * the following:
     * let param: Fields12 = <Fields12>"someUnknownValueThatWillStillBeValid";
     * @readonly
     * @enum {string}
     */
    let Fields12;
    (function (Fields12) {
        Fields12["BASIC"] = "BASIC";
        Fields12["DEFAULT"] = "DEFAULT";
        Fields12["FULL"] = "FULL";
    })(Fields12 = Occ.Fields12 || (Occ.Fields12 = {}));
    /**
     * Defines values for Fields13.
     * Possible values include: 'BASIC', 'DEFAULT', 'FULL'
     * There could be more values for this enum apart from the ones defined here.If
     * you want to set a value that is not from the known values then you can do
     * the following:
     * let param: Fields13 = <Fields13>"someUnknownValueThatWillStillBeValid";
     * @readonly
     * @enum {string}
     */
    let Fields13;
    (function (Fields13) {
        Fields13["BASIC"] = "BASIC";
        Fields13["DEFAULT"] = "DEFAULT";
        Fields13["FULL"] = "FULL";
    })(Fields13 = Occ.Fields13 || (Occ.Fields13 = {}));
    /**
     * Defines values for Fields14.
     * Possible values include: 'BASIC', 'DEFAULT', 'FULL'
     * There could be more values for this enum apart from the ones defined here.If
     * you want to set a value that is not from the known values then you can do
     * the following:
     * let param: Fields14 = <Fields14>"someUnknownValueThatWillStillBeValid";
     * @readonly
     * @enum {string}
     */
    let Fields14;
    (function (Fields14) {
        Fields14["BASIC"] = "BASIC";
        Fields14["DEFAULT"] = "DEFAULT";
        Fields14["FULL"] = "FULL";
    })(Fields14 = Occ.Fields14 || (Occ.Fields14 = {}));
    /**
     * Defines values for Fields15.
     * Possible values include: 'BASIC', 'DEFAULT', 'FULL'
     * There could be more values for this enum apart from the ones defined here.If
     * you want to set a value that is not from the known values then you can do
     * the following:
     * let param: Fields15 = <Fields15>"someUnknownValueThatWillStillBeValid";
     * @readonly
     * @enum {string}
     */
    let Fields15;
    (function (Fields15) {
        Fields15["BASIC"] = "BASIC";
        Fields15["DEFAULT"] = "DEFAULT";
        Fields15["FULL"] = "FULL";
    })(Fields15 = Occ.Fields15 || (Occ.Fields15 = {}));
    /**
     * Defines values for Fields16.
     * Possible values include: 'BASIC', 'DEFAULT', 'FULL'
     * There could be more values for this enum apart from the ones defined here.If
     * you want to set a value that is not from the known values then you can do
     * the following:
     * let param: Fields16 = <Fields16>"someUnknownValueThatWillStillBeValid";
     * @readonly
     * @enum {string}
     */
    let Fields16;
    (function (Fields16) {
        Fields16["BASIC"] = "BASIC";
        Fields16["DEFAULT"] = "DEFAULT";
        Fields16["FULL"] = "FULL";
    })(Fields16 = Occ.Fields16 || (Occ.Fields16 = {}));
    /**
     * Defines values for SortEnum.
     * Possible values include: 'BASIC', 'DEFAULT', 'FULL'
     * There could be more values for this enum apart from the ones defined here.If
     * you want to set a value that is not from the known values then you can do
     * the following:
     * let param: SortEnum = <SortEnum>"someUnknownValueThatWillStillBeValid";
     * @readonly
     * @enum {string}
     */
    let SortEnum;
    (function (SortEnum) {
        SortEnum["BASIC"] = "BASIC";
        SortEnum["DEFAULT"] = "DEFAULT";
        SortEnum["FULL"] = "FULL";
    })(SortEnum = Occ.SortEnum || (Occ.SortEnum = {}));
    /**
     * Defines values for Fields17.
     * Possible values include: 'BASIC', 'DEFAULT', 'FULL'
     * There could be more values for this enum apart from the ones defined here.If
     * you want to set a value that is not from the known values then you can do
     * the following:
     * let param: Fields17 = <Fields17>"someUnknownValueThatWillStillBeValid";
     * @readonly
     * @enum {string}
     */
    let Fields17;
    (function (Fields17) {
        Fields17["BASIC"] = "BASIC";
        Fields17["DEFAULT"] = "DEFAULT";
        Fields17["FULL"] = "FULL";
    })(Fields17 = Occ.Fields17 || (Occ.Fields17 = {}));
    /**
     * Defines values for Fields18.
     * Possible values include: 'BASIC', 'DEFAULT', 'FULL'
     * There could be more values for this enum apart from the ones defined here.If
     * you want to set a value that is not from the known values then you can do
     * the following:
     * let param: Fields18 = <Fields18>"someUnknownValueThatWillStillBeValid";
     * @readonly
     * @enum {string}
     */
    let Fields18;
    (function (Fields18) {
        Fields18["BASIC"] = "BASIC";
        Fields18["DEFAULT"] = "DEFAULT";
        Fields18["FULL"] = "FULL";
    })(Fields18 = Occ.Fields18 || (Occ.Fields18 = {}));
    /**
     * Defines values for Fields19.
     * Possible values include: 'BASIC', 'DEFAULT', 'FULL'
     * There could be more values for this enum apart from the ones defined here.If
     * you want to set a value that is not from the known values then you can do
     * the following:
     * let param: Fields19 = <Fields19>"someUnknownValueThatWillStillBeValid";
     * @readonly
     * @enum {string}
     */
    let Fields19;
    (function (Fields19) {
        Fields19["BASIC"] = "BASIC";
        Fields19["DEFAULT"] = "DEFAULT";
        Fields19["FULL"] = "FULL";
    })(Fields19 = Occ.Fields19 || (Occ.Fields19 = {}));
    /**
     * Defines values for Fields20.
     * Possible values include: 'BASIC', 'DEFAULT', 'FULL'
     * There could be more values for this enum apart from the ones defined here.If
     * you want to set a value that is not from the known values then you can do
     * the following:
     * let param: Fields20 = <Fields20>"someUnknownValueThatWillStillBeValid";
     * @readonly
     * @enum {string}
     */
    let Fields20;
    (function (Fields20) {
        Fields20["BASIC"] = "BASIC";
        Fields20["DEFAULT"] = "DEFAULT";
        Fields20["FULL"] = "FULL";
    })(Fields20 = Occ.Fields20 || (Occ.Fields20 = {}));
    /**
     * Defines values for Fields21.
     * Possible values include: 'BASIC', 'DEFAULT', 'FULL'
     * There could be more values for this enum apart from the ones defined here.If
     * you want to set a value that is not from the known values then you can do
     * the following:
     * let param: Fields21 = <Fields21>"someUnknownValueThatWillStillBeValid";
     * @readonly
     * @enum {string}
     */
    let Fields21;
    (function (Fields21) {
        Fields21["BASIC"] = "BASIC";
        Fields21["DEFAULT"] = "DEFAULT";
        Fields21["FULL"] = "FULL";
    })(Fields21 = Occ.Fields21 || (Occ.Fields21 = {}));
    /**
     * Defines values for Fields22.
     * Possible values include: 'BASIC', 'DEFAULT', 'FULL'
     * There could be more values for this enum apart from the ones defined here.If
     * you want to set a value that is not from the known values then you can do
     * the following:
     * let param: Fields22 = <Fields22>"someUnknownValueThatWillStillBeValid";
     * @readonly
     * @enum {string}
     */
    let Fields22;
    (function (Fields22) {
        Fields22["BASIC"] = "BASIC";
        Fields22["DEFAULT"] = "DEFAULT";
        Fields22["FULL"] = "FULL";
    })(Fields22 = Occ.Fields22 || (Occ.Fields22 = {}));
    /**
     * Defines values for Fields23.
     * Possible values include: 'BASIC', 'DEFAULT', 'FULL'
     * There could be more values for this enum apart from the ones defined here.If
     * you want to set a value that is not from the known values then you can do
     * the following:
     * let param: Fields23 = <Fields23>"someUnknownValueThatWillStillBeValid";
     * @readonly
     * @enum {string}
     */
    let Fields23;
    (function (Fields23) {
        Fields23["BASIC"] = "BASIC";
        Fields23["DEFAULT"] = "DEFAULT";
        Fields23["FULL"] = "FULL";
    })(Fields23 = Occ.Fields23 || (Occ.Fields23 = {}));
    /**
     * Defines values for Fields24.
     * Possible values include: 'BASIC', 'DEFAULT', 'FULL'
     * There could be more values for this enum apart from the ones defined here.If
     * you want to set a value that is not from the known values then you can do
     * the following:
     * let param: Fields24 = <Fields24>"someUnknownValueThatWillStillBeValid";
     * @readonly
     * @enum {string}
     */
    let Fields24;
    (function (Fields24) {
        Fields24["BASIC"] = "BASIC";
        Fields24["DEFAULT"] = "DEFAULT";
        Fields24["FULL"] = "FULL";
    })(Fields24 = Occ.Fields24 || (Occ.Fields24 = {}));
    /**
     * Defines values for Fields25.
     * Possible values include: 'BASIC', 'DEFAULT', 'FULL'
     * There could be more values for this enum apart from the ones defined here.If
     * you want to set a value that is not from the known values then you can do
     * the following:
     * let param: Fields25 = <Fields25>"someUnknownValueThatWillStillBeValid";
     * @readonly
     * @enum {string}
     */
    let Fields25;
    (function (Fields25) {
        Fields25["BASIC"] = "BASIC";
        Fields25["DEFAULT"] = "DEFAULT";
        Fields25["FULL"] = "FULL";
    })(Fields25 = Occ.Fields25 || (Occ.Fields25 = {}));
    /**
     * Defines values for Fields26.
     * Possible values include: 'BASIC', 'DEFAULT', 'FULL'
     * There could be more values for this enum apart from the ones defined here.If
     * you want to set a value that is not from the known values then you can do
     * the following:
     * let param: Fields26 = <Fields26>"someUnknownValueThatWillStillBeValid";
     * @readonly
     * @enum {string}
     */
    let Fields26;
    (function (Fields26) {
        Fields26["BASIC"] = "BASIC";
        Fields26["DEFAULT"] = "DEFAULT";
        Fields26["FULL"] = "FULL";
    })(Fields26 = Occ.Fields26 || (Occ.Fields26 = {}));
    /**
     * Defines values for Fields27.
     * Possible values include: 'BASIC', 'DEFAULT', 'FULL'
     * There could be more values for this enum apart from the ones defined here.If
     * you want to set a value that is not from the known values then you can do
     * the following:
     * let param: Fields27 = <Fields27>"someUnknownValueThatWillStillBeValid";
     * @readonly
     * @enum {string}
     */
    let Fields27;
    (function (Fields27) {
        Fields27["BASIC"] = "BASIC";
        Fields27["DEFAULT"] = "DEFAULT";
        Fields27["FULL"] = "FULL";
    })(Fields27 = Occ.Fields27 || (Occ.Fields27 = {}));
    /**
     * Defines values for Fields28.
     * Possible values include: 'BASIC', 'DEFAULT', 'FULL'
     * There could be more values for this enum apart from the ones defined here.If
     * you want to set a value that is not from the known values then you can do
     * the following:
     * let param: Fields28 = <Fields28>"someUnknownValueThatWillStillBeValid";
     * @readonly
     * @enum {string}
     */
    let Fields28;
    (function (Fields28) {
        Fields28["BASIC"] = "BASIC";
        Fields28["DEFAULT"] = "DEFAULT";
        Fields28["FULL"] = "FULL";
    })(Fields28 = Occ.Fields28 || (Occ.Fields28 = {}));
    /**
     * Defines values for Fields29.
     * Possible values include: 'BASIC', 'DEFAULT', 'FULL'
     * There could be more values for this enum apart from the ones defined here.If
     * you want to set a value that is not from the known values then you can do
     * the following:
     * let param: Fields29 = <Fields29>"someUnknownValueThatWillStillBeValid";
     * @readonly
     * @enum {string}
     */
    let Fields29;
    (function (Fields29) {
        Fields29["BASIC"] = "BASIC";
        Fields29["DEFAULT"] = "DEFAULT";
        Fields29["FULL"] = "FULL";
    })(Fields29 = Occ.Fields29 || (Occ.Fields29 = {}));
    /**
     * Defines values for Fields30.
     * Possible values include: 'BASIC', 'DEFAULT', 'FULL'
     * There could be more values for this enum apart from the ones defined here.If
     * you want to set a value that is not from the known values then you can do
     * the following:
     * let param: Fields30 = <Fields30>"someUnknownValueThatWillStillBeValid";
     * @readonly
     * @enum {string}
     */
    let Fields30;
    (function (Fields30) {
        Fields30["BASIC"] = "BASIC";
        Fields30["DEFAULT"] = "DEFAULT";
        Fields30["FULL"] = "FULL";
    })(Fields30 = Occ.Fields30 || (Occ.Fields30 = {}));
    /**
     * Defines values for Fields31.
     * Possible values include: 'BASIC', 'DEFAULT', 'FULL'
     * There could be more values for this enum apart from the ones defined here.If
     * you want to set a value that is not from the known values then you can do
     * the following:
     * let param: Fields31 = <Fields31>"someUnknownValueThatWillStillBeValid";
     * @readonly
     * @enum {string}
     */
    let Fields31;
    (function (Fields31) {
        Fields31["BASIC"] = "BASIC";
        Fields31["DEFAULT"] = "DEFAULT";
        Fields31["FULL"] = "FULL";
    })(Fields31 = Occ.Fields31 || (Occ.Fields31 = {}));
    /**
     * Defines values for Fields32.
     * Possible values include: 'BASIC', 'DEFAULT', 'FULL'
     * There could be more values for this enum apart from the ones defined here.If
     * you want to set a value that is not from the known values then you can do
     * the following:
     * let param: Fields32 = <Fields32>"someUnknownValueThatWillStillBeValid";
     * @readonly
     * @enum {string}
     */
    let Fields32;
    (function (Fields32) {
        Fields32["BASIC"] = "BASIC";
        Fields32["DEFAULT"] = "DEFAULT";
        Fields32["FULL"] = "FULL";
    })(Fields32 = Occ.Fields32 || (Occ.Fields32 = {}));
    /**
     * Defines values for Fields33.
     * Possible values include: 'BASIC', 'DEFAULT', 'FULL'
     * There could be more values for this enum apart from the ones defined here.If
     * you want to set a value that is not from the known values then you can do
     * the following:
     * let param: Fields33 = <Fields33>"someUnknownValueThatWillStillBeValid";
     * @readonly
     * @enum {string}
     */
    let Fields33;
    (function (Fields33) {
        Fields33["BASIC"] = "BASIC";
        Fields33["DEFAULT"] = "DEFAULT";
        Fields33["FULL"] = "FULL";
    })(Fields33 = Occ.Fields33 || (Occ.Fields33 = {}));
    /**
     * Defines values for Fields34.
     * Possible values include: 'BASIC', 'DEFAULT', 'FULL'
     * There could be more values for this enum apart from the ones defined here.If
     * you want to set a value that is not from the known values then you can do
     * the following:
     * let param: Fields34 = <Fields34>"someUnknownValueThatWillStillBeValid";
     * @readonly
     * @enum {string}
     */
    let Fields34;
    (function (Fields34) {
        Fields34["BASIC"] = "BASIC";
        Fields34["DEFAULT"] = "DEFAULT";
        Fields34["FULL"] = "FULL";
    })(Fields34 = Occ.Fields34 || (Occ.Fields34 = {}));
    /**
     * Defines values for Fields35.
     * Possible values include: 'BASIC', 'DEFAULT', 'FULL'
     * There could be more values for this enum apart from the ones defined here.If
     * you want to set a value that is not from the known values then you can do
     * the following:
     * let param: Fields35 = <Fields35>"someUnknownValueThatWillStillBeValid";
     * @readonly
     * @enum {string}
     */
    let Fields35;
    (function (Fields35) {
        Fields35["BASIC"] = "BASIC";
        Fields35["DEFAULT"] = "DEFAULT";
        Fields35["FULL"] = "FULL";
    })(Fields35 = Occ.Fields35 || (Occ.Fields35 = {}));
    /**
     * Defines values for Fields36.
     * Possible values include: 'BASIC', 'DEFAULT', 'FULL'
     * There could be more values for this enum apart from the ones defined here.If
     * you want to set a value that is not from the known values then you can do
     * the following:
     * let param: Fields36 = <Fields36>"someUnknownValueThatWillStillBeValid";
     * @readonly
     * @enum {string}
     */
    let Fields36;
    (function (Fields36) {
        Fields36["BASIC"] = "BASIC";
        Fields36["DEFAULT"] = "DEFAULT";
        Fields36["FULL"] = "FULL";
    })(Fields36 = Occ.Fields36 || (Occ.Fields36 = {}));
    /**
     * Defines values for Fields37.
     * Possible values include: 'BASIC', 'DEFAULT', 'FULL'
     * There could be more values for this enum apart from the ones defined here.If
     * you want to set a value that is not from the known values then you can do
     * the following:
     * let param: Fields37 = <Fields37>"someUnknownValueThatWillStillBeValid";
     * @readonly
     * @enum {string}
     */
    let Fields37;
    (function (Fields37) {
        Fields37["BASIC"] = "BASIC";
        Fields37["DEFAULT"] = "DEFAULT";
        Fields37["FULL"] = "FULL";
    })(Fields37 = Occ.Fields37 || (Occ.Fields37 = {}));
    /**
     * Defines values for Fields38.
     * Possible values include: 'BASIC', 'DEFAULT', 'FULL'
     * There could be more values for this enum apart from the ones defined here.If
     * you want to set a value that is not from the known values then you can do
     * the following:
     * let param: Fields38 = <Fields38>"someUnknownValueThatWillStillBeValid";
     * @readonly
     * @enum {string}
     */
    let Fields38;
    (function (Fields38) {
        Fields38["BASIC"] = "BASIC";
        Fields38["DEFAULT"] = "DEFAULT";
        Fields38["FULL"] = "FULL";
    })(Fields38 = Occ.Fields38 || (Occ.Fields38 = {}));
    /**
     * Defines values for Fields39.
     * Possible values include: 'BASIC', 'DEFAULT', 'FULL'
     * There could be more values for this enum apart from the ones defined here.If
     * you want to set a value that is not from the known values then you can do
     * the following:
     * let param: Fields39 = <Fields39>"someUnknownValueThatWillStillBeValid";
     * @readonly
     * @enum {string}
     */
    let Fields39;
    (function (Fields39) {
        Fields39["BASIC"] = "BASIC";
        Fields39["DEFAULT"] = "DEFAULT";
        Fields39["FULL"] = "FULL";
    })(Fields39 = Occ.Fields39 || (Occ.Fields39 = {}));
    /**
     * Defines values for Fields40.
     * Possible values include: 'BASIC', 'DEFAULT', 'FULL'
     * There could be more values for this enum apart from the ones defined here.If
     * you want to set a value that is not from the known values then you can do
     * the following:
     * let param: Fields40 = <Fields40>"someUnknownValueThatWillStillBeValid";
     * @readonly
     * @enum {string}
     */
    let Fields40;
    (function (Fields40) {
        Fields40["BASIC"] = "BASIC";
        Fields40["DEFAULT"] = "DEFAULT";
        Fields40["FULL"] = "FULL";
    })(Fields40 = Occ.Fields40 || (Occ.Fields40 = {}));
    /**
     * Defines values for Fields41.
     * Possible values include: 'BASIC', 'DEFAULT', 'FULL'
     * There could be more values for this enum apart from the ones defined here.If
     * you want to set a value that is not from the known values then you can do
     * the following:
     * let param: Fields41 = <Fields41>"someUnknownValueThatWillStillBeValid";
     * @readonly
     * @enum {string}
     */
    let Fields41;
    (function (Fields41) {
        Fields41["BASIC"] = "BASIC";
        Fields41["DEFAULT"] = "DEFAULT";
        Fields41["FULL"] = "FULL";
    })(Fields41 = Occ.Fields41 || (Occ.Fields41 = {}));
    /**
     * Defines values for Fields42.
     * Possible values include: 'BASIC', 'DEFAULT', 'FULL'
     * There could be more values for this enum apart from the ones defined here.If
     * you want to set a value that is not from the known values then you can do
     * the following:
     * let param: Fields42 = <Fields42>"someUnknownValueThatWillStillBeValid";
     * @readonly
     * @enum {string}
     */
    let Fields42;
    (function (Fields42) {
        Fields42["BASIC"] = "BASIC";
        Fields42["DEFAULT"] = "DEFAULT";
        Fields42["FULL"] = "FULL";
    })(Fields42 = Occ.Fields42 || (Occ.Fields42 = {}));
    /**
     * Defines values for Fields43.
     * Possible values include: 'BASIC', 'DEFAULT', 'FULL'
     * There could be more values for this enum apart from the ones defined here.If
     * you want to set a value that is not from the known values then you can do
     * the following:
     * let param: Fields43 = <Fields43>"someUnknownValueThatWillStillBeValid";
     * @readonly
     * @enum {string}
     */
    let Fields43;
    (function (Fields43) {
        Fields43["BASIC"] = "BASIC";
        Fields43["DEFAULT"] = "DEFAULT";
        Fields43["FULL"] = "FULL";
    })(Fields43 = Occ.Fields43 || (Occ.Fields43 = {}));
    /**
     * Defines values for Fields44.
     * Possible values include: 'BASIC', 'DEFAULT', 'FULL'
     * There could be more values for this enum apart from the ones defined here.If
     * you want to set a value that is not from the known values then you can do
     * the following:
     * let param: Fields44 = <Fields44>"someUnknownValueThatWillStillBeValid";
     * @readonly
     * @enum {string}
     */
    let Fields44;
    (function (Fields44) {
        Fields44["BASIC"] = "BASIC";
        Fields44["DEFAULT"] = "DEFAULT";
        Fields44["FULL"] = "FULL";
    })(Fields44 = Occ.Fields44 || (Occ.Fields44 = {}));
    /**
     * Defines values for Fields45.
     * Possible values include: 'BASIC', 'DEFAULT', 'FULL'
     * There could be more values for this enum apart from the ones defined here.If
     * you want to set a value that is not from the known values then you can do
     * the following:
     * let param: Fields45 = <Fields45>"someUnknownValueThatWillStillBeValid";
     * @readonly
     * @enum {string}
     */
    let Fields45;
    (function (Fields45) {
        Fields45["BASIC"] = "BASIC";
        Fields45["DEFAULT"] = "DEFAULT";
        Fields45["FULL"] = "FULL";
    })(Fields45 = Occ.Fields45 || (Occ.Fields45 = {}));
    /**
     * Defines values for Fields46.
     * Possible values include: 'BASIC', 'DEFAULT', 'FULL'
     * There could be more values for this enum apart from the ones defined here.If
     * you want to set a value that is not from the known values then you can do
     * the following:
     * let param: Fields46 = <Fields46>"someUnknownValueThatWillStillBeValid";
     * @readonly
     * @enum {string}
     */
    let Fields46;
    (function (Fields46) {
        Fields46["BASIC"] = "BASIC";
        Fields46["DEFAULT"] = "DEFAULT";
        Fields46["FULL"] = "FULL";
    })(Fields46 = Occ.Fields46 || (Occ.Fields46 = {}));
    /**
     * Defines values for Fields47.
     * Possible values include: 'BASIC', 'DEFAULT', 'FULL'
     * There could be more values for this enum apart from the ones defined here.If
     * you want to set a value that is not from the known values then you can do
     * the following:
     * let param: Fields47 = <Fields47>"someUnknownValueThatWillStillBeValid";
     * @readonly
     * @enum {string}
     */
    let Fields47;
    (function (Fields47) {
        Fields47["BASIC"] = "BASIC";
        Fields47["DEFAULT"] = "DEFAULT";
        Fields47["FULL"] = "FULL";
    })(Fields47 = Occ.Fields47 || (Occ.Fields47 = {}));
    /**
     * Defines values for Fields48.
     * Possible values include: 'BASIC', 'DEFAULT', 'FULL'
     * There could be more values for this enum apart from the ones defined here.If
     * you want to set a value that is not from the known values then you can do
     * the following:
     * let param: Fields48 = <Fields48>"someUnknownValueThatWillStillBeValid";
     * @readonly
     * @enum {string}
     */
    let Fields48;
    (function (Fields48) {
        Fields48["BASIC"] = "BASIC";
        Fields48["DEFAULT"] = "DEFAULT";
        Fields48["FULL"] = "FULL";
    })(Fields48 = Occ.Fields48 || (Occ.Fields48 = {}));
    /**
     * Defines values for Fields49.
     * Possible values include: 'BASIC', 'DEFAULT', 'FULL'
     * There could be more values for this enum apart from the ones defined here.If
     * you want to set a value that is not from the known values then you can do
     * the following:
     * let param: Fields49 = <Fields49>"someUnknownValueThatWillStillBeValid";
     * @readonly
     * @enum {string}
     */
    let Fields49;
    (function (Fields49) {
        Fields49["BASIC"] = "BASIC";
        Fields49["DEFAULT"] = "DEFAULT";
        Fields49["FULL"] = "FULL";
    })(Fields49 = Occ.Fields49 || (Occ.Fields49 = {}));
    /**
     * Defines values for Fields50.
     * Possible values include: 'BASIC', 'DEFAULT', 'FULL'
     * There could be more values for this enum apart from the ones defined here.If
     * you want to set a value that is not from the known values then you can do
     * the following:
     * let param: Fields50 = <Fields50>"someUnknownValueThatWillStillBeValid";
     * @readonly
     * @enum {string}
     */
    let Fields50;
    (function (Fields50) {
        Fields50["BASIC"] = "BASIC";
        Fields50["DEFAULT"] = "DEFAULT";
        Fields50["FULL"] = "FULL";
    })(Fields50 = Occ.Fields50 || (Occ.Fields50 = {}));
    /**
     * Defines values for Fields51.
     * Possible values include: 'BASIC', 'DEFAULT', 'FULL'
     * There could be more values for this enum apart from the ones defined here.If
     * you want to set a value that is not from the known values then you can do
     * the following:
     * let param: Fields51 = <Fields51>"someUnknownValueThatWillStillBeValid";
     * @readonly
     * @enum {string}
     */
    let Fields51;
    (function (Fields51) {
        Fields51["BASIC"] = "BASIC";
        Fields51["DEFAULT"] = "DEFAULT";
        Fields51["FULL"] = "FULL";
    })(Fields51 = Occ.Fields51 || (Occ.Fields51 = {}));
    /**
     * Defines values for Fields52.
     * Possible values include: 'BASIC', 'DEFAULT', 'FULL'
     * There could be more values for this enum apart from the ones defined here.If
     * you want to set a value that is not from the known values then you can do
     * the following:
     * let param: Fields52 = <Fields52>"someUnknownValueThatWillStillBeValid";
     * @readonly
     * @enum {string}
     */
    let Fields52;
    (function (Fields52) {
        Fields52["BASIC"] = "BASIC";
        Fields52["DEFAULT"] = "DEFAULT";
        Fields52["FULL"] = "FULL";
    })(Fields52 = Occ.Fields52 || (Occ.Fields52 = {}));
    /**
     * Defines values for Fields53.
     * Possible values include: 'BASIC', 'DEFAULT', 'FULL'
     * There could be more values for this enum apart from the ones defined here.If
     * you want to set a value that is not from the known values then you can do
     * the following:
     * let param: Fields53 = <Fields53>"someUnknownValueThatWillStillBeValid";
     * @readonly
     * @enum {string}
     */
    let Fields53;
    (function (Fields53) {
        Fields53["BASIC"] = "BASIC";
        Fields53["DEFAULT"] = "DEFAULT";
        Fields53["FULL"] = "FULL";
    })(Fields53 = Occ.Fields53 || (Occ.Fields53 = {}));
    /**
     * Defines values for Fields54.
     * Possible values include: 'BASIC', 'DEFAULT', 'FULL'
     * There could be more values for this enum apart from the ones defined here.If
     * you want to set a value that is not from the known values then you can do
     * the following:
     * let param: Fields54 = <Fields54>"someUnknownValueThatWillStillBeValid";
     * @readonly
     * @enum {string}
     */
    let Fields54;
    (function (Fields54) {
        Fields54["BASIC"] = "BASIC";
        Fields54["DEFAULT"] = "DEFAULT";
        Fields54["FULL"] = "FULL";
    })(Fields54 = Occ.Fields54 || (Occ.Fields54 = {}));
    /**
     * Defines values for Fields55.
     * Possible values include: 'BASIC', 'DEFAULT', 'FULL'
     * There could be more values for this enum apart from the ones defined here.If
     * you want to set a value that is not from the known values then you can do
     * the following:
     * let param: Fields55 = <Fields55>"someUnknownValueThatWillStillBeValid";
     * @readonly
     * @enum {string}
     */
    let Fields55;
    (function (Fields55) {
        Fields55["BASIC"] = "BASIC";
        Fields55["DEFAULT"] = "DEFAULT";
        Fields55["FULL"] = "FULL";
    })(Fields55 = Occ.Fields55 || (Occ.Fields55 = {}));
    /**
     * Defines values for Fields56.
     * Possible values include: 'BASIC', 'DEFAULT', 'FULL'
     * There could be more values for this enum apart from the ones defined here.If
     * you want to set a value that is not from the known values then you can do
     * the following:
     * let param: Fields56 = <Fields56>"someUnknownValueThatWillStillBeValid";
     * @readonly
     * @enum {string}
     */
    let Fields56;
    (function (Fields56) {
        Fields56["BASIC"] = "BASIC";
        Fields56["DEFAULT"] = "DEFAULT";
        Fields56["FULL"] = "FULL";
    })(Fields56 = Occ.Fields56 || (Occ.Fields56 = {}));
    /**
     * Defines values for Fields57.
     * Possible values include: 'BASIC', 'DEFAULT', 'FULL'
     * There could be more values for this enum apart from the ones defined here.If
     * you want to set a value that is not from the known values then you can do
     * the following:
     * let param: Fields57 = <Fields57>"someUnknownValueThatWillStillBeValid";
     * @readonly
     * @enum {string}
     */
    let Fields57;
    (function (Fields57) {
        Fields57["BASIC"] = "BASIC";
        Fields57["DEFAULT"] = "DEFAULT";
        Fields57["FULL"] = "FULL";
    })(Fields57 = Occ.Fields57 || (Occ.Fields57 = {}));
    /**
     * Defines values for Fields58.
     * Possible values include: 'BASIC', 'DEFAULT', 'FULL'
     * There could be more values for this enum apart from the ones defined here.If
     * you want to set a value that is not from the known values then you can do
     * the following:
     * let param: Fields58 = <Fields58>"someUnknownValueThatWillStillBeValid";
     * @readonly
     * @enum {string}
     */
    let Fields58;
    (function (Fields58) {
        Fields58["BASIC"] = "BASIC";
        Fields58["DEFAULT"] = "DEFAULT";
        Fields58["FULL"] = "FULL";
    })(Fields58 = Occ.Fields58 || (Occ.Fields58 = {}));
    /**
     * Defines values for Fields59.
     * Possible values include: 'BASIC', 'DEFAULT', 'FULL'
     * There could be more values for this enum apart from the ones defined here.If
     * you want to set a value that is not from the known values then you can do
     * the following:
     * let param: Fields59 = <Fields59>"someUnknownValueThatWillStillBeValid";
     * @readonly
     * @enum {string}
     */
    let Fields59;
    (function (Fields59) {
        Fields59["BASIC"] = "BASIC";
        Fields59["DEFAULT"] = "DEFAULT";
        Fields59["FULL"] = "FULL";
    })(Fields59 = Occ.Fields59 || (Occ.Fields59 = {}));
    /**
     * Defines values for Fields60.
     * Possible values include: 'BASIC', 'DEFAULT', 'FULL'
     * There could be more values for this enum apart from the ones defined here.If
     * you want to set a value that is not from the known values then you can do
     * the following:
     * let param: Fields60 = <Fields60>"someUnknownValueThatWillStillBeValid";
     * @readonly
     * @enum {string}
     */
    let Fields60;
    (function (Fields60) {
        Fields60["BASIC"] = "BASIC";
        Fields60["DEFAULT"] = "DEFAULT";
        Fields60["FULL"] = "FULL";
    })(Fields60 = Occ.Fields60 || (Occ.Fields60 = {}));
    /**
     * Defines values for Fields61.
     * Possible values include: 'BASIC', 'DEFAULT', 'FULL'
     * There could be more values for this enum apart from the ones defined here.If
     * you want to set a value that is not from the known values then you can do
     * the following:
     * let param: Fields61 = <Fields61>"someUnknownValueThatWillStillBeValid";
     * @readonly
     * @enum {string}
     */
    let Fields61;
    (function (Fields61) {
        Fields61["BASIC"] = "BASIC";
        Fields61["DEFAULT"] = "DEFAULT";
        Fields61["FULL"] = "FULL";
    })(Fields61 = Occ.Fields61 || (Occ.Fields61 = {}));
    /**
     * Defines values for Type.
     * Possible values include: 'all', 'product', 'order'
     * There could be more values for this enum apart from the ones defined here.If
     * you want to set a value that is not from the known values then you can do
     * the following:
     * let param: Type = <Type>"someUnknownValueThatWillStillBeValid";
     * @readonly
     * @enum {string}
     */
    let Type;
    (function (Type) {
        Type["All"] = "all";
        Type["Product"] = "product";
        Type["Order"] = "order";
    })(Type = Occ.Type || (Occ.Type = {}));
    /**
     * @record
     */
    function AnonymousConsent() { }
    Occ.AnonymousConsent = AnonymousConsent;
    if (false) {
        /** @type {?|undefined} */
        AnonymousConsent.prototype.templateCode;
        /** @type {?|undefined} */
        AnonymousConsent.prototype.version;
        /** @type {?|undefined} */
        AnonymousConsent.prototype.consentState;
    }
    let CONSENT_STATUS;
    (function (CONSENT_STATUS) {
        CONSENT_STATUS["ANONYMOUS_CONSENT_GIVEN"] = "GIVEN";
        CONSENT_STATUS["ANONYMOUS_CONSENT_WITHDRAWN"] = "WITHDRAWN";
    })(CONSENT_STATUS = Occ.CONSENT_STATUS || (Occ.CONSENT_STATUS = {}));
    /**
     * @record
     */
    function ConsentTemplate() { }
    Occ.ConsentTemplate = ConsentTemplate;
    if (false) {
        /** @type {?|undefined} */
        ConsentTemplate.prototype.id;
        /** @type {?|undefined} */
        ConsentTemplate.prototype.name;
        /** @type {?|undefined} */
        ConsentTemplate.prototype.description;
        /** @type {?|undefined} */
        ConsentTemplate.prototype.version;
        /** @type {?|undefined} */
        ConsentTemplate.prototype.currentConsent;
    }
    /**
     * @record
     */
    function Consent() { }
    Occ.Consent = Consent;
    if (false) {
        /** @type {?|undefined} */
        Consent.prototype.code;
        /** @type {?|undefined} */
        Consent.prototype.consentGivenDate;
        /** @type {?|undefined} */
        Consent.prototype.consentWithdrawnDate;
    }
    /**
     * @record
     */
    function ConsentTemplateList() { }
    Occ.ConsentTemplateList = ConsentTemplateList;
    if (false) {
        /** @type {?|undefined} */
        ConsentTemplateList.prototype.consentTemplates;
    }
    /**
     * @record
     */
    function BaseSites() { }
    Occ.BaseSites = BaseSites;
    if (false) {
        /** @type {?|undefined} */
        BaseSites.prototype.baseSites;
    }
    /**
     * @record
     */
    function BaseSite() { }
    Occ.BaseSite = BaseSite;
    if (false) {
        /** @type {?|undefined} */
        BaseSite.prototype.channel;
        /** @type {?|undefined} */
        BaseSite.prototype.defaultLanguage;
        /** @type {?|undefined} */
        BaseSite.prototype.defaultPreviewCatalogId;
        /** @type {?|undefined} */
        BaseSite.prototype.defaultPreviewCategoryCode;
        /** @type {?|undefined} */
        BaseSite.prototype.defaultPreviewProductCode;
        /** @type {?|undefined} */
        BaseSite.prototype.locale;
        /** @type {?|undefined} */
        BaseSite.prototype.name;
        /** @type {?|undefined} */
        BaseSite.prototype.theme;
        /** @type {?|undefined} */
        BaseSite.prototype.uid;
        /** @type {?|undefined} */
        BaseSite.prototype.stores;
        /** @type {?|undefined} */
        BaseSite.prototype.urlPatterns;
        /** @type {?|undefined} */
        BaseSite.prototype.urlEncodingAttributes;
    }
    /**
     * @record
     */
    function BaseStore() { }
    Occ.BaseStore = BaseStore;
    if (false) {
        /** @type {?|undefined} */
        BaseStore.prototype.currencies;
        /** @type {?|undefined} */
        BaseStore.prototype.defaultCurrency;
        /** @type {?|undefined} */
        BaseStore.prototype.languages;
        /** @type {?|undefined} */
        BaseStore.prototype.defaultLanguage;
    }
    /**
     * @record
     */
    function ProductInterestEntry() { }
    Occ.ProductInterestEntry = ProductInterestEntry;
    if (false) {
        /** @type {?|undefined} */
        ProductInterestEntry.prototype.interestType;
        /** @type {?|undefined} */
        ProductInterestEntry.prototype.dateAdded;
        /** @type {?|undefined} */
        ProductInterestEntry.prototype.expirationDate;
    }
    /**
     * @record
     */
    function ProductInterestEntryRelation() { }
    Occ.ProductInterestEntryRelation = ProductInterestEntryRelation;
    if (false) {
        /** @type {?|undefined} */
        ProductInterestEntryRelation.prototype.product;
        /** @type {?|undefined} */
        ProductInterestEntryRelation.prototype.productInterestEntry;
    }
    /**
     * @record
     */
    function ProductInterestSearchResult() { }
    Occ.ProductInterestSearchResult = ProductInterestSearchResult;
    if (false) {
        /** @type {?|undefined} */
        ProductInterestSearchResult.prototype.results;
        /** @type {?|undefined} */
        ProductInterestSearchResult.prototype.sorts;
        /** @type {?|undefined} */
        ProductInterestSearchResult.prototype.pagination;
    }
    let NotificationType;
    (function (NotificationType) {
        NotificationType["BACK_IN_STOCK"] = "BACK_IN_STOCK";
    })(NotificationType = Occ.NotificationType || (Occ.NotificationType = {}));
})(Occ || (Occ = {}));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class OccModule {
    /**
     * @return {?}
     */
    static forRoot() {
        return {
            ngModule: OccModule,
            providers: [
                { provide: OccConfig, useExisting: Config },
                provideConfig(defaultOccConfig),
                provideConfigValidator(occConfigValidator),
            ],
        };
    }
}
OccModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    AsmOccModule,
                    CmsOccModule,
                    CartOccModule,
                    CheckoutOccModule,
                    ProductOccModule,
                    SiteContextOccModule,
                    StoreFinderOccModule,
                    UserOccModule,
                    OccConfigLoaderModule.forRoot(),
                ],
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class LoadingScopesService {
    /**
     * @param {?} config
     */
    constructor(config) {
        this.config = config;
    }
    /**
     * Aims to expand scopes based on loading scopes config.
     *
     * I.e. if 'details' scope includes 'list' scope by configuration, it'll return ['details', 'list']
     *
     * If scope data overlaps with each other, the data should be merged in the order of scopes provided,
     * i.e. the last scope is merged last, overwriting parts of the data already provided by preceding scope.
     * It should apply also to implicit scopes (that are included by configuration).
     *
     * @param {?} model
     * @param {?} scopes
     * @return {?}
     */
    expand(model, scopes) {
        /** @type {?} */
        const scopesConfig = this.config &&
            this.config.backend &&
            this.config.backend.loadingScopes &&
            this.config.backend.loadingScopes[model];
        if (scopesConfig) {
            /** @type {?} */
            const expandedScopes = [...scopes];
            /** @type {?} */
            let i = expandedScopes.length;
            while (i > 0) {
                i--;
                /** @type {?} */
                const includedScopes = scopesConfig[expandedScopes[i]] &&
                    scopesConfig[expandedScopes[i]].include;
                if (includedScopes) {
                    for (const includedScope of includedScopes) {
                        if (!expandedScopes.includes(includedScope)) {
                            expandedScopes.splice(i, 0, includedScope);
                            i++;
                        }
                    }
                }
            }
            return expandedScopes;
        }
        return scopes;
    }
    /**
     * Return maxAge for product scope in milliseconds
     *
     * @param {?} model
     * @param {?} scope
     * @return {?}
     */
    getMaxAge(model, scope) {
        /** @type {?} */
        const scopesConfig = this.config &&
            this.config.backend &&
            this.config.backend.loadingScopes &&
            this.config.backend.loadingScopes[model];
        return (scopesConfig[scope] && scopesConfig[scope].maxAge) * 1000 || 0;
    }
}
LoadingScopesService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root',
            },] }
];
/** @nocollapse */
LoadingScopesService.ctorParameters = () => [
    { type: OccConfig }
];
/** @nocollapse */ LoadingScopesService.ngInjectableDef = ɵɵdefineInjectable({ factory: function LoadingScopesService_Factory() { return new LoadingScopesService(ɵɵinject(OccConfig)); }, token: LoadingScopesService, providedIn: "root" });
if (false) {
    /**
     * @type {?}
     * @protected
     */
    LoadingScopesService.prototype.config;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @deprecated since 1.2.0
 * Use OCC_USER_ID_ANONYMOUS instead
 * @type {?}
 */
const ANONYMOUS_USERID = OCC_USER_ID_ANONYMOUS;

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const ANONYMOUS_CONSENTS_HEADER = 'X-Anonymous-Consents';
class AnonymousConsentsInterceptor {
    /**
     * @param {?} anonymousConsentsService
     * @param {?} authService
     * @param {?} occEndpoints
     * @param {?} config
     */
    constructor(anonymousConsentsService, authService, occEndpoints, config) {
        this.anonymousConsentsService = anonymousConsentsService;
        this.authService = authService;
        this.occEndpoints = occEndpoints;
        this.config = config;
    }
    /**
     * @param {?} request
     * @param {?} next
     * @return {?}
     */
    intercept(request, next) {
        return iif((/**
         * @return {?}
         */
        () => isFeatureEnabled(this.config, ANONYMOUS_CONSENTS_FEATURE)), this.anonymousConsentsService.getConsents().pipe(take(1), withLatestFrom(this.authService.isUserLoggedIn()), switchMap((/**
         * @param {?} __0
         * @return {?}
         */
        ([consents, isUserLoggedIn]) => {
            if (!this.isOccUrl(request.url)) {
                return next.handle(request);
            }
            /** @type {?} */
            const clonedRequest = this.handleRequest(consents, request);
            return next.handle(clonedRequest).pipe(tap((/**
             * @param {?} event
             * @return {?}
             */
            event => {
                if (event instanceof HttpResponse) {
                    this.handleResponse(isUserLoggedIn, event.headers.get(ANONYMOUS_CONSENTS_HEADER), consents);
                }
            })));
        }))), next.handle(request));
    }
    /**
     * @private
     * @param {?} isUserLoggedIn
     * @param {?} newRawConsents
     * @param {?} previousConsents
     * @return {?}
     */
    handleResponse(isUserLoggedIn, newRawConsents, previousConsents) {
        if (!isUserLoggedIn && newRawConsents) {
            /** @type {?} */
            let newConsents = [];
            newConsents = this.anonymousConsentsService.decodeAndDeserialize(newRawConsents);
            newConsents = this.giveRequiredConsents(newConsents);
            if (this.anonymousConsentsService.consentsUpdated(newConsents, previousConsents)) {
                this.anonymousConsentsService.setConsents(newConsents);
            }
        }
    }
    /**
     * @private
     * @param {?} consents
     * @param {?} request
     * @return {?}
     */
    handleRequest(consents, request) {
        if (!consents) {
            return request;
        }
        /** @type {?} */
        const rawConsents = this.anonymousConsentsService.serializeAndEncode(consents);
        return request.clone({
            setHeaders: {
                [ANONYMOUS_CONSENTS_HEADER]: rawConsents,
            },
        });
    }
    /**
     * @private
     * @param {?} url
     * @return {?}
     */
    isOccUrl(url) {
        return url.includes(this.occEndpoints.getBaseEndpoint());
    }
    /**
     * @private
     * @param {?} consents
     * @return {?}
     */
    giveRequiredConsents(consents) {
        /** @type {?} */
        const givenConsents = [...consents];
        if (Boolean(this.config.anonymousConsents) &&
            Boolean(this.config.anonymousConsents.requiredConsents)) {
            for (const consent of givenConsents) {
                if (this.config.anonymousConsents.requiredConsents.includes(consent.templateCode)) {
                    consent.consentState = ANONYMOUS_CONSENT_STATUS.GIVEN;
                }
            }
        }
        return givenConsents;
    }
}
AnonymousConsentsInterceptor.decorators = [
    { type: Injectable, args: [{ providedIn: 'root' },] }
];
/** @nocollapse */
AnonymousConsentsInterceptor.ctorParameters = () => [
    { type: AnonymousConsentsService },
    { type: AuthService },
    { type: OccEndpointsService },
    { type: AnonymousConsentsConfig }
];
/** @nocollapse */ AnonymousConsentsInterceptor.ngInjectableDef = ɵɵdefineInjectable({ factory: function AnonymousConsentsInterceptor_Factory() { return new AnonymousConsentsInterceptor(ɵɵinject(AnonymousConsentsService), ɵɵinject(AuthService), ɵɵinject(OccEndpointsService), ɵɵinject(AnonymousConsentsConfig)); }, token: AnonymousConsentsInterceptor, providedIn: "root" });
if (false) {
    /**
     * @type {?}
     * @private
     */
    AnonymousConsentsInterceptor.prototype.anonymousConsentsService;
    /**
     * @type {?}
     * @private
     */
    AnonymousConsentsInterceptor.prototype.authService;
    /**
     * @type {?}
     * @private
     */
    AnonymousConsentsInterceptor.prototype.occEndpoints;
    /**
     * @type {?}
     * @private
     */
    AnonymousConsentsInterceptor.prototype.config;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const interceptors$1 = [
    {
        provide: HTTP_INTERCEPTORS,
        useExisting: AnonymousConsentsInterceptor,
        multi: true,
    },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const PROCESS_FEATURE = 'process';
/**
 * @record
 * @template T
 */
function StateWithProcess() { }
if (false) {
    /* Skipping unnamed member:
    [PROCESS_FEATURE]: EntityLoaderState<T>;*/
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @template T
 * @return {?}
 */
function getProcessState() {
    return createFeatureSelector(PROCESS_FEATURE);
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @template T
 * @param {?} processId
 * @return {?}
 */
function getProcessStateFactory(processId) {
    return createSelector(getProcessState(), (/**
     * @param {?} entityState
     * @return {?}
     */
    entityState => entityStateSelector(entityState, processId)));
}
/**
 * @template T
 * @param {?} processId
 * @return {?}
 */
function getProcessLoadingFactory(processId) {
    return createSelector(getProcessStateFactory(processId), (/**
     * @param {?} loaderState
     * @return {?}
     */
    loaderState => loaderLoadingSelector(loaderState)));
}
/**
 * @template T
 * @param {?} processId
 * @return {?}
 */
function getProcessSuccessFactory(processId) {
    return createSelector(getProcessStateFactory(processId), (/**
     * @param {?} loaderState
     * @return {?}
     */
    loaderState => loaderSuccessSelector(loaderState)));
}
/**
 * @template T
 * @param {?} processId
 * @return {?}
 */
function getProcessErrorFactory(processId) {
    return createSelector(getProcessStateFactory(processId), (/**
     * @param {?} loaderState
     * @return {?}
     */
    loaderState => loaderErrorSelector(loaderState)));
}

var process_selectors = /*#__PURE__*/Object.freeze({
    getProcessStateFactory: getProcessStateFactory,
    getProcessLoadingFactory: getProcessLoadingFactory,
    getProcessSuccessFactory: getProcessSuccessFactory,
    getProcessErrorFactory: getProcessErrorFactory
});

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const LOAD_BILLING_COUNTRIES = '[User] Load Billing Countries';
/** @type {?} */
const LOAD_BILLING_COUNTRIES_FAIL = '[User] Load Billing Countries Fail';
/** @type {?} */
const LOAD_BILLING_COUNTRIES_SUCCESS = '[User] Load Billing Countries Success';
class LoadBillingCountries {
    constructor() {
        this.type = LOAD_BILLING_COUNTRIES;
    }
}
if (false) {
    /** @type {?} */
    LoadBillingCountries.prototype.type;
}
class LoadBillingCountriesFail {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        this.payload = payload;
        this.type = LOAD_BILLING_COUNTRIES_FAIL;
    }
}
if (false) {
    /** @type {?} */
    LoadBillingCountriesFail.prototype.type;
    /** @type {?} */
    LoadBillingCountriesFail.prototype.payload;
}
class LoadBillingCountriesSuccess {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        this.payload = payload;
        this.type = LOAD_BILLING_COUNTRIES_SUCCESS;
    }
}
if (false) {
    /** @type {?} */
    LoadBillingCountriesSuccess.prototype.type;
    /** @type {?} */
    LoadBillingCountriesSuccess.prototype.payload;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const LOAD_CONSIGNMENT_TRACKING = '[User] Load Consignment Tracking';
/** @type {?} */
const LOAD_CONSIGNMENT_TRACKING_FAIL = '[User] Load Consignment Tracking Fail';
/** @type {?} */
const LOAD_CONSIGNMENT_TRACKING_SUCCESS = '[User] Load Consignment Tracking Success';
/** @type {?} */
const CLEAR_CONSIGNMENT_TRACKING = '[User] Clear Consignment Tracking';
class LoadConsignmentTracking {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        this.payload = payload;
        this.type = LOAD_CONSIGNMENT_TRACKING;
    }
}
if (false) {
    /** @type {?} */
    LoadConsignmentTracking.prototype.type;
    /** @type {?} */
    LoadConsignmentTracking.prototype.payload;
}
class LoadConsignmentTrackingFail {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        this.payload = payload;
        this.type = LOAD_CONSIGNMENT_TRACKING_FAIL;
    }
}
if (false) {
    /** @type {?} */
    LoadConsignmentTrackingFail.prototype.type;
    /** @type {?} */
    LoadConsignmentTrackingFail.prototype.payload;
}
class LoadConsignmentTrackingSuccess {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        this.payload = payload;
        this.type = LOAD_CONSIGNMENT_TRACKING_SUCCESS;
    }
}
if (false) {
    /** @type {?} */
    LoadConsignmentTrackingSuccess.prototype.type;
    /** @type {?} */
    LoadConsignmentTrackingSuccess.prototype.payload;
}
class ClearConsignmentTracking {
    constructor() {
        this.type = CLEAR_CONSIGNMENT_TRACKING;
    }
}
if (false) {
    /** @type {?} */
    ClearConsignmentTracking.prototype.type;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const LOAD_DELIVERY_COUNTRIES = '[User] Load Delivery Countries';
/** @type {?} */
const LOAD_DELIVERY_COUNTRIES_FAIL = '[User] Load Delivery Countries Fail';
/** @type {?} */
const LOAD_DELIVERY_COUNTRIES_SUCCESS = '[User] Load Delivery Countries Success';
class LoadDeliveryCountries {
    constructor() {
        this.type = LOAD_DELIVERY_COUNTRIES;
    }
}
if (false) {
    /** @type {?} */
    LoadDeliveryCountries.prototype.type;
}
class LoadDeliveryCountriesFail {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        this.payload = payload;
        this.type = LOAD_DELIVERY_COUNTRIES_FAIL;
    }
}
if (false) {
    /** @type {?} */
    LoadDeliveryCountriesFail.prototype.type;
    /** @type {?} */
    LoadDeliveryCountriesFail.prototype.payload;
}
class LoadDeliveryCountriesSuccess {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        this.payload = payload;
        this.type = LOAD_DELIVERY_COUNTRIES_SUCCESS;
    }
}
if (false) {
    /** @type {?} */
    LoadDeliveryCountriesSuccess.prototype.type;
    /** @type {?} */
    LoadDeliveryCountriesSuccess.prototype.payload;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const FORGOT_PASSWORD_EMAIL_REQUEST = '[User] Forgot Password Email Request';
/** @type {?} */
const FORGOT_PASSWORD_EMAIL_REQUEST_SUCCESS = '[User] Forgot Password Email Request Success';
/** @type {?} */
const FORGOT_PASSWORD_EMAIL_REQUEST_FAIL = '[User] Forgot Password Email Request Fail';
class ForgotPasswordEmailRequest {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        this.payload = payload;
        this.type = FORGOT_PASSWORD_EMAIL_REQUEST;
    }
}
if (false) {
    /** @type {?} */
    ForgotPasswordEmailRequest.prototype.type;
    /** @type {?} */
    ForgotPasswordEmailRequest.prototype.payload;
}
class ForgotPasswordEmailRequestFail {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        this.payload = payload;
        this.type = FORGOT_PASSWORD_EMAIL_REQUEST_FAIL;
    }
}
if (false) {
    /** @type {?} */
    ForgotPasswordEmailRequestFail.prototype.type;
    /** @type {?} */
    ForgotPasswordEmailRequestFail.prototype.payload;
}
class ForgotPasswordEmailRequestSuccess {
    constructor() {
        this.type = FORGOT_PASSWORD_EMAIL_REQUEST_SUCCESS;
    }
}
if (false) {
    /** @type {?} */
    ForgotPasswordEmailRequestSuccess.prototype.type;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const USER_FEATURE = 'user';
/** @type {?} */
const UPDATE_EMAIL_PROCESS_ID = 'updateEmail';
/** @type {?} */
const UPDATE_PASSWORD_PROCESS_ID = 'updatePassword';
/** @type {?} */
const UPDATE_USER_DETAILS_PROCESS_ID = 'updateUserDetails';
/** @type {?} */
const REGISTER_USER_PROCESS_ID = 'registerUser';
/** @type {?} */
const REMOVE_USER_PROCESS_ID = 'removeUser';
/** @type {?} */
const GIVE_CONSENT_PROCESS_ID = 'giveConsent';
/** @type {?} */
const WITHDRAW_CONSENT_PROCESS_ID = 'withdrawConsent';
/** @type {?} */
const UPDATE_NOTIFICATION_PREFERENCES_PROCESS_ID = 'updateNotificationPreferences';
/** @type {?} */
const ADD_PRODUCT_INTEREST_PROCESS_ID = 'addProductInterests';
/** @type {?} */
const REMOVE_PRODUCT_INTERESTS_PROCESS_ID = 'removeProductInterests';
/** @type {?} */
const CANCEL_ORDER_PROCESS_ID = 'cancelOrder';
/** @type {?} */
const CANCEL_RETURN_PROCESS_ID = 'cancelReturn';
/** @type {?} */
const USER_CONSENTS = '[User] User Consents';
/** @type {?} */
const USER_PAYMENT_METHODS = '[User] User Payment Methods';
/** @type {?} */
const USER_ORDERS = '[User] User Orders';
/** @type {?} */
const USER_ADDRESSES = '[User] User Addresses';
/** @type {?} */
const USER_RETURN_REQUESTS = '[User] Order Return Requests';
/** @type {?} */
const USER_RETURN_REQUEST_DETAILS = '[User] Return Request Details';
/** @type {?} */
const USER_ORDER_DETAILS = '[User] User Order Details';
/** @type {?} */
const REGIONS = '[User] Regions';
/** @type {?} */
const CUSTOMER_COUPONS = '[User] Customer Coupons';
/** @type {?} */
const SUBSCRIBE_CUSTOMER_COUPON_PROCESS_ID = 'subscribeCustomerCoupon';
/** @type {?} */
const UNSUBSCRIBE_CUSTOMER_COUPON_PROCESS_ID = 'unsubscribeCustomerCoupon';
/** @type {?} */
const CLAIM_CUSTOMER_COUPON_PROCESS_ID = 'claimCustomerCoupon';
/** @type {?} */
const NOTIFICATION_PREFERENCES = '[User] Notification Preferences';
/** @type {?} */
const PRODUCT_INTERESTS = '[User] Product Interests';
/**
 * @record
 */
function StateWithUser() { }
if (false) {
    /* Skipping unnamed member:
    [USER_FEATURE]: UserState;*/
}
/**
 * @record
 */
function UserState() { }
if (false) {
    /** @type {?} */
    UserState.prototype.account;
    /** @type {?} */
    UserState.prototype.addresses;
    /** @type {?} */
    UserState.prototype.consents;
    /** @type {?} */
    UserState.prototype.billingCountries;
    /** @type {?} */
    UserState.prototype.countries;
    /** @type {?} */
    UserState.prototype.payments;
    /** @type {?} */
    UserState.prototype.orders;
    /** @type {?} */
    UserState.prototype.order;
    /** @type {?} */
    UserState.prototype.orderReturn;
    /** @type {?} */
    UserState.prototype.orderReturnList;
    /** @type {?} */
    UserState.prototype.titles;
    /** @type {?} */
    UserState.prototype.regions;
    /** @type {?} */
    UserState.prototype.resetPassword;
    /** @type {?} */
    UserState.prototype.consignmentTracking;
    /** @type {?} */
    UserState.prototype.customerCoupons;
    /** @type {?} */
    UserState.prototype.notificationPreferences;
    /** @type {?} */
    UserState.prototype.productInterests;
}
/**
 * @record
 */
function RegionsState() { }
if (false) {
    /** @type {?} */
    RegionsState.prototype.entities;
    /** @type {?} */
    RegionsState.prototype.country;
}
/**
 * @record
 */
function BillingCountryEntities() { }
/**
 * @record
 */
function BillingCountriesState() { }
if (false) {
    /** @type {?} */
    BillingCountriesState.prototype.entities;
}
/**
 * @record
 */
function DeliveryCountryEntities() { }
/**
 * @record
 */
function DeliveryCountriesState() { }
if (false) {
    /** @type {?} */
    DeliveryCountriesState.prototype.entities;
}
/**
 * @record
 */
function TitleEntities() { }
/**
 * @record
 */
function TitlesState() { }
if (false) {
    /** @type {?} */
    TitlesState.prototype.entities;
}
/**
 * @record
 */
function UserDetailsState() { }
if (false) {
    /** @type {?} */
    UserDetailsState.prototype.details;
}
/**
 * @record
 */
function ConsignmentTrackingState() { }
if (false) {
    /** @type {?|undefined} */
    ConsignmentTrackingState.prototype.tracking;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const LOAD_ORDER_DETAILS = '[User] Load Order Details';
/** @type {?} */
const LOAD_ORDER_DETAILS_FAIL = '[User] Load Order Details Fail';
/** @type {?} */
const LOAD_ORDER_DETAILS_SUCCESS = '[User] Load Order Details Success';
/** @type {?} */
const CLEAR_ORDER_DETAILS = '[User] Clear Order Details';
/** @type {?} */
const CANCEL_ORDER = '[User] Cancel Order';
/** @type {?} */
const CANCEL_ORDER_FAIL = '[User] Cancel Order Fail';
/** @type {?} */
const CANCEL_ORDER_SUCCESS = '[User] Cancel Order Success';
/** @type {?} */
const RESET_CANCEL_ORDER_PROCESS = '[User] Reset Cancel Order Process';
class LoadOrderDetails extends LoaderLoadAction {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        super(USER_ORDER_DETAILS);
        this.payload = payload;
        this.type = LOAD_ORDER_DETAILS;
    }
}
if (false) {
    /** @type {?} */
    LoadOrderDetails.prototype.type;
    /** @type {?} */
    LoadOrderDetails.prototype.payload;
}
class LoadOrderDetailsFail extends LoaderFailAction {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        super(USER_ORDER_DETAILS, payload);
        this.payload = payload;
        this.type = LOAD_ORDER_DETAILS_FAIL;
    }
}
if (false) {
    /** @type {?} */
    LoadOrderDetailsFail.prototype.type;
    /** @type {?} */
    LoadOrderDetailsFail.prototype.payload;
}
class LoadOrderDetailsSuccess extends LoaderSuccessAction {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        super(USER_ORDER_DETAILS);
        this.payload = payload;
        this.type = LOAD_ORDER_DETAILS_SUCCESS;
    }
}
if (false) {
    /** @type {?} */
    LoadOrderDetailsSuccess.prototype.type;
    /** @type {?} */
    LoadOrderDetailsSuccess.prototype.payload;
}
class ClearOrderDetails extends LoaderResetAction {
    constructor() {
        super(USER_ORDER_DETAILS);
        this.type = CLEAR_ORDER_DETAILS;
    }
}
if (false) {
    /** @type {?} */
    ClearOrderDetails.prototype.type;
}
class CancelOrder extends EntityLoadAction {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        super(PROCESS_FEATURE, CANCEL_ORDER_PROCESS_ID);
        this.payload = payload;
        this.type = CANCEL_ORDER;
    }
}
if (false) {
    /** @type {?} */
    CancelOrder.prototype.type;
    /** @type {?} */
    CancelOrder.prototype.payload;
}
class CancelOrderFail extends EntityFailAction {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        super(PROCESS_FEATURE, CANCEL_ORDER_PROCESS_ID, payload);
        this.payload = payload;
        this.type = CANCEL_ORDER_FAIL;
    }
}
if (false) {
    /** @type {?} */
    CancelOrderFail.prototype.type;
    /** @type {?} */
    CancelOrderFail.prototype.payload;
}
class CancelOrderSuccess extends EntitySuccessAction {
    constructor() {
        super(PROCESS_FEATURE, CANCEL_ORDER_PROCESS_ID);
        this.type = CANCEL_ORDER_SUCCESS;
    }
}
if (false) {
    /** @type {?} */
    CancelOrderSuccess.prototype.type;
}
class ResetCancelOrderProcess extends EntityResetAction {
    constructor() {
        super(PROCESS_FEATURE, CANCEL_ORDER_PROCESS_ID);
        this.type = RESET_CANCEL_ORDER_PROCESS;
    }
}
if (false) {
    /** @type {?} */
    ResetCancelOrderProcess.prototype.type;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const LOAD_USER_PAYMENT_METHODS = '[User] Load User Payment Methods';
/** @type {?} */
const LOAD_USER_PAYMENT_METHODS_FAIL = '[User] Load User Payment Methods Fail';
/** @type {?} */
const LOAD_USER_PAYMENT_METHODS_SUCCESS = '[User] Load User Payment Methods Success';
/** @type {?} */
const SET_DEFAULT_USER_PAYMENT_METHOD = '[User] Set Default User Payment Method';
/** @type {?} */
const SET_DEFAULT_USER_PAYMENT_METHOD_FAIL = '[User] Set Default User Payment Method Fail';
/** @type {?} */
const SET_DEFAULT_USER_PAYMENT_METHOD_SUCCESS = '[User] Set Default User Payment Method Success';
/** @type {?} */
const DELETE_USER_PAYMENT_METHOD = '[User] Delete User Payment Method';
/** @type {?} */
const DELETE_USER_PAYMENT_METHOD_FAIL = '[User] Delete User Payment Method Fail';
/** @type {?} */
const DELETE_USER_PAYMENT_METHOD_SUCCESS = '[User] Delete User  Payment Method Success';
class LoadUserPaymentMethods extends LoaderLoadAction {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        super(USER_PAYMENT_METHODS);
        this.payload = payload;
        this.type = LOAD_USER_PAYMENT_METHODS;
    }
}
if (false) {
    /** @type {?} */
    LoadUserPaymentMethods.prototype.type;
    /** @type {?} */
    LoadUserPaymentMethods.prototype.payload;
}
class LoadUserPaymentMethodsFail extends LoaderFailAction {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        super(USER_PAYMENT_METHODS, payload);
        this.payload = payload;
        this.type = LOAD_USER_PAYMENT_METHODS_FAIL;
    }
}
if (false) {
    /** @type {?} */
    LoadUserPaymentMethodsFail.prototype.type;
    /** @type {?} */
    LoadUserPaymentMethodsFail.prototype.payload;
}
class LoadUserPaymentMethodsSuccess extends LoaderSuccessAction {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        super(USER_PAYMENT_METHODS);
        this.payload = payload;
        this.type = LOAD_USER_PAYMENT_METHODS_SUCCESS;
    }
}
if (false) {
    /** @type {?} */
    LoadUserPaymentMethodsSuccess.prototype.type;
    /** @type {?} */
    LoadUserPaymentMethodsSuccess.prototype.payload;
}
class SetDefaultUserPaymentMethod extends LoaderLoadAction {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        super(USER_PAYMENT_METHODS);
        this.payload = payload;
        this.type = SET_DEFAULT_USER_PAYMENT_METHOD;
    }
}
if (false) {
    /** @type {?} */
    SetDefaultUserPaymentMethod.prototype.type;
    /** @type {?} */
    SetDefaultUserPaymentMethod.prototype.payload;
}
class SetDefaultUserPaymentMethodFail extends LoaderFailAction {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        super(USER_PAYMENT_METHODS, payload);
        this.payload = payload;
        this.type = SET_DEFAULT_USER_PAYMENT_METHOD_FAIL;
    }
}
if (false) {
    /** @type {?} */
    SetDefaultUserPaymentMethodFail.prototype.type;
    /** @type {?} */
    SetDefaultUserPaymentMethodFail.prototype.payload;
}
class SetDefaultUserPaymentMethodSuccess extends LoaderSuccessAction {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        super(USER_PAYMENT_METHODS);
        this.payload = payload;
        this.type = SET_DEFAULT_USER_PAYMENT_METHOD_SUCCESS;
    }
}
if (false) {
    /** @type {?} */
    SetDefaultUserPaymentMethodSuccess.prototype.type;
    /** @type {?} */
    SetDefaultUserPaymentMethodSuccess.prototype.payload;
}
class DeleteUserPaymentMethod extends LoaderLoadAction {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        super(USER_PAYMENT_METHODS);
        this.payload = payload;
        this.type = DELETE_USER_PAYMENT_METHOD;
    }
}
if (false) {
    /** @type {?} */
    DeleteUserPaymentMethod.prototype.type;
    /** @type {?} */
    DeleteUserPaymentMethod.prototype.payload;
}
class DeleteUserPaymentMethodFail extends LoaderFailAction {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        super(USER_PAYMENT_METHODS, payload);
        this.payload = payload;
        this.type = DELETE_USER_PAYMENT_METHOD_FAIL;
    }
}
if (false) {
    /** @type {?} */
    DeleteUserPaymentMethodFail.prototype.type;
    /** @type {?} */
    DeleteUserPaymentMethodFail.prototype.payload;
}
class DeleteUserPaymentMethodSuccess extends LoaderSuccessAction {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        super(USER_PAYMENT_METHODS);
        this.payload = payload;
        this.type = DELETE_USER_PAYMENT_METHOD_SUCCESS;
    }
}
if (false) {
    /** @type {?} */
    DeleteUserPaymentMethodSuccess.prototype.type;
    /** @type {?} */
    DeleteUserPaymentMethodSuccess.prototype.payload;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const LOAD_REGIONS = '[User] Load Regions';
/** @type {?} */
const LOAD_REGIONS_SUCCESS = '[User] Load Regions Success';
/** @type {?} */
const LOAD_REGIONS_FAIL = '[User] Load Regions Fail';
/** @type {?} */
const CLEAR_REGIONS = '[User] Clear Regions';
class LoadRegions extends LoaderLoadAction {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        super(REGIONS);
        this.payload = payload;
        this.type = LOAD_REGIONS;
    }
}
if (false) {
    /** @type {?} */
    LoadRegions.prototype.type;
    /** @type {?} */
    LoadRegions.prototype.payload;
}
class LoadRegionsFail extends LoaderFailAction {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        super(REGIONS, payload);
        this.payload = payload;
        this.type = LOAD_REGIONS_FAIL;
    }
}
if (false) {
    /** @type {?} */
    LoadRegionsFail.prototype.type;
    /** @type {?} */
    LoadRegionsFail.prototype.payload;
}
class LoadRegionsSuccess extends LoaderSuccessAction {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        super(REGIONS);
        this.payload = payload;
        this.type = LOAD_REGIONS_SUCCESS;
    }
}
if (false) {
    /** @type {?} */
    LoadRegionsSuccess.prototype.type;
    /** @type {?} */
    LoadRegionsSuccess.prototype.payload;
}
class ClearRegions {
    constructor() {
        this.type = CLEAR_REGIONS;
    }
}
if (false) {
    /** @type {?} */
    ClearRegions.prototype.type;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const RESET_PASSWORD = '[User] Reset Password';
/** @type {?} */
const RESET_PASSWORD_SUCCESS = '[User] Reset Password Success';
/** @type {?} */
const RESET_PASSWORD_FAIL = '[User] Reset Password Fail';
class ResetPassword {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        this.payload = payload;
        this.type = RESET_PASSWORD;
    }
}
if (false) {
    /** @type {?} */
    ResetPassword.prototype.type;
    /** @type {?} */
    ResetPassword.prototype.payload;
}
class ResetPasswordFail {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        this.payload = payload;
        this.type = RESET_PASSWORD_FAIL;
    }
}
if (false) {
    /** @type {?} */
    ResetPasswordFail.prototype.type;
    /** @type {?} */
    ResetPasswordFail.prototype.payload;
}
class ResetPasswordSuccess {
    constructor() {
        this.type = RESET_PASSWORD_SUCCESS;
    }
}
if (false) {
    /** @type {?} */
    ResetPasswordSuccess.prototype.type;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const LOAD_TITLES = '[User] Load Tiltes';
/** @type {?} */
const LOAD_TITLES_FAIL = '[User] Load Titles Fail';
/** @type {?} */
const LOAD_TITLES_SUCCESS = '[User] Load Titles Success';
class LoadTitles {
    constructor() {
        this.type = LOAD_TITLES;
    }
}
if (false) {
    /** @type {?} */
    LoadTitles.prototype.type;
}
class LoadTitlesFail {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        this.payload = payload;
        this.type = LOAD_TITLES_FAIL;
    }
}
if (false) {
    /** @type {?} */
    LoadTitlesFail.prototype.type;
    /** @type {?} */
    LoadTitlesFail.prototype.payload;
}
class LoadTitlesSuccess {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        this.payload = payload;
        this.type = LOAD_TITLES_SUCCESS;
    }
}
if (false) {
    /** @type {?} */
    LoadTitlesSuccess.prototype.type;
    /** @type {?} */
    LoadTitlesSuccess.prototype.payload;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const UPDATE_EMAIL = '[User] Update Email';
/** @type {?} */
const UPDATE_EMAIL_ERROR = '[User] Update Email Error';
/** @type {?} */
const UPDATE_EMAIL_SUCCESS = '[User] Update Email Success';
/** @type {?} */
const RESET_EMAIL = '[User] Reset Email';
class UpdateEmailAction extends EntityLoadAction {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        super(PROCESS_FEATURE, UPDATE_EMAIL_PROCESS_ID);
        this.payload = payload;
        this.type = UPDATE_EMAIL;
    }
}
if (false) {
    /** @type {?} */
    UpdateEmailAction.prototype.type;
    /** @type {?} */
    UpdateEmailAction.prototype.payload;
}
class UpdateEmailSuccessAction extends EntitySuccessAction {
    /**
     * @param {?} newUid
     */
    constructor(newUid) {
        super(PROCESS_FEATURE, UPDATE_EMAIL_PROCESS_ID);
        this.newUid = newUid;
        this.type = UPDATE_EMAIL_SUCCESS;
    }
}
if (false) {
    /** @type {?} */
    UpdateEmailSuccessAction.prototype.type;
    /** @type {?} */
    UpdateEmailSuccessAction.prototype.newUid;
}
class UpdateEmailErrorAction extends EntityFailAction {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        super(PROCESS_FEATURE, UPDATE_EMAIL_PROCESS_ID, payload);
        this.payload = payload;
        this.type = UPDATE_EMAIL_ERROR;
    }
}
if (false) {
    /** @type {?} */
    UpdateEmailErrorAction.prototype.type;
    /** @type {?} */
    UpdateEmailErrorAction.prototype.payload;
}
class ResetUpdateEmailAction extends EntityResetAction {
    constructor() {
        super(PROCESS_FEATURE, UPDATE_EMAIL_PROCESS_ID);
        this.type = RESET_EMAIL;
    }
}
if (false) {
    /** @type {?} */
    ResetUpdateEmailAction.prototype.type;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const UPDATE_PASSWORD = '[User] Update Password';
/** @type {?} */
const UPDATE_PASSWORD_FAIL = '[User] Update Password Fail';
/** @type {?} */
const UPDATE_PASSWORD_SUCCESS = '[User] Update Password Success';
/** @type {?} */
const UPDATE_PASSWORD_RESET = '[User] Reset Update Password Process State';
class UpdatePassword extends EntityLoadAction {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        super(PROCESS_FEATURE, UPDATE_PASSWORD_PROCESS_ID);
        this.payload = payload;
        this.type = UPDATE_PASSWORD;
    }
}
if (false) {
    /** @type {?} */
    UpdatePassword.prototype.type;
    /** @type {?} */
    UpdatePassword.prototype.payload;
}
class UpdatePasswordFail extends EntityFailAction {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        super(PROCESS_FEATURE, UPDATE_PASSWORD_PROCESS_ID, payload);
        this.payload = payload;
        this.type = UPDATE_PASSWORD_FAIL;
    }
}
if (false) {
    /** @type {?} */
    UpdatePasswordFail.prototype.type;
    /** @type {?} */
    UpdatePasswordFail.prototype.payload;
}
class UpdatePasswordSuccess extends EntitySuccessAction {
    constructor() {
        super(PROCESS_FEATURE, UPDATE_PASSWORD_PROCESS_ID);
        this.type = UPDATE_PASSWORD_SUCCESS;
    }
}
if (false) {
    /** @type {?} */
    UpdatePasswordSuccess.prototype.type;
}
class UpdatePasswordReset extends EntityResetAction {
    constructor() {
        super(PROCESS_FEATURE, UPDATE_PASSWORD_PROCESS_ID);
        this.type = UPDATE_PASSWORD_RESET;
    }
}
if (false) {
    /** @type {?} */
    UpdatePasswordReset.prototype.type;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const LOAD_USER_ADDRESSES = '[User] Load User Addresses';
/** @type {?} */
const LOAD_USER_ADDRESSES_FAIL = '[User] Load User Addresses Fail';
/** @type {?} */
const LOAD_USER_ADDRESSES_SUCCESS = '[User] Load User Addresses Success';
/** @type {?} */
const ADD_USER_ADDRESS = '[User] Add User Address';
/** @type {?} */
const ADD_USER_ADDRESS_FAIL = '[User] Add User Address Fail';
/** @type {?} */
const ADD_USER_ADDRESS_SUCCESS = '[User] Add User Address Success';
/** @type {?} */
const UPDATE_USER_ADDRESS = '[User] Update User Address';
/** @type {?} */
const UPDATE_USER_ADDRESS_FAIL = '[User] Update User Address Fail';
/** @type {?} */
const UPDATE_USER_ADDRESS_SUCCESS = '[User] Update User Address Success';
/** @type {?} */
const DELETE_USER_ADDRESS = '[User] Delete User Address';
/** @type {?} */
const DELETE_USER_ADDRESS_FAIL = '[User] Delete User Address Fail';
/** @type {?} */
const DELETE_USER_ADDRESS_SUCCESS = '[User] Delete User Address Success';
class LoadUserAddresses extends LoaderLoadAction {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        super(USER_ADDRESSES);
        this.payload = payload;
        this.type = LOAD_USER_ADDRESSES;
    }
}
if (false) {
    /** @type {?} */
    LoadUserAddresses.prototype.type;
    /** @type {?} */
    LoadUserAddresses.prototype.payload;
}
class LoadUserAddressesFail extends LoaderFailAction {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        super(USER_ADDRESSES, payload);
        this.payload = payload;
        this.type = LOAD_USER_ADDRESSES_FAIL;
    }
}
if (false) {
    /** @type {?} */
    LoadUserAddressesFail.prototype.type;
    /** @type {?} */
    LoadUserAddressesFail.prototype.payload;
}
class LoadUserAddressesSuccess extends LoaderSuccessAction {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        super(USER_ADDRESSES);
        this.payload = payload;
        this.type = LOAD_USER_ADDRESSES_SUCCESS;
    }
}
if (false) {
    /** @type {?} */
    LoadUserAddressesSuccess.prototype.type;
    /** @type {?} */
    LoadUserAddressesSuccess.prototype.payload;
}
// Adding address actions
class AddUserAddress extends LoaderLoadAction {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        super(USER_ADDRESSES);
        this.payload = payload;
        this.type = ADD_USER_ADDRESS;
    }
}
if (false) {
    /** @type {?} */
    AddUserAddress.prototype.type;
    /** @type {?} */
    AddUserAddress.prototype.payload;
}
class AddUserAddressFail extends LoaderFailAction {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        super(USER_ADDRESSES, payload);
        this.payload = payload;
        this.type = ADD_USER_ADDRESS_FAIL;
    }
}
if (false) {
    /** @type {?} */
    AddUserAddressFail.prototype.type;
    /** @type {?} */
    AddUserAddressFail.prototype.payload;
}
class AddUserAddressSuccess extends LoaderSuccessAction {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        super(USER_ADDRESSES);
        this.payload = payload;
        this.type = ADD_USER_ADDRESS_SUCCESS;
    }
}
if (false) {
    /** @type {?} */
    AddUserAddressSuccess.prototype.type;
    /** @type {?} */
    AddUserAddressSuccess.prototype.payload;
}
// Updating address actions
class UpdateUserAddress extends LoaderLoadAction {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        super(USER_ADDRESSES);
        this.payload = payload;
        this.type = UPDATE_USER_ADDRESS;
    }
}
if (false) {
    /** @type {?} */
    UpdateUserAddress.prototype.type;
    /** @type {?} */
    UpdateUserAddress.prototype.payload;
}
class UpdateUserAddressFail extends LoaderFailAction {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        super(USER_ADDRESSES, payload);
        this.payload = payload;
        this.type = UPDATE_USER_ADDRESS_FAIL;
    }
}
if (false) {
    /** @type {?} */
    UpdateUserAddressFail.prototype.type;
    /** @type {?} */
    UpdateUserAddressFail.prototype.payload;
}
class UpdateUserAddressSuccess extends LoaderSuccessAction {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        super(USER_ADDRESSES);
        this.payload = payload;
        this.type = UPDATE_USER_ADDRESS_SUCCESS;
    }
}
if (false) {
    /** @type {?} */
    UpdateUserAddressSuccess.prototype.type;
    /** @type {?} */
    UpdateUserAddressSuccess.prototype.payload;
}
// Deleting address actions
class DeleteUserAddress extends LoaderLoadAction {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        super(USER_ADDRESSES);
        this.payload = payload;
        this.type = DELETE_USER_ADDRESS;
    }
}
if (false) {
    /** @type {?} */
    DeleteUserAddress.prototype.type;
    /** @type {?} */
    DeleteUserAddress.prototype.payload;
}
class DeleteUserAddressFail extends LoaderFailAction {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        super(USER_ADDRESSES, payload);
        this.payload = payload;
        this.type = DELETE_USER_ADDRESS_FAIL;
    }
}
if (false) {
    /** @type {?} */
    DeleteUserAddressFail.prototype.type;
    /** @type {?} */
    DeleteUserAddressFail.prototype.payload;
}
class DeleteUserAddressSuccess extends LoaderSuccessAction {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        super(USER_ADDRESSES);
        this.payload = payload;
        this.type = DELETE_USER_ADDRESS_SUCCESS;
    }
}
if (false) {
    /** @type {?} */
    DeleteUserAddressSuccess.prototype.type;
    /** @type {?} */
    DeleteUserAddressSuccess.prototype.payload;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const LOAD_USER_CONSENTS = '[User] Load User Consents';
/** @type {?} */
const LOAD_USER_CONSENTS_SUCCESS = '[User] Load User Consents Success';
/** @type {?} */
const LOAD_USER_CONSENTS_FAIL = '[User] Load User Consents Fail';
/** @type {?} */
const RESET_LOAD_USER_CONSENTS = '[User] Reset Load User Consents';
/** @type {?} */
const GIVE_USER_CONSENT = '[User] Give User Consent';
/** @type {?} */
const GIVE_USER_CONSENT_FAIL = '[User] Give User Consent Fail';
/** @type {?} */
const GIVE_USER_CONSENT_SUCCESS = '[User] Give User Consent Success';
/** @type {?} */
const RESET_GIVE_USER_CONSENT_PROCESS = '[User] Reset Give User Consent Process';
/** @type {?} */
const TRANSFER_ANONYMOUS_CONSENT = '[User] Transfer Anonymous Consent';
/** @type {?} */
const WITHDRAW_USER_CONSENT = '[User] Withdraw User Consent';
/** @type {?} */
const WITHDRAW_USER_CONSENT_FAIL = '[User] Withdraw User Consent Fail';
/** @type {?} */
const WITHDRAW_USER_CONSENT_SUCCESS = '[User] Withdraw User Consent Success';
/** @type {?} */
const RESET_WITHDRAW_USER_CONSENT_PROCESS = '[User] Reset Withdraw User Consent Process';
class LoadUserConsents extends LoaderLoadAction {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        super(USER_CONSENTS);
        this.payload = payload;
        this.type = LOAD_USER_CONSENTS;
    }
}
if (false) {
    /** @type {?} */
    LoadUserConsents.prototype.type;
    /** @type {?} */
    LoadUserConsents.prototype.payload;
}
class LoadUserConsentsFail extends LoaderFailAction {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        super(USER_CONSENTS, payload);
        this.payload = payload;
        this.type = LOAD_USER_CONSENTS_FAIL;
    }
}
if (false) {
    /** @type {?} */
    LoadUserConsentsFail.prototype.type;
    /** @type {?} */
    LoadUserConsentsFail.prototype.payload;
}
class LoadUserConsentsSuccess extends LoaderSuccessAction {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        super(USER_CONSENTS);
        this.payload = payload;
        this.type = LOAD_USER_CONSENTS_SUCCESS;
    }
}
if (false) {
    /** @type {?} */
    LoadUserConsentsSuccess.prototype.type;
    /** @type {?} */
    LoadUserConsentsSuccess.prototype.payload;
}
class ResetLoadUserConsents extends LoaderResetAction {
    constructor() {
        super(USER_CONSENTS);
        this.type = RESET_LOAD_USER_CONSENTS;
    }
}
if (false) {
    /** @type {?} */
    ResetLoadUserConsents.prototype.type;
}
class GiveUserConsent extends EntityLoadAction {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        super(PROCESS_FEATURE, GIVE_CONSENT_PROCESS_ID);
        this.payload = payload;
        this.type = GIVE_USER_CONSENT;
    }
}
if (false) {
    /** @type {?} */
    GiveUserConsent.prototype.type;
    /** @type {?} */
    GiveUserConsent.prototype.payload;
}
class GiveUserConsentFail extends EntityFailAction {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        super(PROCESS_FEATURE, GIVE_CONSENT_PROCESS_ID, payload);
        this.type = GIVE_USER_CONSENT_FAIL;
    }
}
if (false) {
    /** @type {?} */
    GiveUserConsentFail.prototype.type;
}
class GiveUserConsentSuccess extends EntitySuccessAction {
    /**
     * @param {?} consentTemplate
     */
    constructor(consentTemplate) {
        super(PROCESS_FEATURE, GIVE_CONSENT_PROCESS_ID);
        this.consentTemplate = consentTemplate;
        this.type = GIVE_USER_CONSENT_SUCCESS;
    }
}
if (false) {
    /** @type {?} */
    GiveUserConsentSuccess.prototype.type;
    /** @type {?} */
    GiveUserConsentSuccess.prototype.consentTemplate;
}
class ResetGiveUserConsentProcess extends EntityResetAction {
    constructor() {
        super(PROCESS_FEATURE, GIVE_CONSENT_PROCESS_ID);
        this.type = RESET_GIVE_USER_CONSENT_PROCESS;
    }
}
if (false) {
    /** @type {?} */
    ResetGiveUserConsentProcess.prototype.type;
}
class TransferAnonymousConsent {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        this.payload = payload;
        this.type = TRANSFER_ANONYMOUS_CONSENT;
    }
}
if (false) {
    /** @type {?} */
    TransferAnonymousConsent.prototype.type;
    /** @type {?} */
    TransferAnonymousConsent.prototype.payload;
}
class WithdrawUserConsent extends EntityLoadAction {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        super(PROCESS_FEATURE, WITHDRAW_CONSENT_PROCESS_ID);
        this.payload = payload;
        this.type = WITHDRAW_USER_CONSENT;
    }
}
if (false) {
    /** @type {?} */
    WithdrawUserConsent.prototype.type;
    /** @type {?} */
    WithdrawUserConsent.prototype.payload;
}
class WithdrawUserConsentFail extends EntityFailAction {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        super(PROCESS_FEATURE, WITHDRAW_CONSENT_PROCESS_ID, payload);
        this.type = WITHDRAW_USER_CONSENT_FAIL;
    }
}
if (false) {
    /** @type {?} */
    WithdrawUserConsentFail.prototype.type;
}
class WithdrawUserConsentSuccess extends EntitySuccessAction {
    constructor() {
        super(PROCESS_FEATURE, WITHDRAW_CONSENT_PROCESS_ID);
        this.type = WITHDRAW_USER_CONSENT_SUCCESS;
    }
}
if (false) {
    /** @type {?} */
    WithdrawUserConsentSuccess.prototype.type;
}
class ResetWithdrawUserConsentProcess extends EntityResetAction {
    constructor() {
        super(PROCESS_FEATURE, WITHDRAW_CONSENT_PROCESS_ID);
        this.type = RESET_WITHDRAW_USER_CONSENT_PROCESS;
    }
}
if (false) {
    /** @type {?} */
    ResetWithdrawUserConsentProcess.prototype.type;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const LOAD_USER_DETAILS = '[User] Load User Details';
/** @type {?} */
const LOAD_USER_DETAILS_FAIL = '[User] Load User Details Fail';
/** @type {?} */
const LOAD_USER_DETAILS_SUCCESS = '[User] Load User Details Success';
/** @type {?} */
const UPDATE_USER_DETAILS = '[User] Update User Details';
/** @type {?} */
const UPDATE_USER_DETAILS_FAIL = '[User] Update User Details Fail';
/** @type {?} */
const UPDATE_USER_DETAILS_SUCCESS = '[User] Update User Details Success';
/** @type {?} */
const RESET_USER_DETAILS = '[User] Reset User Details';
class LoadUserDetails {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        this.payload = payload;
        this.type = LOAD_USER_DETAILS;
    }
}
if (false) {
    /** @type {?} */
    LoadUserDetails.prototype.type;
    /** @type {?} */
    LoadUserDetails.prototype.payload;
}
class LoadUserDetailsFail {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        this.payload = payload;
        this.type = LOAD_USER_DETAILS_FAIL;
    }
}
if (false) {
    /** @type {?} */
    LoadUserDetailsFail.prototype.type;
    /** @type {?} */
    LoadUserDetailsFail.prototype.payload;
}
class LoadUserDetailsSuccess {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        this.payload = payload;
        this.type = LOAD_USER_DETAILS_SUCCESS;
    }
}
if (false) {
    /** @type {?} */
    LoadUserDetailsSuccess.prototype.type;
    /** @type {?} */
    LoadUserDetailsSuccess.prototype.payload;
}
class UpdateUserDetails extends EntityLoadAction {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        super(PROCESS_FEATURE, UPDATE_USER_DETAILS_PROCESS_ID);
        this.payload = payload;
        this.type = UPDATE_USER_DETAILS;
    }
}
if (false) {
    /** @type {?} */
    UpdateUserDetails.prototype.type;
    /** @type {?} */
    UpdateUserDetails.prototype.payload;
}
class UpdateUserDetailsFail extends EntityFailAction {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        super(PROCESS_FEATURE, UPDATE_USER_DETAILS_PROCESS_ID, payload);
        this.payload = payload;
        this.type = UPDATE_USER_DETAILS_FAIL;
    }
}
if (false) {
    /** @type {?} */
    UpdateUserDetailsFail.prototype.type;
    /** @type {?} */
    UpdateUserDetailsFail.prototype.payload;
}
class UpdateUserDetailsSuccess extends EntitySuccessAction {
    /**
     * @param {?} userUpdates
     */
    constructor(userUpdates) {
        super(PROCESS_FEATURE, UPDATE_USER_DETAILS_PROCESS_ID);
        this.userUpdates = userUpdates;
        this.type = UPDATE_USER_DETAILS_SUCCESS;
    }
}
if (false) {
    /** @type {?} */
    UpdateUserDetailsSuccess.prototype.type;
    /** @type {?} */
    UpdateUserDetailsSuccess.prototype.userUpdates;
}
class ResetUpdateUserDetails extends EntityResetAction {
    constructor() {
        super(PROCESS_FEATURE, UPDATE_USER_DETAILS_PROCESS_ID);
        this.type = RESET_USER_DETAILS;
    }
}
if (false) {
    /** @type {?} */
    ResetUpdateUserDetails.prototype.type;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const CLEAR_USER_MISCS_DATA = '[User] Clear User Misc Data';
class ClearUserMiscsData {
    constructor() {
        this.type = CLEAR_USER_MISCS_DATA;
    }
}
if (false) {
    /** @type {?} */
    ClearUserMiscsData.prototype.type;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const LOAD_USER_ORDERS = '[User] Load User Orders';
/** @type {?} */
const LOAD_USER_ORDERS_FAIL = '[User] Load User Orders Fail';
/** @type {?} */
const LOAD_USER_ORDERS_SUCCESS = '[User] Load User Orders Success';
/** @type {?} */
const CLEAR_USER_ORDERS = '[User] Clear User Orders';
class LoadUserOrders extends LoaderLoadAction {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        super(USER_ORDERS);
        this.payload = payload;
        this.type = LOAD_USER_ORDERS;
    }
}
if (false) {
    /** @type {?} */
    LoadUserOrders.prototype.type;
    /** @type {?} */
    LoadUserOrders.prototype.payload;
}
class LoadUserOrdersFail extends LoaderFailAction {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        super(USER_ORDERS, payload);
        this.payload = payload;
        this.type = LOAD_USER_ORDERS_FAIL;
    }
}
if (false) {
    /** @type {?} */
    LoadUserOrdersFail.prototype.type;
    /** @type {?} */
    LoadUserOrdersFail.prototype.payload;
}
class LoadUserOrdersSuccess extends LoaderSuccessAction {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        super(USER_ORDERS);
        this.payload = payload;
        this.type = LOAD_USER_ORDERS_SUCCESS;
    }
}
if (false) {
    /** @type {?} */
    LoadUserOrdersSuccess.prototype.type;
    /** @type {?} */
    LoadUserOrdersSuccess.prototype.payload;
}
class ClearUserOrders extends LoaderResetAction {
    constructor() {
        super(USER_ORDERS);
        this.type = CLEAR_USER_ORDERS;
    }
}
if (false) {
    /** @type {?} */
    ClearUserOrders.prototype.type;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const REGISTER_USER = '[User] Register User';
/** @type {?} */
const REGISTER_USER_FAIL = '[User] Register User Fail';
/** @type {?} */
const REGISTER_USER_SUCCESS = '[User] Register User Success';
/** @type {?} */
const RESET_REGISTER_USER_PROCESS = '[User] Reset Register User Process';
/** @type {?} */
const REGISTER_GUEST = '[User] Register Guest';
/** @type {?} */
const REGISTER_GUEST_FAIL = '[User] Register Guest Fail';
/** @type {?} */
const REGISTER_GUEST_SUCCESS = '[User] Register Guest Success';
/** @type {?} */
const REMOVE_USER = '[User] Remove User';
/** @type {?} */
const REMOVE_USER_FAIL = '[User] Remove User Fail';
/** @type {?} */
const REMOVE_USER_SUCCESS = '[User] Remove User Success';
/** @type {?} */
const REMOVE_USER_RESET = '[User] Reset Remove User Process State';
class RegisterUser extends EntityLoadAction {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        super(PROCESS_FEATURE, REGISTER_USER_PROCESS_ID);
        this.payload = payload;
        this.type = REGISTER_USER;
    }
}
if (false) {
    /** @type {?} */
    RegisterUser.prototype.type;
    /** @type {?} */
    RegisterUser.prototype.payload;
}
class RegisterUserFail extends EntityFailAction {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        super(PROCESS_FEATURE, REGISTER_USER_PROCESS_ID, payload);
        this.payload = payload;
        this.type = REGISTER_USER_FAIL;
    }
}
if (false) {
    /** @type {?} */
    RegisterUserFail.prototype.type;
    /** @type {?} */
    RegisterUserFail.prototype.payload;
}
class RegisterUserSuccess extends EntitySuccessAction {
    constructor() {
        super(PROCESS_FEATURE, REGISTER_USER_PROCESS_ID);
        this.type = REGISTER_USER_SUCCESS;
    }
}
if (false) {
    /** @type {?} */
    RegisterUserSuccess.prototype.type;
}
class ResetRegisterUserProcess extends EntityResetAction {
    constructor() {
        super(PROCESS_FEATURE, REGISTER_USER_PROCESS_ID);
        this.type = RESET_REGISTER_USER_PROCESS;
    }
}
if (false) {
    /** @type {?} */
    ResetRegisterUserProcess.prototype.type;
}
class RegisterGuest {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        this.payload = payload;
        this.type = REGISTER_GUEST;
    }
}
if (false) {
    /** @type {?} */
    RegisterGuest.prototype.type;
    /** @type {?} */
    RegisterGuest.prototype.payload;
}
class RegisterGuestFail {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        this.payload = payload;
        this.type = REGISTER_GUEST_FAIL;
    }
}
if (false) {
    /** @type {?} */
    RegisterGuestFail.prototype.type;
    /** @type {?} */
    RegisterGuestFail.prototype.payload;
}
class RegisterGuestSuccess {
    constructor() {
        this.type = REGISTER_GUEST_SUCCESS;
    }
}
if (false) {
    /** @type {?} */
    RegisterGuestSuccess.prototype.type;
}
class RemoveUser extends EntityLoadAction {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        super(PROCESS_FEATURE, REMOVE_USER_PROCESS_ID);
        this.payload = payload;
        this.type = REMOVE_USER;
    }
}
if (false) {
    /** @type {?} */
    RemoveUser.prototype.type;
    /** @type {?} */
    RemoveUser.prototype.payload;
}
class RemoveUserFail extends EntityFailAction {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        super(PROCESS_FEATURE, REMOVE_USER_PROCESS_ID, payload);
        this.payload = payload;
        this.type = REMOVE_USER_FAIL;
    }
}
if (false) {
    /** @type {?} */
    RemoveUserFail.prototype.type;
    /** @type {?} */
    RemoveUserFail.prototype.payload;
}
class RemoveUserSuccess extends EntitySuccessAction {
    constructor() {
        super(PROCESS_FEATURE, REMOVE_USER_PROCESS_ID);
        this.type = REMOVE_USER_SUCCESS;
    }
}
if (false) {
    /** @type {?} */
    RemoveUserSuccess.prototype.type;
}
class RemoveUserReset extends EntityResetAction {
    constructor() {
        super(PROCESS_FEATURE, REMOVE_USER_PROCESS_ID);
        this.type = REMOVE_USER_RESET;
    }
}
if (false) {
    /** @type {?} */
    RemoveUserReset.prototype.type;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const LOAD_CUSTOMER_COUPONS = '[User] Load Customer Coupons';
/** @type {?} */
const LOAD_CUSTOMER_COUPONS_FAIL = '[User] Load Customer Coupons Fail';
/** @type {?} */
const LOAD_CUSTOMER_COUPONS_SUCCESS = '[User] Load Customer Coupons Success';
/** @type {?} */
const RESET_LOAD_CUSTOMER_COUPONS = '[User] Reset Load Customer Coupons';
/** @type {?} */
const SUBSCRIBE_CUSTOMER_COUPON = '[User] Subscribe Customer Notification Coupon';
/** @type {?} */
const SUBSCRIBE_CUSTOMER_COUPON_FAIL = '[User] Subscribe Customer Coupon Notification Fail';
/** @type {?} */
const SUBSCRIBE_CUSTOMER_COUPON_SUCCESS = '[User] Subscribe Customer Coupon Notification Success';
/** @type {?} */
const RESET_SUBSCRIBE_CUSTOMER_COUPON_PROCESS = '[User] Reset Subscribe Customer Coupon Process';
/** @type {?} */
const UNSUBSCRIBE_CUSTOMER_COUPON = '[User] Unsubscribe Customer Notification Coupon';
/** @type {?} */
const UNSUBSCRIBE_CUSTOMER_COUPON_FAIL = '[User] Unsubscribe Customer Coupon Notification Fail';
/** @type {?} */
const UNSUBSCRIBE_CUSTOMER_COUPON_SUCCESS = '[User] Unsubscribe Customer Coupon Notification Success';
/** @type {?} */
const RESET_UNSUBSCRIBE_CUSTOMER_COUPON_PROCESS = '[User] Reset Unsubscribe Customer Coupon Process';
/** @type {?} */
const CLAIM_CUSTOMER_COUPON = '[User] Claim Customer';
/** @type {?} */
const CLAIM_CUSTOMER_COUPON_FAIL = '[User] Claim Customer Fail';
/** @type {?} */
const CLAIM_CUSTOMER_COUPON_SUCCESS = '[User] Claim Customer Success';
class LoadCustomerCoupons extends LoaderLoadAction {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        super(CUSTOMER_COUPONS);
        this.payload = payload;
        this.type = LOAD_CUSTOMER_COUPONS;
    }
}
if (false) {
    /** @type {?} */
    LoadCustomerCoupons.prototype.type;
    /** @type {?} */
    LoadCustomerCoupons.prototype.payload;
}
class LoadCustomerCouponsFail extends LoaderFailAction {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        super(CUSTOMER_COUPONS, payload);
        this.payload = payload;
        this.type = LOAD_CUSTOMER_COUPONS_FAIL;
    }
}
if (false) {
    /** @type {?} */
    LoadCustomerCouponsFail.prototype.type;
    /** @type {?} */
    LoadCustomerCouponsFail.prototype.payload;
}
class LoadCustomerCouponsSuccess extends LoaderSuccessAction {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        super(CUSTOMER_COUPONS);
        this.payload = payload;
        this.type = LOAD_CUSTOMER_COUPONS_SUCCESS;
    }
}
if (false) {
    /** @type {?} */
    LoadCustomerCouponsSuccess.prototype.type;
    /** @type {?} */
    LoadCustomerCouponsSuccess.prototype.payload;
}
class ResetLoadCustomerCoupons extends LoaderResetAction {
    constructor() {
        super(CUSTOMER_COUPONS);
        this.type = RESET_LOAD_CUSTOMER_COUPONS;
    }
}
if (false) {
    /** @type {?} */
    ResetLoadCustomerCoupons.prototype.type;
}
// Subscribe coupon notification actions
class SubscribeCustomerCoupon extends EntityLoadAction {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        super(PROCESS_FEATURE, SUBSCRIBE_CUSTOMER_COUPON_PROCESS_ID);
        this.payload = payload;
        this.type = SUBSCRIBE_CUSTOMER_COUPON;
    }
}
if (false) {
    /** @type {?} */
    SubscribeCustomerCoupon.prototype.type;
    /** @type {?} */
    SubscribeCustomerCoupon.prototype.payload;
}
class SubscribeCustomerCouponFail extends EntityFailAction {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        super(PROCESS_FEATURE, SUBSCRIBE_CUSTOMER_COUPON_PROCESS_ID, payload);
        this.payload = payload;
        this.type = SUBSCRIBE_CUSTOMER_COUPON_FAIL;
    }
}
if (false) {
    /** @type {?} */
    SubscribeCustomerCouponFail.prototype.type;
    /** @type {?} */
    SubscribeCustomerCouponFail.prototype.payload;
}
class SubscribeCustomerCouponSuccess extends EntitySuccessAction {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        super(PROCESS_FEATURE, SUBSCRIBE_CUSTOMER_COUPON_PROCESS_ID, payload);
        this.payload = payload;
        this.type = SUBSCRIBE_CUSTOMER_COUPON_SUCCESS;
    }
}
if (false) {
    /** @type {?} */
    SubscribeCustomerCouponSuccess.prototype.type;
    /** @type {?} */
    SubscribeCustomerCouponSuccess.prototype.payload;
}
class ResetSubscribeCustomerCouponProcess extends EntityResetAction {
    constructor() {
        super(PROCESS_FEATURE, SUBSCRIBE_CUSTOMER_COUPON_PROCESS_ID);
        this.type = RESET_SUBSCRIBE_CUSTOMER_COUPON_PROCESS;
    }
}
if (false) {
    /** @type {?} */
    ResetSubscribeCustomerCouponProcess.prototype.type;
}
class UnsubscribeCustomerCoupon extends EntityLoadAction {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        super(PROCESS_FEATURE, UNSUBSCRIBE_CUSTOMER_COUPON_PROCESS_ID);
        this.payload = payload;
        this.type = UNSUBSCRIBE_CUSTOMER_COUPON;
    }
}
if (false) {
    /** @type {?} */
    UnsubscribeCustomerCoupon.prototype.type;
    /** @type {?} */
    UnsubscribeCustomerCoupon.prototype.payload;
}
class UnsubscribeCustomerCouponFail extends EntityFailAction {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        super(PROCESS_FEATURE, UNSUBSCRIBE_CUSTOMER_COUPON_PROCESS_ID, payload);
        this.payload = payload;
        this.type = UNSUBSCRIBE_CUSTOMER_COUPON_FAIL;
    }
}
if (false) {
    /** @type {?} */
    UnsubscribeCustomerCouponFail.prototype.type;
    /** @type {?} */
    UnsubscribeCustomerCouponFail.prototype.payload;
}
class UnsubscribeCustomerCouponSuccess extends EntitySuccessAction {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        super(PROCESS_FEATURE, UNSUBSCRIBE_CUSTOMER_COUPON_PROCESS_ID, payload);
        this.payload = payload;
        this.type = UNSUBSCRIBE_CUSTOMER_COUPON_SUCCESS;
    }
}
if (false) {
    /** @type {?} */
    UnsubscribeCustomerCouponSuccess.prototype.type;
    /** @type {?} */
    UnsubscribeCustomerCouponSuccess.prototype.payload;
}
class ResetUnsubscribeCustomerCouponProcess extends EntityResetAction {
    constructor() {
        super(PROCESS_FEATURE, UNSUBSCRIBE_CUSTOMER_COUPON_PROCESS_ID);
        this.type = RESET_UNSUBSCRIBE_CUSTOMER_COUPON_PROCESS;
    }
}
if (false) {
    /** @type {?} */
    ResetUnsubscribeCustomerCouponProcess.prototype.type;
}
class ClaimCustomerCoupon extends EntityLoadAction {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        super(PROCESS_FEATURE, CLAIM_CUSTOMER_COUPON_PROCESS_ID);
        this.payload = payload;
        this.type = CLAIM_CUSTOMER_COUPON;
    }
}
if (false) {
    /** @type {?} */
    ClaimCustomerCoupon.prototype.type;
    /** @type {?} */
    ClaimCustomerCoupon.prototype.payload;
}
class ClaimCustomerCouponFail extends EntityFailAction {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        super(PROCESS_FEATURE, CLAIM_CUSTOMER_COUPON_PROCESS_ID, payload);
        this.payload = payload;
        this.type = CLAIM_CUSTOMER_COUPON_FAIL;
    }
}
if (false) {
    /** @type {?} */
    ClaimCustomerCouponFail.prototype.type;
    /** @type {?} */
    ClaimCustomerCouponFail.prototype.payload;
}
class ClaimCustomerCouponSuccess extends EntitySuccessAction {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        super(PROCESS_FEATURE, CLAIM_CUSTOMER_COUPON_PROCESS_ID, payload);
        this.payload = payload;
        this.type = CLAIM_CUSTOMER_COUPON_SUCCESS;
    }
}
if (false) {
    /** @type {?} */
    ClaimCustomerCouponSuccess.prototype.type;
    /** @type {?} */
    ClaimCustomerCouponSuccess.prototype.payload;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const LOAD_NOTIFICATION_PREFERENCES = '[User] Load Notification Preferences';
/** @type {?} */
const LOAD_NOTIFICATION_PREFERENCES_FAIL = '[User] Load Notification Preferences Fail';
/** @type {?} */
const LOAD_NOTIFICATION_PREFERENCES_SUCCESS = '[User] Load Notification Preferences Success';
/** @type {?} */
const UPDATE_NOTIFICATION_PREFERENCES = '[User] Update Notification Preferences';
/** @type {?} */
const UPDATE_NOTIFICATION_PREFERENCES_FAIL = '[User] Update Notification Preferences Fail';
/** @type {?} */
const UPDATE_NOTIFICATION_PREFERENCES_SUCCESS = '[User] Update Notification Preferences Success';
/** @type {?} */
const RESET_NOTIFICATION_PREFERENCES = '[User] Reset Notification Preferences';
/** @type {?} */
const CLEAR_NOTIFICATION_PREFERENCES = '[User] Clear Notification Preferences';
class LoadNotificationPreferences extends LoaderLoadAction {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        super(NOTIFICATION_PREFERENCES);
        this.payload = payload;
        this.type = LOAD_NOTIFICATION_PREFERENCES;
    }
}
if (false) {
    /** @type {?} */
    LoadNotificationPreferences.prototype.type;
    /** @type {?} */
    LoadNotificationPreferences.prototype.payload;
}
class LoadNotificationPreferencesFail extends LoaderFailAction {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        super(NOTIFICATION_PREFERENCES, payload);
        this.payload = payload;
        this.type = LOAD_NOTIFICATION_PREFERENCES_FAIL;
    }
}
if (false) {
    /** @type {?} */
    LoadNotificationPreferencesFail.prototype.type;
    /** @type {?} */
    LoadNotificationPreferencesFail.prototype.payload;
}
class LoadNotificationPreferencesSuccess extends LoaderSuccessAction {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        super(NOTIFICATION_PREFERENCES);
        this.payload = payload;
        this.type = LOAD_NOTIFICATION_PREFERENCES_SUCCESS;
    }
}
if (false) {
    /** @type {?} */
    LoadNotificationPreferencesSuccess.prototype.type;
    /** @type {?} */
    LoadNotificationPreferencesSuccess.prototype.payload;
}
class UpdateNotificationPreferences extends EntityLoadAction {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        super(PROCESS_FEATURE, UPDATE_NOTIFICATION_PREFERENCES_PROCESS_ID);
        this.payload = payload;
        this.type = UPDATE_NOTIFICATION_PREFERENCES;
    }
}
if (false) {
    /** @type {?} */
    UpdateNotificationPreferences.prototype.type;
    /** @type {?} */
    UpdateNotificationPreferences.prototype.payload;
}
class UpdateNotificationPreferencesFail extends EntityFailAction {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        super(PROCESS_FEATURE, UPDATE_NOTIFICATION_PREFERENCES_PROCESS_ID, payload);
        this.payload = payload;
        this.type = UPDATE_NOTIFICATION_PREFERENCES_FAIL;
    }
}
if (false) {
    /** @type {?} */
    UpdateNotificationPreferencesFail.prototype.type;
    /** @type {?} */
    UpdateNotificationPreferencesFail.prototype.payload;
}
class UpdateNotificationPreferencesSuccess extends EntitySuccessAction {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        super(PROCESS_FEATURE, UPDATE_NOTIFICATION_PREFERENCES_PROCESS_ID);
        this.payload = payload;
        this.type = UPDATE_NOTIFICATION_PREFERENCES_SUCCESS;
    }
}
if (false) {
    /** @type {?} */
    UpdateNotificationPreferencesSuccess.prototype.type;
    /** @type {?} */
    UpdateNotificationPreferencesSuccess.prototype.payload;
}
class ResetNotificationPreferences extends EntityResetAction {
    constructor() {
        super(PROCESS_FEATURE, UPDATE_NOTIFICATION_PREFERENCES_PROCESS_ID);
        this.type = RESET_NOTIFICATION_PREFERENCES;
    }
}
if (false) {
    /** @type {?} */
    ResetNotificationPreferences.prototype.type;
}
class ClearNotificationPreferences extends LoaderResetAction {
    constructor() {
        super(NOTIFICATION_PREFERENCES);
        this.type = CLEAR_NOTIFICATION_PREFERENCES;
    }
}
if (false) {
    /** @type {?} */
    ClearNotificationPreferences.prototype.type;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const LOAD_PRODUCT_INTERESTS = 'Load Product Interests';
/** @type {?} */
const LOAD_PRODUCT_INTERESTS_FAIL = 'Load Product Interests Fail';
/** @type {?} */
const LOAD_PRODUCT_INTERESTS_SUCCESS = 'Load Product Interests Success';
/** @type {?} */
const REMOVE_PRODUCT_INTEREST = 'Remove Product Interest';
/** @type {?} */
const REMOVE_PRODUCT_INTEREST_SUCCESS = 'Remove Product Interest Success';
/** @type {?} */
const REMOVE_PRODUCT_INTEREST_FAIL = 'Remove Product Interest Fail';
/** @type {?} */
const ADD_PRODUCT_INTEREST = 'Add Product Interest';
/** @type {?} */
const ADD_PRODUCT_INTEREST_FAIL = 'Add Product Interest Fail';
/** @type {?} */
const ADD_PRODUCT_INTEREST_SUCCESS = 'Add Product Interest Success';
/** @type {?} */
const ADD_PRODUCT_INTEREST_RESET = 'Add Product Interest Reset';
/** @type {?} */
const REMOVE_PRODUCT_INTEREST_RESET = 'Remove Product Interest Reset';
/** @type {?} */
const CLEAR_PRODUCT_INTERESTS = 'Clear Product Interests';
class LoadProductInterests extends LoaderLoadAction {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        super(PRODUCT_INTERESTS);
        this.payload = payload;
        this.type = LOAD_PRODUCT_INTERESTS;
    }
}
if (false) {
    /** @type {?} */
    LoadProductInterests.prototype.type;
    /** @type {?} */
    LoadProductInterests.prototype.payload;
}
class LoadProductInterestsFail extends LoaderFailAction {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        super(PRODUCT_INTERESTS, payload);
        this.payload = payload;
        this.type = LOAD_PRODUCT_INTERESTS_FAIL;
    }
}
if (false) {
    /** @type {?} */
    LoadProductInterestsFail.prototype.type;
    /** @type {?} */
    LoadProductInterestsFail.prototype.payload;
}
class LoadProductInterestsSuccess extends LoaderSuccessAction {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        super(PRODUCT_INTERESTS);
        this.payload = payload;
        this.type = LOAD_PRODUCT_INTERESTS_SUCCESS;
    }
}
if (false) {
    /** @type {?} */
    LoadProductInterestsSuccess.prototype.type;
    /** @type {?} */
    LoadProductInterestsSuccess.prototype.payload;
}
class RemoveProductInterest extends EntityLoadAction {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        super(PROCESS_FEATURE, REMOVE_PRODUCT_INTERESTS_PROCESS_ID);
        this.payload = payload;
        this.type = REMOVE_PRODUCT_INTEREST;
    }
}
if (false) {
    /** @type {?} */
    RemoveProductInterest.prototype.type;
    /** @type {?} */
    RemoveProductInterest.prototype.payload;
}
class RemoveProductInterestSuccess extends EntitySuccessAction {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        super(PROCESS_FEATURE, REMOVE_PRODUCT_INTERESTS_PROCESS_ID);
        this.payload = payload;
        this.type = REMOVE_PRODUCT_INTEREST_SUCCESS;
    }
}
if (false) {
    /** @type {?} */
    RemoveProductInterestSuccess.prototype.type;
    /** @type {?} */
    RemoveProductInterestSuccess.prototype.payload;
}
class RemoveProductInterestFail extends EntityFailAction {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        super(PROCESS_FEATURE, REMOVE_PRODUCT_INTERESTS_PROCESS_ID, payload);
        this.payload = payload;
        this.type = REMOVE_PRODUCT_INTEREST_FAIL;
    }
}
if (false) {
    /** @type {?} */
    RemoveProductInterestFail.prototype.type;
    /** @type {?} */
    RemoveProductInterestFail.prototype.payload;
}
class AddProductInterest extends EntityLoadAction {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        super(PROCESS_FEATURE, ADD_PRODUCT_INTEREST_PROCESS_ID);
        this.payload = payload;
        this.type = ADD_PRODUCT_INTEREST;
    }
}
if (false) {
    /** @type {?} */
    AddProductInterest.prototype.type;
    /** @type {?} */
    AddProductInterest.prototype.payload;
}
class AddProductInterestSuccess extends EntitySuccessAction {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        super(PROCESS_FEATURE, ADD_PRODUCT_INTEREST_PROCESS_ID);
        this.payload = payload;
        this.type = ADD_PRODUCT_INTEREST_SUCCESS;
    }
}
if (false) {
    /** @type {?} */
    AddProductInterestSuccess.prototype.type;
    /** @type {?} */
    AddProductInterestSuccess.prototype.payload;
}
class AddProductInterestFail extends EntityFailAction {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        super(PROCESS_FEATURE, ADD_PRODUCT_INTEREST_PROCESS_ID, payload);
        this.payload = payload;
        this.type = ADD_PRODUCT_INTEREST_FAIL;
    }
}
if (false) {
    /** @type {?} */
    AddProductInterestFail.prototype.type;
    /** @type {?} */
    AddProductInterestFail.prototype.payload;
}
class ResetAddInterestState extends EntityResetAction {
    constructor() {
        super(PROCESS_FEATURE, ADD_PRODUCT_INTEREST_PROCESS_ID);
        this.type = ADD_PRODUCT_INTEREST_RESET;
    }
}
if (false) {
    /** @type {?} */
    ResetAddInterestState.prototype.type;
}
class ResetRemoveInterestState extends EntityResetAction {
    constructor() {
        super(PROCESS_FEATURE, REMOVE_PRODUCT_INTERESTS_PROCESS_ID);
        this.type = REMOVE_PRODUCT_INTEREST_RESET;
    }
}
if (false) {
    /** @type {?} */
    ResetRemoveInterestState.prototype.type;
}
class ClearProductInterests extends LoaderResetAction {
    constructor() {
        super(PRODUCT_INTERESTS);
        this.type = CLEAR_PRODUCT_INTERESTS;
    }
}
if (false) {
    /** @type {?} */
    ClearProductInterests.prototype.type;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const CREATE_ORDER_RETURN_REQUEST = '[User] Create Order Return Request';
/** @type {?} */
const CREATE_ORDER_RETURN_REQUEST_FAIL = '[User] Create Order Return Request Fail';
/** @type {?} */
const CREATE_ORDER_RETURN_REQUEST_SUCCESS = '[User] Create Order Return Request Success';
/** @type {?} */
const LOAD_ORDER_RETURN_REQUEST = '[User] Load Order Return Request details';
/** @type {?} */
const LOAD_ORDER_RETURN_REQUEST_FAIL = '[User] Load Order Return Request details Fail';
/** @type {?} */
const LOAD_ORDER_RETURN_REQUEST_SUCCESS = '[User] Load Order Return Request details Success';
/** @type {?} */
const CANCEL_ORDER_RETURN_REQUEST = '[User] Cancel Order Return Request';
/** @type {?} */
const CANCEL_ORDER_RETURN_REQUEST_FAIL = '[User] Cancel Order Return Request Fail';
/** @type {?} */
const CANCEL_ORDER_RETURN_REQUEST_SUCCESS = '[User] Cancel Order Return Request Success';
/** @type {?} */
const LOAD_ORDER_RETURN_REQUEST_LIST = '[User] Load User Order Return Request List';
/** @type {?} */
const LOAD_ORDER_RETURN_REQUEST_LIST_FAIL = '[User] Load User Order Return Request List Fail';
/** @type {?} */
const LOAD_ORDER_RETURN_REQUEST_LIST_SUCCESS = '[User] Load User Order Return Request List Success';
/** @type {?} */
const CLEAR_ORDER_RETURN_REQUEST = '[User] Clear Order Return Request Details';
/** @type {?} */
const CLEAR_ORDER_RETURN_REQUEST_LIST = '[User] Clear Order Return Request List';
/** @type {?} */
const RESET_CANCEL_RETURN_PROCESS = '[User] Reset Cancel Return Request Process';
class CreateOrderReturnRequest extends LoaderLoadAction {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        super(USER_RETURN_REQUEST_DETAILS);
        this.payload = payload;
        this.type = CREATE_ORDER_RETURN_REQUEST;
    }
}
if (false) {
    /** @type {?} */
    CreateOrderReturnRequest.prototype.type;
    /** @type {?} */
    CreateOrderReturnRequest.prototype.payload;
}
class CreateOrderReturnRequestFail extends LoaderFailAction {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        super(USER_RETURN_REQUEST_DETAILS, payload);
        this.payload = payload;
        this.type = CREATE_ORDER_RETURN_REQUEST_FAIL;
    }
}
if (false) {
    /** @type {?} */
    CreateOrderReturnRequestFail.prototype.type;
    /** @type {?} */
    CreateOrderReturnRequestFail.prototype.payload;
}
class CreateOrderReturnRequestSuccess extends LoaderSuccessAction {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        super(USER_RETURN_REQUEST_DETAILS);
        this.payload = payload;
        this.type = CREATE_ORDER_RETURN_REQUEST_SUCCESS;
    }
}
if (false) {
    /** @type {?} */
    CreateOrderReturnRequestSuccess.prototype.type;
    /** @type {?} */
    CreateOrderReturnRequestSuccess.prototype.payload;
}
class LoadOrderReturnRequest extends LoaderLoadAction {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        super(USER_RETURN_REQUEST_DETAILS);
        this.payload = payload;
        this.type = LOAD_ORDER_RETURN_REQUEST;
    }
}
if (false) {
    /** @type {?} */
    LoadOrderReturnRequest.prototype.type;
    /** @type {?} */
    LoadOrderReturnRequest.prototype.payload;
}
class LoadOrderReturnRequestFail extends LoaderFailAction {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        super(USER_RETURN_REQUEST_DETAILS, payload);
        this.payload = payload;
        this.type = LOAD_ORDER_RETURN_REQUEST_FAIL;
    }
}
if (false) {
    /** @type {?} */
    LoadOrderReturnRequestFail.prototype.type;
    /** @type {?} */
    LoadOrderReturnRequestFail.prototype.payload;
}
class LoadOrderReturnRequestSuccess extends LoaderSuccessAction {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        super(USER_RETURN_REQUEST_DETAILS);
        this.payload = payload;
        this.type = LOAD_ORDER_RETURN_REQUEST_SUCCESS;
    }
}
if (false) {
    /** @type {?} */
    LoadOrderReturnRequestSuccess.prototype.type;
    /** @type {?} */
    LoadOrderReturnRequestSuccess.prototype.payload;
}
class CancelOrderReturnRequest extends EntityLoadAction {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        super(PROCESS_FEATURE, CANCEL_RETURN_PROCESS_ID);
        this.payload = payload;
        this.type = CANCEL_ORDER_RETURN_REQUEST;
    }
}
if (false) {
    /** @type {?} */
    CancelOrderReturnRequest.prototype.type;
    /** @type {?} */
    CancelOrderReturnRequest.prototype.payload;
}
class CancelOrderReturnRequestFail extends EntityFailAction {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        super(PROCESS_FEATURE, CANCEL_RETURN_PROCESS_ID, payload);
        this.payload = payload;
        this.type = CANCEL_ORDER_RETURN_REQUEST_FAIL;
    }
}
if (false) {
    /** @type {?} */
    CancelOrderReturnRequestFail.prototype.type;
    /** @type {?} */
    CancelOrderReturnRequestFail.prototype.payload;
}
class CancelOrderReturnRequestSuccess extends EntitySuccessAction {
    constructor() {
        super(PROCESS_FEATURE, CANCEL_RETURN_PROCESS_ID);
        this.type = CANCEL_ORDER_RETURN_REQUEST_SUCCESS;
    }
}
if (false) {
    /** @type {?} */
    CancelOrderReturnRequestSuccess.prototype.type;
}
class LoadOrderReturnRequestList extends LoaderLoadAction {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        super(USER_RETURN_REQUESTS);
        this.payload = payload;
        this.type = LOAD_ORDER_RETURN_REQUEST_LIST;
    }
}
if (false) {
    /** @type {?} */
    LoadOrderReturnRequestList.prototype.type;
    /** @type {?} */
    LoadOrderReturnRequestList.prototype.payload;
}
class LoadOrderReturnRequestListFail extends LoaderFailAction {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        super(USER_RETURN_REQUESTS, payload);
        this.payload = payload;
        this.type = LOAD_ORDER_RETURN_REQUEST_LIST_FAIL;
    }
}
if (false) {
    /** @type {?} */
    LoadOrderReturnRequestListFail.prototype.type;
    /** @type {?} */
    LoadOrderReturnRequestListFail.prototype.payload;
}
class LoadOrderReturnRequestListSuccess extends LoaderSuccessAction {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        super(USER_RETURN_REQUESTS);
        this.payload = payload;
        this.type = LOAD_ORDER_RETURN_REQUEST_LIST_SUCCESS;
    }
}
if (false) {
    /** @type {?} */
    LoadOrderReturnRequestListSuccess.prototype.type;
    /** @type {?} */
    LoadOrderReturnRequestListSuccess.prototype.payload;
}
class ClearOrderReturnRequest extends LoaderResetAction {
    constructor() {
        super(USER_RETURN_REQUEST_DETAILS);
        this.type = CLEAR_ORDER_RETURN_REQUEST;
    }
}
if (false) {
    /** @type {?} */
    ClearOrderReturnRequest.prototype.type;
}
class ClearOrderReturnRequestList extends LoaderResetAction {
    constructor() {
        super(USER_RETURN_REQUESTS);
        this.type = CLEAR_ORDER_RETURN_REQUEST_LIST;
    }
}
if (false) {
    /** @type {?} */
    ClearOrderReturnRequestList.prototype.type;
}
class ResetCancelReturnProcess extends EntityResetAction {
    constructor() {
        super(PROCESS_FEATURE, CANCEL_RETURN_PROCESS_ID);
        this.type = RESET_CANCEL_RETURN_PROCESS;
    }
}
if (false) {
    /** @type {?} */
    ResetCancelReturnProcess.prototype.type;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

var userGroup_actions = /*#__PURE__*/Object.freeze({
    LOAD_BILLING_COUNTRIES: LOAD_BILLING_COUNTRIES,
    LOAD_BILLING_COUNTRIES_FAIL: LOAD_BILLING_COUNTRIES_FAIL,
    LOAD_BILLING_COUNTRIES_SUCCESS: LOAD_BILLING_COUNTRIES_SUCCESS,
    LoadBillingCountries: LoadBillingCountries,
    LoadBillingCountriesFail: LoadBillingCountriesFail,
    LoadBillingCountriesSuccess: LoadBillingCountriesSuccess,
    LOAD_CONSIGNMENT_TRACKING: LOAD_CONSIGNMENT_TRACKING,
    LOAD_CONSIGNMENT_TRACKING_FAIL: LOAD_CONSIGNMENT_TRACKING_FAIL,
    LOAD_CONSIGNMENT_TRACKING_SUCCESS: LOAD_CONSIGNMENT_TRACKING_SUCCESS,
    CLEAR_CONSIGNMENT_TRACKING: CLEAR_CONSIGNMENT_TRACKING,
    LoadConsignmentTracking: LoadConsignmentTracking,
    LoadConsignmentTrackingFail: LoadConsignmentTrackingFail,
    LoadConsignmentTrackingSuccess: LoadConsignmentTrackingSuccess,
    ClearConsignmentTracking: ClearConsignmentTracking,
    LOAD_DELIVERY_COUNTRIES: LOAD_DELIVERY_COUNTRIES,
    LOAD_DELIVERY_COUNTRIES_FAIL: LOAD_DELIVERY_COUNTRIES_FAIL,
    LOAD_DELIVERY_COUNTRIES_SUCCESS: LOAD_DELIVERY_COUNTRIES_SUCCESS,
    LoadDeliveryCountries: LoadDeliveryCountries,
    LoadDeliveryCountriesFail: LoadDeliveryCountriesFail,
    LoadDeliveryCountriesSuccess: LoadDeliveryCountriesSuccess,
    FORGOT_PASSWORD_EMAIL_REQUEST: FORGOT_PASSWORD_EMAIL_REQUEST,
    FORGOT_PASSWORD_EMAIL_REQUEST_SUCCESS: FORGOT_PASSWORD_EMAIL_REQUEST_SUCCESS,
    FORGOT_PASSWORD_EMAIL_REQUEST_FAIL: FORGOT_PASSWORD_EMAIL_REQUEST_FAIL,
    ForgotPasswordEmailRequest: ForgotPasswordEmailRequest,
    ForgotPasswordEmailRequestFail: ForgotPasswordEmailRequestFail,
    ForgotPasswordEmailRequestSuccess: ForgotPasswordEmailRequestSuccess,
    LOAD_ORDER_DETAILS: LOAD_ORDER_DETAILS,
    LOAD_ORDER_DETAILS_FAIL: LOAD_ORDER_DETAILS_FAIL,
    LOAD_ORDER_DETAILS_SUCCESS: LOAD_ORDER_DETAILS_SUCCESS,
    CLEAR_ORDER_DETAILS: CLEAR_ORDER_DETAILS,
    CANCEL_ORDER: CANCEL_ORDER,
    CANCEL_ORDER_FAIL: CANCEL_ORDER_FAIL,
    CANCEL_ORDER_SUCCESS: CANCEL_ORDER_SUCCESS,
    RESET_CANCEL_ORDER_PROCESS: RESET_CANCEL_ORDER_PROCESS,
    LoadOrderDetails: LoadOrderDetails,
    LoadOrderDetailsFail: LoadOrderDetailsFail,
    LoadOrderDetailsSuccess: LoadOrderDetailsSuccess,
    ClearOrderDetails: ClearOrderDetails,
    CancelOrder: CancelOrder,
    CancelOrderFail: CancelOrderFail,
    CancelOrderSuccess: CancelOrderSuccess,
    ResetCancelOrderProcess: ResetCancelOrderProcess,
    LOAD_USER_PAYMENT_METHODS: LOAD_USER_PAYMENT_METHODS,
    LOAD_USER_PAYMENT_METHODS_FAIL: LOAD_USER_PAYMENT_METHODS_FAIL,
    LOAD_USER_PAYMENT_METHODS_SUCCESS: LOAD_USER_PAYMENT_METHODS_SUCCESS,
    SET_DEFAULT_USER_PAYMENT_METHOD: SET_DEFAULT_USER_PAYMENT_METHOD,
    SET_DEFAULT_USER_PAYMENT_METHOD_FAIL: SET_DEFAULT_USER_PAYMENT_METHOD_FAIL,
    SET_DEFAULT_USER_PAYMENT_METHOD_SUCCESS: SET_DEFAULT_USER_PAYMENT_METHOD_SUCCESS,
    DELETE_USER_PAYMENT_METHOD: DELETE_USER_PAYMENT_METHOD,
    DELETE_USER_PAYMENT_METHOD_FAIL: DELETE_USER_PAYMENT_METHOD_FAIL,
    DELETE_USER_PAYMENT_METHOD_SUCCESS: DELETE_USER_PAYMENT_METHOD_SUCCESS,
    LoadUserPaymentMethods: LoadUserPaymentMethods,
    LoadUserPaymentMethodsFail: LoadUserPaymentMethodsFail,
    LoadUserPaymentMethodsSuccess: LoadUserPaymentMethodsSuccess,
    SetDefaultUserPaymentMethod: SetDefaultUserPaymentMethod,
    SetDefaultUserPaymentMethodFail: SetDefaultUserPaymentMethodFail,
    SetDefaultUserPaymentMethodSuccess: SetDefaultUserPaymentMethodSuccess,
    DeleteUserPaymentMethod: DeleteUserPaymentMethod,
    DeleteUserPaymentMethodFail: DeleteUserPaymentMethodFail,
    DeleteUserPaymentMethodSuccess: DeleteUserPaymentMethodSuccess,
    LOAD_REGIONS: LOAD_REGIONS,
    LOAD_REGIONS_SUCCESS: LOAD_REGIONS_SUCCESS,
    LOAD_REGIONS_FAIL: LOAD_REGIONS_FAIL,
    CLEAR_REGIONS: CLEAR_REGIONS,
    LoadRegions: LoadRegions,
    LoadRegionsFail: LoadRegionsFail,
    LoadRegionsSuccess: LoadRegionsSuccess,
    ClearRegions: ClearRegions,
    RESET_PASSWORD: RESET_PASSWORD,
    RESET_PASSWORD_SUCCESS: RESET_PASSWORD_SUCCESS,
    RESET_PASSWORD_FAIL: RESET_PASSWORD_FAIL,
    ResetPassword: ResetPassword,
    ResetPasswordFail: ResetPasswordFail,
    ResetPasswordSuccess: ResetPasswordSuccess,
    LOAD_TITLES: LOAD_TITLES,
    LOAD_TITLES_FAIL: LOAD_TITLES_FAIL,
    LOAD_TITLES_SUCCESS: LOAD_TITLES_SUCCESS,
    LoadTitles: LoadTitles,
    LoadTitlesFail: LoadTitlesFail,
    LoadTitlesSuccess: LoadTitlesSuccess,
    UPDATE_EMAIL: UPDATE_EMAIL,
    UPDATE_EMAIL_ERROR: UPDATE_EMAIL_ERROR,
    UPDATE_EMAIL_SUCCESS: UPDATE_EMAIL_SUCCESS,
    RESET_EMAIL: RESET_EMAIL,
    UpdateEmailAction: UpdateEmailAction,
    UpdateEmailSuccessAction: UpdateEmailSuccessAction,
    UpdateEmailErrorAction: UpdateEmailErrorAction,
    ResetUpdateEmailAction: ResetUpdateEmailAction,
    UPDATE_PASSWORD: UPDATE_PASSWORD,
    UPDATE_PASSWORD_FAIL: UPDATE_PASSWORD_FAIL,
    UPDATE_PASSWORD_SUCCESS: UPDATE_PASSWORD_SUCCESS,
    UPDATE_PASSWORD_RESET: UPDATE_PASSWORD_RESET,
    UpdatePassword: UpdatePassword,
    UpdatePasswordFail: UpdatePasswordFail,
    UpdatePasswordSuccess: UpdatePasswordSuccess,
    UpdatePasswordReset: UpdatePasswordReset,
    LOAD_USER_ADDRESSES: LOAD_USER_ADDRESSES,
    LOAD_USER_ADDRESSES_FAIL: LOAD_USER_ADDRESSES_FAIL,
    LOAD_USER_ADDRESSES_SUCCESS: LOAD_USER_ADDRESSES_SUCCESS,
    ADD_USER_ADDRESS: ADD_USER_ADDRESS,
    ADD_USER_ADDRESS_FAIL: ADD_USER_ADDRESS_FAIL,
    ADD_USER_ADDRESS_SUCCESS: ADD_USER_ADDRESS_SUCCESS,
    UPDATE_USER_ADDRESS: UPDATE_USER_ADDRESS,
    UPDATE_USER_ADDRESS_FAIL: UPDATE_USER_ADDRESS_FAIL,
    UPDATE_USER_ADDRESS_SUCCESS: UPDATE_USER_ADDRESS_SUCCESS,
    DELETE_USER_ADDRESS: DELETE_USER_ADDRESS,
    DELETE_USER_ADDRESS_FAIL: DELETE_USER_ADDRESS_FAIL,
    DELETE_USER_ADDRESS_SUCCESS: DELETE_USER_ADDRESS_SUCCESS,
    LoadUserAddresses: LoadUserAddresses,
    LoadUserAddressesFail: LoadUserAddressesFail,
    LoadUserAddressesSuccess: LoadUserAddressesSuccess,
    AddUserAddress: AddUserAddress,
    AddUserAddressFail: AddUserAddressFail,
    AddUserAddressSuccess: AddUserAddressSuccess,
    UpdateUserAddress: UpdateUserAddress,
    UpdateUserAddressFail: UpdateUserAddressFail,
    UpdateUserAddressSuccess: UpdateUserAddressSuccess,
    DeleteUserAddress: DeleteUserAddress,
    DeleteUserAddressFail: DeleteUserAddressFail,
    DeleteUserAddressSuccess: DeleteUserAddressSuccess,
    LOAD_USER_CONSENTS: LOAD_USER_CONSENTS,
    LOAD_USER_CONSENTS_SUCCESS: LOAD_USER_CONSENTS_SUCCESS,
    LOAD_USER_CONSENTS_FAIL: LOAD_USER_CONSENTS_FAIL,
    RESET_LOAD_USER_CONSENTS: RESET_LOAD_USER_CONSENTS,
    GIVE_USER_CONSENT: GIVE_USER_CONSENT,
    GIVE_USER_CONSENT_FAIL: GIVE_USER_CONSENT_FAIL,
    GIVE_USER_CONSENT_SUCCESS: GIVE_USER_CONSENT_SUCCESS,
    RESET_GIVE_USER_CONSENT_PROCESS: RESET_GIVE_USER_CONSENT_PROCESS,
    TRANSFER_ANONYMOUS_CONSENT: TRANSFER_ANONYMOUS_CONSENT,
    WITHDRAW_USER_CONSENT: WITHDRAW_USER_CONSENT,
    WITHDRAW_USER_CONSENT_FAIL: WITHDRAW_USER_CONSENT_FAIL,
    WITHDRAW_USER_CONSENT_SUCCESS: WITHDRAW_USER_CONSENT_SUCCESS,
    RESET_WITHDRAW_USER_CONSENT_PROCESS: RESET_WITHDRAW_USER_CONSENT_PROCESS,
    LoadUserConsents: LoadUserConsents,
    LoadUserConsentsFail: LoadUserConsentsFail,
    LoadUserConsentsSuccess: LoadUserConsentsSuccess,
    ResetLoadUserConsents: ResetLoadUserConsents,
    GiveUserConsent: GiveUserConsent,
    GiveUserConsentFail: GiveUserConsentFail,
    GiveUserConsentSuccess: GiveUserConsentSuccess,
    ResetGiveUserConsentProcess: ResetGiveUserConsentProcess,
    TransferAnonymousConsent: TransferAnonymousConsent,
    WithdrawUserConsent: WithdrawUserConsent,
    WithdrawUserConsentFail: WithdrawUserConsentFail,
    WithdrawUserConsentSuccess: WithdrawUserConsentSuccess,
    ResetWithdrawUserConsentProcess: ResetWithdrawUserConsentProcess,
    LOAD_USER_DETAILS: LOAD_USER_DETAILS,
    LOAD_USER_DETAILS_FAIL: LOAD_USER_DETAILS_FAIL,
    LOAD_USER_DETAILS_SUCCESS: LOAD_USER_DETAILS_SUCCESS,
    UPDATE_USER_DETAILS: UPDATE_USER_DETAILS,
    UPDATE_USER_DETAILS_FAIL: UPDATE_USER_DETAILS_FAIL,
    UPDATE_USER_DETAILS_SUCCESS: UPDATE_USER_DETAILS_SUCCESS,
    RESET_USER_DETAILS: RESET_USER_DETAILS,
    LoadUserDetails: LoadUserDetails,
    LoadUserDetailsFail: LoadUserDetailsFail,
    LoadUserDetailsSuccess: LoadUserDetailsSuccess,
    UpdateUserDetails: UpdateUserDetails,
    UpdateUserDetailsFail: UpdateUserDetailsFail,
    UpdateUserDetailsSuccess: UpdateUserDetailsSuccess,
    ResetUpdateUserDetails: ResetUpdateUserDetails,
    CLEAR_USER_MISCS_DATA: CLEAR_USER_MISCS_DATA,
    ClearUserMiscsData: ClearUserMiscsData,
    LOAD_USER_ORDERS: LOAD_USER_ORDERS,
    LOAD_USER_ORDERS_FAIL: LOAD_USER_ORDERS_FAIL,
    LOAD_USER_ORDERS_SUCCESS: LOAD_USER_ORDERS_SUCCESS,
    CLEAR_USER_ORDERS: CLEAR_USER_ORDERS,
    LoadUserOrders: LoadUserOrders,
    LoadUserOrdersFail: LoadUserOrdersFail,
    LoadUserOrdersSuccess: LoadUserOrdersSuccess,
    ClearUserOrders: ClearUserOrders,
    REGISTER_USER: REGISTER_USER,
    REGISTER_USER_FAIL: REGISTER_USER_FAIL,
    REGISTER_USER_SUCCESS: REGISTER_USER_SUCCESS,
    RESET_REGISTER_USER_PROCESS: RESET_REGISTER_USER_PROCESS,
    REGISTER_GUEST: REGISTER_GUEST,
    REGISTER_GUEST_FAIL: REGISTER_GUEST_FAIL,
    REGISTER_GUEST_SUCCESS: REGISTER_GUEST_SUCCESS,
    REMOVE_USER: REMOVE_USER,
    REMOVE_USER_FAIL: REMOVE_USER_FAIL,
    REMOVE_USER_SUCCESS: REMOVE_USER_SUCCESS,
    REMOVE_USER_RESET: REMOVE_USER_RESET,
    RegisterUser: RegisterUser,
    RegisterUserFail: RegisterUserFail,
    RegisterUserSuccess: RegisterUserSuccess,
    ResetRegisterUserProcess: ResetRegisterUserProcess,
    RegisterGuest: RegisterGuest,
    RegisterGuestFail: RegisterGuestFail,
    RegisterGuestSuccess: RegisterGuestSuccess,
    RemoveUser: RemoveUser,
    RemoveUserFail: RemoveUserFail,
    RemoveUserSuccess: RemoveUserSuccess,
    RemoveUserReset: RemoveUserReset,
    LOAD_CUSTOMER_COUPONS: LOAD_CUSTOMER_COUPONS,
    LOAD_CUSTOMER_COUPONS_FAIL: LOAD_CUSTOMER_COUPONS_FAIL,
    LOAD_CUSTOMER_COUPONS_SUCCESS: LOAD_CUSTOMER_COUPONS_SUCCESS,
    RESET_LOAD_CUSTOMER_COUPONS: RESET_LOAD_CUSTOMER_COUPONS,
    SUBSCRIBE_CUSTOMER_COUPON: SUBSCRIBE_CUSTOMER_COUPON,
    SUBSCRIBE_CUSTOMER_COUPON_FAIL: SUBSCRIBE_CUSTOMER_COUPON_FAIL,
    SUBSCRIBE_CUSTOMER_COUPON_SUCCESS: SUBSCRIBE_CUSTOMER_COUPON_SUCCESS,
    RESET_SUBSCRIBE_CUSTOMER_COUPON_PROCESS: RESET_SUBSCRIBE_CUSTOMER_COUPON_PROCESS,
    UNSUBSCRIBE_CUSTOMER_COUPON: UNSUBSCRIBE_CUSTOMER_COUPON,
    UNSUBSCRIBE_CUSTOMER_COUPON_FAIL: UNSUBSCRIBE_CUSTOMER_COUPON_FAIL,
    UNSUBSCRIBE_CUSTOMER_COUPON_SUCCESS: UNSUBSCRIBE_CUSTOMER_COUPON_SUCCESS,
    RESET_UNSUBSCRIBE_CUSTOMER_COUPON_PROCESS: RESET_UNSUBSCRIBE_CUSTOMER_COUPON_PROCESS,
    CLAIM_CUSTOMER_COUPON: CLAIM_CUSTOMER_COUPON,
    CLAIM_CUSTOMER_COUPON_FAIL: CLAIM_CUSTOMER_COUPON_FAIL,
    CLAIM_CUSTOMER_COUPON_SUCCESS: CLAIM_CUSTOMER_COUPON_SUCCESS,
    LoadCustomerCoupons: LoadCustomerCoupons,
    LoadCustomerCouponsFail: LoadCustomerCouponsFail,
    LoadCustomerCouponsSuccess: LoadCustomerCouponsSuccess,
    ResetLoadCustomerCoupons: ResetLoadCustomerCoupons,
    SubscribeCustomerCoupon: SubscribeCustomerCoupon,
    SubscribeCustomerCouponFail: SubscribeCustomerCouponFail,
    SubscribeCustomerCouponSuccess: SubscribeCustomerCouponSuccess,
    ResetSubscribeCustomerCouponProcess: ResetSubscribeCustomerCouponProcess,
    UnsubscribeCustomerCoupon: UnsubscribeCustomerCoupon,
    UnsubscribeCustomerCouponFail: UnsubscribeCustomerCouponFail,
    UnsubscribeCustomerCouponSuccess: UnsubscribeCustomerCouponSuccess,
    ResetUnsubscribeCustomerCouponProcess: ResetUnsubscribeCustomerCouponProcess,
    ClaimCustomerCoupon: ClaimCustomerCoupon,
    ClaimCustomerCouponFail: ClaimCustomerCouponFail,
    ClaimCustomerCouponSuccess: ClaimCustomerCouponSuccess,
    LOAD_NOTIFICATION_PREFERENCES: LOAD_NOTIFICATION_PREFERENCES,
    LOAD_NOTIFICATION_PREFERENCES_FAIL: LOAD_NOTIFICATION_PREFERENCES_FAIL,
    LOAD_NOTIFICATION_PREFERENCES_SUCCESS: LOAD_NOTIFICATION_PREFERENCES_SUCCESS,
    UPDATE_NOTIFICATION_PREFERENCES: UPDATE_NOTIFICATION_PREFERENCES,
    UPDATE_NOTIFICATION_PREFERENCES_FAIL: UPDATE_NOTIFICATION_PREFERENCES_FAIL,
    UPDATE_NOTIFICATION_PREFERENCES_SUCCESS: UPDATE_NOTIFICATION_PREFERENCES_SUCCESS,
    RESET_NOTIFICATION_PREFERENCES: RESET_NOTIFICATION_PREFERENCES,
    CLEAR_NOTIFICATION_PREFERENCES: CLEAR_NOTIFICATION_PREFERENCES,
    LoadNotificationPreferences: LoadNotificationPreferences,
    LoadNotificationPreferencesFail: LoadNotificationPreferencesFail,
    LoadNotificationPreferencesSuccess: LoadNotificationPreferencesSuccess,
    UpdateNotificationPreferences: UpdateNotificationPreferences,
    UpdateNotificationPreferencesFail: UpdateNotificationPreferencesFail,
    UpdateNotificationPreferencesSuccess: UpdateNotificationPreferencesSuccess,
    ResetNotificationPreferences: ResetNotificationPreferences,
    ClearNotificationPreferences: ClearNotificationPreferences,
    LOAD_PRODUCT_INTERESTS: LOAD_PRODUCT_INTERESTS,
    LOAD_PRODUCT_INTERESTS_FAIL: LOAD_PRODUCT_INTERESTS_FAIL,
    LOAD_PRODUCT_INTERESTS_SUCCESS: LOAD_PRODUCT_INTERESTS_SUCCESS,
    REMOVE_PRODUCT_INTEREST: REMOVE_PRODUCT_INTEREST,
    REMOVE_PRODUCT_INTEREST_SUCCESS: REMOVE_PRODUCT_INTEREST_SUCCESS,
    REMOVE_PRODUCT_INTEREST_FAIL: REMOVE_PRODUCT_INTEREST_FAIL,
    ADD_PRODUCT_INTEREST: ADD_PRODUCT_INTEREST,
    ADD_PRODUCT_INTEREST_FAIL: ADD_PRODUCT_INTEREST_FAIL,
    ADD_PRODUCT_INTEREST_SUCCESS: ADD_PRODUCT_INTEREST_SUCCESS,
    ADD_PRODUCT_INTEREST_RESET: ADD_PRODUCT_INTEREST_RESET,
    REMOVE_PRODUCT_INTEREST_RESET: REMOVE_PRODUCT_INTEREST_RESET,
    CLEAR_PRODUCT_INTERESTS: CLEAR_PRODUCT_INTERESTS,
    LoadProductInterests: LoadProductInterests,
    LoadProductInterestsFail: LoadProductInterestsFail,
    LoadProductInterestsSuccess: LoadProductInterestsSuccess,
    RemoveProductInterest: RemoveProductInterest,
    RemoveProductInterestSuccess: RemoveProductInterestSuccess,
    RemoveProductInterestFail: RemoveProductInterestFail,
    AddProductInterest: AddProductInterest,
    AddProductInterestSuccess: AddProductInterestSuccess,
    AddProductInterestFail: AddProductInterestFail,
    ResetAddInterestState: ResetAddInterestState,
    ResetRemoveInterestState: ResetRemoveInterestState,
    ClearProductInterests: ClearProductInterests,
    CREATE_ORDER_RETURN_REQUEST: CREATE_ORDER_RETURN_REQUEST,
    CREATE_ORDER_RETURN_REQUEST_FAIL: CREATE_ORDER_RETURN_REQUEST_FAIL,
    CREATE_ORDER_RETURN_REQUEST_SUCCESS: CREATE_ORDER_RETURN_REQUEST_SUCCESS,
    LOAD_ORDER_RETURN_REQUEST: LOAD_ORDER_RETURN_REQUEST,
    LOAD_ORDER_RETURN_REQUEST_FAIL: LOAD_ORDER_RETURN_REQUEST_FAIL,
    LOAD_ORDER_RETURN_REQUEST_SUCCESS: LOAD_ORDER_RETURN_REQUEST_SUCCESS,
    CANCEL_ORDER_RETURN_REQUEST: CANCEL_ORDER_RETURN_REQUEST,
    CANCEL_ORDER_RETURN_REQUEST_FAIL: CANCEL_ORDER_RETURN_REQUEST_FAIL,
    CANCEL_ORDER_RETURN_REQUEST_SUCCESS: CANCEL_ORDER_RETURN_REQUEST_SUCCESS,
    LOAD_ORDER_RETURN_REQUEST_LIST: LOAD_ORDER_RETURN_REQUEST_LIST,
    LOAD_ORDER_RETURN_REQUEST_LIST_FAIL: LOAD_ORDER_RETURN_REQUEST_LIST_FAIL,
    LOAD_ORDER_RETURN_REQUEST_LIST_SUCCESS: LOAD_ORDER_RETURN_REQUEST_LIST_SUCCESS,
    CLEAR_ORDER_RETURN_REQUEST: CLEAR_ORDER_RETURN_REQUEST,
    CLEAR_ORDER_RETURN_REQUEST_LIST: CLEAR_ORDER_RETURN_REQUEST_LIST,
    RESET_CANCEL_RETURN_PROCESS: RESET_CANCEL_RETURN_PROCESS,
    CreateOrderReturnRequest: CreateOrderReturnRequest,
    CreateOrderReturnRequestFail: CreateOrderReturnRequestFail,
    CreateOrderReturnRequestSuccess: CreateOrderReturnRequestSuccess,
    LoadOrderReturnRequest: LoadOrderReturnRequest,
    LoadOrderReturnRequestFail: LoadOrderReturnRequestFail,
    LoadOrderReturnRequestSuccess: LoadOrderReturnRequestSuccess,
    CancelOrderReturnRequest: CancelOrderReturnRequest,
    CancelOrderReturnRequestFail: CancelOrderReturnRequestFail,
    CancelOrderReturnRequestSuccess: CancelOrderReturnRequestSuccess,
    LoadOrderReturnRequestList: LoadOrderReturnRequestList,
    LoadOrderReturnRequestListFail: LoadOrderReturnRequestListFail,
    LoadOrderReturnRequestListSuccess: LoadOrderReturnRequestListSuccess,
    ClearOrderReturnRequest: ClearOrderReturnRequest,
    ClearOrderReturnRequestList: ClearOrderReturnRequestList,
    ResetCancelReturnProcess: ResetCancelReturnProcess
});

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const getUserState = createFeatureSelector(USER_FEATURE);

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
const ɵ0$b = /**
 * @param {?} state
 * @return {?}
 */
(state) => state.billingCountries;
/** @type {?} */
const getBillingCountriesState = createSelector(getUserState, (ɵ0$b));
const ɵ1$7 = /**
 * @param {?} state
 * @return {?}
 */
(state) => state.entities;
/** @type {?} */
const getBillingCountriesEntites = createSelector(getBillingCountriesState, (ɵ1$7));
const ɵ2$3 = /**
 * @param {?} entites
 * @return {?}
 */
entites => Object.keys(entites).map((/**
 * @param {?} isocode
 * @return {?}
 */
isocode => entites[isocode]));
/** @type {?} */
const getAllBillingCountries = createSelector(getBillingCountriesEntites, (ɵ2$3));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
const ɵ0$c = /**
 * @param {?} state
 * @return {?}
 */
(state) => state.consignmentTracking;
/** @type {?} */
const getConsignmentTrackingState = createSelector(getUserState, (ɵ0$c));
const ɵ1$8 = /**
 * @param {?} state
 * @return {?}
 */
(state) => state.tracking;
/** @type {?} */
const getConsignmentTracking = createSelector(getConsignmentTrackingState, (ɵ1$8));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
const ɵ0$d = /**
 * @param {?} state
 * @return {?}
 */
(state) => state.countries;
/** @type {?} */
const getDeliveryCountriesState = createSelector(getUserState, (ɵ0$d));
const ɵ1$9 = /**
 * @param {?} state
 * @return {?}
 */
(state) => state.entities;
/** @type {?} */
const getDeliveryCountriesEntites = createSelector(getDeliveryCountriesState, (ɵ1$9));
const ɵ2$4 = /**
 * @param {?} entites
 * @return {?}
 */
entites => Object.keys(entites).map((/**
 * @param {?} isocode
 * @return {?}
 */
isocode => entites[isocode]));
/** @type {?} */
const getAllDeliveryCountries = createSelector(getDeliveryCountriesEntites, (ɵ2$4));
/** @type {?} */
const countrySelectorFactory = (/**
 * @param {?} isocode
 * @return {?}
 */
(isocode) => createSelector(getDeliveryCountriesEntites, (/**
 * @param {?} entities
 * @return {?}
 */
entities => (Object.keys(entities).length !== 0 ? entities[isocode] : null))));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
const ɵ0$e = /**
 * @param {?} state
 * @return {?}
 */
(state) => state.order;
/** @type {?} */
const getOrderState = createSelector(getUserState, (ɵ0$e));
const ɵ1$a = /**
 * @param {?} state
 * @return {?}
 */
(state) => loaderValueSelector(state);
/** @type {?} */
const getOrderDetails = createSelector(getOrderState, (ɵ1$a));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
const ɵ0$f = /**
 * @param {?} state
 * @return {?}
 */
(state) => state.orderReturn;
/** @type {?} */
const getOrderReturnRequestState = createSelector(getUserState, (ɵ0$f));
const ɵ1$b = /**
 * @param {?} state
 * @return {?}
 */
(state) => loaderValueSelector(state);
/** @type {?} */
const getOrderReturnRequest = createSelector(getOrderReturnRequestState, (ɵ1$b));
const ɵ2$5 = /**
 * @param {?} state
 * @return {?}
 */
(state) => loaderLoadingSelector(state);
/** @type {?} */
const getOrderReturnRequestLoading = createSelector(getOrderReturnRequestState, (ɵ2$5));
const ɵ3$3 = /**
 * @param {?} state
 * @return {?}
 */
(state) => loaderSuccessSelector(state) &&
    !loaderLoadingSelector(state);
/** @type {?} */
const getOrderReturnRequestSuccess = createSelector(getOrderReturnRequestState, (ɵ3$3));
const ɵ4 = /**
 * @param {?} state
 * @return {?}
 */
(state) => state.orderReturnList;
/** @type {?} */
const getOrderReturnRequestListState = createSelector(getUserState, (ɵ4));
const ɵ5 = /**
 * @param {?} state
 * @return {?}
 */
(state) => loaderValueSelector(state);
/** @type {?} */
const getOrderReturnRequestList = createSelector(getOrderReturnRequestListState, (ɵ5));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
const ɵ0$g = /**
 * @param {?} state
 * @return {?}
 */
(state) => state.payments;
/** @type {?} */
const getPaymentMethodsState = createSelector(getUserState, (ɵ0$g));
const ɵ1$c = /**
 * @param {?} state
 * @return {?}
 */
(state) => loaderValueSelector(state);
/** @type {?} */
const getPaymentMethods = createSelector(getPaymentMethodsState, (ɵ1$c));
const ɵ2$6 = /**
 * @param {?} state
 * @return {?}
 */
(state) => loaderLoadingSelector(state);
/** @type {?} */
const getPaymentMethodsLoading = createSelector(getPaymentMethodsState, (ɵ2$6));
const ɵ3$4 = /**
 * @param {?} state
 * @return {?}
 */
(state) => loaderSuccessSelector(state) &&
    !loaderLoadingSelector(state);
/** @type {?} */
const getPaymentMethodsLoadedSuccess = createSelector(getPaymentMethodsState, (ɵ3$4));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
const ɵ0$h = /**
 * @param {?} state
 * @return {?}
 */
(state) => state.regions;
/** @type {?} */
const getRegionsLoaderState = createSelector(getUserState, (ɵ0$h));
const ɵ1$d = /**
 * @param {?} state
 * @return {?}
 */
(state) => {
    return loaderValueSelector(state).entities;
};
/** @type {?} */
const getAllRegions = createSelector(getRegionsLoaderState, (ɵ1$d));
const ɵ2$7 = /**
 * @param {?} state
 * @return {?}
 */
(state) => ({
    loaded: loaderSuccessSelector(state),
    loading: loaderLoadingSelector(state),
    regions: loaderValueSelector(state).entities,
    country: loaderValueSelector(state).country,
});
/** @type {?} */
const getRegionsDataAndLoading = createSelector(getRegionsLoaderState, (ɵ2$7));
const ɵ3$5 = /**
 * @param {?} state
 * @return {?}
 */
(state) => loaderValueSelector(state).country;
/** @type {?} */
const getRegionsCountry = createSelector(getRegionsLoaderState, (ɵ3$5));
const ɵ4$1 = /**
 * @param {?} state
 * @return {?}
 */
(state) => loaderLoadingSelector(state);
/** @type {?} */
const getRegionsLoading = createSelector(getRegionsLoaderState, (ɵ4$1));
const ɵ5$1 = /**
 * @param {?} state
 * @return {?}
 */
(state) => loaderSuccessSelector(state);
/** @type {?} */
const getRegionsLoaded = createSelector(getRegionsLoaderState, (ɵ5$1));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
const ɵ0$i = /**
 * @param {?} state
 * @return {?}
 */
(state) => state.resetPassword;
/** @type {?} */
const getResetPassword = createSelector(getUserState, (ɵ0$i));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
const ɵ0$j = /**
 * @param {?} state
 * @return {?}
 */
(state) => state.titles;
/** @type {?} */
const getTitlesState = createSelector(getUserState, (ɵ0$j));
const ɵ1$e = /**
 * @param {?} state
 * @return {?}
 */
(state) => state.entities;
/** @type {?} */
const getTitlesEntites = createSelector(getTitlesState, (ɵ1$e));
const ɵ2$8 = /**
 * @param {?} entites
 * @return {?}
 */
entites => Object.keys(entites).map((/**
 * @param {?} code
 * @return {?}
 */
code => entites[code]));
/** @type {?} */
const getAllTitles = createSelector(getTitlesEntites, (ɵ2$8));
/** @type {?} */
const titleSelectorFactory = (/**
 * @param {?} code
 * @return {?}
 */
(code) => createSelector(getTitlesEntites, (/**
 * @param {?} entities
 * @return {?}
 */
entities => (Object.keys(entities).length !== 0 ? entities[code] : null))));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
const ɵ0$k = /**
 * @param {?} state
 * @return {?}
 */
(state) => state.addresses;
/** @type {?} */
const getAddressesLoaderState = createSelector(getUserState, (ɵ0$k));
const ɵ1$f = /**
 * @param {?} state
 * @return {?}
 */
(state) => loaderValueSelector(state);
/** @type {?} */
const getAddresses = createSelector(getAddressesLoaderState, (ɵ1$f));
const ɵ2$9 = /**
 * @param {?} state
 * @return {?}
 */
(state) => loaderLoadingSelector(state);
/** @type {?} */
const getAddressesLoading = createSelector(getAddressesLoaderState, (ɵ2$9));
const ɵ3$6 = /**
 * @param {?} state
 * @return {?}
 */
(state) => loaderSuccessSelector(state) &&
    !loaderLoadingSelector(state);
/** @type {?} */
const getAddressesLoadedSuccess = createSelector(getAddressesLoaderState, (ɵ3$6));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
const ɵ0$l = /**
 * @param {?} state
 * @return {?}
 */
(state) => state.consents;
/** @type {?} */
const getConsentsState = createSelector(getUserState, (ɵ0$l));
/** @type {?} */
const getConsentsValue = createSelector(getConsentsState, loaderValueSelector);
/** @type {?} */
const getConsentByTemplateId = (/**
 * @param {?} templateId
 * @return {?}
 */
(templateId) => createSelector(getConsentsValue, (/**
 * @param {?} templates
 * @return {?}
 */
templates => templates.find((/**
 * @param {?} template
 * @return {?}
 */
template => template.id === templateId)))));
/** @type {?} */
const getConsentsLoading = createSelector(getConsentsState, loaderLoadingSelector);
/** @type {?} */
const getConsentsSuccess = createSelector(getConsentsState, loaderSuccessSelector);
/** @type {?} */
const getConsentsError = createSelector(getConsentsState, loaderErrorSelector);

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
const ɵ0$m = /**
 * @param {?} state
 * @return {?}
 */
(state) => state.account;
/** @type {?} */
const getDetailsState = createSelector(getUserState, (ɵ0$m));
const ɵ1$g = /**
 * @param {?} state
 * @return {?}
 */
(state) => state.details;
/** @type {?} */
const getDetails = createSelector(getDetailsState, (ɵ1$g));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
const ɵ0$n = /**
 * @param {?} state
 * @return {?}
 */
(state) => state.orders;
/** @type {?} */
const getOrdersState = createSelector(getUserState, (ɵ0$n));
const ɵ1$h = /**
 * @param {?} state
 * @return {?}
 */
(state) => loaderSuccessSelector(state);
/** @type {?} */
const getOrdersLoaded = createSelector(getOrdersState, (ɵ1$h));
const ɵ2$a = /**
 * @param {?} state
 * @return {?}
 */
(state) => loaderValueSelector(state);
/** @type {?} */
const getOrders = createSelector(getOrdersState, (ɵ2$a));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
const ɵ0$o = /**
 * @param {?} state
 * @return {?}
 */
(state) => state.customerCoupons;
/** @type {?} */
const getCustomerCouponsState = createSelector(getUserState, (ɵ0$o));
const ɵ1$i = /**
 * @param {?} state
 * @return {?}
 */
(state) => loaderSuccessSelector(state);
/** @type {?} */
const getCustomerCouponsLoaded = createSelector(getCustomerCouponsState, (ɵ1$i));
const ɵ2$b = /**
 * @param {?} state
 * @return {?}
 */
(state) => loaderLoadingSelector(state);
/** @type {?} */
const getCustomerCouponsLoading = createSelector(getCustomerCouponsState, (ɵ2$b));
const ɵ3$7 = /**
 * @param {?} state
 * @return {?}
 */
(state) => loaderValueSelector(state);
/** @type {?} */
const getCustomerCoupons = createSelector(getCustomerCouponsState, (ɵ3$7));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
const ɵ0$p = /**
 * @param {?} state
 * @return {?}
 */
(state) => state.notificationPreferences;
/** @type {?} */
const getPreferencesLoaderState = createSelector(getUserState, (ɵ0$p));
const ɵ1$j = /**
 * @param {?} state
 * @return {?}
 */
(state) => loaderValueSelector(state);
/** @type {?} */
const getPreferences = createSelector(getPreferencesLoaderState, (ɵ1$j));
const ɵ2$c = /**
 * @param {?} state
 * @return {?}
 */
(state) => loaderValueSelector(state).filter((/**
 * @param {?} p
 * @return {?}
 */
p => p.enabled));
/** @type {?} */
const getEnabledPreferences = createSelector(getPreferencesLoaderState, (ɵ2$c));
const ɵ3$8 = /**
 * @param {?} state
 * @return {?}
 */
(state) => loaderLoadingSelector(state);
/** @type {?} */
const getPreferencesLoading = createSelector(getPreferencesLoaderState, (ɵ3$8));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
const ɵ0$q = /**
 * @param {?} state
 * @return {?}
 */
(state) => state.productInterests;
/** @type {?} */
const getInterestsState = createSelector(getUserState, (ɵ0$q));
const ɵ1$k = /**
 * @param {?} state
 * @return {?}
 */
(state) => loaderValueSelector(state);
/** @type {?} */
const getInterests = createSelector(getInterestsState, (ɵ1$k));
const ɵ2$d = /**
 * @param {?} state
 * @return {?}
 */
(state) => loaderLoadingSelector(state);
/** @type {?} */
const getInterestsLoading = createSelector(getInterestsState, (ɵ2$d));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

var usersGroup_selectors = /*#__PURE__*/Object.freeze({
    getBillingCountriesState: getBillingCountriesState,
    getBillingCountriesEntites: getBillingCountriesEntites,
    getAllBillingCountries: getAllBillingCountries,
    getConsignmentTrackingState: getConsignmentTrackingState,
    getConsignmentTracking: getConsignmentTracking,
    getDeliveryCountriesState: getDeliveryCountriesState,
    getDeliveryCountriesEntites: getDeliveryCountriesEntites,
    getAllDeliveryCountries: getAllDeliveryCountries,
    countrySelectorFactory: countrySelectorFactory,
    getUserState: getUserState,
    getOrderState: getOrderState,
    getOrderDetails: getOrderDetails,
    getOrderReturnRequestState: getOrderReturnRequestState,
    getOrderReturnRequest: getOrderReturnRequest,
    getOrderReturnRequestLoading: getOrderReturnRequestLoading,
    getOrderReturnRequestSuccess: getOrderReturnRequestSuccess,
    getOrderReturnRequestListState: getOrderReturnRequestListState,
    getOrderReturnRequestList: getOrderReturnRequestList,
    getPaymentMethodsState: getPaymentMethodsState,
    getPaymentMethods: getPaymentMethods,
    getPaymentMethodsLoading: getPaymentMethodsLoading,
    getPaymentMethodsLoadedSuccess: getPaymentMethodsLoadedSuccess,
    getRegionsLoaderState: getRegionsLoaderState,
    getAllRegions: getAllRegions,
    getRegionsDataAndLoading: getRegionsDataAndLoading,
    getRegionsCountry: getRegionsCountry,
    getRegionsLoading: getRegionsLoading,
    getRegionsLoaded: getRegionsLoaded,
    getResetPassword: getResetPassword,
    getTitlesState: getTitlesState,
    getTitlesEntites: getTitlesEntites,
    getAllTitles: getAllTitles,
    titleSelectorFactory: titleSelectorFactory,
    getAddressesLoaderState: getAddressesLoaderState,
    getAddresses: getAddresses,
    getAddressesLoading: getAddressesLoading,
    getAddressesLoadedSuccess: getAddressesLoadedSuccess,
    getConsentsState: getConsentsState,
    getConsentsValue: getConsentsValue,
    getConsentByTemplateId: getConsentByTemplateId,
    getConsentsLoading: getConsentsLoading,
    getConsentsSuccess: getConsentsSuccess,
    getConsentsError: getConsentsError,
    getDetailsState: getDetailsState,
    getDetails: getDetails,
    getOrdersState: getOrdersState,
    getOrdersLoaded: getOrdersLoaded,
    getOrders: getOrders,
    getCustomerCouponsState: getCustomerCouponsState,
    getCustomerCouponsLoaded: getCustomerCouponsLoaded,
    getCustomerCouponsLoading: getCustomerCouponsLoading,
    getCustomerCoupons: getCustomerCoupons,
    getPreferencesLoaderState: getPreferencesLoaderState,
    getPreferences: getPreferences,
    getEnabledPreferences: getEnabledPreferences,
    getPreferencesLoading: getPreferencesLoading,
    getInterestsState: getInterestsState,
    getInterests: getInterests,
    getInterestsLoading: getInterestsLoading
});

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class UserConsentService {
    /**
     * @param {?} store
     * @param {?=} authService
     */
    constructor(store, authService) {
        this.store = store;
        this.authService = authService;
    }
    /**
     * Retrieves all consents.
     * @return {?}
     */
    loadConsents() {
        this.withUserId((/**
         * @param {?} userId
         * @return {?}
         */
        userId => this.store.dispatch(new LoadUserConsents(userId))));
    }
    /**
     * Returns all consent templates. If `loadIfMissing` parameter is set to `true`, the method triggers the load if consent templates.
     * @param {?=} loadIfMissing is set to `true`, the method will load templates if those are not already present. The default value is `false`.
     * @return {?}
     */
    getConsents(loadIfMissing = false) {
        return iif((/**
         * @return {?}
         */
        () => loadIfMissing), this.store.pipe(select(getConsentsValue), withLatestFrom(this.getConsentsResultLoading(), this.getConsentsResultSuccess()), filter((/**
         * @param {?} __0
         * @return {?}
         */
        ([_templates, loading, _success]) => !loading)), tap((/**
         * @param {?} __0
         * @return {?}
         */
        ([templates, _loading, success]) => {
            if (!templates || templates.length === 0) {
                // avoid infite loop - if we've already attempted to load templates and we got an empty array as the response
                if (!success) {
                    this.loadConsents();
                }
            }
        })), filter((/**
         * @param {?} __0
         * @return {?}
         */
        ([templates, _loading]) => Boolean(templates))), map((/**
         * @param {?} __0
         * @return {?}
         */
        ([templates, _loading]) => templates))), this.store.pipe(select(getConsentsValue)));
    }
    /**
     * Returns the consents loading flag
     * @return {?}
     */
    getConsentsResultLoading() {
        return this.store.pipe(select(getConsentsLoading));
    }
    /**
     * Returns the consents success flag
     * @return {?}
     */
    getConsentsResultSuccess() {
        return this.store.pipe(select(getConsentsSuccess));
    }
    /**
     * Returns the consents error flag
     * @return {?}
     */
    getConsentsResultError() {
        return this.store.pipe(select(getConsentsError));
    }
    /**
     * Resets the processing state for consent retrieval
     * @return {?}
     */
    resetConsentsProcessState() {
        this.store.dispatch(new ResetLoadUserConsents());
    }
    /**
     * Returns the registered consent for the given template ID.
     *
     * As a side-effect, the method will call `getConsents(true)` to load the templates if those are not present.
     *
     * @param {?} templateId a template ID by which to filter the registered templates.
     * @return {?}
     */
    getConsent(templateId) {
        return this.authService.isUserLoggedIn().pipe(filter(Boolean), tap((/**
         * @param {?} _
         * @return {?}
         */
        _ => this.getConsents(true))), switchMap((/**
         * @param {?} _
         * @return {?}
         */
        _ => this.store.pipe(select(getConsentByTemplateId(templateId))))), filter((/**
         * @param {?} template
         * @return {?}
         */
        template => Boolean(template))), map((/**
         * @param {?} template
         * @return {?}
         */
        template => template.currentConsent)));
    }
    /**
     * Returns `true` if the consent is truthy and if `consentWithdrawnDate` doesn't exist.
     * Otherwise, `false` is returned.
     *
     * @param {?} consent to check
     * @return {?}
     */
    isConsentGiven(consent) {
        return (Boolean(consent) &&
            Boolean(consent.consentGivenDate) &&
            !Boolean(consent.consentWithdrawnDate));
    }
    /**
     * Returns `true` if the consent is either falsy or if `consentWithdrawnDate` is present.
     * Otherwise, `false` is returned.
     *
     * @param {?} consent to check
     * @return {?}
     */
    isConsentWithdrawn(consent) {
        if (Boolean(consent)) {
            return Boolean(consent.consentWithdrawnDate);
        }
        return true;
    }
    /**
     * Give consent for specified consent template ID and version.
     * @param {?} consentTemplateId a template ID for which to give a consent
     * @param {?} consentTemplateVersion a template version for which to give a consent
     * @return {?}
     */
    giveConsent(consentTemplateId, consentTemplateVersion) {
        this.withUserId((/**
         * @param {?} userId
         * @return {?}
         */
        userId => this.store.dispatch(new GiveUserConsent({
            userId,
            consentTemplateId,
            consentTemplateVersion,
        }))));
    }
    /**
     * Returns the give consent process loading flag
     * @return {?}
     */
    getGiveConsentResultLoading() {
        return this.store.pipe(select(getProcessLoadingFactory(GIVE_CONSENT_PROCESS_ID)));
    }
    /**
     * Returns the give consent process success flag
     * @return {?}
     */
    getGiveConsentResultSuccess() {
        return this.store.pipe(select(getProcessSuccessFactory(GIVE_CONSENT_PROCESS_ID)));
    }
    /**
     * Returns the give consent process error flag
     * @return {?}
     */
    getGiveConsentResultError() {
        return this.store.pipe(select(getProcessErrorFactory(GIVE_CONSENT_PROCESS_ID)));
    }
    /**
     * Resents the give consent process flags
     * @return {?}
     */
    resetGiveConsentProcessState() {
        return this.store.dispatch(new ResetGiveUserConsentProcess());
    }
    /**
     * Withdraw consent for the given `consentCode`
     * @param {?} consentCode for which to withdraw the consent
     * @return {?}
     */
    withdrawConsent(consentCode) {
        this.withUserId((/**
         * @param {?} userId
         * @return {?}
         */
        userId => this.store.dispatch(new WithdrawUserConsent({
            userId,
            consentCode,
        }))));
    }
    /**
     * Returns the withdraw consent process loading flag
     * @return {?}
     */
    getWithdrawConsentResultLoading() {
        return this.store.pipe(select(getProcessLoadingFactory(WITHDRAW_CONSENT_PROCESS_ID)));
    }
    /**
     * Returns the withdraw consent process success flag
     * @return {?}
     */
    getWithdrawConsentResultSuccess() {
        return this.store.pipe(select(getProcessSuccessFactory(WITHDRAW_CONSENT_PROCESS_ID)));
    }
    /**
     * Returns the withdraw consent process error flag
     * @return {?}
     */
    getWithdrawConsentResultError() {
        return this.store.pipe(select(getProcessErrorFactory(WITHDRAW_CONSENT_PROCESS_ID)));
    }
    /**
     * Resets the process flags for withdraw consent
     * @return {?}
     */
    resetWithdrawConsentProcessState() {
        return this.store.dispatch(new ResetWithdrawUserConsentProcess());
    }
    /**
     * Filters the provided `templateList`' templates by hiding the template IDs specified in `hideTemplateIds`.
     * If the `hideTemplateIds` is empty, the provided `templateList` is returned.
     *
     * @param {?} templateList a list of consent templates to filter
     * @param {?=} hideTemplateIds template IDs to hide
     * @return {?}
     */
    filterConsentTemplates(templateList, hideTemplateIds = []) {
        if (hideTemplateIds.length === 0) {
            return templateList;
        }
        /** @type {?} */
        const updatedTemplateList = [];
        for (const template of templateList) {
            /** @type {?} */
            const show = !hideTemplateIds.includes(template.id);
            if (show) {
                updatedTemplateList.push(template);
            }
        }
        return updatedTemplateList;
    }
    /**
     * Utility method to distinquish pre / post 1.3.0 in a convenient way.
     *
     * @private
     * @param {?} callback
     * @return {?}
     */
    withUserId(callback) {
        if (this.authService) {
            this.authService
                .getOccUserId()
                .pipe(take(1))
                .subscribe((/**
             * @param {?} userId
             * @return {?}
             */
            userId => callback(userId)));
        }
        else {
            // TODO(issue:#5628) Deprecated since 1.3.0
            callback(OCC_USER_ID_CURRENT);
        }
    }
}
UserConsentService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root',
            },] }
];
/** @nocollapse */
UserConsentService.ctorParameters = () => [
    { type: Store },
    { type: AuthService }
];
/** @nocollapse */ UserConsentService.ngInjectableDef = ɵɵdefineInjectable({ factory: function UserConsentService_Factory() { return new UserConsentService(ɵɵinject(Store), ɵɵinject(AuthService)); }, token: UserConsentService, providedIn: "root" });
if (false) {
    /**
     * @type {?}
     * @protected
     */
    UserConsentService.prototype.store;
    /**
     * @type {?}
     * @protected
     */
    UserConsentService.prototype.authService;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class AnonymousConsentTemplatesConnector {
    /**
     * @param {?} adapter
     */
    constructor(adapter) {
        this.adapter = adapter;
    }
    /**
     * @return {?}
     */
    loadAnonymousConsentTemplates() {
        return this.adapter.loadAnonymousConsentTemplates();
    }
}
AnonymousConsentTemplatesConnector.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root',
            },] }
];
/** @nocollapse */
AnonymousConsentTemplatesConnector.ctorParameters = () => [
    { type: AnonymousConsentTemplatesAdapter }
];
/** @nocollapse */ AnonymousConsentTemplatesConnector.ngInjectableDef = ɵɵdefineInjectable({ factory: function AnonymousConsentTemplatesConnector_Factory() { return new AnonymousConsentTemplatesConnector(ɵɵinject(AnonymousConsentTemplatesAdapter)); }, token: AnonymousConsentTemplatesConnector, providedIn: "root" });
if (false) {
    /**
     * @type {?}
     * @protected
     */
    AnonymousConsentTemplatesConnector.prototype.adapter;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class AnonymousConsentsEffects {
    /**
     * @param {?} actions$
     * @param {?} anonymousConsentTemplatesConnector
     * @param {?} authService
     * @param {?} anonymousConsentsConfig
     * @param {?} anonymousConsentService
     * @param {?} userConsentService
     */
    constructor(actions$, anonymousConsentTemplatesConnector, authService, anonymousConsentsConfig, anonymousConsentService, userConsentService) {
        this.actions$ = actions$;
        this.anonymousConsentTemplatesConnector = anonymousConsentTemplatesConnector;
        this.authService = authService;
        this.anonymousConsentsConfig = anonymousConsentsConfig;
        this.anonymousConsentService = anonymousConsentService;
        this.userConsentService = userConsentService;
        this.loadAnonymousConsentTemplates$ = this.actions$.pipe(ofType(LOAD_ANONYMOUS_CONSENT_TEMPLATES), concatMap((/**
         * @param {?} _
         * @return {?}
         */
        _ => this.anonymousConsentTemplatesConnector
            .loadAnonymousConsentTemplates()
            .pipe(withLatestFrom(this.anonymousConsentService.getTemplates()), mergeMap((/**
         * @param {?} __0
         * @return {?}
         */
        ([newConsentTemplates, currentConsentTemplates]) => {
            /** @type {?} */
            let updated = false;
            if (Boolean(currentConsentTemplates) &&
                currentConsentTemplates.length !== 0) {
                updated = this.anonymousConsentService.detectUpdatedTemplates(currentConsentTemplates, newConsentTemplates);
            }
            return [
                new LoadAnonymousConsentTemplatesSuccess(newConsentTemplates),
                new ToggleAnonymousConsentTemplatesUpdated(updated),
            ];
        })), catchError((/**
         * @param {?} error
         * @return {?}
         */
        error => of(new LoadAnonymousConsentTemplatesFail(makeErrorSerializable(error)))))))));
        this.transferAnonymousConsentsToUser$ = this.actions$.pipe(ofType(LOAD_USER_TOKEN_SUCCESS), filter((/**
         * @return {?}
         */
        () => isFeatureEnabled(this.anonymousConsentsConfig, ANONYMOUS_CONSENTS_FEATURE) && Boolean(this.anonymousConsentsConfig.anonymousConsents))), withLatestFrom(this.actions$.pipe(ofType(REGISTER_USER_SUCCESS))), filter((/**
         * @param {?} __0
         * @return {?}
         */
        ([, registerAction]) => Boolean(registerAction))), switchMap((/**
         * @return {?}
         */
        () => this.anonymousConsentService.getConsents().pipe(withLatestFrom(this.authService.getOccUserId(), this.anonymousConsentService.getTemplates(), this.authService.isUserLoggedIn()), filter((/**
         * @param {?} __0
         * @return {?}
         */
        ([, , , loggedIn]) => loggedIn)), concatMap((/**
         * @param {?} __0
         * @return {?}
         */
        ([consents, userId, templates, _loggedIn]) => {
            /** @type {?} */
            const actions = [];
            for (const consent of consents) {
                if (this.anonymousConsentService.isConsentGiven(consent) &&
                    (!this.anonymousConsentsConfig.anonymousConsents
                        .requiredConsents ||
                        !this.anonymousConsentsConfig.anonymousConsents.requiredConsents.includes(consent.templateCode))) {
                    for (const template of templates) {
                        if (template.id === consent.templateCode) {
                            actions.push(new TransferAnonymousConsent({
                                userId,
                                consentTemplateId: template.id,
                                consentTemplateVersion: template.version,
                            }));
                            break;
                        }
                    }
                }
            }
            if (actions.length > 0) {
                return actions;
            }
            return EMPTY;
        }))))));
        this.giveRequiredConsentsToUser$ = this.actions$.pipe(ofType(LOAD_USER_TOKEN_SUCCESS), filter((/**
         * @param {?} action
         * @return {?}
         */
        action => isFeatureEnabled(this.anonymousConsentsConfig, ANONYMOUS_CONSENTS_FEATURE) &&
            Boolean(this.anonymousConsentsConfig.anonymousConsents) &&
            Boolean(this.anonymousConsentsConfig.anonymousConsents.requiredConsents) &&
            Boolean(action))), concatMap((/**
         * @return {?}
         */
        () => this.userConsentService.getConsentsResultSuccess().pipe(withLatestFrom(this.authService.getOccUserId(), this.userConsentService.getConsents(), this.authService.isUserLoggedIn()), filter((/**
         * @param {?} __0
         * @return {?}
         */
        ([, , , loggedIn]) => loggedIn)), tap((/**
         * @param {?} __0
         * @return {?}
         */
        ([loaded, _userId, _templates, _loggedIn]) => {
            if (!loaded) {
                this.userConsentService.loadConsents();
            }
        })), map((/**
         * @param {?} __0
         * @return {?}
         */
        ([_loaded, userId, templates, _loggedIn]) => {
            return { userId, templates };
        })), concatMap((/**
         * @param {?} __0
         * @return {?}
         */
        ({ userId, templates }) => {
            /** @type {?} */
            const actions = [];
            for (const template of templates) {
                if (this.userConsentService.isConsentWithdrawn(template.currentConsent) &&
                    this.anonymousConsentsConfig.anonymousConsents.requiredConsents.includes(template.id)) {
                    actions.push(new GiveUserConsent({
                        userId,
                        consentTemplateId: template.id,
                        consentTemplateVersion: template.version,
                    }));
                }
            }
            if (actions.length > 0) {
                return actions;
            }
            return EMPTY;
        }))))));
    }
}
AnonymousConsentsEffects.decorators = [
    { type: Injectable }
];
/** @nocollapse */
AnonymousConsentsEffects.ctorParameters = () => [
    { type: Actions },
    { type: AnonymousConsentTemplatesConnector },
    { type: AuthService },
    { type: AnonymousConsentsConfig },
    { type: AnonymousConsentsService },
    { type: UserConsentService }
];
__decorate([
    Effect(),
    __metadata("design:type", Observable)
], AnonymousConsentsEffects.prototype, "loadAnonymousConsentTemplates$", void 0);
__decorate([
    Effect(),
    __metadata("design:type", Observable)
], AnonymousConsentsEffects.prototype, "transferAnonymousConsentsToUser$", void 0);
__decorate([
    Effect(),
    __metadata("design:type", Observable)
], AnonymousConsentsEffects.prototype, "giveRequiredConsentsToUser$", void 0);
if (false) {
    /** @type {?} */
    AnonymousConsentsEffects.prototype.loadAnonymousConsentTemplates$;
    /** @type {?} */
    AnonymousConsentsEffects.prototype.transferAnonymousConsentsToUser$;
    /** @type {?} */
    AnonymousConsentsEffects.prototype.giveRequiredConsentsToUser$;
    /**
     * @type {?}
     * @private
     */
    AnonymousConsentsEffects.prototype.actions$;
    /**
     * @type {?}
     * @private
     */
    AnonymousConsentsEffects.prototype.anonymousConsentTemplatesConnector;
    /**
     * @type {?}
     * @private
     */
    AnonymousConsentsEffects.prototype.authService;
    /**
     * @type {?}
     * @private
     */
    AnonymousConsentsEffects.prototype.anonymousConsentsConfig;
    /**
     * @type {?}
     * @private
     */
    AnonymousConsentsEffects.prototype.anonymousConsentService;
    /**
     * @type {?}
     * @private
     */
    AnonymousConsentsEffects.prototype.userConsentService;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const effects$1 = [AnonymousConsentsEffects];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SiteConnector {
    /**
     * @param {?} adapter
     */
    constructor(adapter) {
        this.adapter = adapter;
    }
    /**
     * @return {?}
     */
    getLanguages() {
        return this.adapter.loadLanguages();
    }
    /**
     * @return {?}
     */
    getCurrencies() {
        return this.adapter.loadCurrencies();
    }
    /**
     * @param {?=} type
     * @return {?}
     */
    getCountries(type) {
        return this.adapter.loadCountries(type);
    }
    /**
     * @param {?} countryIsoCode
     * @return {?}
     */
    getRegions(countryIsoCode) {
        return this.adapter.loadRegions(countryIsoCode);
    }
    /**
     * @return {?}
     */
    getBaseSite() {
        return this.adapter.loadBaseSite();
    }
}
SiteConnector.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root',
            },] }
];
/** @nocollapse */
SiteConnector.ctorParameters = () => [
    { type: SiteAdapter }
];
/** @nocollapse */ SiteConnector.ngInjectableDef = ɵɵdefineInjectable({ factory: function SiteConnector_Factory() { return new SiteConnector(ɵɵinject(SiteAdapter)); }, token: SiteConnector, providedIn: "root" });
if (false) {
    /**
     * @type {?}
     * @protected
     */
    SiteConnector.prototype.adapter;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @record
 * @template T
 */
function SiteContext() { }
if (false) {
    /**
     * @return {?}
     */
    SiteContext.prototype.getAll = function () { };
    /**
     * @return {?}
     */
    SiteContext.prototype.getActive = function () { };
    /**
     * @param {?} isocode
     * @return {?}
     */
    SiteContext.prototype.setActive = function (isocode) { };
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @abstract
 */
class ContextServiceMap {
}
/**
 * @return {?}
 */
function serviceMapFactory() {
    return {
        [LANGUAGE_CONTEXT_ID]: LanguageService,
        [CURRENCY_CONTEXT_ID]: CurrencyService,
        [BASE_SITE_CONTEXT_ID]: BaseSiteService,
    };
}
/** @type {?} */
const contextServiceMapProvider = {
    provide: ContextServiceMap,
    useFactory: serviceMapFactory,
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @deprecated since 1.3 - should be removed from public API and the logic should be moved to the function `initializeContext`
 * @param {?} baseSiteService
 * @param {?} langService
 * @param {?} currService
 * @return {?}
 */
function inititializeContext(baseSiteService, langService, currService) {
    return (/**
     * @return {?}
     */
    () => {
        baseSiteService.initialize();
        langService.initialize();
        currService.initialize();
    });
}
/**
 * @param {?} baseSiteService
 * @param {?} langService
 * @param {?} currService
 * @param {?} configInit
 * @return {?}
 */
function initializeContext(baseSiteService, langService, currService, configInit) {
    return (/**
     * @return {?}
     */
    () => {
        /** @type {?} */
        const initialize = inititializeContext(baseSiteService, langService, currService);
        configInit.getStableConfig('context').then((/**
         * @return {?}
         */
        () => {
            initialize();
        }));
    });
}
/**
 * @deprecated since 1.3 - should be removed
 * @type {?}
 */
const deprecatedContextServiceProviders = [
    BaseSiteService,
    LanguageService,
    CurrencyService,
    {
        provide: APP_INITIALIZER,
        useFactory: inititializeContext,
        deps: [BaseSiteService, LanguageService, CurrencyService],
        multi: true,
    },
];
/** @type {?} */
const contextServiceProviders = [
    BaseSiteService,
    LanguageService,
    CurrencyService,
    {
        provide: APP_INITIALIZER,
        useFactory: initializeContext,
        deps: [
            BaseSiteService,
            LanguageService,
            CurrencyService,
            ConfigInitializerService,
        ],
        multi: true,
    },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SiteContextParamsService {
    /**
     * @param {?} config
     * @param {?} injector
     * @param {?} serviceMap
     */
    constructor(config, injector, serviceMap) {
        this.config = config;
        this.injector = injector;
        this.serviceMap = serviceMap;
    }
    /**
     * @return {?}
     */
    getContextParameters() {
        if (this.config.context) {
            return Object.keys(this.config.context).filter((/**
             * @param {?} param
             * @return {?}
             */
            param => param !== 'urlParameters'));
        }
        return [];
    }
    /**
     * @return {?}
     */
    getUrlEncodingParameters() {
        return (this.config.context && this.config.context.urlParameters) || [];
    }
    /**
     * @param {?} param
     * @return {?}
     */
    getParamValues(param) {
        return getContextParameterValues(this.config, param);
    }
    /**
     * @param {?} param
     * @return {?}
     */
    getParamDefaultValue(param) {
        return getContextParameterDefault(this.config, param);
    }
    /**
     * @param {?} param
     * @return {?}
     */
    getSiteContextService(param) {
        if (this.serviceMap[param]) {
            return this.injector.get(this.serviceMap[param], null);
        }
    }
    /**
     * @param {?} param
     * @return {?}
     */
    getValue(param) {
        /** @type {?} */
        let value;
        /** @type {?} */
        const service = this.getSiteContextService(param);
        if (service) {
            service
                .getActive()
                .subscribe((/**
             * @param {?} val
             * @return {?}
             */
            val => (value = val)))
                .unsubscribe();
        }
        return value !== undefined ? value : this.getParamDefaultValue(param);
    }
    /**
     * @param {?} param
     * @param {?} value
     * @return {?}
     */
    setValue(param, value) {
        /** @type {?} */
        const service = this.getSiteContextService(param);
        if (service) {
            service.setActive(value);
        }
    }
}
SiteContextParamsService.decorators = [
    { type: Injectable }
];
/** @nocollapse */
SiteContextParamsService.ctorParameters = () => [
    { type: SiteContextConfig },
    { type: Injector },
    { type: ContextServiceMap }
];
if (false) {
    /**
     * @type {?}
     * @private
     */
    SiteContextParamsService.prototype.config;
    /**
     * @type {?}
     * @private
     */
    SiteContextParamsService.prototype.injector;
    /**
     * @type {?}
     * @private
     */
    SiteContextParamsService.prototype.serviceMap;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @record
 */
function ParamValuesMap() { }
/**
 * @record
 */
function UrlTreeWithSiteContext() { }
if (false) {
    /** @type {?|undefined} */
    UrlTreeWithSiteContext.prototype.siteContext;
}
/** @type {?} */
const UrlSplit = /(^[^#?]*)(.*)/;
// used to split url into path and query/fragment parts
class SiteContextUrlSerializer extends DefaultUrlSerializer {
    /**
     * @param {?} siteContextParams
     */
    constructor(siteContextParams) {
        super();
        this.siteContextParams = siteContextParams;
    }
    /**
     * @private
     * @return {?}
     */
    get urlEncodingParameters() {
        return this.siteContextParams.getUrlEncodingParameters();
    }
    /**
     * @return {?}
     */
    get hasContextInRoutes() {
        return this.urlEncodingParameters.length > 0;
    }
    /**
     * @param {?} url
     * @return {?}
     */
    parse(url) {
        if (this.hasContextInRoutes) {
            /** @type {?} */
            const urlWithParams = this.urlExtractContextParameters(url);
            /** @type {?} */
            const parsed = (/** @type {?} */ (super.parse(urlWithParams.url)));
            this.urlTreeIncludeContextParameters(parsed, urlWithParams.params);
            return parsed;
        }
        else {
            return super.parse(url);
        }
    }
    /**
     * @param {?} url
     * @return {?}
     */
    urlExtractContextParameters(url) {
        const [, urlPart, queryPart] = url.match(UrlSplit);
        /** @type {?} */
        const segments = urlPart.split('/');
        if (segments[0] === '') {
            segments.shift();
        }
        /** @type {?} */
        const params = {};
        /** @type {?} */
        let paramId = 0;
        /** @type {?} */
        let segmentId = 0;
        while (paramId < this.urlEncodingParameters.length &&
            segmentId < segments.length) {
            /** @type {?} */
            const paramName = this.urlEncodingParameters[paramId];
            /** @type {?} */
            const paramValues = this.siteContextParams.getParamValues(paramName);
            if (paramValues.includes(segments[segmentId])) {
                params[paramName] = segments[segmentId];
                segmentId++;
            }
            paramId++;
        }
        url = segments.slice(Object.keys(params).length).join('/') + queryPart;
        return { url, params };
    }
    /**
     * @private
     * @param {?} urlTree
     * @param {?} params
     * @return {?}
     */
    urlTreeIncludeContextParameters(urlTree, params) {
        urlTree.siteContext = params;
    }
    /**
     * @param {?} tree
     * @return {?}
     */
    serialize(tree) {
        /** @type {?} */
        const params = this.urlTreeExtractContextParameters(tree);
        /** @type {?} */
        const url = super.serialize(tree);
        /** @type {?} */
        const serialized = this.urlIncludeContextParameters(url, params);
        return serialized;
    }
    /**
     * @param {?} urlTree
     * @return {?}
     */
    urlTreeExtractContextParameters(urlTree) {
        return urlTree.siteContext ? urlTree.siteContext : {};
    }
    /**
     * @private
     * @param {?} url
     * @param {?} params
     * @return {?}
     */
    urlIncludeContextParameters(url, params) {
        /** @type {?} */
        const contextRoutePart = this.urlEncodingParameters
            .map((/**
         * @param {?} param
         * @return {?}
         */
        param => {
            return params[param]
                ? params[param]
                : this.siteContextParams.getValue(param);
        }))
            .join('/');
        return contextRoutePart + url;
    }
}
SiteContextUrlSerializer.decorators = [
    { type: Injectable }
];
/** @nocollapse */
SiteContextUrlSerializer.ctorParameters = () => [
    { type: SiteContextParamsService }
];
if (false) {
    /**
     * @type {?}
     * @private
     */
    SiteContextUrlSerializer.prototype.siteContextParams;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SiteContextRoutesHandler {
    /**
     * @param {?} siteContextParams
     * @param {?} serializer
     * @param {?} injector
     */
    constructor(siteContextParams, serializer, injector) {
        this.siteContextParams = siteContextParams;
        this.serializer = serializer;
        this.injector = injector;
        this.subscription = new Subscription();
        this.contextValues = {};
        this.isNavigating = false;
    }
    /**
     * @return {?}
     */
    init() {
        this.router = this.injector.get(Router);
        this.location = this.injector.get(Location);
        /** @type {?} */
        const routingParams = this.siteContextParams.getUrlEncodingParameters();
        if (routingParams.length) {
            this.setContextParamsFromRoute(this.router.url);
            this.subscribeChanges(routingParams);
            this.subscribeRouting();
        }
    }
    /**
     * @private
     * @param {?} params
     * @return {?}
     */
    subscribeChanges(params) {
        params.forEach((/**
         * @param {?} param
         * @return {?}
         */
        param => {
            /** @type {?} */
            const service = this.siteContextParams.getSiteContextService(param);
            if (service) {
                this.subscription.add(service.getActive().subscribe((/**
                 * @param {?} value
                 * @return {?}
                 */
                value => {
                    if (!this.isNavigating &&
                        this.contextValues[param] &&
                        this.contextValues[param] !== value) {
                        /** @type {?} */
                        const parsed = this.router.parseUrl(this.router.url);
                        /** @type {?} */
                        const serialized = this.router.serializeUrl(parsed);
                        this.location.replaceState(serialized);
                    }
                    this.contextValues[param] = value;
                })));
            }
        }));
    }
    /**
     * @private
     * @return {?}
     */
    subscribeRouting() {
        this.subscription.add(this.router.events
            .pipe(filter((/**
         * @param {?} event
         * @return {?}
         */
        event => event instanceof NavigationStart ||
            event instanceof NavigationEnd ||
            event instanceof NavigationError ||
            event instanceof NavigationCancel)))
            .subscribe((/**
         * @param {?} event
         * @return {?}
         */
        (event) => {
            this.isNavigating = event instanceof NavigationStart;
            if (this.isNavigating) {
                this.setContextParamsFromRoute(event.url);
            }
        })));
    }
    /**
     * @private
     * @param {?} url
     * @return {?}
     */
    setContextParamsFromRoute(url) {
        const { params } = this.serializer.urlExtractContextParameters(url);
        Object.keys(params).forEach((/**
         * @param {?} param
         * @return {?}
         */
        param => this.siteContextParams.setValue(param, params[param])));
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.subscription.unsubscribe();
    }
}
SiteContextRoutesHandler.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root',
            },] }
];
/** @nocollapse */
SiteContextRoutesHandler.ctorParameters = () => [
    { type: SiteContextParamsService },
    { type: SiteContextUrlSerializer },
    { type: Injector }
];
/** @nocollapse */ SiteContextRoutesHandler.ngInjectableDef = ɵɵdefineInjectable({ factory: function SiteContextRoutesHandler_Factory() { return new SiteContextRoutesHandler(ɵɵinject(SiteContextParamsService), ɵɵinject(SiteContextUrlSerializer), ɵɵinject(INJECTOR)); }, token: SiteContextRoutesHandler, providedIn: "root" });
if (false) {
    /**
     * @type {?}
     * @private
     */
    SiteContextRoutesHandler.prototype.subscription;
    /**
     * @type {?}
     * @private
     */
    SiteContextRoutesHandler.prototype.contextValues;
    /**
     * @type {?}
     * @private
     */
    SiteContextRoutesHandler.prototype.router;
    /**
     * @type {?}
     * @private
     */
    SiteContextRoutesHandler.prototype.location;
    /**
     * @type {?}
     * @private
     */
    SiteContextRoutesHandler.prototype.isNavigating;
    /**
     * @type {?}
     * @private
     */
    SiteContextRoutesHandler.prototype.siteContextParams;
    /**
     * @type {?}
     * @private
     */
    SiteContextRoutesHandler.prototype.serializer;
    /**
     * @type {?}
     * @private
     */
    SiteContextRoutesHandler.prototype.injector;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// functions below should not be exposed in public API:
/**
 * @param {?} siteContextRoutesHandler
 * @param {?} configInit
 * @return {?}
 */
function initSiteContextRoutesHandler(siteContextRoutesHandler, configInit) {
    return (/**
     * @return {?}
     */
    () => {
        configInit.getStableConfig('context').then((/**
         * @return {?}
         */
        () => {
            siteContextRoutesHandler.init();
        }));
    });
}
/** @type {?} */
const siteContextParamsProviders = [
    SiteContextParamsService,
    SiteContextUrlSerializer,
    { provide: UrlSerializer, useExisting: SiteContextUrlSerializer },
    {
        provide: APP_INITIALIZER,
        useFactory: initSiteContextRoutesHandler,
        deps: [SiteContextRoutesHandler, ConfigInitializerService],
        multi: true,
    },
];
/**
 * @deprecated since 1.3.1; TODO: remove
 * @param {?} siteContextRoutesHandler
 * @return {?}
 */
function deprecatedInitSiteContextRoutesHandler(siteContextRoutesHandler) {
    return (/**
     * @return {?}
     */
    () => {
        siteContextRoutesHandler.init();
    });
}
/**
 * @deprecated since 1.3.1; TODO: remove
 * @type {?}
 */
const deprecatedSiteContextParamsProviders = [
    SiteContextParamsService,
    SiteContextUrlSerializer,
    { provide: UrlSerializer, useExisting: SiteContextUrlSerializer },
    {
        provide: APP_INITIALIZER,
        useFactory: deprecatedInitSiteContextRoutesHandler,
        deps: [SiteContextRoutesHandler],
        multi: true,
    },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} config
 * @return {?}
 */
function baseSiteConfigValidator(config) {
    if (getContextParameterDefault(config, BASE_SITE_CONTEXT_ID) === undefined) {
        return 'Please configure context.parameters.baseSite before using storefront library!';
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @return {?}
 */
function defaultSiteContextConfigFactory() {
    return {
        context: {
            [LANGUAGE_CONTEXT_ID]: [
                'en',
                'de',
                'ja',
                'zh',
                'ru',
                'fr',
                'tr',
                'it',
                'es',
                'uk',
                'pl',
                'nl',
                'hi',
                'ar',
                'pt',
                'bn',
                'pa',
            ],
            [CURRENCY_CONTEXT_ID]: [
                'USD',
                'EUR',
                'JPY',
                'GBP',
                'AUD',
                'CAD',
                'CHF',
                'CNY',
                'SEK',
                'NZD',
                'MXN',
                'SGD',
                'HKD',
                'NOK',
                'KRW',
                'TRY',
                'RUB',
                'INR',
                'BRL',
                'ZAR',
            ],
        },
    };
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class LanguagesEffects {
    /**
     * @param {?} actions$
     * @param {?} siteConnector
     * @param {?} winRef
     */
    constructor(actions$, siteConnector, winRef) {
        this.actions$ = actions$;
        this.siteConnector = siteConnector;
        this.winRef = winRef;
        this.loadLanguages$ = this.actions$.pipe(ofType(LOAD_LANGUAGES), exhaustMap((/**
         * @return {?}
         */
        () => {
            return this.siteConnector.getLanguages().pipe(map((/**
             * @param {?} languages
             * @return {?}
             */
            languages => new LoadLanguagesSuccess(languages))), catchError((/**
             * @param {?} error
             * @return {?}
             */
            error => of(new LoadLanguagesFail(makeErrorSerializable(error))))));
        })));
        this.activateLanguage$ = this.actions$.pipe(ofType(SET_ACTIVE_LANGUAGE), tap((/**
         * @param {?} action
         * @return {?}
         */
        (action) => {
            if (this.winRef.sessionStorage) {
                this.winRef.sessionStorage.setItem('language', action.payload);
            }
        })), map((/**
         * @return {?}
         */
        () => new LanguageChange())));
    }
}
LanguagesEffects.decorators = [
    { type: Injectable }
];
/** @nocollapse */
LanguagesEffects.ctorParameters = () => [
    { type: Actions },
    { type: SiteConnector },
    { type: WindowRef }
];
__decorate([
    Effect(),
    __metadata("design:type", Observable)
], LanguagesEffects.prototype, "loadLanguages$", void 0);
__decorate([
    Effect(),
    __metadata("design:type", Observable)
], LanguagesEffects.prototype, "activateLanguage$", void 0);
if (false) {
    /** @type {?} */
    LanguagesEffects.prototype.loadLanguages$;
    /** @type {?} */
    LanguagesEffects.prototype.activateLanguage$;
    /**
     * @type {?}
     * @private
     */
    LanguagesEffects.prototype.actions$;
    /**
     * @type {?}
     * @private
     */
    LanguagesEffects.prototype.siteConnector;
    /**
     * @type {?}
     * @private
     */
    LanguagesEffects.prototype.winRef;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class CurrenciesEffects {
    /**
     * @param {?} actions$
     * @param {?} siteConnector
     * @param {?} winRef
     */
    constructor(actions$, siteConnector, winRef) {
        this.actions$ = actions$;
        this.siteConnector = siteConnector;
        this.winRef = winRef;
        this.loadCurrencies$ = this.actions$.pipe(ofType(LOAD_CURRENCIES), exhaustMap((/**
         * @return {?}
         */
        () => {
            return this.siteConnector.getCurrencies().pipe(map((/**
             * @param {?} currencies
             * @return {?}
             */
            currencies => new LoadCurrenciesSuccess(currencies))), catchError((/**
             * @param {?} error
             * @return {?}
             */
            error => of(new LoadCurrenciesFail(makeErrorSerializable(error))))));
        })));
        this.activateCurrency$ = this.actions$.pipe(ofType(SET_ACTIVE_CURRENCY), tap((/**
         * @param {?} action
         * @return {?}
         */
        (action) => {
            if (this.winRef.sessionStorage) {
                this.winRef.sessionStorage.setItem('currency', action.payload);
            }
        })), map((/**
         * @return {?}
         */
        () => new CurrencyChange())));
    }
}
CurrenciesEffects.decorators = [
    { type: Injectable }
];
/** @nocollapse */
CurrenciesEffects.ctorParameters = () => [
    { type: Actions },
    { type: SiteConnector },
    { type: WindowRef }
];
__decorate([
    Effect(),
    __metadata("design:type", Observable)
], CurrenciesEffects.prototype, "loadCurrencies$", void 0);
__decorate([
    Effect(),
    __metadata("design:type", Observable)
], CurrenciesEffects.prototype, "activateCurrency$", void 0);
if (false) {
    /** @type {?} */
    CurrenciesEffects.prototype.loadCurrencies$;
    /** @type {?} */
    CurrenciesEffects.prototype.activateCurrency$;
    /**
     * @type {?}
     * @private
     */
    CurrenciesEffects.prototype.actions$;
    /**
     * @type {?}
     * @private
     */
    CurrenciesEffects.prototype.siteConnector;
    /**
     * @type {?}
     * @private
     */
    CurrenciesEffects.prototype.winRef;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class BaseSiteEffects {
    /**
     * @param {?} actions$
     * @param {?} siteConnector
     */
    constructor(actions$, siteConnector) {
        this.actions$ = actions$;
        this.siteConnector = siteConnector;
        this.loadBaseSite$ = this.actions$.pipe(ofType(LOAD_BASE_SITE), exhaustMap((/**
         * @return {?}
         */
        () => {
            return this.siteConnector.getBaseSite().pipe(map((/**
             * @param {?} baseSite
             * @return {?}
             */
            baseSite => new LoadBaseSiteSuccess(baseSite))), catchError((/**
             * @param {?} error
             * @return {?}
             */
            error => of(new LoadBaseSiteFail(makeErrorSerializable(error))))));
        })));
    }
}
BaseSiteEffects.decorators = [
    { type: Injectable }
];
/** @nocollapse */
BaseSiteEffects.ctorParameters = () => [
    { type: Actions },
    { type: SiteConnector }
];
__decorate([
    Effect(),
    __metadata("design:type", Observable)
], BaseSiteEffects.prototype, "loadBaseSite$", void 0);
if (false) {
    /** @type {?} */
    BaseSiteEffects.prototype.loadBaseSite$;
    /**
     * @type {?}
     * @private
     */
    BaseSiteEffects.prototype.actions$;
    /**
     * @type {?}
     * @private
     */
    BaseSiteEffects.prototype.siteConnector;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const effects$2 = [
    LanguagesEffects,
    CurrenciesEffects,
    BaseSiteEffects,
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const initialState$1 = {
    details: {},
    activeSite: '',
};
/**
 * @param {?=} state
 * @param {?=} action
 * @return {?}
 */
function reducer$1(state = initialState$1, action) {
    switch (action.type) {
        case LOAD_BASE_SITE_SUCCESS: {
            return Object.assign({}, state, { details: action.payload });
        }
        case SET_ACTIVE_BASE_SITE: {
            return Object.assign({}, state, { activeSite: action.payload });
        }
    }
    return state;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const initialState$2 = {
    entities: null,
    activeCurrency: null,
};
/**
 * @param {?=} state
 * @param {?=} action
 * @return {?}
 */
function reducer$2(state = initialState$2, action) {
    switch (action.type) {
        case LOAD_CURRENCIES_SUCCESS: {
            /** @type {?} */
            const currencies = action.payload;
            /** @type {?} */
            const entities = currencies.reduce((/**
             * @param {?} currEntities
             * @param {?} currency
             * @return {?}
             */
            (currEntities, currency) => {
                return Object.assign({}, currEntities, { [currency.isocode]: currency });
            }), Object.assign({}, state.entities));
            return Object.assign({}, state, { entities });
        }
        case SET_ACTIVE_CURRENCY: {
            /** @type {?} */
            const isocode = action.payload;
            return Object.assign({}, state, { activeCurrency: isocode });
        }
    }
    return state;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const initialState$3 = {
    entities: null,
    activeLanguage: null,
};
/**
 * @param {?=} state
 * @param {?=} action
 * @return {?}
 */
function reducer$3(state = initialState$3, action) {
    switch (action.type) {
        case LOAD_LANGUAGES_SUCCESS: {
            /** @type {?} */
            const languages = action.payload;
            /** @type {?} */
            const entities = languages.reduce((/**
             * @param {?} langEntities
             * @param {?} language
             * @return {?}
             */
            (langEntities, language) => {
                return Object.assign({}, langEntities, { [language.isocode]: language });
            }), Object.assign({}, state.entities));
            return Object.assign({}, state, { entities });
        }
        case SET_ACTIVE_LANGUAGE: {
            /** @type {?} */
            const isocode = action.payload;
            return Object.assign({}, state, { activeLanguage: isocode });
        }
    }
    return state;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @return {?}
 */
function getReducers$1() {
    return {
        languages: reducer$3,
        currencies: reducer$2,
        baseSite: reducer$1,
    };
}
/** @type {?} */
const reducerToken$1 = new InjectionToken('SiteContextReducers');
/** @type {?} */
const reducerProvider$1 = {
    provide: reducerToken$1,
    useFactory: getReducers$1,
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @return {?}
 */
function siteContextStoreConfigFactory() {
    // if we want to reuse SITE_CONTEXT_FEATURE const in config, we have to use factory instead of plain object
    /** @type {?} */
    const config = {
        state: {
            ssrTransfer: {
                keys: { [SITE_CONTEXT_FEATURE]: StateTransferType.TRANSFER_STATE },
            },
        },
    };
    return config;
}
class SiteContextStoreModule {
}
SiteContextStoreModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    HttpClientModule,
                    StoreModule.forFeature(SITE_CONTEXT_FEATURE, reducerToken$1),
                    EffectsModule.forFeature(effects$2),
                    ConfigModule.withConfigFactory(siteContextStoreConfigFactory),
                ],
                providers: [reducerProvider$1],
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// @dynamic
class SiteContextModule {
    /**
     * @return {?}
     */
    static forRoot() {
        return {
            ngModule: SiteContextModule,
            providers: [
                contextServiceMapProvider,
                ...contextServiceProviders,
                ...siteContextParamsProviders,
                { provide: SiteContextConfig, useExisting: Config },
                provideConfigValidator(baseSiteConfigValidator),
            ],
        };
    }
}
SiteContextModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    ConfigModule.withConfigFactory(defaultSiteContextConfigFactory),
                    StateModule,
                    SiteContextStoreModule,
                ],
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const initialState$4 = false;
/**
 * @param {?=} state
 * @param {?=} action
 * @return {?}
 */
function reducer$4(state = initialState$4, action) {
    switch (action.type) {
        case TOGGLE_ANONYMOUS_CONSENTS_BANNER_DISMISSED: {
            return action.dismissed;
        }
    }
    return state;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const initialState$5 = false;
/**
 * @param {?=} state
 * @param {?=} action
 * @return {?}
 */
function reducer$5(state = initialState$5, action) {
    switch (action.type) {
        case TOGGLE_ANONYMOUS_CONSENT_TEMPLATES_UPDATED: {
            return action.updated;
        }
    }
    return state;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const initialState$6 = [];
/**
 * @param {?} consents
 * @param {?} templateCode
 * @param {?} status
 * @return {?}
 */
function toggleConsentStatus(consents, templateCode, status) {
    if (!consents) {
        return [];
    }
    return consents.map((/**
     * @param {?} consent
     * @return {?}
     */
    consent => {
        if (consent.templateCode === templateCode) {
            consent = Object.assign({}, consent, { consentState: status });
        }
        return consent;
    }));
}
/**
 * @param {?=} state
 * @param {?=} action
 * @return {?}
 */
function reducer$6(state = initialState$6, action) {
    switch (action.type) {
        case GIVE_ANONYMOUS_CONSENT: {
            return toggleConsentStatus(state, action.templateCode, ANONYMOUS_CONSENT_STATUS.GIVEN);
        }
        case WITHDRAW_ANONYMOUS_CONSENT: {
            return toggleConsentStatus(state, action.templateCode, ANONYMOUS_CONSENT_STATUS.WITHDRAWN);
        }
        case SET_ANONYMOUS_CONSENTS: {
            return action.payload;
        }
    }
    return state;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @return {?}
 */
function getReducers$2() {
    return {
        templates: loaderReducer(ANONYMOUS_CONSENTS),
        consents: reducer$6,
        ui: combineReducers({
            bannerDismissed: reducer$4,
            updated: reducer$5,
        }),
    };
}
/** @type {?} */
const reducerToken$2 = new InjectionToken('AnonymousConsentsReducers');
/** @type {?} */
const reducerProvider$2 = {
    provide: reducerToken$2,
    useFactory: getReducers$2,
};
/**
 * @param {?} reducer
 * @return {?}
 */
function clearAnonymousConsentTemplates(reducer) {
    return (/**
     * @param {?} state
     * @param {?} action
     * @return {?}
     */
    function (state, action) {
        if (action.type === LOGOUT ||
            action.type === LANGUAGE_CHANGE) {
            state = Object.assign({}, state, { templates: undefined });
        }
        return reducer(state, action);
    });
}
/** @type {?} */
const metaReducers$1 = [
    clearAnonymousConsentTemplates,
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @return {?}
 */
function anonymousConsentsStoreConfigFactory() {
    /** @type {?} */
    const config = {
        state: {
            storageSync: {
                keys: {
                    [ANONYMOUS_CONSENTS_STORE_FEATURE]: StorageSyncType.LOCAL_STORAGE,
                },
            },
        },
    };
    return config;
}
class AnonymousConsentsStoreModule {
}
AnonymousConsentsStoreModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    ReactiveFormsModule,
                    StateModule,
                    StoreModule.forFeature(ANONYMOUS_CONSENTS_STORE_FEATURE, reducerToken$2, {
                        metaReducers: metaReducers$1,
                    }),
                    EffectsModule.forFeature(effects$1),
                    ConfigModule.withConfigFactory(anonymousConsentsStoreConfigFactory),
                ],
                providers: [reducerProvider$2],
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class AnonymousConsentsModule {
    /**
     * @return {?}
     */
    static forRoot() {
        return {
            ngModule: AnonymousConsentsModule,
            providers: [
                ...interceptors$1,
                AnonymousConsentsService,
                { provide: AnonymousConsentsConfig, useExisting: Config },
            ],
        };
    }
}
AnonymousConsentsModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    AnonymousConsentsStoreModule,
                    ConfigModule.withConfig(defaultAnonymousConsentsConfig),
                ],
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const defaultAsmConfig = {
    asm: {
        agentSessionTimer: {
            startingDelayInSeconds: 600,
        },
        customerSearch: {
            maxResults: 20,
        },
    },
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const ASM_FEATURE = 'asm';
/** @type {?} */
const CUSTOMER_SEARCH_DATA = '[asm] Customer search data';
/** @type {?} */
const CSAGENT_TOKEN_DATA = '[Auth] Customer Support Agent Token Data';
/**
 * @record
 */
function StateWithAsm() { }
if (false) {
    /* Skipping unnamed member:
    [ASM_FEATURE]: AsmState;*/
}
/**
 * @record
 */
function AsmState() { }
if (false) {
    /** @type {?} */
    AsmState.prototype.customerSearchResult;
    /** @type {?} */
    AsmState.prototype.asmUi;
    /** @type {?} */
    AsmState.prototype.csagentToken;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class AsmConnector {
    /**
     * @param {?} asmAdapter
     */
    constructor(asmAdapter) {
        this.asmAdapter = asmAdapter;
    }
    /**
     * @param {?} options
     * @return {?}
     */
    customerSearch(options) {
        return this.asmAdapter.customerSearch(options);
    }
}
AsmConnector.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root',
            },] }
];
/** @nocollapse */
AsmConnector.ctorParameters = () => [
    { type: AsmAdapter }
];
/** @nocollapse */ AsmConnector.ngInjectableDef = ɵɵdefineInjectable({ factory: function AsmConnector_Factory() { return new AsmConnector(ɵɵinject(AsmAdapter)); }, token: AsmConnector, providedIn: "root" });
if (false) {
    /**
     * @type {?}
     * @protected
     */
    AsmConnector.prototype.asmAdapter;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const ASM_UI_UPDATE = '[Asm] UI Update';
class AsmUiUpdate {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        this.payload = payload;
        this.type = ASM_UI_UPDATE;
    }
}
if (false) {
    /** @type {?} */
    AsmUiUpdate.prototype.type;
    /** @type {?} */
    AsmUiUpdate.prototype.payload;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const CUSTOMER_SEARCH = '[Asm] Customer Search';
/** @type {?} */
const CUSTOMER_SEARCH_FAIL = '[Asm] Customer Search Fail';
/** @type {?} */
const CUSTOMER_SEARCH_SUCCESS = '[Asm] Customer Search Success';
/** @type {?} */
const CUSTOMER_SEARCH_RESET = '[Asm] Customer Search Reset';
class CustomerSearch extends LoaderLoadAction {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        super(CUSTOMER_SEARCH_DATA);
        this.payload = payload;
        this.type = CUSTOMER_SEARCH;
    }
}
if (false) {
    /** @type {?} */
    CustomerSearch.prototype.type;
    /** @type {?} */
    CustomerSearch.prototype.payload;
}
class CustomerSearchFail extends LoaderFailAction {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        super(CUSTOMER_SEARCH_DATA);
        this.payload = payload;
        this.type = CUSTOMER_SEARCH_FAIL;
    }
}
if (false) {
    /** @type {?} */
    CustomerSearchFail.prototype.type;
    /** @type {?} */
    CustomerSearchFail.prototype.payload;
}
class CustomerSearchSuccess extends LoaderSuccessAction {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        super(CUSTOMER_SEARCH_DATA);
        this.payload = payload;
        this.type = CUSTOMER_SEARCH_SUCCESS;
    }
}
if (false) {
    /** @type {?} */
    CustomerSearchSuccess.prototype.type;
    /** @type {?} */
    CustomerSearchSuccess.prototype.payload;
}
class CustomerSearchReset extends LoaderResetAction {
    constructor() {
        super(CUSTOMER_SEARCH_DATA);
        this.type = CUSTOMER_SEARCH_RESET;
    }
}
if (false) {
    /** @type {?} */
    CustomerSearchReset.prototype.type;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const LOAD_CUSTOMER_SUPPORT_AGENT_TOKEN = '[Auth] Load Customer Service Agent Token';
/** @type {?} */
const LOAD_CUSTOMER_SUPPORT_AGENT_TOKEN_FAIL = '[Auth] Load Customer Service Agent Token Fail';
/** @type {?} */
const LOAD_CUSTOMER_SUPPORT_AGENT_TOKEN_SUCCESS = '[Auth] Load Customer Service Agent Token Success';
class LoadCustomerSupportAgentToken extends LoaderLoadAction {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        super(CSAGENT_TOKEN_DATA);
        this.payload = payload;
        this.type = LOAD_CUSTOMER_SUPPORT_AGENT_TOKEN;
    }
}
if (false) {
    /** @type {?} */
    LoadCustomerSupportAgentToken.prototype.type;
    /** @type {?} */
    LoadCustomerSupportAgentToken.prototype.payload;
}
class LoadCustomerSupportAgentTokenFail extends LoaderFailAction {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        super(CSAGENT_TOKEN_DATA);
        this.payload = payload;
        this.type = LOAD_CUSTOMER_SUPPORT_AGENT_TOKEN_FAIL;
    }
}
if (false) {
    /** @type {?} */
    LoadCustomerSupportAgentTokenFail.prototype.type;
    /** @type {?} */
    LoadCustomerSupportAgentTokenFail.prototype.payload;
}
class LoadCustomerSupportAgentTokenSuccess extends LoaderSuccessAction {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        super(CSAGENT_TOKEN_DATA);
        this.payload = payload;
        this.type = LOAD_CUSTOMER_SUPPORT_AGENT_TOKEN_SUCCESS;
    }
}
if (false) {
    /** @type {?} */
    LoadCustomerSupportAgentTokenSuccess.prototype.type;
    /** @type {?} */
    LoadCustomerSupportAgentTokenSuccess.prototype.payload;
}
class LogoutCustomerSupportAgent {
    constructor() {
        this.type = LOGOUT_CUSTOMER_SUPPORT_AGENT;
    }
}
if (false) {
    /** @type {?} */
    LogoutCustomerSupportAgent.prototype.type;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

var customerGroup_actions = /*#__PURE__*/Object.freeze({
    ASM_UI_UPDATE: ASM_UI_UPDATE,
    AsmUiUpdate: AsmUiUpdate,
    CUSTOMER_SEARCH: CUSTOMER_SEARCH,
    CUSTOMER_SEARCH_FAIL: CUSTOMER_SEARCH_FAIL,
    CUSTOMER_SEARCH_SUCCESS: CUSTOMER_SEARCH_SUCCESS,
    CUSTOMER_SEARCH_RESET: CUSTOMER_SEARCH_RESET,
    CustomerSearch: CustomerSearch,
    CustomerSearchFail: CustomerSearchFail,
    CustomerSearchSuccess: CustomerSearchSuccess,
    CustomerSearchReset: CustomerSearchReset,
    LOAD_CUSTOMER_SUPPORT_AGENT_TOKEN: LOAD_CUSTOMER_SUPPORT_AGENT_TOKEN,
    LOAD_CUSTOMER_SUPPORT_AGENT_TOKEN_FAIL: LOAD_CUSTOMER_SUPPORT_AGENT_TOKEN_FAIL,
    LOAD_CUSTOMER_SUPPORT_AGENT_TOKEN_SUCCESS: LOAD_CUSTOMER_SUPPORT_AGENT_TOKEN_SUCCESS,
    LoadCustomerSupportAgentToken: LoadCustomerSupportAgentToken,
    LoadCustomerSupportAgentTokenFail: LoadCustomerSupportAgentTokenFail,
    LoadCustomerSupportAgentTokenSuccess: LoadCustomerSupportAgentTokenSuccess,
    LogoutCustomerSupportAgent: LogoutCustomerSupportAgent
});

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class CustomerEffects {
    /**
     * @param {?} actions$
     * @param {?} asmConnector
     */
    constructor(actions$, asmConnector) {
        this.actions$ = actions$;
        this.asmConnector = asmConnector;
        this.customerSearch$ = this.actions$.pipe(ofType(CUSTOMER_SEARCH), map((/**
         * @param {?} action
         * @return {?}
         */
        (action) => action.payload)), switchMap((/**
         * @param {?} options
         * @return {?}
         */
        options => this.asmConnector.customerSearch(options).pipe(map((/**
         * @param {?} customerSearchResults
         * @return {?}
         */
        (customerSearchResults) => {
            return new CustomerSearchSuccess(customerSearchResults);
        })), catchError((/**
         * @param {?} error
         * @return {?}
         */
        error => of(new CustomerSearchFail(makeErrorSerializable(error)))))))));
    }
}
CustomerEffects.decorators = [
    { type: Injectable }
];
/** @nocollapse */
CustomerEffects.ctorParameters = () => [
    { type: Actions },
    { type: AsmConnector }
];
__decorate([
    Effect(),
    __metadata("design:type", Observable)
], CustomerEffects.prototype, "customerSearch$", void 0);
if (false) {
    /** @type {?} */
    CustomerEffects.prototype.customerSearch$;
    /**
     * @type {?}
     * @private
     */
    CustomerEffects.prototype.actions$;
    /**
     * @type {?}
     * @private
     */
    CustomerEffects.prototype.asmConnector;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class CustomerSupportAgentTokenEffects {
    /**
     * @param {?} actions$
     * @param {?} userTokenService
     */
    constructor(actions$, userTokenService) {
        this.actions$ = actions$;
        this.userTokenService = userTokenService;
        this.loadCustomerSupportAgentToken$ = this.actions$.pipe(ofType(LOAD_CUSTOMER_SUPPORT_AGENT_TOKEN), map((/**
         * @param {?} action
         * @return {?}
         */
        (action) => action.payload)), switchMap((/**
         * @param {?} __0
         * @return {?}
         */
        ({ userId, password }) => this.userTokenService.loadToken(userId, password).pipe(map((/**
         * @param {?} token
         * @return {?}
         */
        (token) => {
            /** @type {?} */
            const date = new Date();
            date.setSeconds(date.getSeconds() + token.expires_in);
            token.expiration_time = date.toJSON();
            return new LoadCustomerSupportAgentTokenSuccess(token);
        })), catchError((/**
         * @param {?} error
         * @return {?}
         */
        error => of(new LoadCustomerSupportAgentTokenFail(makeErrorSerializable(error)))))))));
    }
}
CustomerSupportAgentTokenEffects.decorators = [
    { type: Injectable }
];
/** @nocollapse */
CustomerSupportAgentTokenEffects.ctorParameters = () => [
    { type: Actions },
    { type: UserAuthenticationTokenService }
];
__decorate([
    Effect(),
    __metadata("design:type", Observable)
], CustomerSupportAgentTokenEffects.prototype, "loadCustomerSupportAgentToken$", void 0);
if (false) {
    /** @type {?} */
    CustomerSupportAgentTokenEffects.prototype.loadCustomerSupportAgentToken$;
    /**
     * @type {?}
     * @private
     */
    CustomerSupportAgentTokenEffects.prototype.actions$;
    /**
     * @type {?}
     * @private
     */
    CustomerSupportAgentTokenEffects.prototype.userTokenService;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const effects$3 = [
    CustomerEffects,
    CustomerSupportAgentTokenEffects,
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const initialState$7 = (/** @type {?} */ ({ collapsed: false }));
/**
 * @param {?=} state
 * @param {?=} action
 * @return {?}
 */
function reducer$7(state = initialState$7, action) {
    switch (action.type) {
        case ASM_UI_UPDATE: {
            return Object.assign({}, state, action.payload);
        }
        default: {
            return state;
        }
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @return {?}
 */
function getReducers$3() {
    return {
        customerSearchResult: loaderReducer(CUSTOMER_SEARCH_DATA),
        asmUi: reducer$7,
        csagentToken: loaderReducer(CSAGENT_TOKEN_DATA),
    };
}
/** @type {?} */
const reducerToken$3 = new InjectionToken('AsmReducers');
/** @type {?} */
const reducerProvider$3 = {
    provide: reducerToken$3,
    useFactory: getReducers$3,
};
/**
 * @param {?} reducer
 * @return {?}
 */
function clearCustomerSupportAgentAsmState(reducer) {
    return (/**
     * @param {?} state
     * @param {?} action
     * @return {?}
     */
    function (state, action) {
        if (action.type === LOGOUT_CUSTOMER_SUPPORT_AGENT) {
            state = Object.assign({}, state, { customerSearchResult: undefined, csagentToken: undefined });
        }
        return reducer(state, action);
    });
}
/** @type {?} */
const metaReducers$2 = [
    clearCustomerSupportAgentAsmState,
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @return {?}
 */
function asmStoreConfigFactory() {
    /** @type {?} */
    const config = {
        state: {
            storageSync: {
                keys: {
                    'asm.asmUi': StorageSyncType.LOCAL_STORAGE,
                    'asm.csagentToken.value.access_token': StorageSyncType.LOCAL_STORAGE,
                    'asm.csagentToken.value.token_type': StorageSyncType.LOCAL_STORAGE,
                    'asm.csagentToken.value.expires_in': StorageSyncType.LOCAL_STORAGE,
                    'asm.csagentToken.value.expiration_time': StorageSyncType.LOCAL_STORAGE,
                    'asm.csagentToken.value.scope': StorageSyncType.LOCAL_STORAGE,
                    'asm.csagentToken.value.userId': StorageSyncType.LOCAL_STORAGE,
                },
            },
        },
    };
    return config;
}
class AsmStoreModule {
}
AsmStoreModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    HttpClientModule,
                    StateModule,
                    StoreModule.forFeature(ASM_FEATURE, reducerToken$3, { metaReducers: metaReducers$2 }),
                    EffectsModule.forFeature(effects$3),
                    ConfigModule.withConfigFactory(asmStoreConfigFactory),
                ],
                providers: [reducerProvider$3],
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const getAsmState = createFeatureSelector(ASM_FEATURE);

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
const ɵ0$r = /**
 * @param {?} state
 * @return {?}
 */
(state) => state.asmUi;
/** @type {?} */
const getAsmUi = createSelector(getAsmState, (ɵ0$r));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
const ɵ0$s = /**
 * @param {?} state
 * @return {?}
 */
(state) => state.customerSearchResult;
/** @type {?} */
const getCustomerSearchResultsLoaderState = createSelector(getAsmState, (ɵ0$s));
const ɵ1$l = /**
 * @param {?} state
 * @return {?}
 */
state => loaderValueSelector(state);
/** @type {?} */
const getCustomerSearchResults = createSelector(getCustomerSearchResultsLoaderState, (ɵ1$l));
const ɵ2$e = /**
 * @param {?} state
 * @return {?}
 */
state => loaderLoadingSelector(state);
/** @type {?} */
const getCustomerSearchResultsLoading = createSelector(getCustomerSearchResultsLoaderState, (ɵ2$e));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
const ɵ0$t = /**
 * @param {?} state
 * @return {?}
 */
(state) => state.csagentToken;
/** @type {?} */
const getCustomerSupportAgentTokenState = createSelector(getAsmState, (ɵ0$t));
const ɵ1$m = /**
 * @param {?} state
 * @return {?}
 */
state => loaderValueSelector(state);
/** @type {?} */
const getCustomerSupportAgentToken = createSelector(getCustomerSupportAgentTokenState, (ɵ1$m));
const ɵ2$f = /**
 * @param {?} state
 * @return {?}
 */
state => loaderLoadingSelector(state);
/** @type {?} */
const getCustomerSupportAgentTokenLoading = createSelector(getCustomerSupportAgentTokenState, (ɵ2$f));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

var asmGroup_selectors = /*#__PURE__*/Object.freeze({
    getAsmUi: getAsmUi,
    getCustomerSearchResultsLoaderState: getCustomerSearchResultsLoaderState,
    getCustomerSearchResults: getCustomerSearchResults,
    getCustomerSearchResultsLoading: getCustomerSearchResultsLoading,
    getAsmState: getAsmState,
    getCustomerSupportAgentTokenState: getCustomerSupportAgentTokenState,
    getCustomerSupportAgentToken: getCustomerSupportAgentToken,
    getCustomerSupportAgentTokenLoading: getCustomerSupportAgentTokenLoading
});

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class AsmAuthService {
    /**
     * @param {?} store
     * @param {?} authService
     */
    constructor(store, authService) {
        this.store = store;
        this.authService = authService;
    }
    /**
     * Loads a user token for a customer support agent
     * @param {?} userId
     * @param {?} password
     * @return {?}
     */
    authorizeCustomerSupportAgent(userId, password) {
        this.store.dispatch(new LoadCustomerSupportAgentToken({
            userId: userId,
            password: password,
        }));
    }
    /**
     * Starts an ASM customer emulation session.
     * A customer emulation session is stoped by calling logout().
     * @param {?} customerSupportAgentToken
     * @param {?} customerId
     * @return {?}
     */
    startCustomerEmulationSession(customerSupportAgentToken, customerId) {
        this.authService.authorizeWithToken(Object.assign({}, customerSupportAgentToken, { userId: customerId }));
    }
    /**
     * Utility function to determine if a given token is a customer emulation session token.
     * @param {?} userToken
     * @return {?}
     */
    isCustomerEmulationToken(userToken) {
        return (Boolean(userToken) &&
            Boolean(userToken.userId) &&
            userToken.userId !== OCC_USER_ID_CURRENT);
    }
    /**
     * Returns the customer support agent's token
     * @return {?}
     */
    getCustomerSupportAgentToken() {
        return this.store.pipe(select(getCustomerSupportAgentToken));
    }
    /**
     * Returns the customer support agent's token loading status
     * @return {?}
     */
    getCustomerSupportAgentTokenLoading() {
        return this.store.pipe(select(getCustomerSupportAgentTokenLoading));
    }
    /**
     * Logout a customer support agent
     * @return {?}
     */
    logoutCustomerSupportAgent() {
        this.getCustomerSupportAgentToken()
            .pipe(take(1))
            .subscribe((/**
         * @param {?} userToken
         * @return {?}
         */
        userToken => {
            this.store.dispatch(new LogoutCustomerSupportAgent());
            this.store.dispatch(new RevokeUserToken(userToken));
        }));
    }
}
AsmAuthService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root',
            },] }
];
/** @nocollapse */
AsmAuthService.ctorParameters = () => [
    { type: Store },
    { type: AuthService }
];
/** @nocollapse */ AsmAuthService.ngInjectableDef = ɵɵdefineInjectable({ factory: function AsmAuthService_Factory() { return new AsmAuthService(ɵɵinject(Store), ɵɵinject(AuthService)); }, token: AsmAuthService, providedIn: "root" });
if (false) {
    /**
     * @type {?}
     * @protected
     */
    AsmAuthService.prototype.store;
    /**
     * @type {?}
     * @protected
     */
    AsmAuthService.prototype.authService;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class CustomerSupportAgentTokenInterceptor {
    /**
     * @param {?} asmAuthService
     */
    constructor(asmAuthService) {
        this.asmAuthService = asmAuthService;
    }
    /**
     * @param {?} request
     * @param {?} next
     * @return {?}
     */
    intercept(request, next) {
        return this.getCustomerSupportAgentToken(request).pipe(take(1), switchMap((/**
         * @param {?} token
         * @return {?}
         */
        (token) => {
            if (token) {
                request = request.clone({
                    setHeaders: {
                        Authorization: `${token.token_type} ${token.access_token}`,
                    },
                });
            }
            return next.handle(request);
        })));
    }
    /**
     * @private
     * @param {?} request
     * @return {?}
     */
    getCustomerSupportAgentToken(request) {
        if (InterceptorUtil.getInterceptorParam(USE_CUSTOMER_SUPPORT_AGENT_TOKEN, request.headers)) {
            return this.asmAuthService.getCustomerSupportAgentToken();
        }
        return of(null);
    }
}
CustomerSupportAgentTokenInterceptor.decorators = [
    { type: Injectable, args: [{ providedIn: 'root' },] }
];
/** @nocollapse */
CustomerSupportAgentTokenInterceptor.ctorParameters = () => [
    { type: AsmAuthService }
];
/** @nocollapse */ CustomerSupportAgentTokenInterceptor.ngInjectableDef = ɵɵdefineInjectable({ factory: function CustomerSupportAgentTokenInterceptor_Factory() { return new CustomerSupportAgentTokenInterceptor(ɵɵinject(AsmAuthService)); }, token: CustomerSupportAgentTokenInterceptor, providedIn: "root" });
if (false) {
    /**
     * @type {?}
     * @private
     */
    CustomerSupportAgentTokenInterceptor.prototype.asmAuthService;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {string} */
const GlobalMessageType = {
    MSG_TYPE_CONFIRMATION: '[GlobalMessage] Confirmation',
    MSG_TYPE_ERROR: '[GlobalMessage] Error',
    MSG_TYPE_INFO: '[GlobalMessage] Information',
};
/**
 * @record
 */
function GlobalMessage() { }
if (false) {
    /** @type {?} */
    GlobalMessage.prototype.text;
    /** @type {?} */
    GlobalMessage.prototype.type;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @abstract
 */
class GlobalMessageConfig {
}
if (false) {
    /** @type {?} */
    GlobalMessageConfig.prototype.globalMessages;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const ADD_MESSAGE = '[Global-message] Add a Message';
/** @type {?} */
const REMOVE_MESSAGE = '[Global-message] Remove a Message';
/** @type {?} */
const REMOVE_MESSAGES_BY_TYPE = '[Global-message] Remove messages by type';
class AddMessage {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        this.payload = payload;
        this.type = ADD_MESSAGE;
    }
}
if (false) {
    /** @type {?} */
    AddMessage.prototype.type;
    /** @type {?} */
    AddMessage.prototype.payload;
}
class RemoveMessage {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        this.payload = payload;
        this.type = REMOVE_MESSAGE;
    }
}
if (false) {
    /** @type {?} */
    RemoveMessage.prototype.type;
    /** @type {?} */
    RemoveMessage.prototype.payload;
}
class RemoveMessagesByType {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        this.payload = payload;
        this.type = REMOVE_MESSAGES_BY_TYPE;
    }
}
if (false) {
    /** @type {?} */
    RemoveMessagesByType.prototype.type;
    /** @type {?} */
    RemoveMessagesByType.prototype.payload;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

var globalMessageGroup_actions = /*#__PURE__*/Object.freeze({
    ADD_MESSAGE: ADD_MESSAGE,
    REMOVE_MESSAGE: REMOVE_MESSAGE,
    REMOVE_MESSAGES_BY_TYPE: REMOVE_MESSAGES_BY_TYPE,
    AddMessage: AddMessage,
    RemoveMessage: RemoveMessage,
    RemoveMessagesByType: RemoveMessagesByType
});

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const GLOBAL_MESSAGE_FEATURE = 'global-message';
/**
 * @record
 */
function StateWithGlobalMessage() { }
if (false) {
    /* Skipping unnamed member:
    [GLOBAL_MESSAGE_FEATURE]: GlobalMessageState;*/
}
/**
 * @record
 */
function GlobalMessageState() { }
if (false) {
    /** @type {?} */
    GlobalMessageState.prototype.entities;
}
/**
 * @record
 */
function GlobalMessageEntities() { }

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const getGlobalMessageState = createFeatureSelector(GLOBAL_MESSAGE_FEATURE);

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
const ɵ0$u = /**
 * @param {?} state
 * @return {?}
 */
(state) => state.entities;
/** @type {?} */
const getGlobalMessageEntities = createSelector(getGlobalMessageState, (ɵ0$u));
/** @type {?} */
const getGlobalMessageEntitiesByType = (/**
 * @param {?} type
 * @return {?}
 */
(type) => {
    return createSelector(getGlobalMessageEntities, (/**
     * @param {?} entities
     * @return {?}
     */
    entities => entities && entities[type]));
});
/** @type {?} */
const getGlobalMessageCountByType = (/**
 * @param {?} type
 * @return {?}
 */
(type) => {
    return createSelector(getGlobalMessageEntitiesByType(type), (/**
     * @param {?} entities
     * @return {?}
     */
    entities => entities && entities.length));
});

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

var globalMessageGroup_selectors = /*#__PURE__*/Object.freeze({
    getGlobalMessageState: getGlobalMessageState,
    getGlobalMessageEntities: getGlobalMessageEntities,
    getGlobalMessageEntitiesByType: getGlobalMessageEntitiesByType,
    getGlobalMessageCountByType: getGlobalMessageCountByType
});

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class GlobalMessageService {
    /**
     * @param {?} store
     */
    constructor(store) {
        this.store = store;
    }
    /**
     * Get all global messages
     * @return {?}
     */
    get() {
        return this.store.pipe(select(getGlobalMessageEntities), filter((/**
         * @param {?} data
         * @return {?}
         */
        data => data !== undefined)));
    }
    /**
     * Add one message into store
     * @param {?} text
     * @param {?} type
     * @return {?}
     */
    add(text, type) {
        this.store.dispatch(new AddMessage({
            text: typeof text === 'string' ? { raw: text } : text,
            type,
        }));
    }
    /**
     * Remove message(s) from store
     * @param {?} type
     * @param {?=} index
     * @return {?}
     */
    remove(type, index) {
        this.store.dispatch(index !== undefined
            ? new RemoveMessage({
                type: type,
                index: index,
            })
            : new RemoveMessagesByType(type));
    }
}
GlobalMessageService.decorators = [
    { type: Injectable }
];
/** @nocollapse */
GlobalMessageService.ctorParameters = () => [
    { type: Store }
];
if (false) {
    /**
     * @type {?}
     * @protected
     */
    GlobalMessageService.prototype.store;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {number} */
const HttpResponseStatus = {
    UNKNOWN: -1,
    BAD_REQUEST: 400,
    FORBIDDEN: 403,
    NOT_FOUND: 404,
    CONFLICT: 409,
    BAD_GATEWAY: 502,
    GATEWAY_TIMEOUT: 504,
    INTERNAL_SERVER_ERROR: 500,
};
HttpResponseStatus[HttpResponseStatus.UNKNOWN] = 'UNKNOWN';
HttpResponseStatus[HttpResponseStatus.BAD_REQUEST] = 'BAD_REQUEST';
HttpResponseStatus[HttpResponseStatus.FORBIDDEN] = 'FORBIDDEN';
HttpResponseStatus[HttpResponseStatus.NOT_FOUND] = 'NOT_FOUND';
HttpResponseStatus[HttpResponseStatus.CONFLICT] = 'CONFLICT';
HttpResponseStatus[HttpResponseStatus.BAD_GATEWAY] = 'BAD_GATEWAY';
HttpResponseStatus[HttpResponseStatus.GATEWAY_TIMEOUT] = 'GATEWAY_TIMEOUT';
HttpResponseStatus[HttpResponseStatus.INTERNAL_SERVER_ERROR] = 'INTERNAL_SERVER_ERROR';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @abstract
 */
class HttpErrorHandler {
    /**
     * @param {?} globalMessageService
     */
    constructor(globalMessageService) {
        this.globalMessageService = globalMessageService;
    }
}
HttpErrorHandler.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root',
            },] }
];
/** @nocollapse */
HttpErrorHandler.ctorParameters = () => [
    { type: GlobalMessageService }
];
/** @nocollapse */ HttpErrorHandler.ngInjectableDef = ɵɵdefineInjectable({ factory: function HttpErrorHandler_Factory() { return new HttpErrorHandler(ɵɵinject(GlobalMessageService)); }, token: HttpErrorHandler, providedIn: "root" });
if (false) {
    /**
     * The http response status number which is handled by this handler.
     * Implementations can set the response status number, i.e. 404, so that
     * the handler can be found by the error interceptor.
     * @type {?}
     */
    HttpErrorHandler.prototype.responseStatus;
    /**
     * @type {?}
     * @protected
     */
    HttpErrorHandler.prototype.globalMessageService;
    /**
     * Handles the error response for the respose status that is register for the handler
     * @abstract
     * @param {?} request
     * @param {?} errorResponse
     * @return {?}
     */
    HttpErrorHandler.prototype.handleError = function (request, errorResponse) { };
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class BadGatewayHandler extends HttpErrorHandler {
    constructor() {
        super(...arguments);
        this.responseStatus = HttpResponseStatus.BAD_GATEWAY;
    }
    /**
     * @return {?}
     */
    handleError() {
        this.globalMessageService.add({ key: 'httpHandlers.badGateway' }, GlobalMessageType.MSG_TYPE_ERROR);
    }
}
BadGatewayHandler.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root',
            },] }
];
/** @nocollapse */ BadGatewayHandler.ngInjectableDef = ɵɵdefineInjectable({ factory: function BadGatewayHandler_Factory() { return new BadGatewayHandler(ɵɵinject(GlobalMessageService)); }, token: BadGatewayHandler, providedIn: "root" });
if (false) {
    /** @type {?} */
    BadGatewayHandler.prototype.responseStatus;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const OAUTH_ENDPOINT$1 = '/authorizationserver/oauth/token';
class BadRequestHandler extends HttpErrorHandler {
    constructor() {
        super(...arguments);
        this.responseStatus = HttpResponseStatus.BAD_REQUEST;
    }
    /**
     * @param {?} request
     * @param {?} response
     * @return {?}
     */
    handleError(request, response) {
        if (response.url.includes(OAUTH_ENDPOINT$1) &&
            response.error &&
            response.error.error === 'invalid_grant' &&
            request.body.get('grant_type') === 'password') {
            this.globalMessageService.add({
                key: 'httpHandlers.badRequestPleaseLoginAgain',
                params: {
                    errorMessage: response.error.error_description || response.message || '',
                },
            }, GlobalMessageType.MSG_TYPE_ERROR);
            this.globalMessageService.remove(GlobalMessageType.MSG_TYPE_CONFIRMATION);
        }
        else {
            if (response.error &&
                response.error.errors &&
                response.error.errors instanceof Array) {
                response.error.errors.forEach((/**
                 * @param {?} error
                 * @return {?}
                 */
                (error) => {
                    /** @type {?} */
                    let errorMessage;
                    if (error.type === 'PasswordMismatchError') {
                        // uses en translation error message instead of backend exception error
                        // @todo: this condition could be removed if backend gives better message
                        errorMessage = {
                            key: 'httpHandlers.badRequestOldPasswordIncorrect',
                        };
                    }
                    else if (error.subjectType === 'cart' &&
                        error.reason === 'notFound') {
                        errorMessage = { key: 'httpHandlers.cartNotFound' };
                    }
                    else if (error.type === 'ValidationError') {
                        // build translation key in case of backend field validation error
                        errorMessage = {
                            key: `httpHandlers.validationErrors.${error.reason}.${error.subject}`,
                        };
                    }
                    else {
                        // this is currently showing up in case we have a page not found. It should be a 404.
                        // see https://jira.hybris.com/browse/CMSX-8516
                        errorMessage = { raw: error.message || '' };
                    }
                    // @todo: remove this condition once backend is improved, see:
                    // https://github.com/SAP/cloud-commerce-spartacus-storefront/issues/6679
                    if (error.type !== 'JaloObjectNoLongerValidError') {
                        this.globalMessageService.add(errorMessage, GlobalMessageType.MSG_TYPE_ERROR);
                    }
                }));
            }
        }
    }
}
BadRequestHandler.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root',
            },] }
];
/** @nocollapse */ BadRequestHandler.ngInjectableDef = ɵɵdefineInjectable({ factory: function BadRequestHandler_Factory() { return new BadRequestHandler(ɵɵinject(GlobalMessageService)); }, token: BadRequestHandler, providedIn: "root" });
if (false) {
    /** @type {?} */
    BadRequestHandler.prototype.responseStatus;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ConflictHandler extends HttpErrorHandler {
    constructor() {
        super(...arguments);
        this.responseStatus = HttpResponseStatus.CONFLICT;
    }
    /**
     * @return {?}
     */
    handleError() {
        this.globalMessageService.add({ key: 'httpHandlers.conflict' }, GlobalMessageType.MSG_TYPE_ERROR);
    }
}
ConflictHandler.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root',
            },] }
];
/** @nocollapse */ ConflictHandler.ngInjectableDef = ɵɵdefineInjectable({ factory: function ConflictHandler_Factory() { return new ConflictHandler(ɵɵinject(GlobalMessageService)); }, token: ConflictHandler, providedIn: "root" });
if (false) {
    /** @type {?} */
    ConflictHandler.prototype.responseStatus;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ForbiddenHandler extends HttpErrorHandler {
    constructor() {
        super(...arguments);
        this.responseStatus = HttpResponseStatus.FORBIDDEN;
    }
    /**
     * @return {?}
     */
    handleError() {
        this.globalMessageService.add({ key: 'httpHandlers.forbidden' }, GlobalMessageType.MSG_TYPE_ERROR);
    }
}
ForbiddenHandler.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root',
            },] }
];
/** @nocollapse */ ForbiddenHandler.ngInjectableDef = ɵɵdefineInjectable({ factory: function ForbiddenHandler_Factory() { return new ForbiddenHandler(ɵɵinject(GlobalMessageService)); }, token: ForbiddenHandler, providedIn: "root" });
if (false) {
    /** @type {?} */
    ForbiddenHandler.prototype.responseStatus;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class GatewayTimeoutHandler extends HttpErrorHandler {
    constructor() {
        super(...arguments);
        this.responseStatus = HttpResponseStatus.GATEWAY_TIMEOUT;
    }
    /**
     * @return {?}
     */
    handleError() {
        this.globalMessageService.add({ key: 'httpHandlers.gatewayTimeout' }, GlobalMessageType.MSG_TYPE_ERROR);
    }
}
GatewayTimeoutHandler.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root',
            },] }
];
/** @nocollapse */ GatewayTimeoutHandler.ngInjectableDef = ɵɵdefineInjectable({ factory: function GatewayTimeoutHandler_Factory() { return new GatewayTimeoutHandler(ɵɵinject(GlobalMessageService)); }, token: GatewayTimeoutHandler, providedIn: "root" });
if (false) {
    /** @type {?} */
    GatewayTimeoutHandler.prototype.responseStatus;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class InternalServerErrorHandler extends HttpErrorHandler {
    constructor() {
        super(...arguments);
        this.responseStatus = HttpResponseStatus.INTERNAL_SERVER_ERROR;
    }
    /**
     * @return {?}
     */
    handleError() {
        this.globalMessageService.add({ key: 'httpHandlers.internalServerError' }, GlobalMessageType.MSG_TYPE_ERROR);
    }
}
InternalServerErrorHandler.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root',
            },] }
];
/** @nocollapse */ InternalServerErrorHandler.ngInjectableDef = ɵɵdefineInjectable({ factory: function InternalServerErrorHandler_Factory() { return new InternalServerErrorHandler(ɵɵinject(GlobalMessageService)); }, token: InternalServerErrorHandler, providedIn: "root" });
if (false) {
    /** @type {?} */
    InternalServerErrorHandler.prototype.responseStatus;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NotFoundHandler extends HttpErrorHandler {
    constructor() {
        super(...arguments);
        this.responseStatus = HttpResponseStatus.NOT_FOUND;
    }
    // empty error handler to avoid we fallabck to the unknown error handler
    /**
     * @return {?}
     */
    handleError() { }
}
NotFoundHandler.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root',
            },] }
];
/** @nocollapse */ NotFoundHandler.ngInjectableDef = ɵɵdefineInjectable({ factory: function NotFoundHandler_Factory() { return new NotFoundHandler(ɵɵinject(GlobalMessageService)); }, token: NotFoundHandler, providedIn: "root" });
if (false) {
    /** @type {?} */
    NotFoundHandler.prototype.responseStatus;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class UnknownErrorHandler extends HttpErrorHandler {
    /**
     * @param {?} globalMessageService
     */
    constructor(globalMessageService) {
        super(globalMessageService);
        this.globalMessageService = globalMessageService;
        this.responseStatus = HttpResponseStatus.UNKNOWN;
    }
    /**
     * @return {?}
     */
    handleError() {
        if (isDevMode()) {
            console.warn(`Unknown http response error: ${this.responseStatus}`);
        }
    }
}
UnknownErrorHandler.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root',
            },] }
];
/** @nocollapse */
UnknownErrorHandler.ctorParameters = () => [
    { type: GlobalMessageService }
];
/** @nocollapse */ UnknownErrorHandler.ngInjectableDef = ɵɵdefineInjectable({ factory: function UnknownErrorHandler_Factory() { return new UnknownErrorHandler(ɵɵinject(GlobalMessageService)); }, token: UnknownErrorHandler, providedIn: "root" });
if (false) {
    /** @type {?} */
    UnknownErrorHandler.prototype.responseStatus;
    /**
     * @type {?}
     * @protected
     */
    UnknownErrorHandler.prototype.globalMessageService;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class HttpErrorInterceptor {
    /**
     * @param {?} handlers
     */
    constructor(handlers) {
        this.handlers = handlers;
        // We reverse the handlers to allow for custom handlers
        // that replace standard handlers
        this.handlers.reverse();
    }
    /**
     * @param {?} request
     * @param {?} next
     * @return {?}
     */
    intercept(request, next) {
        return next.handle(request).pipe(catchError((/**
         * @param {?} response
         * @return {?}
         */
        (response) => {
            if (response instanceof HttpErrorResponse) {
                this.handleErrorResponse(request, response);
                return throwError(response);
            }
        })));
    }
    /**
     * @protected
     * @param {?} request
     * @param {?} response
     * @return {?}
     */
    handleErrorResponse(request, response) {
        /** @type {?} */
        const handler = this.getResponseHandler(response);
        if (handler) {
            handler.handleError(request, response);
        }
    }
    /**
     * return the error handler that matches the `HttpResponseStatus` code.
     * If no handler is available, the UNKNOWN handler is returned.
     * @protected
     * @param {?} response
     * @return {?}
     */
    getResponseHandler(response) {
        /** @type {?} */
        const status = response.status;
        /** @type {?} */
        let handler = this.handlers.find((/**
         * @param {?} h
         * @return {?}
         */
        h => h.responseStatus === status));
        if (!handler) {
            handler = this.handlers.find((/**
             * @param {?} h
             * @return {?}
             */
            h => h.responseStatus === HttpResponseStatus.UNKNOWN));
        }
        return handler;
    }
}
HttpErrorInterceptor.decorators = [
    { type: Injectable, args: [{ providedIn: 'root' },] }
];
/** @nocollapse */
HttpErrorInterceptor.ctorParameters = () => [
    { type: Array, decorators: [{ type: Inject, args: [HttpErrorHandler,] }] }
];
/** @nocollapse */ HttpErrorInterceptor.ngInjectableDef = ɵɵdefineInjectable({ factory: function HttpErrorInterceptor_Factory() { return new HttpErrorInterceptor(ɵɵinject(HttpErrorHandler)); }, token: HttpErrorInterceptor, providedIn: "root" });
if (false) {
    /**
     * @type {?}
     * @protected
     */
    HttpErrorInterceptor.prototype.handlers;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const errorHandlers = [
    {
        provide: HttpErrorHandler,
        useExisting: UnknownErrorHandler,
        multi: true,
    },
    {
        provide: HttpErrorHandler,
        useExisting: BadGatewayHandler,
        multi: true,
    },
    {
        provide: HttpErrorHandler,
        useExisting: BadRequestHandler,
        multi: true,
    },
    {
        provide: HttpErrorHandler,
        useExisting: ConflictHandler,
        multi: true,
    },
    {
        provide: HttpErrorHandler,
        useExisting: ForbiddenHandler,
        multi: true,
    },
    {
        provide: HttpErrorHandler,
        useExisting: GatewayTimeoutHandler,
        multi: true,
    },
    {
        provide: HttpErrorHandler,
        useExisting: InternalServerErrorHandler,
        multi: true,
    },
    {
        provide: HttpErrorHandler,
        useExisting: NotFoundHandler,
        multi: true,
    },
];
/** @type {?} */
const httpErrorInterceptors = [
    {
        provide: HTTP_INTERCEPTORS,
        useExisting: HttpErrorInterceptor,
        multi: true,
    },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const initialState$8 = {
    entities: {},
};
/**
 * @param {?=} state
 * @param {?=} action
 * @return {?}
 */
function reducer$8(state = initialState$8, action) {
    switch (action.type) {
        case ADD_MESSAGE: {
            /** @type {?} */
            const message = action.payload;
            if (state.entities[message.type] === undefined) {
                return Object.assign({}, state, { entities: Object.assign({}, state.entities, { [message.type]: [message.text] }) });
            }
            else {
                /** @type {?} */
                const currentMessages = state.entities[message.type];
                return Object.assign({}, state, { entities: Object.assign({}, state.entities, { [message.type]: [...currentMessages, message.text] }) });
            }
        }
        case REMOVE_MESSAGE: {
            /** @type {?} */
            const msgType = action.payload.type;
            /** @type {?} */
            const msgIndex = action.payload.index;
            if (Object.keys(state.entities).length === 0 ||
                !state.entities[msgType]) {
                return state;
            }
            /** @type {?} */
            const messages = [...state.entities[msgType]];
            messages.splice(msgIndex, 1);
            return Object.assign({}, state, { entities: Object.assign({}, state.entities, { [msgType]: messages }) });
        }
        case REMOVE_MESSAGES_BY_TYPE: {
            /** @type {?} */
            const entities = Object.assign({}, state.entities, { [action.payload]: [] });
            return Object.assign({}, state, { entities });
        }
    }
    return state;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @return {?}
 */
function getReducers$4() {
    return reducer$8;
}
/** @type {?} */
const reducerToken$4 = new InjectionToken('GlobalMessageReducers');
/** @type {?} */
const reducerProvider$4 = {
    provide: reducerToken$4,
    useFactory: getReducers$4,
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class GlobalMessageStoreModule {
}
GlobalMessageStoreModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    StateModule,
                    StoreModule.forFeature(GLOBAL_MESSAGE_FEATURE, reducerToken$4),
                ],
                providers: [reducerProvider$4],
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} objA
 * @param {?} objB
 * @return {?}
 */
function shallowEqualObjects(objA, objB) {
    if (objA === objB) {
        return true;
    }
    if (!objA || !objB) {
        return false;
    }
    /** @type {?} */
    const aKeys = Object.keys(objA);
    /** @type {?} */
    const bKeys = Object.keys(objB);
    /** @type {?} */
    const aKeysLen = aKeys.length;
    /** @type {?} */
    const bKeysLen = bKeys.length;
    if (aKeysLen !== bKeysLen) {
        return false;
    }
    for (let i = 0; i < aKeysLen; i++) {
        /** @type {?} */
        const key = aKeys[i];
        if (objA[key] !== objB[key]) {
            return false;
        }
    }
    return true;
}
/**
 * @param {?} objA
 * @param {?} objB
 * @return {?}
 */
function deepEqualObjects(objA, objB) {
    if (objA === objB) {
        return true; // if both objA and objB are null or undefined and exactly the same
    }
    else if (!(objA instanceof Object) || !(objB instanceof Object)) {
        return false; // if they are not strictly equal, they both need to be Objects
    }
    else if (objA.constructor !== objB.constructor) {
        // they must have the exact same prototype chain, the closest we can do is
        // test their constructor.
        return false;
    }
    else {
        for (const key in objA) {
            if (!objA.hasOwnProperty(key)) {
                continue; // other properties were tested using objA.constructor === y.constructor
            }
            if (!objB.hasOwnProperty(key)) {
                return false; // allows to compare objA[ key ] and objB[ key ] when set to undefined
            }
            if (objA[key] === objB[key]) {
                continue; // if they have the same strict value or identity then they are equal
            }
            if (typeof objA[key] !== 'object') {
                return false; // Numbers, Strings, Functions, Booleans must be strictly equal
            }
            if (!deepEqualObjects(objA[key], objB[key])) {
                return false;
            }
        }
        for (const key in objB) {
            if (objB.hasOwnProperty(key) && !objA.hasOwnProperty(key)) {
                return false;
            }
        }
        return true;
    }
}
/**
 * @param {?} obj
 * @param {?} arr
 * @return {?}
 */
function countOfDeepEqualObjects(obj, arr) {
    return arr.reduce((/**
     * @param {?} acc
     * @param {?} curr
     * @return {?}
     */
    (acc, curr) => {
        if (deepEqualObjects(obj, curr)) {
            acc++;
        }
        return acc;
    }), 0);
}
/**
 * @param {?} obj
 * @param {?} arr
 * @return {?}
 */
function indexOfFirstOccurrence(obj, arr) {
    for (let index = 0; index < arr.length; index++) {
        if (deepEqualObjects(arr[index], obj)) {
            return index;
        }
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class GlobalMessageEffect {
    /**
     * @param {?} actions$
     * @param {?} store
     * @param {?} config
     * @param {?} platformId
     */
    constructor(actions$, store, config, platformId) {
        this.actions$ = actions$;
        this.store = store;
        this.config = config;
        this.platformId = platformId;
        this.removeDuplicated$ = this.actions$.pipe(ofType(ADD_MESSAGE), pluck('payload'), switchMap((/**
         * @param {?} message
         * @return {?}
         */
        (message) => of(message.text).pipe(withLatestFrom(this.store.pipe(select(getGlobalMessageEntitiesByType(message.type)))), filter((/**
         * @param {?} __0
         * @return {?}
         */
        ([text, messages]) => countOfDeepEqualObjects(text, messages) > 1)), map((/**
         * @param {?} __0
         * @return {?}
         */
        ([text, messages]) => new RemoveMessage({
            type: message.type,
            index: indexOfFirstOccurrence(text, messages),
        })))))));
        this.hideAfterDelay$ = isPlatformBrowser(this.platformId) // we don't want to run this logic when doing SSR
            ? this.actions$.pipe(ofType(ADD_MESSAGE), pluck('payload', 'type'), concatMap((/**
             * @param {?} type
             * @return {?}
             */
            (type) => {
                /** @type {?} */
                const config = this.config.globalMessages[type];
                return this.store.pipe(select(getGlobalMessageCountByType(type)), take(1), filter((/**
                 * @param {?} count
                 * @return {?}
                 */
                (count) => config && config.timeout !== undefined && count && count > 0)), delay(config.timeout), switchMap((/**
                 * @return {?}
                 */
                () => of(new RemoveMessage({
                    type,
                    index: 0,
                })))));
            })))
            : EMPTY;
    }
}
GlobalMessageEffect.decorators = [
    { type: Injectable }
];
/** @nocollapse */
GlobalMessageEffect.ctorParameters = () => [
    { type: Actions },
    { type: Store },
    { type: GlobalMessageConfig },
    { type: undefined, decorators: [{ type: Inject, args: [PLATFORM_ID,] }] }
];
__decorate([
    Effect(),
    __metadata("design:type", Observable)
], GlobalMessageEffect.prototype, "removeDuplicated$", void 0);
__decorate([
    Effect(),
    __metadata("design:type", Observable)
], GlobalMessageEffect.prototype, "hideAfterDelay$", void 0);
if (false) {
    /** @type {?} */
    GlobalMessageEffect.prototype.removeDuplicated$;
    /** @type {?} */
    GlobalMessageEffect.prototype.hideAfterDelay$;
    /**
     * @type {?}
     * @private
     */
    GlobalMessageEffect.prototype.actions$;
    /**
     * @type {?}
     * @private
     */
    GlobalMessageEffect.prototype.store;
    /**
     * @type {?}
     * @private
     */
    GlobalMessageEffect.prototype.config;
    /**
     * @type {?}
     * @private
     */
    GlobalMessageEffect.prototype.platformId;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @return {?}
 */
function defaultGlobalMessageConfigFactory() {
    return {
        globalMessages: {
            [GlobalMessageType.MSG_TYPE_CONFIRMATION]: {
                timeout: 3000,
            },
            [GlobalMessageType.MSG_TYPE_INFO]: {
                timeout: 3000,
            },
            [GlobalMessageType.MSG_TYPE_ERROR]: {
                timeout: 7000,
            },
        },
    };
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class GlobalMessageModule {
    /**
     * @return {?}
     */
    static forRoot() {
        return {
            ngModule: GlobalMessageModule,
            providers: [...errorHandlers, ...httpErrorInterceptors],
        };
    }
}
GlobalMessageModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    GlobalMessageStoreModule,
                    EffectsModule.forFeature([GlobalMessageEffect]),
                    ConfigModule.withConfigFactory(defaultGlobalMessageConfigFactory),
                ],
                providers: [
                    GlobalMessageService,
                    { provide: GlobalMessageConfig, useExisting: Config },
                ],
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class CustomerSupportAgentErrorHandlingService {
    /**
     * @param {?} asmAuthService
     * @param {?} globalMessageService
     */
    constructor(asmAuthService, globalMessageService) {
        this.asmAuthService = asmAuthService;
        this.globalMessageService = globalMessageService;
    }
    /**
     * @return {?}
     */
    terminateCustomerSupportAgentExpiredSession() {
        this.asmAuthService.logoutCustomerSupportAgent();
        this.globalMessageService.add({
            key: 'asm.csagentTokenExpired',
        }, GlobalMessageType.MSG_TYPE_ERROR);
    }
}
CustomerSupportAgentErrorHandlingService.decorators = [
    { type: Injectable, args: [{ providedIn: 'root' },] }
];
/** @nocollapse */
CustomerSupportAgentErrorHandlingService.ctorParameters = () => [
    { type: AsmAuthService },
    { type: GlobalMessageService }
];
/** @nocollapse */ CustomerSupportAgentErrorHandlingService.ngInjectableDef = ɵɵdefineInjectable({ factory: function CustomerSupportAgentErrorHandlingService_Factory() { return new CustomerSupportAgentErrorHandlingService(ɵɵinject(AsmAuthService), ɵɵinject(GlobalMessageService)); }, token: CustomerSupportAgentErrorHandlingService, providedIn: "root" });
if (false) {
    /**
     * @type {?}
     * @protected
     */
    CustomerSupportAgentErrorHandlingService.prototype.asmAuthService;
    /**
     * @type {?}
     * @protected
     */
    CustomerSupportAgentErrorHandlingService.prototype.globalMessageService;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class CustomerSupportAgentAuthErrorInterceptor {
    /**
     * @param {?} csagentErrorHandlingService
     */
    constructor(csagentErrorHandlingService) {
        this.csagentErrorHandlingService = csagentErrorHandlingService;
    }
    /**
     * @param {?} request
     * @param {?} next
     * @return {?}
     */
    intercept(request, next) {
        /** @type {?} */
        const isCustomerSupportAgentRequest = this.isCustomerSupportAgentRequest(request);
        if (isCustomerSupportAgentRequest) {
            request = InterceptorUtil.removeHeader(USE_CUSTOMER_SUPPORT_AGENT_TOKEN, request);
        }
        return next.handle(request).pipe(catchError((/**
         * @param {?} errResponse
         * @return {?}
         */
        (errResponse) => {
            if (errResponse instanceof HttpErrorResponse) {
                // Unauthorized
                if (isCustomerSupportAgentRequest && errResponse.status === 401) {
                    this.csagentErrorHandlingService.terminateCustomerSupportAgentExpiredSession();
                    return of((/** @type {?} */ (undefined)));
                }
            }
            return throwError(errResponse);
        })));
    }
    /**
     * @private
     * @param {?} request
     * @return {?}
     */
    isCustomerSupportAgentRequest(request) {
        /** @type {?} */
        const isRequestMapping = InterceptorUtil.getInterceptorParam(USE_CUSTOMER_SUPPORT_AGENT_TOKEN, request.headers);
        return Boolean(isRequestMapping);
    }
}
CustomerSupportAgentAuthErrorInterceptor.decorators = [
    { type: Injectable, args: [{ providedIn: 'root' },] }
];
/** @nocollapse */
CustomerSupportAgentAuthErrorInterceptor.ctorParameters = () => [
    { type: CustomerSupportAgentErrorHandlingService }
];
/** @nocollapse */ CustomerSupportAgentAuthErrorInterceptor.ngInjectableDef = ɵɵdefineInjectable({ factory: function CustomerSupportAgentAuthErrorInterceptor_Factory() { return new CustomerSupportAgentAuthErrorInterceptor(ɵɵinject(CustomerSupportAgentErrorHandlingService)); }, token: CustomerSupportAgentAuthErrorInterceptor, providedIn: "root" });
if (false) {
    /**
     * @type {?}
     * @private
     */
    CustomerSupportAgentAuthErrorInterceptor.prototype.csagentErrorHandlingService;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const interceptors$2 = [
    {
        provide: HTTP_INTERCEPTORS,
        useExisting: CustomerSupportAgentTokenInterceptor,
        multi: true,
    },
    {
        provide: HTTP_INTERCEPTORS,
        useExisting: CustomerSupportAgentAuthErrorInterceptor,
        multi: true,
    },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class AsmModule {
    /**
     * @return {?}
     */
    static forRoot() {
        return {
            ngModule: AsmModule,
            providers: [{ provide: AsmConfig, useExisting: Config }, ...interceptors$2],
        };
    }
}
AsmModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    HttpClientModule,
                    AsmStoreModule,
                    ConfigModule.withConfig(defaultAsmConfig),
                ],
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class AsmService {
    /**
     * @param {?} store
     */
    constructor(store) {
        this.store = store;
    }
    /**
     * Search for customers
     * @param {?} options
     * @return {?}
     */
    customerSearch(options) {
        this.store.dispatch(new CustomerSearch(options));
    }
    /**
     * Reset the customer search result data to the initial state.
     * @return {?}
     */
    customerSearchReset() {
        this.store.dispatch(new CustomerSearchReset());
    }
    /**
     * Returns the customer search result data.
     * @return {?}
     */
    getCustomerSearchResults() {
        return this.store.pipe(select(getCustomerSearchResults));
    }
    /**
     * Returns the customer search result loading status.
     * @return {?}
     */
    getCustomerSearchResultsLoading() {
        return this.store.pipe(select(getCustomerSearchResultsLoading));
    }
    /**
     * Updates the state of the ASM UI
     * @param {?} asmUi
     * @return {?}
     */
    updateAsmUiState(asmUi) {
        this.store.dispatch(new AsmUiUpdate(asmUi));
    }
    /**
     * Get the state of the ASM UI
     * @return {?}
     */
    getAsmUiState() {
        return this.store.pipe(select(getAsmUi));
    }
}
AsmService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root',
            },] }
];
/** @nocollapse */
AsmService.ctorParameters = () => [
    { type: Store }
];
/** @nocollapse */ AsmService.ngInjectableDef = ɵɵdefineInjectable({ factory: function AsmService_Factory() { return new AsmService(ɵɵinject(Store)); }, token: AsmService, providedIn: "root" });
if (false) {
    /**
     * @type {?}
     * @protected
     */
    AsmService.prototype.store;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @record
 */
function CustomerSearchPage() { }
if (false) {
    /** @type {?} */
    CustomerSearchPage.prototype.entries;
    /** @type {?|undefined} */
    CustomerSearchPage.prototype.pagination;
    /** @type {?|undefined} */
    CustomerSearchPage.prototype.sorts;
}
/**
 * @record
 */
function CustomerSearchOptions() { }
if (false) {
    /** @type {?|undefined} */
    CustomerSearchOptions.prototype.query;
    /** @type {?|undefined} */
    CustomerSearchOptions.prototype.pageSize;
}
/**
 * @record
 */
function AsmUi() { }
if (false) {
    /** @type {?|undefined} */
    AsmUi.prototype.collapsed;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @abstract
 */
class PageMetaResolver {
    /**
     * @param {?} page
     * @return {?}
     */
    getScore(page) {
        /** @type {?} */
        let score = 0;
        if (this.pageType) {
            score += page.type === this.pageType ? 1 : -1;
        }
        if (this.pageTemplate) {
            score += page.template === this.pageTemplate ? 1 : -1;
        }
        return score;
    }
}
if (false) {
    /** @type {?} */
    PageMetaResolver.prototype.pageType;
    /** @type {?} */
    PageMetaResolver.prototype.pageTemplate;
    /**
     * The resolve method is no longer preferred and will be removed with release 2.0.
     * The caller `PageMetaService` service is improved to expect all individual resolvers
     * instead, so that the code is easier extensible.
     *
     * @deprecated since version 1.3
     * @abstract
     * @return {?}
     */
    PageMetaResolver.prototype.resolve = function () { };
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// Email Standard RFC 5322:
/** @type {?} */
const EMAIL_PATTERN = /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
// tslint:disable-line
/** @type {?} */
const PASSWORD_PATTERN = /^(?=.*?[A-Z])(?=.*?[0-9])(?=.*?[!@#$%^*()_\-+{};:.,]).{6,}$/;

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const CART_FEATURE = 'cart';
/** @type {?} */
const CART_DATA = '[Cart] Cart Data';
/** @type {?} */
const ADD_VOUCHER_PROCESS_ID = 'addVoucher';
/**
 * @record
 */
function StateWithCart() { }
if (false) {
    /* Skipping unnamed member:
    [CART_FEATURE]: CartsState;*/
}
/**
 * @record
 */
function CartsState() { }
if (false) {
    /** @type {?} */
    CartsState.prototype.active;
}
/**
 * @record
 */
function CartState() { }
if (false) {
    /** @type {?} */
    CartState.prototype.content;
    /** @type {?} */
    CartState.prototype.entries;
    /** @type {?} */
    CartState.prototype.refresh;
    /** @type {?} */
    CartState.prototype.cartMergeComplete;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const getCartContentSelector = (/**
 * @param {?} state
 * @return {?}
 */
(state) => state.content);
const ɵ0$v = getCartContentSelector;
/** @type {?} */
const getCartRefreshSelector = (/**
 * @param {?} state
 * @return {?}
 */
(state) => state.refresh);
const ɵ1$n = getCartRefreshSelector;
/** @type {?} */
const getCartEntriesSelector = (/**
 * @param {?} state
 * @return {?}
 */
(state) => state.entries);
const ɵ2$g = getCartEntriesSelector;
/** @type {?} */
const getCartMergeCompleteSelector = (/**
 * @param {?} state
 * @return {?}
 */
(state) => state.cartMergeComplete);
const ɵ3$9 = getCartMergeCompleteSelector;
/** @type {?} */
const getCartsState = createFeatureSelector(CART_FEATURE);
const ɵ4$2 = /**
 * @param {?} cartsState
 * @return {?}
 */
(cartsState) => cartsState.active;
/** @type {?} */
const getActiveCartState = createSelector(getCartsState, (ɵ4$2));
const ɵ5$2 = /**
 * @param {?} state
 * @return {?}
 */
state => loaderValueSelector(state);
/** @type {?} */
const getCartState = createSelector(getActiveCartState, (ɵ5$2));
/** @type {?} */
const getCartContent = createSelector(getCartState, getCartContentSelector);
/** @type {?} */
const getCartRefresh = createSelector(getCartState, getCartRefreshSelector);
const ɵ6 = /**
 * @param {?} state
 * @return {?}
 */
state => (loaderSuccessSelector(state) &&
    !loaderLoadingSelector(state) &&
    !loaderValueSelector(state).refresh) ||
    (loaderErrorSelector(state) &&
        !loaderLoadingSelector(state) &&
        !loaderValueSelector(state).refresh);
/** @type {?} */
const getCartLoaded = createSelector(getActiveCartState, (ɵ6));
const ɵ7 = /**
 * @param {?} state
 * @return {?}
 */
state => loaderLoadingSelector(state);
/** @type {?} */
const getCartLoading = createSelector(getActiveCartState, (ɵ7));
/** @type {?} */
const getCartMergeComplete = createSelector(getCartState, getCartMergeCompleteSelector);
/** @type {?} */
const getCartEntriesMap = createSelector(getCartState, getCartEntriesSelector);
/** @type {?} */
const getCartEntrySelectorFactory = (/**
 * @param {?} productCode
 * @return {?}
 */
(productCode) => {
    return createSelector(getCartEntriesMap, (/**
     * @param {?} entries
     * @return {?}
     */
    entries => {
        if (entries) {
            return entries[productCode];
        }
    }));
});
const ɵ8 = /**
 * @param {?} entities
 * @return {?}
 */
entities => {
    return Object.keys(entities).map((/**
     * @param {?} code
     * @return {?}
     */
    code => entities[code]));
};
/** @type {?} */
const getCartEntries = createSelector(getCartEntriesMap, (ɵ8));
const ɵ9 = /**
 * @param {?} content
 * @return {?}
 */
content => content.user;
/** @type {?} */
const getCartUser = createSelector(getCartContent, (ɵ9));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

var cartGroup_selectors = /*#__PURE__*/Object.freeze({
    getCartsState: getCartsState,
    getActiveCartState: getActiveCartState,
    getCartState: getCartState,
    getCartContent: getCartContent,
    getCartRefresh: getCartRefresh,
    getCartLoaded: getCartLoaded,
    getCartLoading: getCartLoading,
    getCartMergeComplete: getCartMergeComplete,
    getCartEntriesMap: getCartEntriesMap,
    getCartEntrySelectorFactory: getCartEntrySelectorFactory,
    getCartEntries: getCartEntries,
    getCartUser: getCartUser
});

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const MULTI_CART_FEATURE = 'multi-cart';
/** @type {?} */
const MULTI_CART_DATA = '[Multi Cart] Multi Cart Data';
/**
 * @record
 */
function StateWithMultiCart() { }
if (false) {
    /* Skipping unnamed member:
    [MULTI_CART_FEATURE]: MultiCartState;*/
}
/**
 * @record
 */
function MultiCartState() { }
if (false) {
    /** @type {?} */
    MultiCartState.prototype.carts;
    /** @type {?} */
    MultiCartState.prototype.active;
    /** @type {?} */
    MultiCartState.prototype.wishList;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const getMultiCartState = createFeatureSelector(MULTI_CART_FEATURE);
const ɵ0$w = /**
 * @param {?} state
 * @return {?}
 */
(state) => state.carts;
/** @type {?} */
const getMultiCartEntities = createSelector(getMultiCartState, (ɵ0$w));
/** @type {?} */
const getCartEntitySelectorFactory = (/**
 * @param {?} cartId
 * @return {?}
 */
(cartId) => {
    return createSelector(getMultiCartEntities, (/**
     * @param {?} state
     * @return {?}
     */
    (state) => entityProcessesLoaderStateSelector(state, cartId)));
});
/** @type {?} */
const getCartSelectorFactory = (/**
 * @param {?} cartId
 * @return {?}
 */
(cartId) => {
    return createSelector(getMultiCartEntities, (/**
     * @param {?} state
     * @return {?}
     */
    (state) => entityValueSelector(state, cartId)));
});
/** @type {?} */
const getCartIsStableSelectorFactory = (/**
 * @param {?} cartId
 * @return {?}
 */
(cartId) => {
    return createSelector(getMultiCartEntities, (/**
     * @param {?} state
     * @return {?}
     */
    (state) => entityIsStableSelector(state, cartId)));
});
/** @type {?} */
const getCartHasPendingProcessesSelectorFactory = (/**
 * @param {?} cartId
 * @return {?}
 */
(cartId) => {
    return createSelector(getMultiCartEntities, (/**
     * @param {?} state
     * @return {?}
     */
    (state) => entityHasPendingProcessesSelector(state, cartId)));
});
/** @type {?} */
const getCartEntriesSelectorFactory = (/**
 * @param {?} cartId
 * @return {?}
 */
(cartId) => {
    return createSelector(getCartSelectorFactory(cartId), (/**
     * @param {?} state
     * @return {?}
     */
    (state) => {
        return state && state.entries ? state.entries : [];
    }));
});
/** @type {?} */
const getCartEntrySelectorFactory$1 = (/**
 * @param {?} cartId
 * @param {?} productCode
 * @return {?}
 */
(cartId, productCode) => {
    return createSelector(getCartEntriesSelectorFactory(cartId), (/**
     * @param {?} state
     * @return {?}
     */
    (state) => {
        return state
            ? state.find((/**
             * @param {?} entry
             * @return {?}
             */
            entry => entry.product.code === productCode))
            : undefined;
    }));
});
const ɵ1$o = /**
 * @param {?} state
 * @return {?}
 */
(state) => state.active;
/** @type {?} */
const getActiveCartId = createSelector(getMultiCartState, (ɵ1$o));
const ɵ2$h = /**
 * @param {?} state
 * @return {?}
 */
(state) => state.wishList;
/** @type {?} */
const getWishListId = createSelector(getMultiCartState, (ɵ2$h));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

var multiCartGroup_selectors = /*#__PURE__*/Object.freeze({
    getMultiCartState: getMultiCartState,
    getMultiCartEntities: getMultiCartEntities,
    getCartEntitySelectorFactory: getCartEntitySelectorFactory,
    getCartSelectorFactory: getCartSelectorFactory,
    getCartIsStableSelectorFactory: getCartIsStableSelectorFactory,
    getCartHasPendingProcessesSelectorFactory: getCartHasPendingProcessesSelectorFactory,
    getCartEntriesSelectorFactory: getCartEntriesSelectorFactory,
    getCartEntrySelectorFactory: getCartEntrySelectorFactory$1,
    getActiveCartId: getActiveCartId,
    getWishListId: getWishListId
});

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} cart
 * @param {?} userId
 * @return {?}
 */
function getCartIdByUserId(cart, userId) {
    if (userId === OCC_USER_ID_ANONYMOUS) {
        return cart.guid;
    }
    return cart.code;
}
/**
 * What is a temporary cart?
 * - frontend only cart entity!
 * - can be identified in store by `temp-` prefix with some unique id (multiple carts can be created at the same time eg. active cart, wishlist)
 *
 * Why we need temporary carts?
 * - to have information about cart creation process (meta flags: loading, error - for showing loader, error message)
 * - to know if there is currently a cart creation process in progress (eg. so, we don't create more than one active cart at the same time)
 * - cart identifiers are created in the backend, so those are only known after cart is created
 *
 * Temporary cart lifecycle
 * - create cart method invoked
 * - new `temp-${uuid}` cart is created with `loading=true` state
 * - backend returns created cart
 * - normal cart entity is saved under correct id (eg. for logged user under cart `code` key)
 * - temporary cart value is set to backend response (anyone observing this cart can read code/guid from it and switch selector to normal cart)
 * - in next tick temporary cart is removed
 * @param {?} cartId
 * @return {?}
 */
function isTempCartId(cartId) {
    return cartId.startsWith('temp-');
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const CREATE_CART = '[Cart] Create Cart';
/** @type {?} */
const CREATE_CART_FAIL = '[Cart] Create Cart Fail';
/** @type {?} */
const CREATE_CART_SUCCESS = '[Cart] Create Cart Success';
/** @type {?} */
const LOAD_CART = '[Cart] Load Cart';
/** @type {?} */
const LOAD_CART_FAIL = '[Cart] Load Cart Fail';
/** @type {?} */
const LOAD_CART_SUCCESS = '[Cart] Load Cart Success';
/** @type {?} */
const ADD_EMAIL_TO_CART = '[Cart] Add Email to Cart';
/** @type {?} */
const ADD_EMAIL_TO_CART_FAIL = '[Cart] Add Email to Cart Fail';
/** @type {?} */
const ADD_EMAIL_TO_CART_SUCCESS = '[Cart] Add Email to Cart Success';
/** @type {?} */
const MERGE_CART = '[Cart] Merge Cart';
/** @type {?} */
const MERGE_CART_SUCCESS = '[Cart] Merge Cart Success';
/** @type {?} */
const RESET_CART_DETAILS = '[Cart] Reset Cart Details';
/** @type {?} */
const CLEAR_EXPIRED_COUPONS = '[Cart] Clear Expired Coupon';
/** @type {?} */
const CLEAR_CART = '[Cart] Clear Cart';
/** @type {?} */
const DELETE_CART = '[Cart] Delete Cart';
/** @type {?} */
const DELETE_CART_FAIL = '[Cart] Delete Cart Fail';
class CreateCart extends LoaderLoadAction {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        super(CART_DATA);
        this.payload = payload;
        this.type = CREATE_CART;
    }
}
if (false) {
    /** @type {?} */
    CreateCart.prototype.type;
    /** @type {?} */
    CreateCart.prototype.payload;
}
class CreateCartFail extends LoaderFailAction {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        super(CART_DATA, payload);
        this.payload = payload;
        this.type = CREATE_CART_FAIL;
    }
}
if (false) {
    /** @type {?} */
    CreateCartFail.prototype.type;
    /** @type {?} */
    CreateCartFail.prototype.payload;
}
class CreateCartSuccess extends LoaderSuccessAction {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        super(CART_DATA);
        this.payload = payload;
        this.type = CREATE_CART_SUCCESS;
    }
}
if (false) {
    /** @type {?} */
    CreateCartSuccess.prototype.type;
    /** @type {?} */
    CreateCartSuccess.prototype.payload;
}
class AddEmailToCart extends LoaderLoadAction {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        super(CART_DATA);
        this.payload = payload;
        this.type = ADD_EMAIL_TO_CART;
    }
}
if (false) {
    /** @type {?} */
    AddEmailToCart.prototype.type;
    /** @type {?} */
    AddEmailToCart.prototype.payload;
}
class AddEmailToCartFail extends LoaderFailAction {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        super(CART_DATA, payload);
        this.payload = payload;
        this.type = ADD_EMAIL_TO_CART_FAIL;
    }
}
if (false) {
    /** @type {?} */
    AddEmailToCartFail.prototype.type;
    /** @type {?} */
    AddEmailToCartFail.prototype.payload;
}
class AddEmailToCartSuccess extends LoaderSuccessAction {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        super(CART_DATA);
        this.payload = payload;
        this.type = ADD_EMAIL_TO_CART_SUCCESS;
    }
}
if (false) {
    /** @type {?} */
    AddEmailToCartSuccess.prototype.type;
    /** @type {?} */
    AddEmailToCartSuccess.prototype.payload;
}
class LoadCart extends LoaderLoadAction {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        super(CART_DATA);
        this.payload = payload;
        this.type = LOAD_CART;
    }
}
if (false) {
    /** @type {?} */
    LoadCart.prototype.type;
    /** @type {?} */
    LoadCart.prototype.payload;
}
class LoadCartFail extends LoaderFailAction {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        super(CART_DATA, payload);
        this.payload = payload;
        this.type = LOAD_CART_FAIL;
    }
}
if (false) {
    /** @type {?} */
    LoadCartFail.prototype.type;
    /** @type {?} */
    LoadCartFail.prototype.payload;
}
class LoadCartSuccess extends LoaderSuccessAction {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        super(CART_DATA);
        this.payload = payload;
        this.type = LOAD_CART_SUCCESS;
    }
}
if (false) {
    /** @type {?} */
    LoadCartSuccess.prototype.type;
    /** @type {?} */
    LoadCartSuccess.prototype.payload;
}
class MergeCart {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        this.payload = payload;
        this.type = MERGE_CART;
    }
}
if (false) {
    /** @type {?} */
    MergeCart.prototype.type;
    /** @type {?} */
    MergeCart.prototype.payload;
}
class MergeCartSuccess {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        this.payload = payload;
        this.type = MERGE_CART_SUCCESS;
    }
}
if (false) {
    /** @type {?} */
    MergeCartSuccess.prototype.type;
    /** @type {?} */
    MergeCartSuccess.prototype.payload;
}
class ResetCartDetails {
    constructor() {
        this.type = RESET_CART_DETAILS;
    }
}
if (false) {
    /** @type {?} */
    ResetCartDetails.prototype.type;
}
class ClearExpiredCoupons {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        this.payload = payload;
        this.type = CLEAR_EXPIRED_COUPONS;
    }
}
if (false) {
    /** @type {?} */
    ClearExpiredCoupons.prototype.type;
    /** @type {?} */
    ClearExpiredCoupons.prototype.payload;
}
class ClearCart extends LoaderResetAction {
    constructor() {
        super(CART_DATA);
        this.type = CLEAR_CART;
    }
}
if (false) {
    /** @type {?} */
    ClearCart.prototype.type;
}
class DeleteCart extends LoaderLoadAction {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        super(CART_DATA);
        this.payload = payload;
        this.type = DELETE_CART;
    }
}
if (false) {
    /** @type {?} */
    DeleteCart.prototype.type;
    /** @type {?} */
    DeleteCart.prototype.payload;
}
class DeleteCartFail extends LoaderFailAction {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        super(CART_DATA, payload);
        this.payload = payload;
        this.type = DELETE_CART_FAIL;
    }
}
if (false) {
    /** @type {?} */
    DeleteCartFail.prototype.type;
    /** @type {?} */
    DeleteCartFail.prototype.payload;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const CART_ADD_ENTRY = '[Cart-entry] Add Entry';
/** @type {?} */
const CART_ADD_ENTRY_SUCCESS = '[Cart-entry] Add Entry Success';
/** @type {?} */
const CART_ADD_ENTRY_FAIL = '[Cart-entry] Add Entry Fail';
/** @type {?} */
const CART_REMOVE_ENTRY = '[Cart-entry] Remove Entry';
/** @type {?} */
const CART_REMOVE_ENTRY_SUCCESS = '[Cart-entry] Remove Entry Success';
/** @type {?} */
const CART_REMOVE_ENTRY_FAIL = '[Cart-entry] Remove Entry Fail';
/** @type {?} */
const CART_UPDATE_ENTRY = '[Cart-entry] Update Entry';
/** @type {?} */
const CART_UPDATE_ENTRY_SUCCESS = '[Cart-entry] Update Entry Success';
/** @type {?} */
const CART_UPDATE_ENTRY_FAIL = '[Cart-entry] Update Entry Fail';
class CartAddEntry extends LoaderLoadAction {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        super(CART_DATA);
        this.payload = payload;
        this.type = CART_ADD_ENTRY;
    }
}
if (false) {
    /** @type {?} */
    CartAddEntry.prototype.type;
    /** @type {?} */
    CartAddEntry.prototype.payload;
}
class CartAddEntrySuccess extends LoaderSuccessAction {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        super(CART_DATA);
        this.payload = payload;
        this.type = CART_ADD_ENTRY_SUCCESS;
    }
}
if (false) {
    /** @type {?} */
    CartAddEntrySuccess.prototype.type;
    /** @type {?} */
    CartAddEntrySuccess.prototype.payload;
}
class CartAddEntryFail extends LoaderFailAction {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        super(CART_DATA, payload);
        this.payload = payload;
        this.type = CART_ADD_ENTRY_FAIL;
    }
}
if (false) {
    /** @type {?} */
    CartAddEntryFail.prototype.type;
    /** @type {?} */
    CartAddEntryFail.prototype.payload;
}
class CartRemoveEntry extends LoaderLoadAction {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        super(CART_DATA);
        this.payload = payload;
        this.type = CART_REMOVE_ENTRY;
    }
}
if (false) {
    /** @type {?} */
    CartRemoveEntry.prototype.type;
    /** @type {?} */
    CartRemoveEntry.prototype.payload;
}
class CartRemoveEntrySuccess extends LoaderSuccessAction {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        super(CART_DATA);
        this.payload = payload;
        this.type = CART_REMOVE_ENTRY_SUCCESS;
    }
}
if (false) {
    /** @type {?} */
    CartRemoveEntrySuccess.prototype.type;
    /** @type {?} */
    CartRemoveEntrySuccess.prototype.payload;
}
class CartRemoveEntryFail extends LoaderFailAction {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        super(CART_DATA, payload);
        this.payload = payload;
        this.type = CART_REMOVE_ENTRY_FAIL;
    }
}
if (false) {
    /** @type {?} */
    CartRemoveEntryFail.prototype.type;
    /** @type {?} */
    CartRemoveEntryFail.prototype.payload;
}
class CartUpdateEntry extends LoaderLoadAction {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        super(CART_DATA);
        this.payload = payload;
        this.type = CART_UPDATE_ENTRY;
    }
}
if (false) {
    /** @type {?} */
    CartUpdateEntry.prototype.type;
    /** @type {?} */
    CartUpdateEntry.prototype.payload;
}
class CartUpdateEntrySuccess extends LoaderSuccessAction {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        super(CART_DATA);
        this.payload = payload;
        this.type = CART_UPDATE_ENTRY_SUCCESS;
    }
}
if (false) {
    /** @type {?} */
    CartUpdateEntrySuccess.prototype.type;
    /** @type {?} */
    CartUpdateEntrySuccess.prototype.payload;
}
class CartUpdateEntryFail extends LoaderFailAction {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        super(CART_DATA, payload);
        this.payload = payload;
        this.type = CART_UPDATE_ENTRY_FAIL;
    }
}
if (false) {
    /** @type {?} */
    CartUpdateEntryFail.prototype.type;
    /** @type {?} */
    CartUpdateEntryFail.prototype.payload;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const CART_ADD_VOUCHER = '[Cart-voucher] Add Cart Vouchers';
/** @type {?} */
const CART_ADD_VOUCHER_FAIL = '[Cart-voucher] Add Cart Voucher Fail';
/** @type {?} */
const CART_ADD_VOUCHER_SUCCESS = '[Cart-voucher] Add Cart Voucher Success';
/** @type {?} */
const CART_RESET_ADD_VOUCHER = '[Cart-voucher] Reset Add Cart Voucher';
/** @type {?} */
const CART_REMOVE_VOUCHER = '[Cart-voucher] Remove Cart Voucher';
/** @type {?} */
const CART_REMOVE_VOUCHER_FAIL = '[Cart-voucher] Remove Cart Voucher Fail';
/** @type {?} */
const CART_REMOVE_VOUCHER_SUCCESS = '[Cart-voucher] Remove Cart Voucher Success';
// Adding cart voucher actions
class CartAddVoucher extends EntityLoadAction {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        super(PROCESS_FEATURE, ADD_VOUCHER_PROCESS_ID);
        this.payload = payload;
        this.type = CART_ADD_VOUCHER;
    }
}
if (false) {
    /** @type {?} */
    CartAddVoucher.prototype.type;
    /** @type {?} */
    CartAddVoucher.prototype.payload;
}
class CartAddVoucherFail extends EntityFailAction {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        super(PROCESS_FEATURE, ADD_VOUCHER_PROCESS_ID, payload);
        this.payload = payload;
        this.type = CART_ADD_VOUCHER_FAIL;
    }
}
if (false) {
    /** @type {?} */
    CartAddVoucherFail.prototype.type;
    /** @type {?} */
    CartAddVoucherFail.prototype.payload;
}
class CartAddVoucherSuccess extends EntitySuccessAction {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        super(PROCESS_FEATURE, ADD_VOUCHER_PROCESS_ID);
        this.payload = payload;
        this.type = CART_ADD_VOUCHER_SUCCESS;
    }
}
if (false) {
    /** @type {?} */
    CartAddVoucherSuccess.prototype.type;
    /** @type {?} */
    CartAddVoucherSuccess.prototype.payload;
}
class CartResetAddVoucher extends EntityResetAction {
    constructor() {
        super(PROCESS_FEATURE, ADD_VOUCHER_PROCESS_ID);
        this.type = CART_RESET_ADD_VOUCHER;
    }
}
if (false) {
    /** @type {?} */
    CartResetAddVoucher.prototype.type;
}
// Deleting cart voucher
class CartRemoveVoucher extends LoaderLoadAction {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        super(CART_DATA);
        this.payload = payload;
        this.type = CART_REMOVE_VOUCHER;
    }
}
if (false) {
    /** @type {?} */
    CartRemoveVoucher.prototype.type;
    /** @type {?} */
    CartRemoveVoucher.prototype.payload;
}
class CartRemoveVoucherFail extends LoaderFailAction {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        super(CART_DATA, payload);
        this.payload = payload;
        this.type = CART_REMOVE_VOUCHER_FAIL;
    }
}
if (false) {
    /** @type {?} */
    CartRemoveVoucherFail.prototype.type;
    /** @type {?} */
    CartRemoveVoucherFail.prototype.payload;
}
class CartRemoveVoucherSuccess extends LoaderSuccessAction {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        super(CART_DATA);
        this.payload = payload;
        this.type = CART_REMOVE_VOUCHER_SUCCESS;
    }
}
if (false) {
    /** @type {?} */
    CartRemoveVoucherSuccess.prototype.type;
    /** @type {?} */
    CartRemoveVoucherSuccess.prototype.payload;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const REMOVE_TEMP_CART = '[Multi Cart] Remove Temp Cart';
/** @type {?} */
const CREATE_MULTI_CART = '[Multi Cart] Create Cart';
/** @type {?} */
const CREATE_MULTI_CART_FAIL = '[Multi Cart] Create Cart Fail';
/** @type {?} */
const CREATE_MULTI_CART_SUCCESS = '[Multi Cart] Create Cart Success';
/** @type {?} */
const LOAD_MULTI_CART = '[Multi Cart] Load Cart';
/** @type {?} */
const LOAD_MULTI_CART_FAIL = '[Multi Cart] Load Cart Fail';
/** @type {?} */
const LOAD_MULTI_CART_SUCCESS = '[Multi Cart] Load Cart Success';
/** @type {?} */
const MERGE_MULTI_CART = '[Multi Cart] Merge Cart';
/** @type {?} */
const MERGE_MULTI_CART_SUCCESS = '[Multi Cart] Merge Cart Success';
/** @type {?} */
const RESET_MULTI_CART_DETAILS = '[Multi Cart] Reset Cart Details';
/** @type {?} */
const SET_TEMP_CART = '[Multi Cart] Set Temp Cart';
/** @type {?} */
const REMOVE_CART = '[Multi Cart] Remove Cart';
/** @type {?} */
const ADD_EMAIL_TO_MULTI_CART = '[Multi Cart] Add Email';
/** @type {?} */
const ADD_EMAIL_TO_MULTI_CART_FAIL = '[Multi Cart] Add Email Fail';
/** @type {?} */
const ADD_EMAIL_TO_MULTI_CART_SUCCESS = '[Multi Cart] Add Email Success';
/** @type {?} */
const CART_PROCESSES_INCREMENT = '[Multi Cart] Cart Processes Increment';
/** @type {?} */
const CART_PROCESSES_DECREMENT = '[Multi Cart] Cart Processes Decrement';
/**
 * To keep track of cart creation process we use cart with `temp-${uuid}` id.
 * After creating cart we switch to entity with `code` or `guid`.
 * We need `temp-${uuid}` cart entities for loading/error state.
 */
class RemoveTempCart extends EntityRemoveAction {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        super(MULTI_CART_FEATURE, payload.tempCartId);
        this.payload = payload;
        this.type = REMOVE_TEMP_CART;
    }
}
if (false) {
    /** @type {?} */
    RemoveTempCart.prototype.type;
    /** @type {?} */
    RemoveTempCart.prototype.payload;
}
class SetTempCart extends EntitySuccessAction {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        super(MULTI_CART_FEATURE, payload.tempCartId, payload.cart);
        this.payload = payload;
        this.type = SET_TEMP_CART;
    }
}
if (false) {
    /** @type {?} */
    SetTempCart.prototype.type;
    /** @type {?} */
    SetTempCart.prototype.payload;
}
class CreateMultiCart extends EntityLoadAction {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        super(MULTI_CART_FEATURE, payload.tempCartId);
        this.payload = payload;
        this.type = CREATE_MULTI_CART;
    }
}
if (false) {
    /** @type {?} */
    CreateMultiCart.prototype.type;
    /** @type {?} */
    CreateMultiCart.prototype.payload;
}
class CreateMultiCartFail extends EntityFailAction {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        super(MULTI_CART_FEATURE, payload.tempCartId);
        this.payload = payload;
        this.type = CREATE_MULTI_CART_FAIL;
    }
}
if (false) {
    /** @type {?} */
    CreateMultiCartFail.prototype.type;
    /** @type {?} */
    CreateMultiCartFail.prototype.payload;
}
class CreateMultiCartSuccess extends EntitySuccessAction {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        super(MULTI_CART_FEATURE, getCartIdByUserId(payload.cart, payload.userId));
        this.payload = payload;
        this.type = CREATE_MULTI_CART_SUCCESS;
    }
}
if (false) {
    /** @type {?} */
    CreateMultiCartSuccess.prototype.type;
    /** @type {?} */
    CreateMultiCartSuccess.prototype.payload;
}
class LoadMultiCart extends EntityLoadAction {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        super(MULTI_CART_FEATURE, payload.cartId);
        this.payload = payload;
        this.type = LOAD_MULTI_CART;
    }
}
if (false) {
    /** @type {?} */
    LoadMultiCart.prototype.type;
    /** @type {?} */
    LoadMultiCart.prototype.payload;
}
class LoadMultiCartFail extends EntityFailAction {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        super(MULTI_CART_FEATURE, payload.cartId, payload.error);
        this.payload = payload;
        this.type = LOAD_MULTI_CART_FAIL;
    }
}
if (false) {
    /** @type {?} */
    LoadMultiCartFail.prototype.type;
    /** @type {?} */
    LoadMultiCartFail.prototype.payload;
}
class LoadMultiCartSuccess extends EntitySuccessAction {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        super(MULTI_CART_FEATURE, getCartIdByUserId(payload.cart, payload.userId));
        this.payload = payload;
        this.type = LOAD_MULTI_CART_SUCCESS;
    }
}
if (false) {
    /** @type {?} */
    LoadMultiCartSuccess.prototype.type;
    /** @type {?} */
    LoadMultiCartSuccess.prototype.payload;
}
class MergeMultiCart {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        this.payload = payload;
        this.type = MERGE_MULTI_CART;
    }
}
if (false) {
    /** @type {?} */
    MergeMultiCart.prototype.type;
    /** @type {?} */
    MergeMultiCart.prototype.payload;
}
class MergeMultiCartSuccess extends EntityRemoveAction {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        super(MULTI_CART_FEATURE, payload.oldCartId);
        this.payload = payload;
        this.type = MERGE_MULTI_CART_SUCCESS;
    }
}
if (false) {
    /** @type {?} */
    MergeMultiCartSuccess.prototype.type;
    /** @type {?} */
    MergeMultiCartSuccess.prototype.payload;
}
class ResetMultiCartDetails extends EntityProcessesLoaderResetAction {
    constructor() {
        super(MULTI_CART_FEATURE, undefined);
        this.type = RESET_MULTI_CART_DETAILS;
    }
}
if (false) {
    /** @type {?} */
    ResetMultiCartDetails.prototype.type;
}
class RemoveCart extends EntityRemoveAction {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        super(MULTI_CART_FEATURE, payload);
        this.payload = payload;
        this.type = REMOVE_CART;
    }
}
if (false) {
    /** @type {?} */
    RemoveCart.prototype.type;
    /** @type {?} */
    RemoveCart.prototype.payload;
}
class AddEmailToMultiCart extends EntityLoadAction {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        super(MULTI_CART_FEATURE, payload.cartId);
        this.payload = payload;
        this.type = ADD_EMAIL_TO_MULTI_CART;
    }
}
if (false) {
    /** @type {?} */
    AddEmailToMultiCart.prototype.type;
    /** @type {?} */
    AddEmailToMultiCart.prototype.payload;
}
class AddEmailToMultiCartFail extends EntityFailAction {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        super(MULTI_CART_FEATURE, payload.cartId, payload.error);
        this.payload = payload;
        this.type = ADD_EMAIL_TO_MULTI_CART_FAIL;
    }
}
if (false) {
    /** @type {?} */
    AddEmailToMultiCartFail.prototype.type;
    /** @type {?} */
    AddEmailToMultiCartFail.prototype.payload;
}
class AddEmailToMultiCartSuccess extends EntitySuccessAction {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        super(MULTI_CART_FEATURE, payload.cartId);
        this.payload = payload;
        this.type = ADD_EMAIL_TO_MULTI_CART_SUCCESS;
    }
}
if (false) {
    /** @type {?} */
    AddEmailToMultiCartSuccess.prototype.type;
    /** @type {?} */
    AddEmailToMultiCartSuccess.prototype.payload;
}
class CartProcessesIncrement extends EntityProcessesIncrementAction {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        super(MULTI_CART_FEATURE, payload);
        this.payload = payload;
        this.type = CART_PROCESSES_INCREMENT;
    }
}
if (false) {
    /** @type {?} */
    CartProcessesIncrement.prototype.type;
    /** @type {?} */
    CartProcessesIncrement.prototype.payload;
}
class CartProcessesDecrement extends EntityProcessesDecrementAction {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        super(MULTI_CART_FEATURE, payload);
        this.payload = payload;
        this.type = CART_PROCESSES_DECREMENT;
    }
}
if (false) {
    /** @type {?} */
    CartProcessesDecrement.prototype.type;
    /** @type {?} */
    CartProcessesDecrement.prototype.payload;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const CREATE_WISH_LIST = '[Wish List] Create Wish List';
/** @type {?} */
const CREATE_WISH_LIST_FAIL = '[Wish List] Create Wish List Fail';
/** @type {?} */
const CREATE_WISH_LIST_SUCCESS = '[Wish List] Create Wish List Success';
/** @type {?} */
const LOAD_WISH_LIST = '[Wish List] Load Wish List';
/** @type {?} */
const LOAD_WISH_LIST_SUCCESS = '[Wish List] Load Wish List Success';
/** @type {?} */
const RESET_WISH_LIST_DETAILS = '[Wish List] Reset Wish List';
class CreateWishList {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        this.payload = payload;
        this.type = CREATE_WISH_LIST;
    }
}
if (false) {
    /** @type {?} */
    CreateWishList.prototype.type;
    /** @type {?} */
    CreateWishList.prototype.payload;
}
class CreateWishListSuccess extends EntitySuccessAction {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        super(MULTI_CART_FEATURE, getCartIdByUserId(payload.cart, payload.userId));
        this.payload = payload;
        this.type = CREATE_WISH_LIST_SUCCESS;
    }
}
if (false) {
    /** @type {?} */
    CreateWishListSuccess.prototype.type;
    /** @type {?} */
    CreateWishListSuccess.prototype.payload;
}
class CreateWishListFail extends EntityFailAction {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        super(MULTI_CART_FEATURE, payload.cartId, payload.error);
        this.payload = payload;
        this.type = CREATE_WISH_LIST_FAIL;
    }
}
if (false) {
    /** @type {?} */
    CreateWishListFail.prototype.type;
    /** @type {?} */
    CreateWishListFail.prototype.payload;
}
class LoadWishList {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        this.payload = payload;
        this.type = LOAD_WISH_LIST;
    }
}
if (false) {
    /** @type {?} */
    LoadWishList.prototype.type;
    /** @type {?} */
    LoadWishList.prototype.payload;
}
class LoadWishListSuccess extends EntitySuccessAction {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        super(MULTI_CART_FEATURE, getCartIdByUserId(payload.cart, payload.userId));
        this.payload = payload;
        this.type = LOAD_WISH_LIST_SUCCESS;
    }
}
if (false) {
    /** @type {?} */
    LoadWishListSuccess.prototype.type;
    /** @type {?} */
    LoadWishListSuccess.prototype.payload;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

var cartGroup_actions = /*#__PURE__*/Object.freeze({
    CART_ADD_ENTRY: CART_ADD_ENTRY,
    CART_ADD_ENTRY_SUCCESS: CART_ADD_ENTRY_SUCCESS,
    CART_ADD_ENTRY_FAIL: CART_ADD_ENTRY_FAIL,
    CART_REMOVE_ENTRY: CART_REMOVE_ENTRY,
    CART_REMOVE_ENTRY_SUCCESS: CART_REMOVE_ENTRY_SUCCESS,
    CART_REMOVE_ENTRY_FAIL: CART_REMOVE_ENTRY_FAIL,
    CART_UPDATE_ENTRY: CART_UPDATE_ENTRY,
    CART_UPDATE_ENTRY_SUCCESS: CART_UPDATE_ENTRY_SUCCESS,
    CART_UPDATE_ENTRY_FAIL: CART_UPDATE_ENTRY_FAIL,
    CartAddEntry: CartAddEntry,
    CartAddEntrySuccess: CartAddEntrySuccess,
    CartAddEntryFail: CartAddEntryFail,
    CartRemoveEntry: CartRemoveEntry,
    CartRemoveEntrySuccess: CartRemoveEntrySuccess,
    CartRemoveEntryFail: CartRemoveEntryFail,
    CartUpdateEntry: CartUpdateEntry,
    CartUpdateEntrySuccess: CartUpdateEntrySuccess,
    CartUpdateEntryFail: CartUpdateEntryFail,
    CART_ADD_VOUCHER: CART_ADD_VOUCHER,
    CART_ADD_VOUCHER_FAIL: CART_ADD_VOUCHER_FAIL,
    CART_ADD_VOUCHER_SUCCESS: CART_ADD_VOUCHER_SUCCESS,
    CART_RESET_ADD_VOUCHER: CART_RESET_ADD_VOUCHER,
    CART_REMOVE_VOUCHER: CART_REMOVE_VOUCHER,
    CART_REMOVE_VOUCHER_FAIL: CART_REMOVE_VOUCHER_FAIL,
    CART_REMOVE_VOUCHER_SUCCESS: CART_REMOVE_VOUCHER_SUCCESS,
    CartAddVoucher: CartAddVoucher,
    CartAddVoucherFail: CartAddVoucherFail,
    CartAddVoucherSuccess: CartAddVoucherSuccess,
    CartResetAddVoucher: CartResetAddVoucher,
    CartRemoveVoucher: CartRemoveVoucher,
    CartRemoveVoucherFail: CartRemoveVoucherFail,
    CartRemoveVoucherSuccess: CartRemoveVoucherSuccess,
    CREATE_CART: CREATE_CART,
    CREATE_CART_FAIL: CREATE_CART_FAIL,
    CREATE_CART_SUCCESS: CREATE_CART_SUCCESS,
    LOAD_CART: LOAD_CART,
    LOAD_CART_FAIL: LOAD_CART_FAIL,
    LOAD_CART_SUCCESS: LOAD_CART_SUCCESS,
    ADD_EMAIL_TO_CART: ADD_EMAIL_TO_CART,
    ADD_EMAIL_TO_CART_FAIL: ADD_EMAIL_TO_CART_FAIL,
    ADD_EMAIL_TO_CART_SUCCESS: ADD_EMAIL_TO_CART_SUCCESS,
    MERGE_CART: MERGE_CART,
    MERGE_CART_SUCCESS: MERGE_CART_SUCCESS,
    RESET_CART_DETAILS: RESET_CART_DETAILS,
    CLEAR_EXPIRED_COUPONS: CLEAR_EXPIRED_COUPONS,
    CLEAR_CART: CLEAR_CART,
    DELETE_CART: DELETE_CART,
    DELETE_CART_FAIL: DELETE_CART_FAIL,
    CreateCart: CreateCart,
    CreateCartFail: CreateCartFail,
    CreateCartSuccess: CreateCartSuccess,
    AddEmailToCart: AddEmailToCart,
    AddEmailToCartFail: AddEmailToCartFail,
    AddEmailToCartSuccess: AddEmailToCartSuccess,
    LoadCart: LoadCart,
    LoadCartFail: LoadCartFail,
    LoadCartSuccess: LoadCartSuccess,
    MergeCart: MergeCart,
    MergeCartSuccess: MergeCartSuccess,
    ResetCartDetails: ResetCartDetails,
    ClearExpiredCoupons: ClearExpiredCoupons,
    ClearCart: ClearCart,
    DeleteCart: DeleteCart,
    DeleteCartFail: DeleteCartFail,
    REMOVE_TEMP_CART: REMOVE_TEMP_CART,
    CREATE_MULTI_CART: CREATE_MULTI_CART,
    CREATE_MULTI_CART_FAIL: CREATE_MULTI_CART_FAIL,
    CREATE_MULTI_CART_SUCCESS: CREATE_MULTI_CART_SUCCESS,
    LOAD_MULTI_CART: LOAD_MULTI_CART,
    LOAD_MULTI_CART_FAIL: LOAD_MULTI_CART_FAIL,
    LOAD_MULTI_CART_SUCCESS: LOAD_MULTI_CART_SUCCESS,
    MERGE_MULTI_CART: MERGE_MULTI_CART,
    MERGE_MULTI_CART_SUCCESS: MERGE_MULTI_CART_SUCCESS,
    RESET_MULTI_CART_DETAILS: RESET_MULTI_CART_DETAILS,
    SET_TEMP_CART: SET_TEMP_CART,
    REMOVE_CART: REMOVE_CART,
    ADD_EMAIL_TO_MULTI_CART: ADD_EMAIL_TO_MULTI_CART,
    ADD_EMAIL_TO_MULTI_CART_FAIL: ADD_EMAIL_TO_MULTI_CART_FAIL,
    ADD_EMAIL_TO_MULTI_CART_SUCCESS: ADD_EMAIL_TO_MULTI_CART_SUCCESS,
    CART_PROCESSES_INCREMENT: CART_PROCESSES_INCREMENT,
    CART_PROCESSES_DECREMENT: CART_PROCESSES_DECREMENT,
    RemoveTempCart: RemoveTempCart,
    SetTempCart: SetTempCart,
    CreateMultiCart: CreateMultiCart,
    CreateMultiCartFail: CreateMultiCartFail,
    CreateMultiCartSuccess: CreateMultiCartSuccess,
    LoadMultiCart: LoadMultiCart,
    LoadMultiCartFail: LoadMultiCartFail,
    LoadMultiCartSuccess: LoadMultiCartSuccess,
    MergeMultiCart: MergeMultiCart,
    MergeMultiCartSuccess: MergeMultiCartSuccess,
    ResetMultiCartDetails: ResetMultiCartDetails,
    RemoveCart: RemoveCart,
    AddEmailToMultiCart: AddEmailToMultiCart,
    AddEmailToMultiCartFail: AddEmailToMultiCartFail,
    AddEmailToMultiCartSuccess: AddEmailToMultiCartSuccess,
    CartProcessesIncrement: CartProcessesIncrement,
    CartProcessesDecrement: CartProcessesDecrement,
    CREATE_WISH_LIST: CREATE_WISH_LIST,
    CREATE_WISH_LIST_FAIL: CREATE_WISH_LIST_FAIL,
    CREATE_WISH_LIST_SUCCESS: CREATE_WISH_LIST_SUCCESS,
    LOAD_WISH_LIST: LOAD_WISH_LIST,
    LOAD_WISH_LIST_SUCCESS: LOAD_WISH_LIST_SUCCESS,
    RESET_WISH_LIST_DETAILS: RESET_WISH_LIST_DETAILS,
    CreateWishList: CreateWishList,
    CreateWishListSuccess: CreateWishListSuccess,
    CreateWishListFail: CreateWishListFail,
    LoadWishList: LoadWishList,
    LoadWishListSuccess: LoadWishListSuccess
});

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class MultiCartService {
    /**
     * @param {?} store
     */
    constructor(store) {
        this.store = store;
    }
    /**
     * Returns cart from store as an observable
     *
     * @param {?} cartId
     * @return {?}
     */
    getCart(cartId) {
        return this.store.pipe(select(getCartSelectorFactory(cartId)));
    }
    /**
     * Returns cart entity from store (cart with loading, error, success flags) as an observable
     *
     * @param {?} cartId
     * @return {?}
     */
    getCartEntity(cartId) {
        return this.store.pipe(select(getCartEntitySelectorFactory(cartId)));
    }
    /**
     * Returns true when there are no operations on that in progress and it is not currently loading
     *
     * @param {?} cartId
     * @return {?}
     */
    isStable(cartId) {
        return this.store.pipe(select(getCartIsStableSelectorFactory(cartId)), 
        // We dispatch a lot of actions just after finishing some process or loading, so we want this flag not to flicker.
        // This flickering should only be avoided when switching from false to true
        // Start of loading should be showed instantly (no debounce)
        // Extra actions are only dispatched after some loading
        debounce((/**
         * @param {?} isStable
         * @return {?}
         */
        isStable => (isStable ? timer(0) : EMPTY))), distinctUntilChanged());
    }
    /**
     * Simple random temp cart id generator
     * @private
     * @return {?}
     */
    generateTempCartId() {
        /** @type {?} */
        const pseudoUuid = Math.random()
            .toString(36)
            .substr(2, 9);
        return `temp-${pseudoUuid}`;
    }
    /**
     * Create or merge cart
     *
     * @param {?} __0
     * @return {?}
     */
    createCart({ userId, oldCartId, toMergeCartGuid, extraData, }) {
        // to support creating multiple carts at the same time we need to use different entity for every process
        // simple random uuid generator is used here for entity names
        /** @type {?} */
        const tempCartId = this.generateTempCartId();
        this.store.dispatch(new CreateCart({
            extraData,
            userId,
            oldCartId,
            toMergeCartGuid,
            tempCartId,
        }));
        return this.getCartEntity(tempCartId);
    }
    /**
     * Merge provided cart to current user cart
     *
     * @param {?} __0
     * @return {?}
     */
    mergeToCurrentCart({ userId, cartId, extraData }) {
        /** @type {?} */
        const tempCartId = this.generateTempCartId();
        this.store.dispatch(new MergeCart({
            userId,
            cartId,
            extraData,
            tempCartId,
        }));
    }
    /**
     * Load cart
     *
     * @param {?} __0
     * @return {?}
     */
    loadCart({ cartId, userId, extraData, }) {
        this.store.dispatch(new LoadCart({
            userId,
            cartId,
            extraData,
        }));
    }
    /**
     * Get cart entries as an observable
     * @param {?} cartId
     * @return {?}
     */
    getEntries(cartId) {
        return this.store.pipe(select(getCartEntriesSelectorFactory(cartId)));
    }
    /**
     * Add entry to cart
     *
     * @param {?} userId
     * @param {?} cartId
     * @param {?} productCode
     * @param {?} quantity
     * @return {?}
     */
    addEntry(userId, cartId, productCode, quantity) {
        this.store.dispatch(new CartAddEntry({
            userId,
            cartId,
            productCode,
            quantity,
        }));
    }
    /**
     * Add multiple entries to cart
     *
     * @param {?} userId
     * @param {?} cartId
     * @param {?} products Array with items (productCode and quantity)
     * @return {?}
     */
    addEntries(userId, cartId, products) {
        products.forEach((/**
         * @param {?} product
         * @return {?}
         */
        product => {
            this.store.dispatch(new CartAddEntry({
                userId,
                cartId,
                productCode: product.productCode,
                quantity: product.quantity,
            }));
        }));
    }
    /**
     * Remove entry from cart
     *
     * @param {?} userId
     * @param {?} cartId
     * @param {?} entryNumber
     * @return {?}
     */
    removeEntry(userId, cartId, entryNumber) {
        this.store.dispatch(new CartRemoveEntry({
            userId,
            cartId,
            entry: entryNumber,
        }));
    }
    /**
     * Update entry in cart. For quantity = 0 it removes entry
     *
     * @param {?} userId
     * @param {?} cartId
     * @param {?} entryNumber
     * @param {?} quantity
     * @return {?}
     */
    updateEntry(userId, cartId, entryNumber, quantity) {
        if (quantity > 0) {
            this.store.dispatch(new CartUpdateEntry({
                userId,
                cartId,
                entry: entryNumber,
                qty: quantity,
            }));
        }
        else {
            this.removeEntry(userId, cartId, entryNumber);
        }
    }
    /**
     * Get specific entry from cart
     *
     * @param {?} cartId
     * @param {?} productCode
     * @return {?}
     */
    getEntry(cartId, productCode) {
        return this.store.pipe(select(getCartEntrySelectorFactory$1(cartId, productCode)));
    }
    /**
     * Assign email to the cart
     *
     * @param {?} cartId
     * @param {?} userId
     * @param {?} email
     * @return {?}
     */
    assignEmail(cartId, userId, email) {
        this.store.dispatch(new AddEmailToCart({
            userId,
            cartId,
            email,
        }));
    }
    /**
     * Delete cart
     *
     * @param {?} cartId
     * @param {?} userId
     * @return {?}
     */
    deleteCart(cartId, userId) {
        this.store.dispatch(new DeleteCart({
            userId,
            cartId,
        }));
    }
}
MultiCartService.decorators = [
    { type: Injectable }
];
/** @nocollapse */
MultiCartService.ctorParameters = () => [
    { type: Store }
];
if (false) {
    /**
     * @type {?}
     * @protected
     */
    MultiCartService.prototype.store;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ActiveCartService {
    /**
     * @param {?} store
     * @param {?} authService
     * @param {?} multiCartService
     */
    constructor(store, authService, multiCartService) {
        this.store = store;
        this.authService = authService;
        this.multiCartService = multiCartService;
        this.PREVIOUS_USER_ID_INITIAL_VALUE = 'PREVIOUS_USER_ID_INITIAL_VALUE';
        this.previousUserId = this.PREVIOUS_USER_ID_INITIAL_VALUE;
        this.userId = OCC_USER_ID_ANONYMOUS;
        this.activeCartId$ = this.store.pipe(select(getActiveCartId), map((/**
         * @param {?} cartId
         * @return {?}
         */
        cartId => {
            if (!cartId) {
                return OCC_CART_ID_CURRENT;
            }
            return cartId;
        })));
        this.cartSelector$ = this.activeCartId$.pipe(switchMap((/**
         * @param {?} cartId
         * @return {?}
         */
        cartId => this.multiCartService.getCartEntity(cartId))));
        this.authService.getOccUserId().subscribe((/**
         * @param {?} userId
         * @return {?}
         */
        userId => {
            this.userId = userId;
            if (this.userId !== OCC_USER_ID_ANONYMOUS) {
                if (this.isJustLoggedIn(userId)) {
                    this.loadOrMerge(this.cartId);
                }
            }
            this.previousUserId = userId;
        }));
        this.activeCartId$.subscribe((/**
         * @param {?} cartId
         * @return {?}
         */
        cartId => {
            this.cartId = cartId;
        }));
        this.initActiveCart();
    }
    /**
     * @private
     * @return {?}
     */
    initActiveCart() {
        this.activeCart$ = this.cartSelector$.pipe(withLatestFrom(this.activeCartId$), map((/**
         * @param {?} __0
         * @return {?}
         */
        ([cartEntity, activeCartId]) => {
            return {
                cart: cartEntity.value,
                cartId: activeCartId,
                isStable: !cartEntity.loading && cartEntity.processesCount === 0,
                loaded: (cartEntity.error || cartEntity.success) && !cartEntity.loading,
            };
        })), 
        // we want to emit empty carts even if those are not stable
        // on merge cart action we want to switch to empty cart so no one would use old cartId which can be already obsolete
        // so on merge action the resulting stream looks like this: old_cart -> {} -> new_cart
        filter((/**
         * @param {?} __0
         * @return {?}
         */
        ({ isStable, cart }) => isStable || this.isEmpty(cart))), tap((/**
         * @param {?} __0
         * @return {?}
         */
        ({ cart, cartId, loaded, isStable }) => {
            if (isStable &&
                this.isEmpty(cart) &&
                !loaded &&
                !isTempCartId(cartId)) {
                this.load(cartId);
            }
        })), map((/**
         * @param {?} __0
         * @return {?}
         */
        ({ cart }) => (cart ? cart : {}))), tap((/**
         * @param {?} cart
         * @return {?}
         */
        cart => {
            if (cart) {
                this.cartUser = cart.user;
            }
        })), distinctUntilChanged(), shareReplay({ bufferSize: 1, refCount: true }));
    }
    /**
     * Returns active cart
     * @return {?}
     */
    getActive() {
        return this.activeCart$;
    }
    /**
     * Returns active cart id
     * @return {?}
     */
    getActiveCartId() {
        return this.activeCart$.pipe(map((/**
         * @param {?} cart
         * @return {?}
         */
        cart => getCartIdByUserId(cart, this.userId))), distinctUntilChanged());
    }
    /**
     * Returns cart entries
     * @return {?}
     */
    getEntries() {
        return this.activeCartId$.pipe(switchMap((/**
         * @param {?} cartId
         * @return {?}
         */
        cartId => this.multiCartService.getEntries(cartId))), distinctUntilChanged());
    }
    /**
     * Returns true when cart is stable (not loading and not pending processes on cart)
     * @return {?}
     */
    getLoaded() {
        // Debounce is used here, to avoid flickering when we switch between different cart entities.
        // For example during `addEntry` method. We might try to load current cart, so `current cart will be then active id.
        // After load fails we might create new cart so we switch to `temp-${uuid}` cart entity used when creating cart.
        // At the end we finally switch to cart `code` for cart id. Between those switches cart `getLoaded` function should not flicker.
        return this.activeCartId$.pipe(switchMap((/**
         * @param {?} cartId
         * @return {?}
         */
        cartId => this.multiCartService.isStable(cartId))), debounce((/**
         * @param {?} state
         * @return {?}
         */
        state => (state ? timer(0) : EMPTY))), distinctUntilChanged());
    }
    /**
     * @private
     * @param {?} cartId
     * @return {?}
     */
    loadOrMerge(cartId) {
        // for login user, whenever there's an existing cart, we will load the user
        // current cart and merge it into the existing cart
        if (!cartId || cartId === OCC_CART_ID_CURRENT) {
            this.multiCartService.loadCart({
                userId: this.userId,
                cartId: OCC_CART_ID_CURRENT,
                extraData: {
                    active: true,
                },
            });
        }
        else if (this.isGuestCart()) {
            this.guestCartMerge(cartId);
        }
        else {
            this.multiCartService.mergeToCurrentCart({
                userId: this.userId,
                cartId,
                extraData: {
                    active: true,
                },
            });
        }
    }
    /**
     * @private
     * @param {?} cartId
     * @return {?}
     */
    load(cartId) {
        if (this.userId !== OCC_USER_ID_ANONYMOUS) {
            this.multiCartService.loadCart({
                userId: this.userId,
                cartId: cartId ? cartId : OCC_CART_ID_CURRENT,
                extraData: {
                    active: true,
                },
            });
        }
        else if (cartId && cartId !== OCC_CART_ID_CURRENT) {
            this.multiCartService.loadCart({
                userId: this.userId,
                cartId: cartId,
                extraData: {
                    active: true,
                },
            });
        }
    }
    /**
     * @private
     * @param {?} cartEntries
     * @return {?}
     */
    addEntriesGuestMerge(cartEntries) {
        /** @type {?} */
        const entriesToAdd = cartEntries.map((/**
         * @param {?} entry
         * @return {?}
         */
        entry => ({
            productCode: entry.product.code,
            quantity: entry.quantity,
        })));
        this.requireLoadedCartForGuestMerge().subscribe((/**
         * @param {?} cartState
         * @return {?}
         */
        cartState => {
            this.multiCartService.addEntries(this.userId, getCartIdByUserId(cartState.value, this.userId), entriesToAdd);
        }));
    }
    /**
     * @private
     * @return {?}
     */
    requireLoadedCartForGuestMerge() {
        return this.requireLoadedCart(this.cartSelector$.pipe(filter((/**
         * @return {?}
         */
        () => !this.isGuestCart()))));
    }
    /**
     * @private
     * @param {?} cartState
     * @return {?}
     */
    isCartCreating(cartState) {
        // cart creating is always represented with loading flags
        // when all loading flags are false it means that we restored wrong cart id
        // could happen on context change or reload right in the middle on cart create call
        return (isTempCartId(this.cartId) &&
            (cartState.loading || cartState.success || cartState.error));
    }
    /**
     * @private
     * @param {?=} customCartSelector$
     * @return {?}
     */
    requireLoadedCart(customCartSelector$) {
        // For guest cart merge we want to filter guest cart in the whole stream
        // We have to wait with load/create/addEntry after guest cart will be deleted.
        // That's why you can provide custom selector with this filter applied.
        /** @type {?} */
        const cartSelector$ = customCartSelector$
            ? customCartSelector$
            : this.cartSelector$;
        return cartSelector$.pipe(filter((/**
         * @param {?} cartState
         * @return {?}
         */
        cartState => !cartState.loading)), 
        // Avoid load/create call when there are new cart creating at the moment
        filter((/**
         * @param {?} cartState
         * @return {?}
         */
        cartState => !this.isCartCreating(cartState))), take(1), switchMap((/**
         * @param {?} cartState
         * @return {?}
         */
        cartState => {
            // Try to load the cart, because it might have been created on another device between our login and add entry call
            if (this.isEmpty(cartState.value) &&
                this.userId !== OCC_USER_ID_ANONYMOUS) {
                this.load(undefined);
            }
            return cartSelector$;
        })), filter((/**
         * @param {?} cartState
         * @return {?}
         */
        cartState => !cartState.loading)), 
        // create cart can happen to anonymous user if it is not empty or to any other user if it is loaded and empty
        filter((/**
         * @param {?} cartState
         * @return {?}
         */
        cartState => this.userId === OCC_USER_ID_ANONYMOUS ||
            cartState.success ||
            cartState.error)), take(1), switchMap((/**
         * @param {?} cartState
         * @return {?}
         */
        cartState => {
            if (this.isEmpty(cartState.value)) {
                this.multiCartService.createCart({
                    userId: this.userId,
                    extraData: {
                        active: true,
                    },
                });
            }
            return cartSelector$;
        })), filter((/**
         * @param {?} cartState
         * @return {?}
         */
        cartState => !cartState.loading)), filter((/**
         * @param {?} cartState
         * @return {?}
         */
        cartState => cartState.success || cartState.error)), 
        // wait for active cart id to point to code/guid to avoid some work on temp cart entity
        filter((/**
         * @param {?} cartState
         * @return {?}
         */
        cartState => !this.isCartCreating(cartState))), filter((/**
         * @param {?} cartState
         * @return {?}
         */
        cartState => !this.isEmpty(cartState.value))), take(1));
    }
    /**
     * Add entry to active cart
     *
     * @param {?} productCode
     * @param {?} quantity
     * @return {?}
     */
    addEntry(productCode, quantity) {
        this.requireLoadedCart().subscribe((/**
         * @param {?} cartState
         * @return {?}
         */
        cartState => {
            this.multiCartService.addEntry(this.userId, getCartIdByUserId(cartState.value, this.userId), productCode, quantity);
        }));
    }
    /**
     * Remove entry
     *
     * @param {?} entry
     * @return {?}
     */
    removeEntry(entry) {
        this.multiCartService.removeEntry(this.userId, this.cartId, entry.entryNumber);
    }
    /**
     * Update entry
     *
     * @param {?} entryNumber
     * @param {?} quantity
     * @return {?}
     */
    updateEntry(entryNumber, quantity) {
        this.multiCartService.updateEntry(this.userId, this.cartId, entryNumber, quantity);
    }
    /**
     * Returns cart entry
     *
     * @param {?} productCode
     * @return {?}
     */
    getEntry(productCode) {
        return this.activeCartId$.pipe(switchMap((/**
         * @param {?} cartId
         * @return {?}
         */
        cartId => this.multiCartService.getEntry(cartId, productCode))), distinctUntilChanged());
    }
    /**
     * Assign email to cart
     *
     * @param {?} email
     * @return {?}
     */
    addEmail(email) {
        this.multiCartService.assignEmail(this.cartId, this.userId, email);
    }
    /**
     * Get assigned user to cart
     * @return {?}
     */
    getAssignedUser() {
        return this.getActive().pipe(map((/**
         * @param {?} cart
         * @return {?}
         */
        cart => cart.user)));
    }
    /**
     * Returns true for guest cart
     * @return {?}
     */
    isGuestCart() {
        return (this.cartUser &&
            (this.cartUser.name === OCC_USER_ID_GUEST ||
                this.isEmail(this.cartUser.uid
                    .split('|')
                    .slice(1)
                    .join('|'))));
    }
    /**
     * Add multiple entries to a cart
     *
     * @param {?} cartEntries : list of entries to add (OrderEntry[])
     * @return {?}
     */
    addEntries(cartEntries) {
        cartEntries.forEach((/**
         * @param {?} entry
         * @return {?}
         */
        entry => {
            this.addEntry(entry.product.code, entry.quantity);
        }));
    }
    /**
     * @private
     * @param {?} str
     * @return {?}
     */
    isEmail(str) {
        if (str) {
            return str.match(EMAIL_PATTERN) ? true : false;
        }
        return false;
    }
    // TODO: Remove once backend is updated
    /**
     * Temporary method to merge guest cart with user cart because of backend limitation
     * This is for an edge case
     * @private
     * @param {?} cartId
     * @return {?}
     */
    guestCartMerge(cartId) {
        /** @type {?} */
        let cartEntries;
        this.getEntries()
            .pipe(take(1))
            .subscribe((/**
         * @param {?} entries
         * @return {?}
         */
        entries => {
            cartEntries = entries;
        }));
        this.multiCartService.deleteCart(cartId, OCC_USER_ID_ANONYMOUS);
        this.addEntriesGuestMerge(cartEntries);
    }
    /**
     * @private
     * @param {?} cart
     * @return {?}
     */
    isEmpty(cart) {
        return (!cart || (typeof cart === 'object' && Object.keys(cart).length === 0));
    }
    /**
     * @private
     * @param {?} userId
     * @return {?}
     */
    isJustLoggedIn(userId) {
        return (this.previousUserId !== userId && // *just* logged in
            this.previousUserId !== this.PREVIOUS_USER_ID_INITIAL_VALUE // not app initialization
        );
    }
}
ActiveCartService.decorators = [
    { type: Injectable }
];
/** @nocollapse */
ActiveCartService.ctorParameters = () => [
    { type: Store },
    { type: AuthService },
    { type: MultiCartService }
];
if (false) {
    /**
     * @type {?}
     * @private
     */
    ActiveCartService.prototype.PREVIOUS_USER_ID_INITIAL_VALUE;
    /**
     * @type {?}
     * @private
     */
    ActiveCartService.prototype.previousUserId;
    /**
     * @type {?}
     * @private
     */
    ActiveCartService.prototype.activeCart$;
    /**
     * @type {?}
     * @private
     */
    ActiveCartService.prototype.userId;
    /**
     * @type {?}
     * @private
     */
    ActiveCartService.prototype.cartId;
    /**
     * @type {?}
     * @private
     */
    ActiveCartService.prototype.cartUser;
    /**
     * @type {?}
     * @private
     */
    ActiveCartService.prototype.activeCartId$;
    /**
     * @type {?}
     * @private
     */
    ActiveCartService.prototype.cartSelector$;
    /**
     * @type {?}
     * @protected
     */
    ActiveCartService.prototype.store;
    /**
     * @type {?}
     * @protected
     */
    ActiveCartService.prototype.authService;
    /**
     * @type {?}
     * @protected
     */
    ActiveCartService.prototype.multiCartService;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @license
 * The MIT License
 * Copyright (c) 2010-2019 Google LLC. http://angular.io/license
 *
 * See:
 * - https://github.com/angular/angular/blob/6f5f481fdae03f1d8db36284b64c7b82d9519d85/packages/service-worker/config/src/glob.ts
 * - https://github.com/angular/angular/blob/6f5f481fdae03f1d8db36284b64c7b82d9519d85/aio/tests/deployment/shared/helpers.ts#L17
 * - https://github.com/angular/angular/blob/6f5f481fdae03f1d8db36284b64c7b82d9519d85/packages/service-worker/config/src/generator.ts#L86
 */
/** @type {?} */
const QUESTION_MARK = '[^/]';
/** @type {?} */
const WILD_SINGLE = '[^/]*';
/** @type {?} */
const WILD_OPEN = '(?:.+\\/)?';
/** @type {?} */
const TO_ESCAPE_BASE = [
    { replace: /\./g, with: '\\.' },
    { replace: /\+/g, with: '\\+' },
    { replace: /\*/g, with: WILD_SINGLE },
];
/** @type {?} */
const TO_ESCAPE_WILDCARD_QM = [
    ...TO_ESCAPE_BASE,
    { replace: /\?/g, with: QUESTION_MARK },
];
/** @type {?} */
const TO_ESCAPE_LITERAL_QM = [
    ...TO_ESCAPE_BASE,
    { replace: /\?/g, with: '\\?' },
];
/**
 * Converts the glob-like pattern into regex string.
 *
 * Patterns use a limited glob format:
 * `**` matches 0 or more path segments
 * `*` matches 0 or more characters excluding `/`
 * `?` matches exactly one character excluding `/` (but when \@param literalQuestionMark is true, `?` is treated as normal character)
 * The `!` prefix marks the pattern as being negative, meaning that only URLs that don't match the pattern will be included
 *
 * @param {?} glob glob-like pattern
 * @param {?=} literalQuestionMark when true, it tells that `?` is treated as a normal character
 * @return {?}
 */
function globToRegex(glob, literalQuestionMark = false) {
    /** @type {?} */
    const toEscape = literalQuestionMark
        ? TO_ESCAPE_LITERAL_QM
        : TO_ESCAPE_WILDCARD_QM;
    /** @type {?} */
    const segments = glob.split('/').reverse();
    /** @type {?} */
    let regex = '';
    while (segments.length > 0) {
        /** @type {?} */
        const segment = segments.pop();
        if (segment === '**') {
            if (segments.length > 0) {
                regex += WILD_OPEN;
            }
            else {
                regex += '.*';
            }
        }
        else {
            /** @type {?} */
            const processed = toEscape.reduce((/**
             * @param {?} seg
             * @param {?} escape
             * @return {?}
             */
            (seg, escape) => seg.replace(escape.replace, escape.with)), segment);
            regex += processed;
            if (segments.length > 0) {
                regex += '\\/';
            }
        }
    }
    return regex;
}
/**
 * For given list of glob-like patterns, returns a matcher function.
 *
 * The matcher returns true for given URL only when ANY of the positive patterns is matched and NONE of the negative ones.
 * @param {?} patterns
 * @return {?}
 */
function getGlobMatcher(patterns) {
    /** @type {?} */
    const processedPatterns = processGlobPatterns(patterns).map((/**
     * @param {?} __0
     * @return {?}
     */
    ({ positive, regex }) => ({
        positive,
        regex: new RegExp(regex),
    })));
    /** @type {?} */
    const includePatterns = processedPatterns.filter((/**
     * @param {?} spec
     * @return {?}
     */
    spec => spec.positive));
    /** @type {?} */
    const excludePatterns = processedPatterns.filter((/**
     * @param {?} spec
     * @return {?}
     */
    spec => !spec.positive));
    return (/**
     * @param {?} url
     * @return {?}
     */
    (url) => includePatterns.some((/**
     * @param {?} pattern
     * @return {?}
     */
    pattern => pattern.regex.test(url))) &&
        !excludePatterns.some((/**
         * @param {?} pattern
         * @return {?}
         */
        pattern => pattern.regex.test(url))));
}
/**
 * Converts list of glob-like patterns into list of RegExps with information whether the glob pattern is positive or negative
 * @param {?} urls
 * @return {?}
 */
function processGlobPatterns(urls) {
    return urls.map((/**
     * @param {?} url
     * @return {?}
     */
    url => {
        /** @type {?} */
        const positive = !url.startsWith('!');
        url = positive ? url : url.substr(1);
        return { positive, regex: `^${globToRegex(url)}$` };
    }));
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class GlobService {
    /**
     * For given list of glob-like patterns, returns a validator function.
     *
     * The validator returns true for given URL only when ANY of the positive patterns is matched and NONE of the negative ones.
     * @param {?} patterns
     * @return {?}
     */
    getValidator(patterns) {
        /** @type {?} */
        const processedPatterns = processGlobPatterns(patterns).map((/**
         * @param {?} __0
         * @return {?}
         */
        ({ positive, regex }) => ({
            positive,
            regex: new RegExp(regex),
        })));
        /** @type {?} */
        const includePatterns = processedPatterns.filter((/**
         * @param {?} spec
         * @return {?}
         */
        spec => spec.positive));
        /** @type {?} */
        const excludePatterns = processedPatterns.filter((/**
         * @param {?} spec
         * @return {?}
         */
        spec => !spec.positive));
        return (/**
         * @param {?} url
         * @return {?}
         */
        (url) => includePatterns.some((/**
         * @param {?} pattern
         * @return {?}
         */
        pattern => pattern.regex.test(url))) &&
            !excludePatterns.some((/**
             * @param {?} pattern
             * @return {?}
             */
            pattern => pattern.regex.test(url))));
    }
}
GlobService.decorators = [
    { type: Injectable, args: [{ providedIn: 'root' },] }
];
/** @nocollapse */ GlobService.ngInjectableDef = ɵɵdefineInjectable({ factory: function GlobService_Factory() { return new GlobService(); }, token: GlobService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @deprecated since version 1.4
 * Replace particular methods usage with replacements from other services
 */
class CartDataService {
    /**
     * @param {?} store
     * @param {?} authService
     */
    constructor(store, authService) {
        this.store = store;
        this.authService = authService;
        this._userId = OCC_USER_ID_ANONYMOUS;
        this.authService
            .getUserToken()
            .pipe(filter((/**
         * @param {?} userToken
         * @return {?}
         */
        userToken => this.userId !== userToken.userId)))
            .subscribe((/**
         * @param {?} userToken
         * @return {?}
         */
        userToken => {
            if (Object.keys(userToken).length !== 0) {
                this._userId = userToken.userId;
            }
            else {
                this._userId = OCC_USER_ID_ANONYMOUS;
            }
        }));
        this.store.pipe(select(getCartContent)).subscribe((/**
         * @param {?} cart
         * @return {?}
         */
        cart => {
            this._cart = cart;
        }));
    }
    /**
     * @return {?}
     */
    get hasCart() {
        return !!this._cart && Object.keys(this._cart).length > 0;
    }
    /**
     * @deprecated since version 1.4
     * Use `getOccUserId` from `AuthService` instead
     * @return {?}
     */
    get userId() {
        return this._userId;
    }
    /**
     * @deprecated since version 1.4
     * Use `getActive` from `ActiveCartService` instead
     * @return {?}
     */
    get cart() {
        return this._cart;
    }
    /**
     * @deprecated since version 1.4
     * Use `getActiveCartId` from `ActiveCartService` instead
     * @return {?}
     */
    get cartId() {
        if (this.hasCart) {
            return this.userId === OCC_USER_ID_ANONYMOUS
                ? this.cart.guid
                : this.cart.code;
        }
    }
    /**
     * @deprecated since version 1.4
     * Use `isGuestCart` from `ActiveCartService` instead
     * @return {?}
     */
    get isGuestCart() {
        return (this.cart.user &&
            (this.cart.user.name === OCC_USER_ID_GUEST ||
                this.isEmail(this.cart.user.uid
                    .split('|')
                    .slice(1)
                    .join('|'))));
    }
    /**
     * @private
     * @param {?} str
     * @return {?}
     */
    isEmail(str) {
        if (str) {
            return str.match(EMAIL_PATTERN) ? true : false;
        }
        return false;
    }
}
CartDataService.decorators = [
    { type: Injectable }
];
/** @nocollapse */
CartDataService.ctorParameters = () => [
    { type: Store },
    { type: AuthService }
];
if (false) {
    /**
     * @type {?}
     * @private
     */
    CartDataService.prototype._userId;
    /**
     * @type {?}
     * @private
     */
    CartDataService.prototype._cart;
    /**
     * @type {?}
     * @protected
     */
    CartDataService.prototype.store;
    /**
     * @type {?}
     * @protected
     */
    CartDataService.prototype.authService;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class CartVoucherService {
    /**
     * @param {?} store
     * @param {?} authService
     */
    constructor(store, authService) {
        this.store = store;
        this.authService = authService;
    }
    /**
     * @param {?} voucherId
     * @param {?=} cartId
     * @return {?}
     */
    addVoucher(voucherId, cartId) {
        this.combineUserAndCartId(cartId).subscribe((/**
         * @param {?} __0
         * @return {?}
         */
        ([occUserId, cartIdentifier]) => this.store.dispatch(new CartAddVoucher({
            userId: occUserId,
            cartId: cartIdentifier,
            voucherId: voucherId,
        }))));
    }
    /**
     * @param {?} voucherId
     * @param {?=} cartId
     * @return {?}
     */
    removeVoucher(voucherId, cartId) {
        this.combineUserAndCartId(cartId).subscribe((/**
         * @param {?} __0
         * @return {?}
         */
        ([occUserId, cartIdentifier]) => this.store.dispatch(new CartRemoveVoucher({
            userId: occUserId,
            cartId: cartIdentifier,
            voucherId: voucherId,
        }))));
    }
    /**
     * @return {?}
     */
    getAddVoucherResultError() {
        return this.store.pipe(select(getProcessErrorFactory(ADD_VOUCHER_PROCESS_ID)));
    }
    /**
     * @return {?}
     */
    getAddVoucherResultSuccess() {
        return this.store.pipe(select(getProcessSuccessFactory(ADD_VOUCHER_PROCESS_ID)));
    }
    /**
     * @return {?}
     */
    getAddVoucherResultLoading() {
        return this.store.pipe(select(getProcessLoadingFactory(ADD_VOUCHER_PROCESS_ID)));
    }
    /**
     * @return {?}
     */
    resetAddVoucherProcessingState() {
        this.store.dispatch(new CartResetAddVoucher());
    }
    /**
     * @private
     * @param {?} cartId
     * @return {?}
     */
    combineUserAndCartId(cartId) {
        if (cartId) {
            return this.authService.getOccUserId().pipe(take(1), map((/**
             * @param {?} userId
             * @return {?}
             */
            userId => [userId, cartId])));
        }
        else {
            return combineLatest([
                this.authService.getOccUserId(),
                this.store.pipe(select(getCartContent), map((/**
                 * @param {?} cart
                 * @return {?}
                 */
                cart => cart))),
            ]).pipe(take(1), map((/**
             * @param {?} __0
             * @return {?}
             */
            ([userId, cart]) => [
                userId,
                userId === OCC_USER_ID_ANONYMOUS ? cart.guid : cart.code,
            ])));
        }
    }
}
CartVoucherService.decorators = [
    { type: Injectable }
];
/** @nocollapse */
CartVoucherService.ctorParameters = () => [
    { type: Store },
    { type: AuthService }
];
if (false) {
    /**
     * @type {?}
     * @protected
     */
    CartVoucherService.prototype.store;
    /**
     * @type {?}
     * @protected
     */
    CartVoucherService.prototype.authService;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @deprecated since version 1.4
 * Use ActiveCartService instead (API is almost the same)
 * From 1.4 version CartService uses ActiveCartService if it is available
 * Fixes and improvements will be only implemented in ActiveCartService
 */
class CartService {
    /**
     * @param {?} store
     * @param {?} cartData
     * @param {?} authService
     * @param {?=} activeCartService
     */
    constructor(store, cartData, authService, activeCartService) {
        this.store = store;
        this.cartData = cartData;
        this.authService = authService;
        this.activeCartService = activeCartService;
        this.PREVIOUS_USER_ID_INITIAL_VALUE = 'PREVIOUS_USER_ID_INITIAL_VALUE';
        this.previousUserId = this.PREVIOUS_USER_ID_INITIAL_VALUE;
        this._activeCart$ = combineLatest([
            this.store.select(getCartContent),
            this.store.select(getCartLoading),
            this.authService.getUserToken(),
            this.store.select(getCartLoaded),
        ]).pipe(
        // combineLatest emits multiple times on each property update instead of one emit
        // additionally dispatching actions that changes selectors used here needs to happen in order
        // for this asyncScheduler is used here
        debounceTime(0), filter((/**
         * @param {?} __0
         * @return {?}
         */
        ([, loading]) => !loading)), tap((/**
         * @param {?} __0
         * @return {?}
         */
        ([cart, , userToken, loaded]) => {
            if (this.isJustLoggedIn(userToken.userId)) {
                this.loadOrMerge();
            }
            else if ((this.isCreated(cart) && this.isIncomplete(cart)) ||
                (this.isLoggedIn(userToken.userId) &&
                    !this.isCreated(cart) &&
                    !loaded) // try to load current cart for logged in user (loaded flag to prevent infinite loop when user doesn't have cart)
            ) {
                this.load();
            }
            this.previousUserId = userToken.userId;
        })), filter((/**
         * @param {?} __0
         * @return {?}
         */
        ([cart]) => !this.isCreated(cart) ||
            (this.isCreated(cart) && !this.isIncomplete(cart)))), map((/**
         * @param {?} __0
         * @return {?}
         */
        ([cart]) => cart)), shareReplay({ bufferSize: 1, refCount: true }));
    }
    /**
     * @return {?}
     */
    getActive() {
        if (this.activeCartService) {
            return this.activeCartService.getActive();
        }
        return this._activeCart$;
    }
    /**
     * @return {?}
     */
    getEntries() {
        if (this.activeCartService) {
            return this.activeCartService.getEntries();
        }
        return this.store.pipe(select(getCartEntries));
    }
    // TODO: to remove in 2.0
    // doesn't seem useful for end developers
    // there shouldn't be a need for such low level information
    /**
     * @return {?}
     */
    getCartMergeComplete() {
        return this.store.pipe(select(getCartMergeComplete));
    }
    /**
     * @return {?}
     */
    getLoaded() {
        if (this.activeCartService) {
            return this.activeCartService.getLoaded();
        }
        return this.store.pipe(select(getCartLoaded));
    }
    /**
     * @private
     * @return {?}
     */
    loadOrMerge() {
        // for login user, whenever there's an existing cart, we will load the user
        // current cart and merge it into the existing cart
        if (!this.isCreated(this.cartData.cart)) {
            this.store.dispatch(new LoadCart({
                userId: this.cartData.userId,
                cartId: OCC_CART_ID_CURRENT,
            }));
        }
        else if (this.isGuestCart()) {
            this.guestCartMerge();
        }
        else {
            this.store.dispatch(new MergeCart({
                userId: this.cartData.userId,
                cartId: this.cartData.cart.guid,
            }));
        }
    }
    /**
     * @private
     * @return {?}
     */
    load() {
        if (this.cartData.userId !== OCC_USER_ID_ANONYMOUS) {
            this.store.dispatch(new LoadCart({
                userId: this.cartData.userId,
                cartId: this.cartData.cartId
                    ? this.cartData.cartId
                    : OCC_CART_ID_CURRENT,
            }));
        }
        else {
            this.store.dispatch(new LoadCart({
                userId: this.cartData.userId,
                cartId: this.cartData.cartId,
            }));
        }
    }
    /**
     * @param {?} productCode
     * @param {?} quantity
     * @return {?}
     */
    addEntry(productCode, quantity) {
        if (this.activeCartService) {
            return this.activeCartService.addEntry(productCode, quantity);
        }
        this.store
            .pipe(select(getActiveCartState), tap((/**
         * @param {?} cartState
         * @return {?}
         */
        cartState => {
            if (!this.isCreated(cartState.value.content) && !cartState.loading) {
                this.store.dispatch(new CreateCart({
                    userId: this.cartData.userId,
                }));
            }
        })), filter((/**
         * @param {?} cartState
         * @return {?}
         */
        cartState => this.isCreated(cartState.value.content))), take(1))
            .subscribe((/**
         * @param {?} _
         * @return {?}
         */
        _ => {
            this.store.dispatch(new CartAddEntry({
                userId: this.cartData.userId,
                cartId: this.cartData.cartId,
                productCode: productCode,
                quantity: quantity,
            }));
        }));
    }
    /**
     * @param {?} entry
     * @return {?}
     */
    removeEntry(entry) {
        if (this.activeCartService) {
            return this.activeCartService.removeEntry(entry);
        }
        this.store.dispatch(new CartRemoveEntry({
            userId: this.cartData.userId,
            cartId: this.cartData.cartId,
            entry: entry.entryNumber,
        }));
    }
    /**
     * @param {?} entryNumber
     * @param {?} quantity
     * @return {?}
     */
    updateEntry(entryNumber, quantity) {
        if (this.activeCartService) {
            return this.activeCartService.updateEntry(parseInt(entryNumber, 10), quantity);
        }
        if (quantity > 0) {
            this.store.dispatch(new CartUpdateEntry({
                userId: this.cartData.userId,
                cartId: this.cartData.cartId,
                entry: entryNumber,
                qty: quantity,
            }));
        }
        else {
            this.store.dispatch(new CartRemoveEntry({
                userId: this.cartData.userId,
                cartId: this.cartData.cartId,
                entry: entryNumber,
            }));
        }
    }
    /**
     * @param {?} productCode
     * @return {?}
     */
    getEntry(productCode) {
        if (this.activeCartService) {
            return this.activeCartService.getEntry(productCode);
        }
        return this.store.pipe(select(getCartEntrySelectorFactory(productCode)));
    }
    /**
     * @param {?} email
     * @return {?}
     */
    addEmail(email) {
        if (this.activeCartService) {
            return this.activeCartService.addEmail(email);
        }
        this.store.dispatch(new AddEmailToCart({
            userId: this.cartData.userId,
            cartId: this.cartData.cartId,
            email: email,
        }));
    }
    /**
     * @return {?}
     */
    getAssignedUser() {
        if (this.activeCartService) {
            return this.activeCartService.getAssignedUser();
        }
        return this.store.pipe(select(getCartUser));
    }
    /**
     * @return {?}
     */
    isGuestCart() {
        if (this.activeCartService) {
            return this.activeCartService.isGuestCart();
        }
        return this.cartData.isGuestCart;
    }
    /**
     * Add multiple entries to a cart
     * Requires a created cart
     * @param {?} cartEntries : list of entries to add (OrderEntry[])
     * @return {?}
     */
    addEntries(cartEntries) {
        if (this.activeCartService) {
            return this.activeCartService.addEntries(cartEntries);
        }
        /** @type {?} */
        let newEntries = 0;
        this.getEntries()
            .pipe(tap((/**
         * @return {?}
         */
        () => {
            // Keep adding entries until the user cart contains the same number of entries
            // as the guest cart did
            if (newEntries < cartEntries.length) {
                this.store.dispatch(new CartAddEntry({
                    userId: this.cartData.userId,
                    cartId: this.cartData.cartId,
                    productCode: cartEntries[newEntries].product.code,
                    quantity: cartEntries[newEntries].quantity,
                }));
                newEntries++;
            }
        })), filter((/**
         * @return {?}
         */
        () => newEntries === cartEntries.length)), take(1))
            .subscribe();
    }
    /**
     * @private
     * @param {?} cart
     * @return {?}
     */
    isCreated(cart) {
        return cart && typeof cart.guid !== 'undefined';
    }
    /**
     * Cart is incomplete if it contains only `guid`, `code` and `user` properties, which come from local storage.
     * To get cart content, we need to load cart from backend.
     * @private
     * @param {?} cart
     * @return {?}
     */
    isIncomplete(cart) {
        return cart && Object.keys(cart).length <= 3;
    }
    /**
     * @private
     * @param {?} userId
     * @return {?}
     */
    isJustLoggedIn(userId) {
        return (this.isLoggedIn(userId) &&
            this.previousUserId !== userId && // *just* logged in
            this.previousUserId !== this.PREVIOUS_USER_ID_INITIAL_VALUE // not app initialization
        );
    }
    /**
     * @private
     * @param {?} userId
     * @return {?}
     */
    isLoggedIn(userId) {
        return typeof userId !== 'undefined';
    }
    // TODO: Remove once backend is updated
    /**
     * Temporary method to merge guest cart with user cart because of backend limitation
     * This is for an edge case
     * @private
     * @return {?}
     */
    guestCartMerge() {
        /** @type {?} */
        let cartEntries;
        this.getEntries()
            .pipe(take(1))
            .subscribe((/**
         * @param {?} entries
         * @return {?}
         */
        entries => {
            cartEntries = entries;
        }));
        this.store.dispatch(new DeleteCart({
            userId: OCC_USER_ID_ANONYMOUS,
            cartId: this.cartData.cart.guid,
        }));
        this.store
            .pipe(select(getActiveCartState), filter((/**
         * @param {?} cartState
         * @return {?}
         */
        cartState => !cartState.loading)), tap((/**
         * @param {?} cartState
         * @return {?}
         */
        cartState => {
            // If the cart is not created it needs to be created
            // This step should happen before adding entries to avoid conflicts in the requests
            if (!this.isCreated(cartState.value.content)) {
                this.store.dispatch(new CreateCart({
                    userId: this.cartData.userId,
                }));
            }
        })), filter((/**
         * @param {?} cartState
         * @return {?}
         */
        cartState => this.isCreated(cartState.value.content))), take(1))
            .subscribe((/**
         * @return {?}
         */
        () => {
            this.addEntries(cartEntries);
        }));
    }
    /**
     * @param {?} voucherId
     * @return {?}
     */
    addVoucher(voucherId) {
        this.store.dispatch(new CartAddVoucher({
            userId: this.cartData.userId,
            cartId: this.cartData.cartId,
            voucherId: voucherId,
        }));
    }
}
CartService.decorators = [
    { type: Injectable }
];
/** @nocollapse */
CartService.ctorParameters = () => [
    { type: Store },
    { type: CartDataService },
    { type: AuthService },
    { type: ActiveCartService }
];
if (false) {
    /**
     * @type {?}
     * @private
     */
    CartService.prototype.PREVIOUS_USER_ID_INITIAL_VALUE;
    /**
     * @type {?}
     * @private
     */
    CartService.prototype.previousUserId;
    /**
     * @type {?}
     * @private
     */
    CartService.prototype._activeCart$;
    /**
     * @type {?}
     * @protected
     */
    CartService.prototype.store;
    /**
     * @type {?}
     * @protected
     */
    CartService.prototype.cartData;
    /**
     * @type {?}
     * @protected
     */
    CartService.prototype.authService;
    /**
     * @type {?}
     * @protected
     */
    CartService.prototype.activeCartService;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class UserService {
    /**
     * @param {?} store
     * @param {?=} authService
     */
    constructor(store, authService) {
        this.store = store;
        this.authService = authService;
    }
    /**
     * Returns a user
     * @return {?}
     */
    get() {
        return this.store.pipe(select(getDetails), tap((/**
         * @param {?} details
         * @return {?}
         */
        details => {
            if (Object.keys(details).length === 0) {
                this.load();
            }
        })));
    }
    /**
     * Loads the user's details
     * @return {?}
     */
    load() {
        this.withUserId((/**
         * @param {?} userId
         * @return {?}
         */
        userId => {
            if (userId !== OCC_USER_ID_ANONYMOUS) {
                this.store.dispatch(new LoadUserDetails(userId));
            }
        }));
    }
    /**
     * Register a new user
     *
     * @param {?} userRegisterFormData
     * @return {?}
     */
    register(userRegisterFormData) {
        this.store.dispatch(new RegisterUser(userRegisterFormData));
    }
    /**
     * Register a new user from guest
     *
     * @param {?} guid
     * @param {?} password
     * @return {?}
     */
    registerGuest(guid, password) {
        this.store.dispatch(new RegisterGuest({ guid, password }));
    }
    /**
     * Returns the register user process loading flag
     * @return {?}
     */
    getRegisterUserResultLoading() {
        return this.store.pipe(select(getProcessLoadingFactory(REGISTER_USER_PROCESS_ID)));
    }
    /**
     * Returns the register user process success flag
     * @return {?}
     */
    getRegisterUserResultSuccess() {
        return this.store.pipe(select(getProcessSuccessFactory(REGISTER_USER_PROCESS_ID)));
    }
    /**
     * Returns the register user process error flag
     * @return {?}
     */
    getRegisterUserResultError() {
        return this.store.pipe(select(getProcessErrorFactory(REGISTER_USER_PROCESS_ID)));
    }
    /**
     * Resets the register user process flags
     * @return {?}
     */
    resetRegisterUserProcessState() {
        return this.store.dispatch(new ResetRegisterUserProcess());
    }
    /**
     * Remove user account, that's also called close user's account
     * @return {?}
     */
    remove() {
        this.withUserId((/**
         * @param {?} userId
         * @return {?}
         */
        userId => this.store.dispatch(new RemoveUser(userId))));
    }
    /**
     * Returns the remove user loading flag
     * @return {?}
     */
    getRemoveUserResultLoading() {
        return this.store.pipe(select(getProcessLoadingFactory(REMOVE_USER_PROCESS_ID)));
    }
    /**
     * Returns the remove user failure outcome.
     * @return {?}
     */
    getRemoveUserResultError() {
        return this.store.pipe(select(getProcessErrorFactory(REMOVE_USER_PROCESS_ID)));
    }
    /**
     * Returns the remove user process success outcome.
     * @return {?}
     */
    getRemoveUserResultSuccess() {
        return this.store.pipe(select(getProcessSuccessFactory(REMOVE_USER_PROCESS_ID)));
    }
    /**
     * Resets the remove user process state. The state needs to be reset after the process
     * concludes, regardless if it's a success or an error
     * @return {?}
     */
    resetRemoveUserProcessState() {
        this.store.dispatch(new RemoveUserReset());
    }
    /**
     * Returns titles
     * @return {?}
     */
    getTitles() {
        return this.store.pipe(select(getAllTitles));
    }
    /**
     * Retrieves titles
     * @return {?}
     */
    loadTitles() {
        this.store.dispatch(new LoadTitles());
    }
    /**
     * Return whether user's password is successfully reset
     * @return {?}
     */
    isPasswordReset() {
        return this.store.pipe(select(getResetPassword));
    }
    /**
     * Updates the user's details
     * @param {?} userDetails to be updated
     * @return {?}
     */
    updatePersonalDetails(userDetails) {
        this.withUserId((/**
         * @param {?} userId
         * @return {?}
         */
        userId => this.store.dispatch(new UpdateUserDetails({
            username: userId,
            userDetails,
        }))));
    }
    /**
     * Returns the update user's personal details loading flag
     * @return {?}
     */
    getUpdatePersonalDetailsResultLoading() {
        return this.store.pipe(select(getProcessLoadingFactory(UPDATE_USER_DETAILS_PROCESS_ID)));
    }
    /**
     * Returns the update user's personal details error flag
     * @return {?}
     */
    getUpdatePersonalDetailsResultError() {
        return this.store.pipe(select(getProcessErrorFactory(UPDATE_USER_DETAILS_PROCESS_ID)));
    }
    /**
     * Returns the update user's personal details success flag
     * @return {?}
     */
    getUpdatePersonalDetailsResultSuccess() {
        return this.store.pipe(select(getProcessSuccessFactory(UPDATE_USER_DETAILS_PROCESS_ID)));
    }
    /**
     * Resets the update user details processing state
     * @return {?}
     */
    resetUpdatePersonalDetailsProcessingState() {
        this.store.dispatch(new ResetUpdateUserDetails());
    }
    /**
     * Reset new password.  Part of the forgot password flow.
     * @param {?} token
     * @param {?} password
     * @return {?}
     */
    resetPassword(token, password) {
        this.store.dispatch(new ResetPassword({ token, password }));
    }
    /*
       * Request an email to reset a forgotten password.
       */
    /**
     * @param {?} userEmailAddress
     * @return {?}
     */
    requestForgotPasswordEmail(userEmailAddress) {
        this.store.dispatch(new ForgotPasswordEmailRequest(userEmailAddress));
    }
    /**
     * Updates the user's email
     * @param {?} password
     * @param {?} newUid
     * @return {?}
     */
    updateEmail(password, newUid) {
        this.withUserId((/**
         * @param {?} userId
         * @return {?}
         */
        userId => this.store.dispatch(new UpdateEmailAction({
            uid: userId,
            password,
            newUid,
        }))));
    }
    /**
     * Returns the update user's email success flag
     * @return {?}
     */
    getUpdateEmailResultSuccess() {
        return this.store.pipe(select(getProcessSuccessFactory(UPDATE_EMAIL_PROCESS_ID)));
    }
    /**
     * Returns the update user's email error flag
     * @return {?}
     */
    getUpdateEmailResultError() {
        return this.store.pipe(select(getProcessErrorFactory(UPDATE_EMAIL_PROCESS_ID)));
    }
    /**
     * Returns the update user's email loading flag
     * @return {?}
     */
    getUpdateEmailResultLoading() {
        return this.store.pipe(select(getProcessLoadingFactory(UPDATE_EMAIL_PROCESS_ID)));
    }
    /**
     * Resets the update user's email processing state
     * @return {?}
     */
    resetUpdateEmailResultState() {
        this.store.dispatch(new ResetUpdateEmailAction());
    }
    /**
     * Updates the password for the user
     * @param {?} oldPassword the current password that will be changed
     * @param {?} newPassword the new password
     * @return {?}
     */
    updatePassword(oldPassword, newPassword) {
        this.withUserId((/**
         * @param {?} userId
         * @return {?}
         */
        userId => this.store.dispatch(new UpdatePassword({
            userId,
            oldPassword,
            newPassword,
        }))));
    }
    /**
     * Returns the update password loading flag
     * @return {?}
     */
    getUpdatePasswordResultLoading() {
        return this.store.pipe(select(getProcessLoadingFactory(UPDATE_PASSWORD_PROCESS_ID)));
    }
    /**
     * Returns the update password failure outcome.
     * @return {?}
     */
    getUpdatePasswordResultError() {
        return this.store.pipe(select(getProcessErrorFactory(UPDATE_PASSWORD_PROCESS_ID)));
    }
    /**
     * Returns the update password process success outcome.
     * @return {?}
     */
    getUpdatePasswordResultSuccess() {
        return this.store.pipe(select(getProcessSuccessFactory(UPDATE_PASSWORD_PROCESS_ID)));
    }
    /**
     * Resets the update password process state. The state needs to be reset after the process
     * concludes, regardless if it's a success or an error
     * @return {?}
     */
    resetUpdatePasswordProcessState() {
        this.store.dispatch(new UpdatePasswordReset());
    }
    /**
     * Utility method to distinquish pre / post 1.3.0 in a convenient way.
     *
     * @private
     * @param {?} callback
     * @return {?}
     */
    withUserId(callback) {
        if (this.authService) {
            this.authService
                .getOccUserId()
                .pipe(take(1))
                .subscribe((/**
             * @param {?} userId
             * @return {?}
             */
            userId => callback(userId)));
        }
        else {
            // TODO(issue:#5628) Deprecated since 1.3.0
            callback(OCC_USER_ID_CURRENT);
        }
    }
}
UserService.decorators = [
    { type: Injectable }
];
/** @nocollapse */
UserService.ctorParameters = () => [
    { type: Store },
    { type: AuthService }
];
if (false) {
    /**
     * @type {?}
     * @protected
     */
    UserService.prototype.store;
    /**
     * @type {?}
     * @protected
     */
    UserService.prototype.authService;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SelectiveCartService {
    /**
     * @param {?} store
     * @param {?} userService
     * @param {?} authService
     * @param {?} multiCartService
     * @param {?} baseSiteService
     */
    constructor(store, userService, authService, multiCartService, baseSiteService) {
        this.store = store;
        this.userService = userService;
        this.authService = authService;
        this.multiCartService = multiCartService;
        this.baseSiteService = baseSiteService;
        this.cartId$ = new BehaviorSubject(undefined);
        this.PREVIOUS_USER_ID_INITIAL_VALUE = 'PREVIOUS_USER_ID_INITIAL_VALUE';
        this.previousUserId = this.PREVIOUS_USER_ID_INITIAL_VALUE;
        this.cartSelector$ = this.cartId$.pipe(switchMap((/**
         * @param {?} cartId
         * @return {?}
         */
        cartId => {
            this.cartId = cartId;
            return this.multiCartService.getCartEntity(cartId);
        })));
        combineLatest([
            this.userService.get(),
            this.baseSiteService.getActive(),
        ]).subscribe((/**
         * @param {?} __0
         * @return {?}
         */
        ([user, activeBaseSite]) => {
            if (user && user.customerId && activeBaseSite) {
                this.customerId = user.customerId;
                this.cartId$.next(`selectivecart${activeBaseSite}${this.customerId}`);
            }
            else if (user && !user.customerId) {
                this.cartId$.next(undefined);
            }
        }));
        this.authService.getOccUserId().subscribe((/**
         * @param {?} userId
         * @return {?}
         */
        userId => {
            this.userId = userId;
            if (this.isJustLoggedIn(userId)) {
                this.load();
            }
            this.previousUserId = userId;
        }));
        this.selectiveCart$ = this.cartSelector$.pipe(map((/**
         * @param {?} cartEntity
         * @return {?}
         */
        (cartEntity) => {
            return {
                cart: cartEntity.value,
                loading: cartEntity.loading,
                loaded: (cartEntity.error || cartEntity.success) && !cartEntity.loading,
            };
        })), filter((/**
         * @param {?} __0
         * @return {?}
         */
        ({ loading }) => !loading)), tap((/**
         * @param {?} __0
         * @return {?}
         */
        ({ cart, loaded }) => {
            if (this.cartId && this.isEmpty(cart) && !loaded) {
                this.load();
            }
        })), map((/**
         * @param {?} __0
         * @return {?}
         */
        ({ cart }) => (cart ? cart : {}))), shareReplay({ bufferSize: 1, refCount: true }));
    }
    /**
     * @return {?}
     */
    getCart() {
        return this.selectiveCart$;
    }
    /**
     * @return {?}
     */
    getEntries() {
        return this.multiCartService.getEntries(this.cartId);
    }
    /**
     * @return {?}
     */
    getLoaded() {
        return this.cartSelector$.pipe(map((/**
         * @param {?} cart
         * @return {?}
         */
        cart => (cart.success || cart.error) && !cart.loading)));
    }
    /**
     * @private
     * @return {?}
     */
    load() {
        if (this.isLoggedIn(this.userId) && this.cartId) {
            this.multiCartService.loadCart({
                userId: this.userId,
                cartId: this.cartId,
            });
        }
    }
    /**
     * @param {?} productCode
     * @param {?} quantity
     * @return {?}
     */
    addEntry(productCode, quantity) {
        /** @type {?} */
        let loadAttempted = false;
        this.cartSelector$
            .pipe(filter((/**
         * @return {?}
         */
        () => !loadAttempted)), switchMap((/**
         * @param {?} cartState
         * @return {?}
         */
        cartState => {
            if (this.isEmpty(cartState.value) && !cartState.loading) {
                loadAttempted = true;
                this.load();
            }
            return of(cartState);
        })), filter((/**
         * @param {?} cartState
         * @return {?}
         */
        cartState => !this.isEmpty(cartState.value))), take(1))
            .subscribe((/**
         * @param {?} _
         * @return {?}
         */
        _ => {
            this.multiCartService.addEntry(this.userId, this.cartId, productCode, quantity);
        }));
    }
    /**
     * @param {?} entry
     * @return {?}
     */
    removeEntry(entry) {
        this.multiCartService.removeEntry(this.userId, this.cartId, entry.entryNumber);
    }
    /**
     * @param {?} entryNumber
     * @param {?} quantity
     * @return {?}
     */
    updateEntry(entryNumber, quantity) {
        this.multiCartService.updateEntry(this.userId, this.cartId, entryNumber, quantity);
    }
    /**
     * @param {?} productCode
     * @return {?}
     */
    getEntry(productCode) {
        return this.multiCartService.getEntry(this.cartId, productCode);
    }
    /**
     * @private
     * @param {?} cart
     * @return {?}
     */
    isEmpty(cart) {
        return (!cart || (typeof cart === 'object' && Object.keys(cart).length === 0));
    }
    /**
     * @private
     * @param {?} userId
     * @return {?}
     */
    isJustLoggedIn(userId) {
        return (this.isLoggedIn(userId) &&
            this.previousUserId !== userId && // *just* logged in
            this.previousUserId !== this.PREVIOUS_USER_ID_INITIAL_VALUE // not app initialization
        );
    }
    /**
     * @private
     * @param {?} userId
     * @return {?}
     */
    isLoggedIn(userId) {
        return typeof userId !== 'undefined' && userId !== OCC_USER_ID_ANONYMOUS;
    }
}
SelectiveCartService.decorators = [
    { type: Injectable }
];
/** @nocollapse */
SelectiveCartService.ctorParameters = () => [
    { type: Store },
    { type: UserService },
    { type: AuthService },
    { type: MultiCartService },
    { type: BaseSiteService }
];
if (false) {
    /**
     * @type {?}
     * @private
     */
    SelectiveCartService.prototype.customerId;
    /**
     * @type {?}
     * @private
     */
    SelectiveCartService.prototype.userId;
    /**
     * @type {?}
     * @private
     */
    SelectiveCartService.prototype.cartId;
    /**
     * @type {?}
     * @private
     */
    SelectiveCartService.prototype.selectiveCart$;
    /**
     * @type {?}
     * @private
     */
    SelectiveCartService.prototype.cartId$;
    /**
     * @type {?}
     * @private
     */
    SelectiveCartService.prototype.PREVIOUS_USER_ID_INITIAL_VALUE;
    /**
     * @type {?}
     * @private
     */
    SelectiveCartService.prototype.previousUserId;
    /**
     * @type {?}
     * @private
     */
    SelectiveCartService.prototype.cartSelector$;
    /**
     * @type {?}
     * @protected
     */
    SelectiveCartService.prototype.store;
    /**
     * @type {?}
     * @protected
     */
    SelectiveCartService.prototype.userService;
    /**
     * @type {?}
     * @protected
     */
    SelectiveCartService.prototype.authService;
    /**
     * @type {?}
     * @protected
     */
    SelectiveCartService.prototype.multiCartService;
    /**
     * @type {?}
     * @protected
     */
    SelectiveCartService.prototype.baseSiteService;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class WishListService {
    /**
     * @param {?} store
     * @param {?} authService
     * @param {?} userService
     * @param {?} multiCartService
     */
    constructor(store, authService, userService, multiCartService) {
        this.store = store;
        this.authService = authService;
        this.userService = userService;
        this.multiCartService = multiCartService;
    }
    /**
     * @param {?} userId
     * @param {?=} name
     * @param {?=} description
     * @return {?}
     */
    createWishList(userId, name, description) {
        this.store.dispatch(new CreateWishList({ userId, name, description }));
    }
    /**
     * @return {?}
     */
    getWishList() {
        return combineLatest([
            this.getWishListId(),
            this.userService.get(),
            this.authService.getOccUserId(),
        ]).pipe(distinctUntilChanged(), tap((/**
         * @param {?} __0
         * @return {?}
         */
        ([wishListId, user, userId]) => {
            if (!Boolean(wishListId) &&
                userId !== OCC_USER_ID_ANONYMOUS &&
                Boolean(user) &&
                Boolean(user.customerId)) {
                this.loadWishList(userId, user.customerId);
            }
        })), filter((/**
         * @param {?} __0
         * @return {?}
         */
        ([wishListId]) => Boolean(wishListId))), switchMap((/**
         * @param {?} __0
         * @return {?}
         */
        ([wishListId]) => this.multiCartService.getCart(wishListId))));
    }
    /**
     * @param {?} userId
     * @param {?} customerId
     * @return {?}
     */
    loadWishList(userId, customerId) {
        this.store.dispatch(new LoadWishList({ userId, customerId }));
    }
    /**
     * @param {?} productCode
     * @return {?}
     */
    addEntry(productCode) {
        this.getWishListId()
            .pipe(distinctUntilChanged(), withLatestFrom(this.authService.getOccUserId(), this.userService.get()), tap((/**
         * @param {?} __0
         * @return {?}
         */
        ([wishListId, userId, user]) => {
            if (!Boolean(wishListId) &&
                Boolean(user) &&
                Boolean(user.customerId)) {
                this.loadWishList(userId, user.customerId);
            }
        })), filter((/**
         * @param {?} __0
         * @return {?}
         */
        ([wishListId]) => Boolean(wishListId))), take(1))
            .subscribe((/**
         * @param {?} __0
         * @return {?}
         */
        ([wishListId, userId]) => this.multiCartService.addEntry(userId, wishListId, productCode, 1)));
    }
    /**
     * @param {?} entry
     * @return {?}
     */
    removeEntry(entry) {
        this.getWishListId()
            .pipe(distinctUntilChanged(), withLatestFrom(this.authService.getOccUserId(), this.userService.get()), tap((/**
         * @param {?} __0
         * @return {?}
         */
        ([wishListId, userId, user]) => {
            if (!Boolean(wishListId) &&
                Boolean(user) &&
                Boolean(user.customerId)) {
                this.loadWishList(userId, user.customerId);
            }
        })), filter((/**
         * @param {?} __0
         * @return {?}
         */
        ([wishListId]) => Boolean(wishListId))), take(1))
            .subscribe((/**
         * @param {?} __0
         * @return {?}
         */
        ([wishListId, userId]) => this.multiCartService.removeEntry(userId, wishListId, entry.entryNumber)));
    }
    /**
     * @return {?}
     */
    getWishListLoading() {
        return this.getWishListId().pipe(switchMap((/**
         * @param {?} wishListId
         * @return {?}
         */
        wishListId => this.multiCartService.isStable(wishListId).pipe(map((/**
         * @param {?} stable
         * @return {?}
         */
        stable => !stable))))));
    }
    /**
     * @protected
     * @return {?}
     */
    getWishListId() {
        return this.store.pipe(select(getWishListId));
    }
}
WishListService.decorators = [
    { type: Injectable }
];
/** @nocollapse */
WishListService.ctorParameters = () => [
    { type: Store },
    { type: AuthService },
    { type: UserService },
    { type: MultiCartService }
];
if (false) {
    /**
     * @type {?}
     * @protected
     */
    WishListService.prototype.store;
    /**
     * @type {?}
     * @protected
     */
    WishListService.prototype.authService;
    /**
     * @type {?}
     * @protected
     */
    WishListService.prototype.userService;
    /**
     * @type {?}
     * @protected
     */
    WishListService.prototype.multiCartService;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const CMS_FEATURE = 'cms';
/** @type {?} */
const NAVIGATION_DETAIL_ENTITY = '[Cms] Navigation Entity';
// TODO(issue:6027) - fix the const value to `[Cms] Component Entity`
/** @type {?} */
const COMPONENT_ENTITY = '[Cms[ Component Entity';
/**
 * @record
 */
function StateWithCms() { }
if (false) {
    /* Skipping unnamed member:
    [CMS_FEATURE]: CmsState;*/
}
/**
 * @record
 */
function ComponentsContext() { }
if (false) {
    /** @type {?} */
    ComponentsContext.prototype.component;
    /**
     * Page context stores an information for which context does the component exist.
     * For example, if `SiteLogoComponent` was successfully loaded for a product page with an ID of 1776948, then this object will contain:
     *
     * ```ts
     * ProductPage-1776948: {
     *  success: true,
     *  loading: false,
     *  error: false,
     *  // The `value` property indicates that the component exists for the given page context.
     *  value: true
     * }
     * ```
     *
     * If the same `SiteLogoComponent` component was tried to be loaded on homepage (page context id is `homepage`),
     * and it doesn't exist for some reason (maybe it has a restriction), then this object will contain:
     *
     * ```ts
     * ProductPage-1776948: {
     *  success: true,
     *  loading: false,
     *  error: false,
     *  // The `value` property indicates that the component exists for the given page context.
     *  value: true
     * },
     * ContentPage-homepage: {
     *  success: true,
     *  loading: false,
     *  error: false,
     *  // The `value` in this case is `false` indicating that the component was tried to be loaded, but it doesn't exist or has a restriction.
     *  value: false
     * }
     * ```
     *
     * @type {?}
     */
    ComponentsContext.prototype.pageContext;
}
/**
 * @record
 */
function NavigationNodes() { }
/**
 * @record
 */
function PageState() { }
if (false) {
    /** @type {?} */
    PageState.prototype.pageData;
    /** @type {?} */
    PageState.prototype.index;
}
/**
 * @record
 */
function CmsState() { }
if (false) {
    /** @type {?} */
    CmsState.prototype.page;
    /** @type {?} */
    CmsState.prototype.component;
    /** @type {?} */
    CmsState.prototype.components;
    /** @type {?} */
    CmsState.prototype.navigation;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const LOAD_CMS_COMPONENT = '[Cms] Load Component';
/** @type {?} */
const LOAD_CMS_COMPONENT_FAIL = '[Cms] Load Component Fail';
/** @type {?} */
const LOAD_CMS_COMPONENT_SUCCESS = '[Cms] Load Component Success';
// TODO(issue:6027) - rename the const to `CMS_GET_COMPONENT_FROM_PAGE`
/** @type {?} */
const CMS_GET_COMPONENET_FROM_PAGE = '[Cms] Get Component from Page';
class LoadCmsComponent extends EntityLoadAction {
    // TODO(issue:6027) - this action should have only one `payload` property which should encapsulate all of the constructor's arguments
    /**
     * @param {?} payload
     * @param {?=} pageContext
     */
    constructor(payload, pageContext) {
        super(COMPONENT_ENTITY, payload);
        this.payload = payload;
        this.pageContext = pageContext;
        this.type = LOAD_CMS_COMPONENT;
    }
}
if (false) {
    /** @type {?} */
    LoadCmsComponent.prototype.type;
    /** @type {?} */
    LoadCmsComponent.prototype.payload;
    /** @type {?} */
    LoadCmsComponent.prototype.pageContext;
}
class LoadCmsComponentFail extends EntityFailAction {
    // TODO(issue:6027) - this action should have only one `payload` property which should encapsulate all of the constructor's arguments
    /**
     * @param {?} uid
     * @param {?} payload
     * @param {?=} pageContext
     */
    constructor(uid, payload, pageContext) {
        super(COMPONENT_ENTITY, uid, payload);
        this.payload = payload;
        this.pageContext = pageContext;
        this.type = LOAD_CMS_COMPONENT_FAIL;
    }
}
if (false) {
    /** @type {?} */
    LoadCmsComponentFail.prototype.type;
    /** @type {?} */
    LoadCmsComponentFail.prototype.payload;
    /** @type {?} */
    LoadCmsComponentFail.prototype.pageContext;
}
/**
 * @template T
 */
class LoadCmsComponentSuccess extends EntitySuccessAction {
    // TODO(issue:6027) - this action should have only one `payload` property which should encapsulate all of the constructor's arguments
    /**
     * @param {?} payload
     * @param {?=} uid
     * @param {?=} pageContext
     */
    constructor(payload, uid, pageContext) {
        super(COMPONENT_ENTITY, uid || payload.uid || '');
        this.payload = payload;
        this.pageContext = pageContext;
        this.type = LOAD_CMS_COMPONENT_SUCCESS;
    }
}
if (false) {
    /** @type {?} */
    LoadCmsComponentSuccess.prototype.type;
    /** @type {?} */
    LoadCmsComponentSuccess.prototype.payload;
    /** @type {?} */
    LoadCmsComponentSuccess.prototype.pageContext;
}
/**
 * @template T
 */
class CmsGetComponentFromPage extends EntitySuccessAction {
    // TODO(issue:6027) - this action should have only one `payload` property which should encapsulate all of the constructor's arguments
    /**
     * @param {?} payload
     * @param {?=} pageContext
     */
    constructor(payload, pageContext) {
        super(COMPONENT_ENTITY, payload.map((/**
         * @param {?} cmp
         * @return {?}
         */
        cmp => cmp.uid)));
        this.payload = payload;
        this.pageContext = pageContext;
        this.type = CMS_GET_COMPONENET_FROM_PAGE;
    }
}
if (false) {
    /** @type {?} */
    CmsGetComponentFromPage.prototype.type;
    /** @type {?} */
    CmsGetComponentFromPage.prototype.payload;
    /** @type {?} */
    CmsGetComponentFromPage.prototype.pageContext;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const LOAD_CMS_NAVIGATION_ITEMS = '[Cms] Load NavigationEntry items';
/** @type {?} */
const LOAD_CMS_NAVIGATION_ITEMS_FAIL = '[Cms] Load NavigationEntry items Fail';
/** @type {?} */
const LOAD_CMS_NAVIGATION_ITEMS_SUCCESS = '[Cms] Load NavigationEntry items Success';
class LoadCmsNavigationItems extends EntityLoadAction {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        super(NAVIGATION_DETAIL_ENTITY, payload.nodeId);
        this.payload = payload;
        this.type = LOAD_CMS_NAVIGATION_ITEMS;
    }
}
if (false) {
    /** @type {?} */
    LoadCmsNavigationItems.prototype.type;
    /** @type {?} */
    LoadCmsNavigationItems.prototype.payload;
}
class LoadCmsNavigationItemsFail extends EntityFailAction {
    /**
     * @param {?} nodeId
     * @param {?} payload
     */
    constructor(nodeId, payload) {
        super(NAVIGATION_DETAIL_ENTITY, nodeId, payload);
        this.payload = payload;
        this.type = LOAD_CMS_NAVIGATION_ITEMS_FAIL;
    }
}
if (false) {
    /** @type {?} */
    LoadCmsNavigationItemsFail.prototype.type;
    /** @type {?} */
    LoadCmsNavigationItemsFail.prototype.payload;
}
class LoadCmsNavigationItemsSuccess extends EntitySuccessAction {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        super(NAVIGATION_DETAIL_ENTITY, payload.nodeId);
        this.payload = payload;
        this.type = LOAD_CMS_NAVIGATION_ITEMS_SUCCESS;
    }
}
if (false) {
    /** @type {?} */
    LoadCmsNavigationItemsSuccess.prototype.type;
    /** @type {?} */
    LoadCmsNavigationItemsSuccess.prototype.payload;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const LOAD_CMS_PAGE_DATA = '[Cms] Load Page Data';
/** @type {?} */
const LOAD_CMS_PAGE_DATA_FAIL = '[Cms] Load Page Data Fail';
/** @type {?} */
const LOAD_CMS_PAGE_DATA_SUCCESS = '[Cms] Load Page Data Success';
/** @type {?} */
const CMS_SET_PAGE_SUCCESS_INDEX = '[Cms] Set Page Success Index';
/** @type {?} */
const CMS_SET_PAGE_FAIL_INDEX = '[Cms] Set Page Fail Index';
class LoadCmsPageData extends EntityLoadAction {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        super(payload.type, payload.id);
        this.payload = payload;
        this.type = LOAD_CMS_PAGE_DATA;
    }
}
if (false) {
    /** @type {?} */
    LoadCmsPageData.prototype.type;
    /** @type {?} */
    LoadCmsPageData.prototype.payload;
}
class LoadCmsPageDataFail extends EntityFailAction {
    /**
     * @param {?} pageContext
     * @param {?} error
     */
    constructor(pageContext, error) {
        super(pageContext.type, pageContext.id, error);
        this.type = LOAD_CMS_PAGE_DATA_FAIL;
    }
}
if (false) {
    /** @type {?} */
    LoadCmsPageDataFail.prototype.type;
}
class LoadCmsPageDataSuccess extends EntitySuccessAction {
    /**
     * @param {?} pageContext
     * @param {?} payload
     */
    constructor(pageContext, payload) {
        super(pageContext.type, pageContext.id, payload);
        this.type = LOAD_CMS_PAGE_DATA_SUCCESS;
    }
}
if (false) {
    /** @type {?} */
    LoadCmsPageDataSuccess.prototype.type;
}
class CmsSetPageSuccessIndex extends EntitySuccessAction {
    /**
     * @param {?} pageContext
     * @param {?} payload
     */
    constructor(pageContext, payload) {
        super(pageContext.type, pageContext.id, payload);
        this.type = CMS_SET_PAGE_SUCCESS_INDEX;
    }
}
if (false) {
    /** @type {?} */
    CmsSetPageSuccessIndex.prototype.type;
}
class CmsSetPageFailIndex extends EntityFailAction {
    /**
     * @param {?} pageContext
     * @param {?} payload
     */
    constructor(pageContext, payload) {
        super(pageContext.type, pageContext.id);
        this.payload = payload;
        this.type = CMS_SET_PAGE_FAIL_INDEX;
    }
}
if (false) {
    /** @type {?} */
    CmsSetPageFailIndex.prototype.type;
    /** @type {?} */
    CmsSetPageFailIndex.prototype.payload;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

var cmsGroup_actions = /*#__PURE__*/Object.freeze({
    LOAD_CMS_COMPONENT: LOAD_CMS_COMPONENT,
    LOAD_CMS_COMPONENT_FAIL: LOAD_CMS_COMPONENT_FAIL,
    LOAD_CMS_COMPONENT_SUCCESS: LOAD_CMS_COMPONENT_SUCCESS,
    CMS_GET_COMPONENET_FROM_PAGE: CMS_GET_COMPONENET_FROM_PAGE,
    LoadCmsComponent: LoadCmsComponent,
    LoadCmsComponentFail: LoadCmsComponentFail,
    LoadCmsComponentSuccess: LoadCmsComponentSuccess,
    CmsGetComponentFromPage: CmsGetComponentFromPage,
    LOAD_CMS_NAVIGATION_ITEMS: LOAD_CMS_NAVIGATION_ITEMS,
    LOAD_CMS_NAVIGATION_ITEMS_FAIL: LOAD_CMS_NAVIGATION_ITEMS_FAIL,
    LOAD_CMS_NAVIGATION_ITEMS_SUCCESS: LOAD_CMS_NAVIGATION_ITEMS_SUCCESS,
    LoadCmsNavigationItems: LoadCmsNavigationItems,
    LoadCmsNavigationItemsFail: LoadCmsNavigationItemsFail,
    LoadCmsNavigationItemsSuccess: LoadCmsNavigationItemsSuccess,
    LOAD_CMS_PAGE_DATA: LOAD_CMS_PAGE_DATA,
    LOAD_CMS_PAGE_DATA_FAIL: LOAD_CMS_PAGE_DATA_FAIL,
    LOAD_CMS_PAGE_DATA_SUCCESS: LOAD_CMS_PAGE_DATA_SUCCESS,
    CMS_SET_PAGE_SUCCESS_INDEX: CMS_SET_PAGE_SUCCESS_INDEX,
    CMS_SET_PAGE_FAIL_INDEX: CMS_SET_PAGE_FAIL_INDEX,
    LoadCmsPageData: LoadCmsPageData,
    LoadCmsPageDataFail: LoadCmsPageDataFail,
    LoadCmsPageDataSuccess: LoadCmsPageDataSuccess,
    CmsSetPageSuccessIndex: CmsSetPageSuccessIndex,
    CmsSetPageFailIndex: CmsSetPageFailIndex
});

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const getCmsState = createFeatureSelector(CMS_FEATURE);

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// TODO(issue:6027) - delete this method
/**
 * @deprecated as of 2.0, this method will be removed.
 * @type {?}
 */
const getComponentEntitiesSelector = (/**
 * @param {?} state
 * @return {?}
 */
(state) => Object.keys(state.entities).reduce((/**
 * @param {?} acc
 * @param {?} cur
 * @return {?}
 */
(acc, cur) => {
    acc[cur] = state.entities[cur].value;
    return acc;
}), {}));
const ɵ0$x = getComponentEntitiesSelector;
// TODO(issue:6027) - delete this method
const ɵ1$p = /**
 * @param {?} state
 * @return {?}
 */
(state) => state.component;
/**
 * @deprecated as of 2.0, this method will be removed in favour of `getComponentsState`
 * @type {?}
 */
const getComponentState = createSelector(getCmsState, (ɵ1$p));
// TODO(issue:6027) - delete this method
/**
 * @deprecated as of 2.0, this method will be removed.
 * @type {?}
 */
const getComponentEntities = createSelector(getComponentState, getComponentEntitiesSelector);
// TODO(issue:6027) - delete this method
/**
 * @deprecated as of 2.0, this method will be removed in favour of `componentsLoaderStateSelectorFactory`
 * @type {?}
 */
const componentStateSelectorFactory = (/**
 * @param {?} uid
 * @return {?}
 */
(uid) => {
    return createSelector(getComponentState, (/**
     * @param {?} entities
     * @return {?}
     */
    entities => {
        // the whole component entities are empty
        if (Object.keys(entities.entities).length === 0) {
            return undefined;
        }
        else {
            return entityStateSelector(entities, uid);
        }
    }));
});
// TODO(issue:6027) - delete this method
/**
 * @deprecated as of 2.0, this method will be removed in favour of `componentsSelectorFactory`
 * @type {?}
 */
const componentSelectorFactory = (/**
 * @param {?} uid
 * @return {?}
 */
(uid) => {
    return createSelector(componentStateSelectorFactory(uid), (/**
     * @param {?} state
     * @return {?}
     */
    state => {
        if (state) {
            return loaderValueSelector(state);
        }
        else {
            return undefined;
        }
    }));
});
const ɵ2$i = /**
 * @param {?} state
 * @return {?}
 */
state => state.components;
/** @type {?} */
const getComponentsState = createSelector(getCmsState, (ɵ2$i));
/** @type {?} */
const componentsContextSelectorFactory = (/**
 * @param {?} uid
 * @return {?}
 */
(uid) => {
    return createSelector(getComponentsState, (/**
     * @param {?} componentsState
     * @return {?}
     */
    componentsState => entitySelector(componentsState, uid)));
});
/** @type {?} */
const componentsLoaderStateSelectorFactory = (/**
 * @param {?} uid
 * @param {?} context
 * @return {?}
 */
(uid, context) => {
    return createSelector(componentsContextSelectorFactory(uid), (/**
     * @param {?} componentsContext
     * @return {?}
     */
    componentsContext => (componentsContext &&
        componentsContext.pageContext &&
        componentsContext.pageContext[context]) ||
        initialLoaderState));
});
/** @type {?} */
const componentsContextExistsSelectorFactory = (/**
 * @param {?} uid
 * @param {?} context
 * @return {?}
 */
(uid, context) => {
    return createSelector(componentsLoaderStateSelectorFactory(uid, context), (/**
     * @param {?} loaderState
     * @return {?}
     */
    loaderState => loaderValueSelector(loaderState) || false));
});
/** @type {?} */
const componentsDataSelectorFactory = (/**
 * @param {?} uid
 * @return {?}
 */
(uid) => {
    return createSelector(componentsContextSelectorFactory(uid), (/**
     * @param {?} state
     * @return {?}
     */
    state => (state ? state.component : undefined)));
});
/** @type {?} */
const componentsSelectorFactory = (/**
 * @param {?} uid
 * @param {?} context
 * @return {?}
 */
(uid, context) => {
    return createSelector(componentsDataSelectorFactory(uid), componentsContextExistsSelectorFactory(uid, context), (/**
     * @param {?} componentState
     * @param {?} exists
     * @return {?}
     */
    (componentState, exists) => {
        if (componentState && exists) {
            return componentState;
        }
        else {
            return undefined;
        }
    }));
});

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
const ɵ0$y = /**
 * @param {?} state
 * @return {?}
 */
(state) => state.navigation;
/** @type {?} */
const getNavigationEntryItemState = createSelector(getCmsState, (ɵ0$y));
/** @type {?} */
const getSelectedNavigationEntryItemState = (/**
 * @param {?} nodeId
 * @return {?}
 */
(nodeId) => {
    return createSelector(getNavigationEntryItemState, (/**
     * @param {?} nodes
     * @return {?}
     */
    nodes => entityStateSelector(nodes, nodeId)));
});
/** @type {?} */
const getNavigationEntryItems = (/**
 * @param {?} nodeId
 * @return {?}
 */
(nodeId) => {
    return createSelector(getSelectedNavigationEntryItemState(nodeId), (/**
     * @param {?} itemState
     * @return {?}
     */
    itemState => loaderValueSelector(itemState)));
});

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const getPageEntitiesSelector = (/**
 * @param {?} state
 * @return {?}
 */
(state) => state.pageData.entities);
const ɵ0$z = getPageEntitiesSelector;
/** @type {?} */
const getIndexByType = (/**
 * @param {?} index
 * @param {?} type
 * @return {?}
 */
(index, type) => {
    switch (type) {
        case PageType.CONTENT_PAGE: {
            return index.content;
        }
        case PageType.PRODUCT_PAGE: {
            return index.product;
        }
        case PageType.CATEGORY_PAGE: {
            return index.category;
        }
        case PageType.CATALOG_PAGE: {
            return index.catalog;
        }
    }
    return { entities: {} };
});
const ɵ1$q = getIndexByType;
/** @type {?} */
const getPageComponentTypesSelector = (/**
 * @param {?} page
 * @return {?}
 */
(page) => {
    /** @type {?} */
    const componentTypes = new Set();
    if (page && page.slots) {
        for (const slot of Object.keys(page.slots)) {
            for (const component of page.slots[slot].components || []) {
                componentTypes.add(component.flexType);
            }
        }
    }
    return Array.from(componentTypes);
});
const ɵ2$j = getPageComponentTypesSelector;
const ɵ3$a = /**
 * @param {?} state
 * @return {?}
 */
(state) => state.page;
/** @type {?} */
const getPageState = createSelector(getCmsState, (ɵ3$a));
const ɵ4$3 = /**
 * @param {?} page
 * @return {?}
 */
(page) => page.index;
/** @type {?} */
const getPageStateIndex = createSelector(getPageState, (ɵ4$3));
/** @type {?} */
const getPageStateIndexEntityLoaderState = (/**
 * @param {?} pageContext
 * @return {?}
 */
(pageContext) => createSelector(getPageStateIndex, (/**
 * @param {?} index
 * @return {?}
 */
(index) => getIndexByType(index, pageContext.type))));
/** @type {?} */
const getPageStateIndexLoaderState = (/**
 * @param {?} pageContext
 * @return {?}
 */
(pageContext) => createSelector(getPageStateIndexEntityLoaderState(pageContext), (/**
 * @param {?} indexState
 * @return {?}
 */
indexState => entityStateSelector(indexState, pageContext.id))));
/** @type {?} */
const getPageStateIndexValue = (/**
 * @param {?} pageContext
 * @return {?}
 */
(pageContext) => createSelector(getPageStateIndexLoaderState(pageContext), (/**
 * @param {?} entity
 * @return {?}
 */
entity => loaderValueSelector(entity))));
/** @type {?} */
const getPageEntities = createSelector(getPageState, getPageEntitiesSelector);
/** @type {?} */
const getPageData = (/**
 * @param {?} pageContext
 * @return {?}
 */
(pageContext) => createSelector(getPageEntities, getPageStateIndexValue(pageContext), (/**
 * @param {?} entities
 * @param {?} indexValue
 * @return {?}
 */
(entities, indexValue) => entities[indexValue])));
/** @type {?} */
const getPageComponentTypes = (/**
 * @param {?} pageContext
 * @return {?}
 */
(pageContext) => createSelector(getPageData(pageContext), (/**
 * @param {?} pageData
 * @return {?}
 */
pageData => getPageComponentTypesSelector(pageData))));
/** @type {?} */
const getCurrentSlotSelectorFactory = (/**
 * @param {?} pageContext
 * @param {?} position
 * @return {?}
 */
(pageContext, position) => {
    return createSelector(getPageData(pageContext), (/**
     * @param {?} entity
     * @return {?}
     */
    entity => {
        if (entity) {
            return entity.slots[position] || { components: [] };
        }
    }));
});

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

var cmsGroup_selectors = /*#__PURE__*/Object.freeze({
    getComponentState: getComponentState,
    getComponentEntities: getComponentEntities,
    componentStateSelectorFactory: componentStateSelectorFactory,
    componentSelectorFactory: componentSelectorFactory,
    getComponentsState: getComponentsState,
    componentsContextSelectorFactory: componentsContextSelectorFactory,
    componentsLoaderStateSelectorFactory: componentsLoaderStateSelectorFactory,
    componentsContextExistsSelectorFactory: componentsContextExistsSelectorFactory,
    componentsDataSelectorFactory: componentsDataSelectorFactory,
    componentsSelectorFactory: componentsSelectorFactory,
    getCmsState: getCmsState,
    getNavigationEntryItemState: getNavigationEntryItemState,
    getSelectedNavigationEntryItemState: getSelectedNavigationEntryItemState,
    getNavigationEntryItems: getNavigationEntryItems,
    getPageState: getPageState,
    getPageStateIndex: getPageStateIndex,
    getPageStateIndexEntityLoaderState: getPageStateIndexEntityLoaderState,
    getPageStateIndexLoaderState: getPageStateIndexLoaderState,
    getPageStateIndexValue: getPageStateIndexValue,
    getPageEntities: getPageEntities,
    getPageData: getPageData,
    getPageComponentTypes: getPageComponentTypes,
    getCurrentSlotSelectorFactory: getCurrentSlotSelectorFactory
});

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const CURRENT_CONTEXT_KEY = 'current';
/**
 *
 * Serializes the provided page context.
 * The pattern used for serialization is: `pageContext.type-pageContext.id`.
 *
 * @param {?} pageContext to serialize
 * @param {?=} ignoreContentPageId if set to true, and the PageType is of type ContentPage, then the serialized page context will not contain the ID.
 * Otherwise, the page context if fully serialized.
 * @return {?}
 */
function serializePageContext(pageContext, ignoreContentPageId) {
    if (!pageContext) {
        return CURRENT_CONTEXT_KEY;
    }
    if (ignoreContentPageId && pageContext.type === PageType.CONTENT_PAGE) {
        return `${pageContext.type}`;
    }
    return `${pageContext.type}-${pageContext.id}`;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class CmsService {
    /**
     * @param {?} store
     * @param {?} routingService
     */
    constructor(store, routingService) {
        this.store = store;
        this.routingService = routingService;
        this._launchInSmartEdit = false;
        this.components = {};
    }
    /**
     * Set _launchInSmartEdit value
     * @param {?} value
     * @return {?}
     */
    set launchInSmartEdit(value) {
        this._launchInSmartEdit = value;
    }
    /**
     * Whether the app launched in smart edit
     * @return {?}
     */
    isLaunchInSmartEdit() {
        return this._launchInSmartEdit;
    }
    /**
     * Get current CMS page data
     * @return {?}
     */
    getCurrentPage() {
        return this.routingService
            .getPageContext()
            .pipe(switchMap((/**
         * @param {?} pageContext
         * @return {?}
         */
        pageContext => this.store.select(getPageData(pageContext)))));
    }
    /**
     * Get CMS component data by uid
     *
     * This method can be safely and optimally used to load multiple components data at the same time.
     * Calling getComponentData multiple times for different components will always result in optimized
     * back-end request: all components requested at the same time (in one event loop) will be loaded in one network call.
     *
     * In case the component data is not present, the method will load it.
     * Otherwise, if the page context is not provided, the current page context from the router state will be used instead.
     *
     * @template T
     * @param {?} uid CMS component uid
     * @param {?=} pageContext if provided, it will be used to lookup the component data.
     * @return {?}
     */
    getComponentData(uid, pageContext) {
        /** @type {?} */
        const context = serializePageContext(pageContext, true);
        if (!this.components[uid]) {
            // create the component data structure, if it doesn't already exist
            this.components[uid] = {};
        }
        /** @type {?} */
        const component = this.components[uid];
        if (!component[context]) {
            // create the component data and assign it to the component's context
            component[context] = this.createComponentData(uid, pageContext);
        }
        return (/** @type {?} */ (component[context]));
    }
    /**
     * @private
     * @template T
     * @param {?} uid
     * @param {?=} pageContext
     * @return {?}
     */
    createComponentData(uid, pageContext) {
        if (!pageContext) {
            return this.routingService.getPageContext().pipe(filter((/**
             * @param {?} currentContext
             * @return {?}
             */
            currentContext => !!currentContext)), switchMap((/**
             * @param {?} currentContext
             * @return {?}
             */
            currentContext => this.getComponentData(uid, currentContext))));
        }
        /** @type {?} */
        const context = serializePageContext(pageContext, true);
        /** @type {?} */
        const loading$ = combineLatest([
            this.routingService.getNextPageContext(),
            this.store.pipe(select(componentsLoaderStateSelectorFactory(uid, context))),
        ]).pipe(observeOn(queueScheduler), tap((/**
         * @param {?} __0
         * @return {?}
         */
        ([nextContext, loadingState]) => {
            /** @type {?} */
            const attemptedLoad = loadingState.loading || loadingState.success || loadingState.error;
            // if the requested context is the same as the one that's currently being navigated to
            // (as it might already been triggered and might be available shortly from page data)
            // TODO(issue:3649), TODO(issue:3668) - this optimization could be removed
            /** @type {?} */
            const couldBeLoadedWithPageData = nextContext
                ? serializePageContext(nextContext, true) === context
                : false;
            if (!attemptedLoad && !couldBeLoadedWithPageData) {
                this.store.dispatch(new LoadCmsComponent(uid, pageContext));
            }
        })));
        /** @type {?} */
        const component$ = (/** @type {?} */ (this.store.pipe(select(componentsSelectorFactory(uid, context)), 
        // TODO(issue:6027) - this `filter` should be removed.
        // The reason for removal: with `filter` in place, when moving to a page that has restrictions, the component data will still emit the previous value.
        // Removing it causes some components to fail, because they are not checking
        // if the data is actually there. I noticed these that this component is failing, but there are possibly more:
        // - `tab-paragraph-container.component.ts` when visiting any PDP page
        filter((/**
         * @param {?} component
         * @return {?}
         */
        component => !!component)))));
        return using((/**
         * @return {?}
         */
        () => loading$.subscribe()), (/**
         * @return {?}
         */
        () => component$)).pipe(shareReplay({ bufferSize: 1, refCount: true }));
    }
    /**
     * Given the position, get the content slot data
     * @param {?} position : content slot position
     * @return {?}
     */
    getContentSlot(position) {
        return this.routingService.getPageContext().pipe(switchMap((/**
         * @param {?} pageContext
         * @return {?}
         */
        pageContext => this.store.pipe(select(getCurrentSlotSelectorFactory(pageContext, position)), filter(Boolean)))));
    }
    /**
     * Given navigation node uid, get items (with id and type) inside the navigation entries
     * @param {?} navigationNodeUid : uid of the navigation node
     * @return {?}
     */
    getNavigationEntryItems(navigationNodeUid) {
        return this.store.pipe(select(getNavigationEntryItems(navigationNodeUid)));
    }
    /**
     * Load navigation items data
     * @param {?} rootUid : the uid of the root navigation node
     * @param {?} itemList : list of items (with id and type)
     * @return {?}
     */
    loadNavigationItems(rootUid, itemList) {
        this.store.dispatch(new LoadCmsNavigationItems({
            nodeId: rootUid,
            items: itemList,
        }));
    }
    /**
     * Refresh the content of the latest cms page
     * @return {?}
     */
    refreshLatestPage() {
        this.routingService
            .getPageContext()
            .pipe(take(1))
            .subscribe((/**
         * @param {?} pageContext
         * @return {?}
         */
        pageContext => this.store.dispatch(new LoadCmsPageData(pageContext))));
    }
    /**
     * Refresh the cms page content by page Id
     * @param {?} pageId
     * @return {?}
     */
    refreshPageById(pageId) {
        /** @type {?} */
        const pageContext = { id: pageId };
        this.store.dispatch(new LoadCmsPageData(pageContext));
    }
    /**
     * Refresh cms component's content
     * @param {?} uid component uid
     * @param {?=} pageContext an optional parameter that enables the caller to specify for which context the component should be refreshed.
     * If not specified, 'current' page context is used.
     * @return {?}
     */
    refreshComponent(uid, pageContext) {
        this.store.dispatch(new LoadCmsComponent(uid, pageContext));
    }
    /**
     * Given pageContext, return the CMS page data
     * @param {?} pageContext
     * @return {?}
     */
    getPageState(pageContext) {
        return this.store.pipe(select(getPageData(pageContext)));
    }
    /**
     * Given pageContext, return the CMS page data
     * @param {?} pageContext
     * @return {?}
     */
    getPageComponentTypes(pageContext) {
        return this.store.pipe(select(getPageComponentTypes(pageContext)));
    }
    /**
     * Given pageContext, return whether the CMS page data exists or not
     * @param {?} pageContext
     * @param {?=} forceReload
     * @return {?}
     */
    hasPage(pageContext, forceReload = false) {
        return this.store.pipe(select(getPageStateIndexLoaderState(pageContext)), tap((/**
         * @param {?} entity
         * @return {?}
         */
        (entity) => {
            /** @type {?} */
            const attemptedLoad = entity.loading || entity.success || entity.error;
            /** @type {?} */
            const shouldReload = forceReload && !entity.loading;
            if (!attemptedLoad || shouldReload) {
                this.store.dispatch(new LoadCmsPageData(pageContext));
                forceReload = false;
            }
        })), filter((/**
         * @param {?} entity
         * @return {?}
         */
        entity => {
            if (!entity.hasOwnProperty('value')) {
                // if we have incomplete state from SSR failed load transfer state,
                // we should wait for reload and actual value
                return false;
            }
            return entity.success || (entity.error && !entity.loading);
        })), pluck('success'), catchError((/**
         * @return {?}
         */
        () => of(false))));
    }
    /**
     * Given pageContext, return the CMS page data
     *
     * @param {?} pageContext
     * @param {?=} forceReload
     * @return {?}
     */
    getPage(pageContext, forceReload = false) {
        return this.hasPage(pageContext, forceReload).pipe(switchMap((/**
         * @param {?} hasPage
         * @return {?}
         */
        hasPage => hasPage ? this.getPageState(pageContext) : of(null))));
    }
    /**
     * @param {?} pageContext
     * @return {?}
     */
    getPageIndex(pageContext) {
        return this.store.pipe(select(getPageStateIndexValue(pageContext)));
    }
    /**
     * @param {?} pageContext
     * @param {?} value
     * @return {?}
     */
    setPageFailIndex(pageContext, value) {
        this.store.dispatch(new CmsSetPageFailIndex(pageContext, value));
    }
}
CmsService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root',
            },] }
];
/** @nocollapse */
CmsService.ctorParameters = () => [
    { type: Store },
    { type: RoutingService }
];
/** @nocollapse */ CmsService.ngInjectableDef = ɵɵdefineInjectable({ factory: function CmsService_Factory() { return new CmsService(ɵɵinject(Store), ɵɵinject(RoutingService)); }, token: CmsService, providedIn: "root" });
if (false) {
    /**
     * @type {?}
     * @private
     */
    CmsService.prototype._launchInSmartEdit;
    /**
     * @type {?}
     * @private
     */
    CmsService.prototype.components;
    /**
     * @type {?}
     * @protected
     */
    CmsService.prototype.store;
    /**
     * @type {?}
     * @protected
     */
    CmsService.prototype.routingService;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @record
 */
function Page() { }
if (false) {
    /** @type {?|undefined} */
    Page.prototype.pageId;
    /** @type {?|undefined} */
    Page.prototype.name;
    /** @type {?|undefined} */
    Page.prototype.type;
    /** @type {?|undefined} */
    Page.prototype.title;
    /** @type {?|undefined} */
    Page.prototype.template;
    /** @type {?|undefined} */
    Page.prototype.loadTime;
    /** @type {?} */
    Page.prototype.slots;
    /** @type {?|undefined} */
    Page.prototype.properties;
    /** @type {?|undefined} */
    Page.prototype.label;
}
/**
 * Represents the cms structure for pages, slots and components.
 * @record
 */
function CmsStructureModel() { }
if (false) {
    /** @type {?|undefined} */
    CmsStructureModel.prototype.page;
    /** @type {?|undefined} */
    CmsStructureModel.prototype.components;
}
/**
 * Represents the page meta data that can be used
 * to resolve page data and seo related data.
 * @record
 */
function PageMeta() { }
if (false) {
    /**
     * the page title is used for the page title tag which
     * is visible in the browser navigation as well as in the
     * Search Engine Result Page
     * @type {?|undefined}
     */
    PageMeta.prototype.title;
    /**
     * the page heading is typically used in the UI
     * @type {?|undefined}
     */
    PageMeta.prototype.heading;
    /**
     * the page description is used in the Search Engine Result Page
     * @type {?|undefined}
     */
    PageMeta.prototype.description;
    /**
     * the robots information drives search engines to index the page and
     * follow links in the page
     * @type {?|undefined}
     */
    PageMeta.prototype.robots;
    /**
     * image that can be added to the og:image metatag
     * @type {?|undefined}
     */
    PageMeta.prototype.image;
    /**
     * the list of breadcrumbs that can be rendered in the page UI.
     * @type {?|undefined}
     */
    PageMeta.prototype.breadcrumbs;
}
/**
 * @record
 */
function BreadcrumbMeta() { }
if (false) {
    /** @type {?} */
    BreadcrumbMeta.prototype.label;
    /** @type {?} */
    BreadcrumbMeta.prototype.link;
}
/** @enum {string} */
const PageRobotsMeta = {
    INDEX: 'INDEX',
    NOINDEX: 'NOINDEX',
    FOLLOW: 'FOLLOW',
    NOFOLLOW: 'NOFOLLOW',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Resolves the page data for all Content Pages based on the `PageType.CONTENT_PAGE`
 * and the `CartPageTemplate`. If the cart page matches this template, the more generic
 * `ContentPageMetaResolver` is overriden by this resolver.
 *
 * The page title and robots are resolved in this implementation only.
 */
class CartPageMetaResolver extends PageMetaResolver {
    /**
     * @param {?} cms
     */
    constructor(cms) {
        super();
        this.cms = cms;
        this.cms$ = this.cms
            .getCurrentPage()
            .pipe(filter((/**
         * @param {?} page
         * @return {?}
         */
        page => !!page)));
        this.pageType = PageType.CONTENT_PAGE;
        this.pageTemplate = 'CartPageTemplate';
    }
    /**
     * @deprecated since version 1.3
     *
     * The resolve method is no longer preferred and will be removed with release 2.0.
     * The caller `PageMetaService` service is improved to expect all individual resolvers
     * instead, so that the code is easier extensible.
     * @return {?}
     */
    resolve() {
        return this.cms$.pipe(switchMap((/**
         * @param {?} page
         * @return {?}
         */
        page => combineLatest([this.resolveTitle(page), this.resolveRobots()]))), map((/**
         * @param {?} __0
         * @return {?}
         */
        ([title, robots]) => ({ title, robots }))));
    }
    /**
     * @param {?=} page
     * @return {?}
     */
    resolveTitle(page) {
        return page ? of(page.title) : this.cms$.pipe(map((/**
         * @param {?} p
         * @return {?}
         */
        p => p.title)));
    }
    /**
     * @return {?}
     */
    resolveRobots() {
        return of([PageRobotsMeta.NOFOLLOW, PageRobotsMeta.NOINDEX]);
    }
}
CartPageMetaResolver.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root',
            },] }
];
/** @nocollapse */
CartPageMetaResolver.ctorParameters = () => [
    { type: CmsService }
];
/** @nocollapse */ CartPageMetaResolver.ngInjectableDef = ɵɵdefineInjectable({ factory: function CartPageMetaResolver_Factory() { return new CartPageMetaResolver(ɵɵinject(CmsService)); }, token: CartPageMetaResolver, providedIn: "root" });
if (false) {
    /** @type {?} */
    CartPageMetaResolver.prototype.cms$;
    /**
     * @type {?}
     * @protected
     */
    CartPageMetaResolver.prototype.cms;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 *
 * Withdraw from the source observable when notifier emits a value
 *
 * Withdraw will result in resubscribing to the source observable
 * Operator is useful to kill ongoing emission transformation on notifier emission
 *
 * @template T
 * @param {?} notifier
 * @return {?}
 */
function withdrawOn(notifier) {
    return (/**
     * @param {?} source
     * @return {?}
     */
    (source) => notifier.pipe(startWith(undefined), switchMapTo(source)));
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class CartEntryConnector {
    /**
     * @param {?} adapter
     */
    constructor(adapter) {
        this.adapter = adapter;
    }
    /**
     * @param {?} userId
     * @param {?} cartId
     * @param {?} productCode
     * @param {?=} quantity
     * @return {?}
     */
    add(userId, cartId, productCode, quantity) {
        return this.adapter.add(userId, cartId, productCode, quantity);
    }
    /**
     * @param {?} userId
     * @param {?} cartId
     * @param {?} entryNumber
     * @param {?} qty
     * @param {?=} pickupStore
     * @return {?}
     */
    update(userId, cartId, entryNumber, qty, pickupStore) {
        return this.adapter.update(userId, cartId, entryNumber, qty, pickupStore);
    }
    /**
     * @param {?} userId
     * @param {?} cartId
     * @param {?} entryNumber
     * @return {?}
     */
    remove(userId, cartId, entryNumber) {
        return this.adapter.remove(userId, cartId, entryNumber);
    }
}
CartEntryConnector.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root',
            },] }
];
/** @nocollapse */
CartEntryConnector.ctorParameters = () => [
    { type: CartEntryAdapter }
];
/** @nocollapse */ CartEntryConnector.ngInjectableDef = ɵɵdefineInjectable({ factory: function CartEntryConnector_Factory() { return new CartEntryConnector(ɵɵinject(CartEntryAdapter)); }, token: CartEntryConnector, providedIn: "root" });
if (false) {
    /**
     * @type {?}
     * @protected
     */
    CartEntryConnector.prototype.adapter;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @deprecated since version 1.5
 *
 * spartacus ngrx effects will no longer be a part of public API
 *
 * TODO(issue:#4507)
 */
class CartEntryEffects {
    /**
     * @param {?} actions$
     * @param {?} cartEntryConnector
     */
    constructor(actions$, cartEntryConnector) {
        this.actions$ = actions$;
        this.cartEntryConnector = cartEntryConnector;
        this.contextChange$ = this.actions$.pipe(ofType(CURRENCY_CHANGE, LANGUAGE_CHANGE));
        this.addEntry$ = this.actions$.pipe(ofType(CART_ADD_ENTRY), map((/**
         * @param {?} action
         * @return {?}
         */
        (action) => action.payload)), concatMap((/**
         * @param {?} payload
         * @return {?}
         */
        payload => {
            return this.cartEntryConnector
                .add(payload.userId, payload.cartId, payload.productCode, payload.quantity)
                .pipe(map((/**
             * @param {?} entry
             * @return {?}
             */
            (entry) => new CartAddEntrySuccess(Object.assign({}, entry, { userId: payload.userId, cartId: payload.cartId })))), catchError((/**
             * @param {?} error
             * @return {?}
             */
            error => from([
                new CartAddEntryFail(makeErrorSerializable(error)),
                new CartProcessesDecrement(payload.cartId),
                new LoadCart({
                    cartId: payload.cartId,
                    userId: payload.userId,
                }),
            ]))));
        })), withdrawOn(this.contextChange$));
        this.removeEntry$ = this.actions$.pipe(ofType(CART_REMOVE_ENTRY), map((/**
         * @param {?} action
         * @return {?}
         */
        (action) => action.payload)), concatMap((/**
         * @param {?} payload
         * @return {?}
         */
        payload => this.cartEntryConnector
            .remove(payload.userId, payload.cartId, payload.entry)
            .pipe(map((/**
         * @return {?}
         */
        () => {
            return new CartRemoveEntrySuccess({
                userId: payload.userId,
                cartId: payload.cartId,
            });
        })), catchError((/**
         * @param {?} error
         * @return {?}
         */
        error => from([
            new CartRemoveEntryFail(makeErrorSerializable(error)),
            new CartProcessesDecrement(payload.cartId),
            new LoadCart({
                cartId: payload.cartId,
                userId: payload.userId,
            }),
        ])))))), withdrawOn(this.contextChange$));
        this.updateEntry$ = this.actions$.pipe(ofType(CART_UPDATE_ENTRY), map((/**
         * @param {?} action
         * @return {?}
         */
        (action) => action.payload)), concatMap((/**
         * @param {?} payload
         * @return {?}
         */
        payload => this.cartEntryConnector
            .update(payload.userId, payload.cartId, payload.entry, payload.qty)
            .pipe(map((/**
         * @return {?}
         */
        () => {
            return new CartUpdateEntrySuccess({
                userId: payload.userId,
                cartId: payload.cartId,
            });
        })), catchError((/**
         * @param {?} error
         * @return {?}
         */
        error => from([
            new CartUpdateEntryFail(makeErrorSerializable(error)),
            new CartProcessesDecrement(payload.cartId),
            new LoadCart({
                cartId: payload.cartId,
                userId: payload.userId,
            }),
        ])))))), withdrawOn(this.contextChange$));
    }
}
CartEntryEffects.decorators = [
    { type: Injectable }
];
/** @nocollapse */
CartEntryEffects.ctorParameters = () => [
    { type: Actions },
    { type: CartEntryConnector }
];
__decorate([
    Effect(),
    __metadata("design:type", Observable)
], CartEntryEffects.prototype, "addEntry$", void 0);
__decorate([
    Effect(),
    __metadata("design:type", Observable)
], CartEntryEffects.prototype, "removeEntry$", void 0);
__decorate([
    Effect(),
    __metadata("design:type", Observable)
], CartEntryEffects.prototype, "updateEntry$", void 0);
if (false) {
    /**
     * @type {?}
     * @private
     */
    CartEntryEffects.prototype.contextChange$;
    /** @type {?} */
    CartEntryEffects.prototype.addEntry$;
    /** @type {?} */
    CartEntryEffects.prototype.removeEntry$;
    /** @type {?} */
    CartEntryEffects.prototype.updateEntry$;
    /**
     * @type {?}
     * @private
     */
    CartEntryEffects.prototype.actions$;
    /**
     * @type {?}
     * @private
     */
    CartEntryEffects.prototype.cartEntryConnector;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class CartVoucherConnector {
    /**
     * @param {?} adapter
     */
    constructor(adapter) {
        this.adapter = adapter;
    }
    /**
     * @param {?} userId
     * @param {?} cartId
     * @param {?} voucherId
     * @return {?}
     */
    add(userId, cartId, voucherId) {
        return this.adapter.add(userId, cartId, voucherId);
    }
    /**
     * @param {?} userId
     * @param {?} cartId
     * @param {?} voucherId
     * @return {?}
     */
    remove(userId, cartId, voucherId) {
        return this.adapter.remove(userId, cartId, voucherId);
    }
}
CartVoucherConnector.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root',
            },] }
];
/** @nocollapse */
CartVoucherConnector.ctorParameters = () => [
    { type: CartVoucherAdapter }
];
/** @nocollapse */ CartVoucherConnector.ngInjectableDef = ɵɵdefineInjectable({ factory: function CartVoucherConnector_Factory() { return new CartVoucherConnector(ɵɵinject(CartVoucherAdapter)); }, token: CartVoucherConnector, providedIn: "root" });
if (false) {
    /**
     * @type {?}
     * @protected
     */
    CartVoucherConnector.prototype.adapter;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @deprecated since version 1.5
 *
 * spartacus ngrx effects will no longer be a part of public API
 *
 * TODO(issue:#4507)
 */
class CartVoucherEffects {
    /**
     * @param {?} actions$
     * @param {?} cartVoucherConnector
     * @param {?} messageService
     */
    constructor(actions$, cartVoucherConnector, messageService) {
        this.actions$ = actions$;
        this.cartVoucherConnector = cartVoucherConnector;
        this.messageService = messageService;
        this.addCartVoucher$ = this.actions$.pipe(ofType(CART_ADD_VOUCHER), map((/**
         * @param {?} action
         * @return {?}
         */
        (action) => action.payload)), mergeMap((/**
         * @param {?} payload
         * @return {?}
         */
        payload => {
            return this.cartVoucherConnector
                .add(payload.userId, payload.cartId, payload.voucherId)
                .pipe(map((/**
             * @return {?}
             */
            () => {
                this.showGlobalMessage('voucher.applyVoucherSuccess', payload.voucherId, GlobalMessageType.MSG_TYPE_CONFIRMATION);
                return new CartAddVoucherSuccess({
                    userId: payload.userId,
                    cartId: payload.cartId,
                });
            })), catchError((/**
             * @param {?} error
             * @return {?}
             */
            error => from([
                new CartAddVoucherFail(makeErrorSerializable(error)),
                new CartProcessesDecrement(payload.cartId),
                new LoadCart({
                    userId: payload.userId,
                    cartId: payload.cartId,
                }),
            ]))));
        })));
        this.removeCartVoucher$ = this.actions$.pipe(ofType(CART_REMOVE_VOUCHER), map((/**
         * @param {?} action
         * @return {?}
         */
        (action) => action.payload)), mergeMap((/**
         * @param {?} payload
         * @return {?}
         */
        payload => {
            return this.cartVoucherConnector
                .remove(payload.userId, payload.cartId, payload.voucherId)
                .pipe(map((/**
             * @return {?}
             */
            () => {
                this.showGlobalMessage('voucher.removeVoucherSuccess', payload.voucherId, GlobalMessageType.MSG_TYPE_INFO);
                return new CartRemoveVoucherSuccess({
                    userId: payload.userId,
                    cartId: payload.cartId,
                });
            })), catchError((/**
             * @param {?} error
             * @return {?}
             */
            error => from([
                new CartRemoveVoucherFail(makeErrorSerializable(error)),
                new CartProcessesDecrement(payload.cartId),
                new LoadCart({
                    userId: payload.userId,
                    cartId: payload.cartId,
                }),
            ]))));
        })));
    }
    /**
     * @private
     * @param {?} text
     * @param {?} param
     * @param {?} messageType
     * @return {?}
     */
    showGlobalMessage(text, param, messageType) {
        this.messageService.add({ key: text, params: { voucherCode: param } }, messageType);
    }
}
CartVoucherEffects.decorators = [
    { type: Injectable }
];
/** @nocollapse */
CartVoucherEffects.ctorParameters = () => [
    { type: Actions },
    { type: CartVoucherConnector },
    { type: GlobalMessageService }
];
__decorate([
    Effect(),
    __metadata("design:type", Observable)
], CartVoucherEffects.prototype, "addCartVoucher$", void 0);
__decorate([
    Effect(),
    __metadata("design:type", Observable)
], CartVoucherEffects.prototype, "removeCartVoucher$", void 0);
if (false) {
    /** @type {?} */
    CartVoucherEffects.prototype.addCartVoucher$;
    /** @type {?} */
    CartVoucherEffects.prototype.removeCartVoucher$;
    /**
     * @type {?}
     * @private
     */
    CartVoucherEffects.prototype.actions$;
    /**
     * @type {?}
     * @private
     */
    CartVoucherEffects.prototype.cartVoucherConnector;
    /**
     * @type {?}
     * @private
     */
    CartVoucherEffects.prototype.messageService;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const VERIFY_ADDRESS = '[Checkout] Verify Address';
/** @type {?} */
const VERIFY_ADDRESS_FAIL = '[Checkout] Verify Address Fail';
/** @type {?} */
const VERIFY_ADDRESS_SUCCESS = '[Checkout] Verify Address Success';
/** @type {?} */
const CLEAR_ADDRESS_VERIFICATION_RESULTS = '[Checkout] Clear Address Verification Results';
class VerifyAddress {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        this.payload = payload;
        this.type = VERIFY_ADDRESS;
    }
}
if (false) {
    /** @type {?} */
    VerifyAddress.prototype.type;
    /** @type {?} */
    VerifyAddress.prototype.payload;
}
class VerifyAddressFail {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        this.payload = payload;
        this.type = VERIFY_ADDRESS_FAIL;
    }
}
if (false) {
    /** @type {?} */
    VerifyAddressFail.prototype.type;
    /** @type {?} */
    VerifyAddressFail.prototype.payload;
}
class VerifyAddressSuccess {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        this.payload = payload;
        this.type = VERIFY_ADDRESS_SUCCESS;
    }
}
if (false) {
    /** @type {?} */
    VerifyAddressSuccess.prototype.type;
    /** @type {?} */
    VerifyAddressSuccess.prototype.payload;
}
class ClearAddressVerificationResults {
    constructor() {
        this.type = CLEAR_ADDRESS_VERIFICATION_RESULTS;
    }
}
if (false) {
    /** @type {?} */
    ClearAddressVerificationResults.prototype.type;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const LOAD_CARD_TYPES = '[Checkout] Load Card Types';
/** @type {?} */
const LOAD_CARD_TYPES_FAIL = '[Checkout] Load Card Fail';
/** @type {?} */
const LOAD_CARD_TYPES_SUCCESS = '[Checkout] Load Card Success';
class LoadCardTypes {
    constructor() {
        this.type = LOAD_CARD_TYPES;
    }
}
if (false) {
    /** @type {?} */
    LoadCardTypes.prototype.type;
}
class LoadCardTypesFail {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        this.payload = payload;
        this.type = LOAD_CARD_TYPES_FAIL;
    }
}
if (false) {
    /** @type {?} */
    LoadCardTypesFail.prototype.type;
    /** @type {?} */
    LoadCardTypesFail.prototype.payload;
}
class LoadCardTypesSuccess {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        this.payload = payload;
        this.type = LOAD_CARD_TYPES_SUCCESS;
    }
}
if (false) {
    /** @type {?} */
    LoadCardTypesSuccess.prototype.type;
    /** @type {?} */
    LoadCardTypesSuccess.prototype.payload;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const CHECKOUT_FEATURE = 'checkout';
/** @type {?} */
const CHECKOUT_DETAILS = '[Checkout] Checkout Details';
/** @type {?} */
const SET_DELIVERY_ADDRESS_PROCESS_ID = 'setDeliveryAddress';
/** @type {?} */
const SET_DELIVERY_MODE_PROCESS_ID = 'setDeliveryMode';
/** @type {?} */
const SET_SUPPORTED_DELIVERY_MODE_PROCESS_ID = 'setSupportedDeliveryMode';
/** @type {?} */
const SET_PAYMENT_DETAILS_PROCESS_ID = 'setPaymentDetails';
/**
 * @record
 */
function StateWithCheckout() { }
if (false) {
    /* Skipping unnamed member:
    [CHECKOUT_FEATURE]: CheckoutState;*/
}
/**
 * @record
 */
function AddressVerificationState() { }
if (false) {
    /** @type {?} */
    AddressVerificationState.prototype.results;
}
/**
 * @record
 */
function CardTypesState() { }
if (false) {
    /** @type {?} */
    CardTypesState.prototype.entities;
}
/**
 * @record
 */
function CheckoutStepsState() { }
if (false) {
    /** @type {?} */
    CheckoutStepsState.prototype.address;
    /** @type {?} */
    CheckoutStepsState.prototype.deliveryMode;
    /** @type {?} */
    CheckoutStepsState.prototype.paymentDetails;
    /** @type {?} */
    CheckoutStepsState.prototype.orderDetails;
}
/**
 * @record
 */
function CheckoutState() { }
if (false) {
    /** @type {?} */
    CheckoutState.prototype.steps;
    /** @type {?} */
    CheckoutState.prototype.cardTypes;
    /** @type {?} */
    CheckoutState.prototype.addressVerification;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const CLEAR_CHECKOUT_DELIVERY_ADDRESS = '[Checkout] Clear Checkout Delivery Address';
/** @type {?} */
const CLEAR_CHECKOUT_DELIVERY_ADDRESS_SUCCESS = '[Checkout] Clear Checkout Delivery Address Success';
/** @type {?} */
const CLEAR_CHECKOUT_DELIVERY_ADDRESS_FAIL = '[Checkout] Clear Checkout Delivery Address Fail';
/** @type {?} */
const CLEAR_CHECKOUT_DELIVERY_MODE = '[Checkout] Clear Checkout Delivery Mode';
/** @type {?} */
const CLEAR_CHECKOUT_DELIVERY_MODE_SUCCESS = '[Checkout] Clear Checkout Delivery Mode Success';
/** @type {?} */
const CLEAR_CHECKOUT_DELIVERY_MODE_FAIL = '[Checkout] Clear Checkout Delivery Mode Fail';
/** @type {?} */
const ADD_DELIVERY_ADDRESS = '[Checkout] Add Delivery Address';
/** @type {?} */
const ADD_DELIVERY_ADDRESS_FAIL = '[Checkout] Add Delivery Address Fail';
/** @type {?} */
const ADD_DELIVERY_ADDRESS_SUCCESS = '[Checkout] Add Delivery Address Success';
/** @type {?} */
const SET_DELIVERY_ADDRESS = '[Checkout] Set Delivery Address';
/** @type {?} */
const SET_DELIVERY_ADDRESS_FAIL = '[Checkout] Set Delivery Address Fail';
/** @type {?} */
const SET_DELIVERY_ADDRESS_SUCCESS = '[Checkout] Set Delivery Address Success';
/** @type {?} */
const RESET_SET_DELIVERY_ADDRESS_PROCESS = '[Checkout] Reset Set Delivery Address Process';
/** @type {?} */
const LOAD_SUPPORTED_DELIVERY_MODES = '[Checkout] Load Supported Delivery Modes';
/** @type {?} */
const LOAD_SUPPORTED_DELIVERY_MODES_FAIL = '[Checkout] Load Supported Delivery Modes Fail';
/** @type {?} */
const LOAD_SUPPORTED_DELIVERY_MODES_SUCCESS = '[Checkout] Load Supported Delivery Modes Success';
/** @type {?} */
const CLEAR_SUPPORTED_DELIVERY_MODES = '[Checkout] Clear Supported Delivery Modes';
/** @type {?} */
const SET_DELIVERY_MODE = '[Checkout] Set Delivery Mode';
/** @type {?} */
const SET_DELIVERY_MODE_FAIL = '[Checkout] Set Delivery Mode Fail';
/** @type {?} */
const SET_DELIVERY_MODE_SUCCESS = '[Checkout] Set Delivery Mode Success';
/** @type {?} */
const RESET_SET_DELIVERY_MODE_PROCESS = '[Checkout] Reset Set Delivery Mode Process';
/** @type {?} */
const SET_SUPPORTED_DELIVERY_MODES = '[Checkout] Set Supported Delivery Modes';
/** @type {?} */
const SET_SUPPORTED_DELIVERY_MODES_FAIL = '[Checkout] Set Supported Delivery Modes Fail';
/** @type {?} */
const SET_SUPPORTED_DELIVERY_MODES_SUCCESS = '[Checkout] Set Supported Delivery Modes Success';
/** @type {?} */
const RESET_SUPPORTED_SET_DELIVERY_MODES_PROCESS = '[Checkout] Reset Set Supported Delivery Modes Process';
/** @type {?} */
const CREATE_PAYMENT_DETAILS = '[Checkout] Create Payment Details';
/** @type {?} */
const CREATE_PAYMENT_DETAILS_FAIL = '[Checkout] Create Payment Details Fail';
/** @type {?} */
const CREATE_PAYMENT_DETAILS_SUCCESS = '[Checkout] Create Payment Details Success';
/** @type {?} */
const SET_PAYMENT_DETAILS = '[Checkout] Set Payment Details';
/** @type {?} */
const SET_PAYMENT_DETAILS_FAIL = '[Checkout] Set Payment Details Fail';
/** @type {?} */
const SET_PAYMENT_DETAILS_SUCCESS = '[Checkout] Set Payment Details Success';
/** @type {?} */
const RESET_SET_PAYMENT_DETAILS_PROCESS = '[Checkout] Reset Set Payment Details Process';
/** @type {?} */
const PLACE_ORDER = '[Checkout] Place Order';
/** @type {?} */
const PLACE_ORDER_FAIL = '[Checkout] Place Order Fail';
/** @type {?} */
const PLACE_ORDER_SUCCESS = '[Checkout] Place Order Success';
/** @type {?} */
const CLEAR_CHECKOUT_STEP = '[Checkout] Clear One Checkout Step';
/** @type {?} */
const CLEAR_CHECKOUT_DATA = '[Checkout] Clear Checkout Data';
/** @type {?} */
const LOAD_CHECKOUT_DETAILS = '[Checkout] Load Checkout Details';
/** @type {?} */
const LOAD_CHECKOUT_DETAILS_FAIL = '[Checkout] Load Checkout Details Fail';
/** @type {?} */
const LOAD_CHECKOUT_DETAILS_SUCCESS = '[Checkout] Load Checkout Details Success';
/** @type {?} */
const CHECKOUT_CLEAR_MISCS_DATA = '[Checkout] Clear Miscs Data';
/** @type {?} */
const PAYMENT_PROCESS_SUCCESS = '[Checkout] Payment Process Success';
class AddDeliveryAddress {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        this.payload = payload;
        this.type = ADD_DELIVERY_ADDRESS;
    }
}
if (false) {
    /** @type {?} */
    AddDeliveryAddress.prototype.type;
    /** @type {?} */
    AddDeliveryAddress.prototype.payload;
}
class AddDeliveryAddressFail {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        this.payload = payload;
        this.type = ADD_DELIVERY_ADDRESS_FAIL;
    }
}
if (false) {
    /** @type {?} */
    AddDeliveryAddressFail.prototype.type;
    /** @type {?} */
    AddDeliveryAddressFail.prototype.payload;
}
class AddDeliveryAddressSuccess {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        this.payload = payload;
        this.type = ADD_DELIVERY_ADDRESS_SUCCESS;
    }
}
if (false) {
    /** @type {?} */
    AddDeliveryAddressSuccess.prototype.type;
    /** @type {?} */
    AddDeliveryAddressSuccess.prototype.payload;
}
class SetDeliveryAddress extends EntityLoadAction {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        super(PROCESS_FEATURE, SET_DELIVERY_ADDRESS_PROCESS_ID);
        this.payload = payload;
        this.type = SET_DELIVERY_ADDRESS;
    }
}
if (false) {
    /** @type {?} */
    SetDeliveryAddress.prototype.type;
    /** @type {?} */
    SetDeliveryAddress.prototype.payload;
}
class SetDeliveryAddressFail extends EntityFailAction {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        super(PROCESS_FEATURE, SET_DELIVERY_ADDRESS_PROCESS_ID, payload);
        this.payload = payload;
        this.type = SET_DELIVERY_ADDRESS_FAIL;
    }
}
if (false) {
    /** @type {?} */
    SetDeliveryAddressFail.prototype.type;
    /** @type {?} */
    SetDeliveryAddressFail.prototype.payload;
}
class SetDeliveryAddressSuccess extends EntitySuccessAction {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        super(PROCESS_FEATURE, SET_DELIVERY_ADDRESS_PROCESS_ID);
        this.payload = payload;
        this.type = SET_DELIVERY_ADDRESS_SUCCESS;
    }
}
if (false) {
    /** @type {?} */
    SetDeliveryAddressSuccess.prototype.type;
    /** @type {?} */
    SetDeliveryAddressSuccess.prototype.payload;
}
class ResetSetDeliveryAddressProcess extends EntityResetAction {
    constructor() {
        super(PROCESS_FEATURE, SET_DELIVERY_ADDRESS_PROCESS_ID);
        this.type = RESET_SET_DELIVERY_ADDRESS_PROCESS;
    }
}
if (false) {
    /** @type {?} */
    ResetSetDeliveryAddressProcess.prototype.type;
}
class LoadSupportedDeliveryModes extends EntityLoadAction {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        super(PROCESS_FEATURE, SET_SUPPORTED_DELIVERY_MODE_PROCESS_ID);
        this.payload = payload;
        this.type = LOAD_SUPPORTED_DELIVERY_MODES;
    }
}
if (false) {
    /** @type {?} */
    LoadSupportedDeliveryModes.prototype.type;
    /** @type {?} */
    LoadSupportedDeliveryModes.prototype.payload;
}
class LoadSupportedDeliveryModesFail extends EntityFailAction {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        super(PROCESS_FEATURE, SET_SUPPORTED_DELIVERY_MODE_PROCESS_ID);
        this.payload = payload;
        this.type = LOAD_SUPPORTED_DELIVERY_MODES_FAIL;
    }
}
if (false) {
    /** @type {?} */
    LoadSupportedDeliveryModesFail.prototype.type;
    /** @type {?} */
    LoadSupportedDeliveryModesFail.prototype.payload;
}
class LoadSupportedDeliveryModesSuccess extends EntitySuccessAction {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        super(PROCESS_FEATURE, SET_SUPPORTED_DELIVERY_MODE_PROCESS_ID);
        this.payload = payload;
        this.type = LOAD_SUPPORTED_DELIVERY_MODES_SUCCESS;
    }
}
if (false) {
    /** @type {?} */
    LoadSupportedDeliveryModesSuccess.prototype.type;
    /** @type {?} */
    LoadSupportedDeliveryModesSuccess.prototype.payload;
}
class ResetLoadSupportedDeliveryModesProcess extends EntityResetAction {
    constructor() {
        super(PROCESS_FEATURE, SET_SUPPORTED_DELIVERY_MODE_PROCESS_ID);
        this.type = RESET_SUPPORTED_SET_DELIVERY_MODES_PROCESS;
    }
}
if (false) {
    /** @type {?} */
    ResetLoadSupportedDeliveryModesProcess.prototype.type;
}
class SetDeliveryMode extends EntityLoadAction {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        super(PROCESS_FEATURE, SET_DELIVERY_MODE_PROCESS_ID);
        this.payload = payload;
        this.type = SET_DELIVERY_MODE;
    }
}
if (false) {
    /** @type {?} */
    SetDeliveryMode.prototype.type;
    /** @type {?} */
    SetDeliveryMode.prototype.payload;
}
class SetDeliveryModeFail extends EntityFailAction {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        super(PROCESS_FEATURE, SET_DELIVERY_MODE_PROCESS_ID, payload);
        this.payload = payload;
        this.type = SET_DELIVERY_MODE_FAIL;
    }
}
if (false) {
    /** @type {?} */
    SetDeliveryModeFail.prototype.type;
    /** @type {?} */
    SetDeliveryModeFail.prototype.payload;
}
class SetDeliveryModeSuccess extends EntitySuccessAction {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        super(PROCESS_FEATURE, SET_DELIVERY_MODE_PROCESS_ID);
        this.payload = payload;
        this.type = SET_DELIVERY_MODE_SUCCESS;
    }
}
if (false) {
    /** @type {?} */
    SetDeliveryModeSuccess.prototype.type;
    /** @type {?} */
    SetDeliveryModeSuccess.prototype.payload;
}
class ResetSetDeliveryModeProcess extends EntityResetAction {
    constructor() {
        super(PROCESS_FEATURE, SET_DELIVERY_MODE_PROCESS_ID);
        this.type = RESET_SET_DELIVERY_MODE_PROCESS;
    }
}
if (false) {
    /** @type {?} */
    ResetSetDeliveryModeProcess.prototype.type;
}
class CreatePaymentDetails extends EntityLoadAction {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        super(PROCESS_FEATURE, SET_PAYMENT_DETAILS_PROCESS_ID);
        this.payload = payload;
        this.type = CREATE_PAYMENT_DETAILS;
    }
}
if (false) {
    /** @type {?} */
    CreatePaymentDetails.prototype.type;
    /** @type {?} */
    CreatePaymentDetails.prototype.payload;
}
class CreatePaymentDetailsFail extends EntityFailAction {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        super(PROCESS_FEATURE, SET_PAYMENT_DETAILS_PROCESS_ID);
        this.payload = payload;
        this.type = CREATE_PAYMENT_DETAILS_FAIL;
    }
}
if (false) {
    /** @type {?} */
    CreatePaymentDetailsFail.prototype.type;
    /** @type {?} */
    CreatePaymentDetailsFail.prototype.payload;
}
class CreatePaymentDetailsSuccess {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        this.payload = payload;
        this.type = CREATE_PAYMENT_DETAILS_SUCCESS;
    }
}
if (false) {
    /** @type {?} */
    CreatePaymentDetailsSuccess.prototype.type;
    /** @type {?} */
    CreatePaymentDetailsSuccess.prototype.payload;
}
class PaymentProcessSuccess extends EntitySuccessAction {
    constructor() {
        super(PROCESS_FEATURE, SET_PAYMENT_DETAILS_PROCESS_ID);
        this.type = PAYMENT_PROCESS_SUCCESS;
    }
}
if (false) {
    /** @type {?} */
    PaymentProcessSuccess.prototype.type;
}
class SetPaymentDetails extends EntityLoadAction {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        super(PROCESS_FEATURE, SET_PAYMENT_DETAILS_PROCESS_ID);
        this.payload = payload;
        this.type = SET_PAYMENT_DETAILS;
    }
}
if (false) {
    /** @type {?} */
    SetPaymentDetails.prototype.type;
    /** @type {?} */
    SetPaymentDetails.prototype.payload;
}
class SetPaymentDetailsFail extends EntityFailAction {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        super(PROCESS_FEATURE, SET_PAYMENT_DETAILS_PROCESS_ID, payload);
        this.payload = payload;
        this.type = SET_PAYMENT_DETAILS_FAIL;
    }
}
if (false) {
    /** @type {?} */
    SetPaymentDetailsFail.prototype.type;
    /** @type {?} */
    SetPaymentDetailsFail.prototype.payload;
}
class SetPaymentDetailsSuccess extends EntitySuccessAction {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        super(PROCESS_FEATURE, SET_PAYMENT_DETAILS_PROCESS_ID);
        this.payload = payload;
        this.type = SET_PAYMENT_DETAILS_SUCCESS;
    }
}
if (false) {
    /** @type {?} */
    SetPaymentDetailsSuccess.prototype.type;
    /** @type {?} */
    SetPaymentDetailsSuccess.prototype.payload;
}
class ResetSetPaymentDetailsProcess extends EntityResetAction {
    constructor() {
        super(PROCESS_FEATURE, SET_PAYMENT_DETAILS_PROCESS_ID);
        this.type = RESET_SET_PAYMENT_DETAILS_PROCESS;
    }
}
if (false) {
    /** @type {?} */
    ResetSetPaymentDetailsProcess.prototype.type;
}
class PlaceOrder {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        this.payload = payload;
        this.type = PLACE_ORDER;
    }
}
if (false) {
    /** @type {?} */
    PlaceOrder.prototype.type;
    /** @type {?} */
    PlaceOrder.prototype.payload;
}
class PlaceOrderFail {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        this.payload = payload;
        this.type = PLACE_ORDER_FAIL;
    }
}
if (false) {
    /** @type {?} */
    PlaceOrderFail.prototype.type;
    /** @type {?} */
    PlaceOrderFail.prototype.payload;
}
class PlaceOrderSuccess {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        this.payload = payload;
        this.type = PLACE_ORDER_SUCCESS;
    }
}
if (false) {
    /** @type {?} */
    PlaceOrderSuccess.prototype.type;
    /** @type {?} */
    PlaceOrderSuccess.prototype.payload;
}
class ClearSupportedDeliveryModes {
    constructor() {
        this.type = CLEAR_SUPPORTED_DELIVERY_MODES;
    }
}
if (false) {
    /** @type {?} */
    ClearSupportedDeliveryModes.prototype.type;
}
class ClearCheckoutStep {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        this.payload = payload;
        this.type = CLEAR_CHECKOUT_STEP;
    }
}
if (false) {
    /** @type {?} */
    ClearCheckoutStep.prototype.type;
    /** @type {?} */
    ClearCheckoutStep.prototype.payload;
}
class ClearCheckoutData {
    constructor() {
        this.type = CLEAR_CHECKOUT_DATA;
    }
}
if (false) {
    /** @type {?} */
    ClearCheckoutData.prototype.type;
}
class LoadCheckoutDetails extends LoaderLoadAction {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        super(CHECKOUT_DETAILS);
        this.payload = payload;
        this.type = LOAD_CHECKOUT_DETAILS;
    }
}
if (false) {
    /** @type {?} */
    LoadCheckoutDetails.prototype.type;
    /** @type {?} */
    LoadCheckoutDetails.prototype.payload;
}
class LoadCheckoutDetailsFail extends LoaderFailAction {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        super(CHECKOUT_DETAILS, payload);
        this.payload = payload;
        this.type = LOAD_CHECKOUT_DETAILS_FAIL;
    }
}
if (false) {
    /** @type {?} */
    LoadCheckoutDetailsFail.prototype.type;
    /** @type {?} */
    LoadCheckoutDetailsFail.prototype.payload;
}
class LoadCheckoutDetailsSuccess extends LoaderSuccessAction {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        super(CHECKOUT_DETAILS);
        this.payload = payload;
        this.type = LOAD_CHECKOUT_DETAILS_SUCCESS;
    }
}
if (false) {
    /** @type {?} */
    LoadCheckoutDetailsSuccess.prototype.type;
    /** @type {?} */
    LoadCheckoutDetailsSuccess.prototype.payload;
}
class CheckoutClearMiscsData {
    constructor() {
        this.type = CHECKOUT_CLEAR_MISCS_DATA;
    }
}
if (false) {
    /** @type {?} */
    CheckoutClearMiscsData.prototype.type;
}
class ClearCheckoutDeliveryAddress {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        this.payload = payload;
        this.type = CLEAR_CHECKOUT_DELIVERY_ADDRESS;
    }
}
if (false) {
    /** @type {?} */
    ClearCheckoutDeliveryAddress.prototype.type;
    /** @type {?} */
    ClearCheckoutDeliveryAddress.prototype.payload;
}
class ClearCheckoutDeliveryAddressSuccess {
    constructor() {
        this.type = CLEAR_CHECKOUT_DELIVERY_ADDRESS_SUCCESS;
    }
}
if (false) {
    /** @type {?} */
    ClearCheckoutDeliveryAddressSuccess.prototype.type;
}
class ClearCheckoutDeliveryAddressFail {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        this.payload = payload;
        this.type = CLEAR_CHECKOUT_DELIVERY_ADDRESS_FAIL;
    }
}
if (false) {
    /** @type {?} */
    ClearCheckoutDeliveryAddressFail.prototype.type;
    /** @type {?} */
    ClearCheckoutDeliveryAddressFail.prototype.payload;
}
class ClearCheckoutDeliveryMode {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        this.payload = payload;
        this.type = CLEAR_CHECKOUT_DELIVERY_MODE;
    }
}
if (false) {
    /** @type {?} */
    ClearCheckoutDeliveryMode.prototype.type;
    /** @type {?} */
    ClearCheckoutDeliveryMode.prototype.payload;
}
class ClearCheckoutDeliveryModeSuccess {
    /**
     * @param {?=} payload
     */
    constructor(payload) {
        this.payload = payload;
        this.type = CLEAR_CHECKOUT_DELIVERY_MODE_SUCCESS;
    }
}
if (false) {
    /** @type {?} */
    ClearCheckoutDeliveryModeSuccess.prototype.type;
    /** @type {?} */
    ClearCheckoutDeliveryModeSuccess.prototype.payload;
}
class ClearCheckoutDeliveryModeFail {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        this.payload = payload;
        this.type = CLEAR_CHECKOUT_DELIVERY_MODE_FAIL;
    }
}
if (false) {
    /** @type {?} */
    ClearCheckoutDeliveryModeFail.prototype.type;
    /** @type {?} */
    ClearCheckoutDeliveryModeFail.prototype.payload;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

var checkoutGroup_actions = /*#__PURE__*/Object.freeze({
    VERIFY_ADDRESS: VERIFY_ADDRESS,
    VERIFY_ADDRESS_FAIL: VERIFY_ADDRESS_FAIL,
    VERIFY_ADDRESS_SUCCESS: VERIFY_ADDRESS_SUCCESS,
    CLEAR_ADDRESS_VERIFICATION_RESULTS: CLEAR_ADDRESS_VERIFICATION_RESULTS,
    VerifyAddress: VerifyAddress,
    VerifyAddressFail: VerifyAddressFail,
    VerifyAddressSuccess: VerifyAddressSuccess,
    ClearAddressVerificationResults: ClearAddressVerificationResults,
    LOAD_CARD_TYPES: LOAD_CARD_TYPES,
    LOAD_CARD_TYPES_FAIL: LOAD_CARD_TYPES_FAIL,
    LOAD_CARD_TYPES_SUCCESS: LOAD_CARD_TYPES_SUCCESS,
    LoadCardTypes: LoadCardTypes,
    LoadCardTypesFail: LoadCardTypesFail,
    LoadCardTypesSuccess: LoadCardTypesSuccess,
    CLEAR_CHECKOUT_DELIVERY_ADDRESS: CLEAR_CHECKOUT_DELIVERY_ADDRESS,
    CLEAR_CHECKOUT_DELIVERY_ADDRESS_SUCCESS: CLEAR_CHECKOUT_DELIVERY_ADDRESS_SUCCESS,
    CLEAR_CHECKOUT_DELIVERY_ADDRESS_FAIL: CLEAR_CHECKOUT_DELIVERY_ADDRESS_FAIL,
    CLEAR_CHECKOUT_DELIVERY_MODE: CLEAR_CHECKOUT_DELIVERY_MODE,
    CLEAR_CHECKOUT_DELIVERY_MODE_SUCCESS: CLEAR_CHECKOUT_DELIVERY_MODE_SUCCESS,
    CLEAR_CHECKOUT_DELIVERY_MODE_FAIL: CLEAR_CHECKOUT_DELIVERY_MODE_FAIL,
    ADD_DELIVERY_ADDRESS: ADD_DELIVERY_ADDRESS,
    ADD_DELIVERY_ADDRESS_FAIL: ADD_DELIVERY_ADDRESS_FAIL,
    ADD_DELIVERY_ADDRESS_SUCCESS: ADD_DELIVERY_ADDRESS_SUCCESS,
    SET_DELIVERY_ADDRESS: SET_DELIVERY_ADDRESS,
    SET_DELIVERY_ADDRESS_FAIL: SET_DELIVERY_ADDRESS_FAIL,
    SET_DELIVERY_ADDRESS_SUCCESS: SET_DELIVERY_ADDRESS_SUCCESS,
    RESET_SET_DELIVERY_ADDRESS_PROCESS: RESET_SET_DELIVERY_ADDRESS_PROCESS,
    LOAD_SUPPORTED_DELIVERY_MODES: LOAD_SUPPORTED_DELIVERY_MODES,
    LOAD_SUPPORTED_DELIVERY_MODES_FAIL: LOAD_SUPPORTED_DELIVERY_MODES_FAIL,
    LOAD_SUPPORTED_DELIVERY_MODES_SUCCESS: LOAD_SUPPORTED_DELIVERY_MODES_SUCCESS,
    CLEAR_SUPPORTED_DELIVERY_MODES: CLEAR_SUPPORTED_DELIVERY_MODES,
    SET_DELIVERY_MODE: SET_DELIVERY_MODE,
    SET_DELIVERY_MODE_FAIL: SET_DELIVERY_MODE_FAIL,
    SET_DELIVERY_MODE_SUCCESS: SET_DELIVERY_MODE_SUCCESS,
    RESET_SET_DELIVERY_MODE_PROCESS: RESET_SET_DELIVERY_MODE_PROCESS,
    SET_SUPPORTED_DELIVERY_MODES: SET_SUPPORTED_DELIVERY_MODES,
    SET_SUPPORTED_DELIVERY_MODES_FAIL: SET_SUPPORTED_DELIVERY_MODES_FAIL,
    SET_SUPPORTED_DELIVERY_MODES_SUCCESS: SET_SUPPORTED_DELIVERY_MODES_SUCCESS,
    RESET_SUPPORTED_SET_DELIVERY_MODES_PROCESS: RESET_SUPPORTED_SET_DELIVERY_MODES_PROCESS,
    CREATE_PAYMENT_DETAILS: CREATE_PAYMENT_DETAILS,
    CREATE_PAYMENT_DETAILS_FAIL: CREATE_PAYMENT_DETAILS_FAIL,
    CREATE_PAYMENT_DETAILS_SUCCESS: CREATE_PAYMENT_DETAILS_SUCCESS,
    SET_PAYMENT_DETAILS: SET_PAYMENT_DETAILS,
    SET_PAYMENT_DETAILS_FAIL: SET_PAYMENT_DETAILS_FAIL,
    SET_PAYMENT_DETAILS_SUCCESS: SET_PAYMENT_DETAILS_SUCCESS,
    RESET_SET_PAYMENT_DETAILS_PROCESS: RESET_SET_PAYMENT_DETAILS_PROCESS,
    PLACE_ORDER: PLACE_ORDER,
    PLACE_ORDER_FAIL: PLACE_ORDER_FAIL,
    PLACE_ORDER_SUCCESS: PLACE_ORDER_SUCCESS,
    CLEAR_CHECKOUT_STEP: CLEAR_CHECKOUT_STEP,
    CLEAR_CHECKOUT_DATA: CLEAR_CHECKOUT_DATA,
    LOAD_CHECKOUT_DETAILS: LOAD_CHECKOUT_DETAILS,
    LOAD_CHECKOUT_DETAILS_FAIL: LOAD_CHECKOUT_DETAILS_FAIL,
    LOAD_CHECKOUT_DETAILS_SUCCESS: LOAD_CHECKOUT_DETAILS_SUCCESS,
    CHECKOUT_CLEAR_MISCS_DATA: CHECKOUT_CLEAR_MISCS_DATA,
    PAYMENT_PROCESS_SUCCESS: PAYMENT_PROCESS_SUCCESS,
    AddDeliveryAddress: AddDeliveryAddress,
    AddDeliveryAddressFail: AddDeliveryAddressFail,
    AddDeliveryAddressSuccess: AddDeliveryAddressSuccess,
    SetDeliveryAddress: SetDeliveryAddress,
    SetDeliveryAddressFail: SetDeliveryAddressFail,
    SetDeliveryAddressSuccess: SetDeliveryAddressSuccess,
    ResetSetDeliveryAddressProcess: ResetSetDeliveryAddressProcess,
    LoadSupportedDeliveryModes: LoadSupportedDeliveryModes,
    LoadSupportedDeliveryModesFail: LoadSupportedDeliveryModesFail,
    LoadSupportedDeliveryModesSuccess: LoadSupportedDeliveryModesSuccess,
    ResetLoadSupportedDeliveryModesProcess: ResetLoadSupportedDeliveryModesProcess,
    SetDeliveryMode: SetDeliveryMode,
    SetDeliveryModeFail: SetDeliveryModeFail,
    SetDeliveryModeSuccess: SetDeliveryModeSuccess,
    ResetSetDeliveryModeProcess: ResetSetDeliveryModeProcess,
    CreatePaymentDetails: CreatePaymentDetails,
    CreatePaymentDetailsFail: CreatePaymentDetailsFail,
    CreatePaymentDetailsSuccess: CreatePaymentDetailsSuccess,
    PaymentProcessSuccess: PaymentProcessSuccess,
    SetPaymentDetails: SetPaymentDetails,
    SetPaymentDetailsFail: SetPaymentDetailsFail,
    SetPaymentDetailsSuccess: SetPaymentDetailsSuccess,
    ResetSetPaymentDetailsProcess: ResetSetPaymentDetailsProcess,
    PlaceOrder: PlaceOrder,
    PlaceOrderFail: PlaceOrderFail,
    PlaceOrderSuccess: PlaceOrderSuccess,
    ClearSupportedDeliveryModes: ClearSupportedDeliveryModes,
    ClearCheckoutStep: ClearCheckoutStep,
    ClearCheckoutData: ClearCheckoutData,
    LoadCheckoutDetails: LoadCheckoutDetails,
    LoadCheckoutDetailsFail: LoadCheckoutDetailsFail,
    LoadCheckoutDetailsSuccess: LoadCheckoutDetailsSuccess,
    CheckoutClearMiscsData: CheckoutClearMiscsData,
    ClearCheckoutDeliveryAddress: ClearCheckoutDeliveryAddress,
    ClearCheckoutDeliveryAddressSuccess: ClearCheckoutDeliveryAddressSuccess,
    ClearCheckoutDeliveryAddressFail: ClearCheckoutDeliveryAddressFail,
    ClearCheckoutDeliveryMode: ClearCheckoutDeliveryMode,
    ClearCheckoutDeliveryModeSuccess: ClearCheckoutDeliveryModeSuccess,
    ClearCheckoutDeliveryModeFail: ClearCheckoutDeliveryModeFail
});

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class CartConnector {
    /**
     * @param {?} adapter
     */
    constructor(adapter) {
        this.adapter = adapter;
    }
    /**
     * @param {?} userId
     * @return {?}
     */
    loadAll(userId) {
        return this.adapter.loadAll(userId);
    }
    /**
     * @param {?} userId
     * @param {?} cartId
     * @return {?}
     */
    load(userId, cartId) {
        return this.adapter.load(userId, cartId);
    }
    /**
     * @param {?} userId
     * @param {?=} oldCartId
     * @param {?=} toMergeCartGuid
     * @return {?}
     */
    create(userId, oldCartId, toMergeCartGuid) {
        return this.adapter.create(userId, oldCartId, toMergeCartGuid);
    }
    /**
     * @param {?} userId
     * @param {?} cartId
     * @return {?}
     */
    delete(userId, cartId) {
        return this.adapter.delete(userId, cartId);
    }
    /**
     * @param {?} userId
     * @param {?} cartId
     * @param {?} email
     * @return {?}
     */
    addEmail(userId, cartId, email) {
        return this.adapter.addEmail(userId, cartId, email);
    }
}
CartConnector.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root',
            },] }
];
/** @nocollapse */
CartConnector.ctorParameters = () => [
    { type: CartAdapter }
];
/** @nocollapse */ CartConnector.ngInjectableDef = ɵɵdefineInjectable({ factory: function CartConnector_Factory() { return new CartConnector(ɵɵinject(CartAdapter)); }, token: CartConnector, providedIn: "root" });
if (false) {
    /**
     * @type {?}
     * @protected
     */
    CartConnector.prototype.adapter;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @deprecated since version 1.5
 *
 * spartacus ngrx effects will no longer be a part of public API
 *
 * TODO(issue:#4507)
 */
class CartEffects {
    /**
     * @param {?} actions$
     * @param {?} cartConnector
     * @param {?} cartData
     * @param {?=} store
     */
    constructor(actions$, cartConnector, cartData, store) {
        this.actions$ = actions$;
        this.cartConnector = cartConnector;
        this.cartData = cartData;
        this.store = store;
        this.contextChange$ = this.actions$.pipe(ofType(CURRENCY_CHANGE, LANGUAGE_CHANGE));
        this.loadCart$ = this.actions$.pipe(ofType(LOAD_CART), map((/**
         * @param {?} action
         * @return {?}
         */
        (action) => action.payload)), groupBy((/**
         * @param {?} payload
         * @return {?}
         */
        payload => payload.cartId)), mergeMap((/**
         * @param {?} group$
         * @return {?}
         */
        group$ => group$.pipe(switchMap((/**
         * @param {?} payload
         * @return {?}
         */
        payload => {
            return of(payload).pipe(withLatestFrom(
            // TODO: deprecated -> remove check for store in 2.0 when store will be required
            !this.store
                ? of(false)
                : this.store.pipe(select(getCartHasPendingProcessesSelectorFactory(payload.cartId)))));
        })), filter((/**
         * @param {?} __0
         * @return {?}
         */
        ([_, hasPendingProcesses]) => !hasPendingProcesses)), map((/**
         * @param {?} __0
         * @return {?}
         */
        ([payload]) => payload)), switchMap((/**
         * @param {?} payload
         * @return {?}
         */
        payload => {
            /** @type {?} */
            const loadCartParams = {
                userId: (payload && payload.userId) || this.cartData.userId,
                cartId: (payload && payload.cartId) || this.cartData.cartId,
            };
            if (this.isMissingData(loadCartParams)) {
                return from([
                    new LoadCartFail({}),
                    new LoadMultiCartFail({
                        cartId: loadCartParams.cartId,
                    }),
                ]);
            }
            return this.cartConnector
                .load(loadCartParams.userId, loadCartParams.cartId)
                .pipe(
            // TODO: remove with the `cart` store feature
            withLatestFrom(
            // TODO: deprecated -> remove check for store in 2.0 when store will be required
            !this.store
                ? of(payload.cartId)
                : this.store.pipe(select(getActiveCartId))), mergeMap((/**
             * @param {?} __0
             * @return {?}
             */
            ([cart, activeCartId]) => {
                /** @type {?} */
                let actions = [];
                if (cart) {
                    // `cart` store branch should only be updated for active cart
                    // avoid dispatching LoadCartSuccess action on different cart loads
                    if (loadCartParams.cartId === activeCartId ||
                        loadCartParams.cartId === OCC_CART_ID_CURRENT) {
                        actions.push(new LoadCartSuccess(cart));
                    }
                    actions.push(new LoadMultiCartSuccess({
                        cart,
                        userId: loadCartParams.userId,
                        extraData: payload.extraData,
                    }));
                    if (loadCartParams.cartId === OCC_CART_ID_CURRENT) {
                        // Removing cart from entity object under `current` key as it is no longer needed.
                        // Current cart is loaded under it's code entity.
                        actions.push(new RemoveCart(OCC_CART_ID_CURRENT));
                    }
                }
                else {
                    actions = [
                        new LoadCartFail({}),
                        new LoadMultiCartFail({
                            cartId: loadCartParams.cartId,
                        }),
                    ];
                }
                return actions;
            })), catchError((/**
             * @param {?} error
             * @return {?}
             */
            error => {
                if (error && error.error && error.error.errors) {
                    /** @type {?} */
                    const couponExpiredErrors = error.error.errors.filter((/**
                     * @param {?} err
                     * @return {?}
                     */
                    err => err.reason === 'invalid'));
                    if (couponExpiredErrors.length > 0) {
                        // clear coupons actions just wanted to reload cart again
                        // no need to do it in refresh or keep that action
                        // however removing this action will be a breaking change
                        // remove that action in 2.0 release
                        // @deprecated since 1.4
                        return from([
                            new LoadCart(Object.assign({}, payload)),
                            new ClearExpiredCoupons({}),
                        ]);
                    }
                    /** @type {?} */
                    const cartNotFoundErrors = error.error.errors.filter((/**
                     * @param {?} err
                     * @return {?}
                     */
                    err => err.reason === 'notFound' || 'UnknownResourceError'));
                    if (cartNotFoundErrors.length > 0 &&
                        payload.extraData &&
                        payload.extraData.active) {
                        // Clear cart is responsible for removing cart in `cart` store feature.
                        // Remove cart does the same thing, but in `multi-cart` store feature.
                        return from([
                            new ClearCart(),
                            new RemoveCart(loadCartParams.cartId),
                        ]);
                    }
                }
                return from([
                    new LoadCartFail(makeErrorSerializable(error)),
                    new LoadMultiCartFail({
                        cartId: loadCartParams.cartId,
                        error: makeErrorSerializable(error),
                    }),
                ]);
            })));
        }))))), withdrawOn(this.contextChange$));
        this.createCart$ = this.actions$.pipe(ofType(CREATE_CART), map((/**
         * @param {?} action
         * @return {?}
         */
        (action) => action.payload)), mergeMap((/**
         * @param {?} payload
         * @return {?}
         */
        payload => {
            return this.cartConnector
                .create(payload.userId, payload.oldCartId, payload.toMergeCartGuid)
                .pipe(switchMap((/**
             * @param {?} cart
             * @return {?}
             */
            (cart) => {
                /** @type {?} */
                const conditionalActions = [];
                if (payload.oldCartId) {
                    conditionalActions.push(new MergeCartSuccess({
                        userId: payload.userId,
                        cartId: cart.code,
                    }));
                    conditionalActions.push(new MergeMultiCartSuccess({
                        userId: payload.userId,
                        cartId: cart.code,
                        oldCartId: payload.oldCartId,
                    }));
                }
                // `cart` store branch should only be updated for active cart
                // avoid dispatching CreateCartSuccess action on different cart loads
                if (payload.extraData && payload.extraData.active) {
                    conditionalActions.push(new CreateCartSuccess(cart));
                }
                return [
                    new CreateMultiCartSuccess({
                        cart,
                        userId: payload.userId,
                        extraData: payload.extraData,
                    }),
                    new SetTempCart({
                        cart,
                        tempCartId: payload.tempCartId,
                    }),
                    ...conditionalActions,
                ];
            })), catchError((/**
             * @param {?} error
             * @return {?}
             */
            error => from([
                new CreateCartFail(makeErrorSerializable(error)),
                new CreateMultiCartFail({
                    tempCartId: payload.tempCartId,
                    error: makeErrorSerializable(error),
                }),
            ]))));
        })), withdrawOn(this.contextChange$));
        this.mergeCart$ = this.actions$.pipe(ofType(MERGE_CART), map((/**
         * @param {?} action
         * @return {?}
         */
        (action) => action.payload)), mergeMap((/**
         * @param {?} payload
         * @return {?}
         */
        payload => {
            return this.cartConnector.load(payload.userId, OCC_CART_ID_CURRENT).pipe(mergeMap((/**
             * @param {?} currentCart
             * @return {?}
             */
            currentCart => {
                return [
                    new CreateCart({
                        userId: payload.userId,
                        oldCartId: payload.cartId,
                        toMergeCartGuid: currentCart ? currentCart.guid : undefined,
                        extraData: payload.extraData,
                        tempCartId: payload.tempCartId,
                    }),
                ];
            })));
        })), withdrawOn(this.contextChange$));
        this.refresh$ = this.actions$.pipe(ofType(CART_ADD_ENTRY_SUCCESS, CART_UPDATE_ENTRY_SUCCESS, CART_REMOVE_ENTRY_SUCCESS, ADD_EMAIL_TO_CART_SUCCESS, CLEAR_CHECKOUT_DELIVERY_MODE_SUCCESS, CART_ADD_VOUCHER_SUCCESS, CART_REMOVE_VOUCHER_SUCCESS), map((/**
         * @param {?} action
         * @return {?}
         */
        (action) => action.payload)), concatMap((/**
         * @param {?} payload
         * @return {?}
         */
        payload => from([
            new CartProcessesDecrement(payload.cartId),
            new LoadCart({
                userId: payload.userId,
                cartId: payload.cartId,
            }),
        ]))));
        this.refreshWithoutProcesses$ = this.actions$.pipe(ofType(MERGE_CART_SUCCESS), map((/**
         * @param {?} action
         * @return {?}
         */
        (action) => action.payload)), map((/**
         * @param {?} payload
         * @return {?}
         */
        payload => new LoadCart({
            userId: payload.userId,
            cartId: payload.cartId,
        }))));
        this.resetCartDetailsOnSiteContextChange$ = this.actions$.pipe(ofType(LANGUAGE_CHANGE, CURRENCY_CHANGE), mergeMap((/**
         * @return {?}
         */
        () => {
            return [
                new ResetCartDetails(),
                new ResetMultiCartDetails(),
            ];
        })));
        this.addEmail$ = this.actions$.pipe(ofType(ADD_EMAIL_TO_CART), map((/**
         * @param {?} action
         * @return {?}
         */
        (action) => action.payload)), mergeMap((/**
         * @param {?} payload
         * @return {?}
         */
        payload => this.cartConnector
            .addEmail(payload.userId, payload.cartId, payload.email)
            .pipe(mergeMap((/**
         * @return {?}
         */
        () => {
            return [
                new AddEmailToCartSuccess({
                    userId: payload.userId,
                    cartId: payload.cartId,
                }),
                new AddEmailToMultiCartSuccess({
                    userId: payload.userId,
                    cartId: payload.cartId,
                }),
            ];
        })), catchError((/**
         * @param {?} error
         * @return {?}
         */
        error => from([
            new AddEmailToCartFail(makeErrorSerializable(error)),
            new AddEmailToMultiCartFail({
                error: makeErrorSerializable(error),
                userId: payload.userId,
                cartId: payload.cartId,
            }),
            new CartProcessesDecrement(payload.cartId),
            new LoadCart({
                userId: payload.userId,
                cartId: payload.cartId,
            }),
        ])))))), withdrawOn(this.contextChange$));
        this.deleteCart$ = this.actions$.pipe(ofType(DELETE_CART), map((/**
         * @param {?} action
         * @return {?}
         */
        (action) => action.payload)), exhaustMap((/**
         * @param {?} payload
         * @return {?}
         */
        payload => this.cartConnector.delete(payload.userId, payload.cartId).pipe(map((/**
         * @return {?}
         */
        () => {
            return new ClearCart();
        })), catchError((/**
         * @param {?} error
         * @return {?}
         */
        error => of(new DeleteCartFail(makeErrorSerializable(error)))))))));
    }
    /**
     * @private
     * @param {?} payload
     * @return {?}
     */
    isMissingData(payload) {
        return payload.userId === undefined || payload.cartId === undefined;
    }
}
CartEffects.decorators = [
    { type: Injectable }
];
/** @nocollapse */
CartEffects.ctorParameters = () => [
    { type: Actions },
    { type: CartConnector },
    { type: CartDataService },
    { type: Store }
];
__decorate([
    Effect(),
    __metadata("design:type", Observable)
], CartEffects.prototype, "loadCart$", void 0);
__decorate([
    Effect(),
    __metadata("design:type", Observable)
], CartEffects.prototype, "createCart$", void 0);
__decorate([
    Effect(),
    __metadata("design:type", Observable)
], CartEffects.prototype, "mergeCart$", void 0);
__decorate([
    Effect(),
    __metadata("design:type", Observable)
], CartEffects.prototype, "refresh$", void 0);
__decorate([
    Effect(),
    __metadata("design:type", Observable)
], CartEffects.prototype, "refreshWithoutProcesses$", void 0);
__decorate([
    Effect(),
    __metadata("design:type", Observable)
], CartEffects.prototype, "resetCartDetailsOnSiteContextChange$", void 0);
__decorate([
    Effect(),
    __metadata("design:type", Observable)
], CartEffects.prototype, "addEmail$", void 0);
__decorate([
    Effect(),
    __metadata("design:type", Observable)
], CartEffects.prototype, "deleteCart$", void 0);
if (false) {
    /**
     * @type {?}
     * @private
     */
    CartEffects.prototype.contextChange$;
    /** @type {?} */
    CartEffects.prototype.loadCart$;
    /** @type {?} */
    CartEffects.prototype.createCart$;
    /** @type {?} */
    CartEffects.prototype.mergeCart$;
    /** @type {?} */
    CartEffects.prototype.refresh$;
    /** @type {?} */
    CartEffects.prototype.refreshWithoutProcesses$;
    /** @type {?} */
    CartEffects.prototype.resetCartDetailsOnSiteContextChange$;
    /** @type {?} */
    CartEffects.prototype.addEmail$;
    /** @type {?} */
    CartEffects.prototype.deleteCart$;
    /**
     * @type {?}
     * @private
     */
    CartEffects.prototype.actions$;
    /**
     * @type {?}
     * @private
     */
    CartEffects.prototype.cartConnector;
    /**
     * @type {?}
     * @private
     */
    CartEffects.prototype.cartData;
    /**
     * @type {?}
     * @private
     */
    CartEffects.prototype.store;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SaveCartConnector {
    /**
     * @param {?} adapter
     */
    constructor(adapter) {
        this.adapter = adapter;
    }
    /**
     * @param {?} userId
     * @param {?} cartId
     * @param {?=} saveCartName
     * @param {?=} saveCartDescription
     * @return {?}
     */
    saveCart(userId, cartId, saveCartName, saveCartDescription) {
        return this.adapter.saveCart(userId, cartId, saveCartName, saveCartDescription);
    }
}
SaveCartConnector.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root',
            },] }
];
/** @nocollapse */
SaveCartConnector.ctorParameters = () => [
    { type: SaveCartAdapter }
];
/** @nocollapse */ SaveCartConnector.ngInjectableDef = ɵɵdefineInjectable({ factory: function SaveCartConnector_Factory() { return new SaveCartConnector(ɵɵinject(SaveCartAdapter)); }, token: SaveCartConnector, providedIn: "root" });
if (false) {
    /**
     * @type {?}
     * @protected
     */
    SaveCartConnector.prototype.adapter;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @deprecated since version 1.5
 *
 * spartacus ngrx effects will no longer be a part of public API
 *
 * TODO(issue:#4507)
 */
class WishListEffects {
    /**
     * @param {?} actions$
     * @param {?} cartConnector
     * @param {?} saveCartConnector
     * @param {?} authService
     * @param {?} store
     */
    constructor(actions$, cartConnector, saveCartConnector, authService, store) {
        this.actions$ = actions$;
        this.cartConnector = cartConnector;
        this.saveCartConnector = saveCartConnector;
        this.authService = authService;
        this.store = store;
        this.createWishList$ = this.actions$.pipe(ofType(CREATE_WISH_LIST), map((/**
         * @param {?} action
         * @return {?}
         */
        (action) => action.payload)), switchMap((/**
         * @param {?} payload
         * @return {?}
         */
        payload => {
            return this.cartConnector.create(payload.userId).pipe(switchMap((/**
             * @param {?} cart
             * @return {?}
             */
            cart => {
                return this.saveCartConnector
                    .saveCart(payload.userId, cart.code, payload.name, payload.description)
                    .pipe(switchMap((/**
                 * @param {?} saveCartResult
                 * @return {?}
                 */
                saveCartResult => [
                    new CreateWishListSuccess({
                        cart: saveCartResult.savedCartData,
                        userId: payload.userId,
                    }),
                ])), catchError((/**
                 * @param {?} error
                 * @return {?}
                 */
                error => from([
                    new CreateWishListFail({
                        cartId: cart.code,
                        error: makeErrorSerializable(error),
                    }),
                ]))));
            })));
        })));
        this.loadWishList$ = this.actions$.pipe(ofType(LOAD_WISH_LIST), map((/**
         * @param {?} action
         * @return {?}
         */
        (action) => action.payload)), concatMap((/**
         * @param {?} payload
         * @return {?}
         */
        payload => {
            const { userId, customerId } = payload;
            return this.cartConnector.loadAll(userId).pipe(switchMap((/**
             * @param {?} carts
             * @return {?}
             */
            carts => {
                if (carts) {
                    /** @type {?} */
                    const wishList = carts.find((/**
                     * @param {?} cart
                     * @return {?}
                     */
                    cart => cart.name === `wishlist${customerId}`));
                    if (Boolean(wishList)) {
                        return [
                            new LoadWishListSuccess({
                                cart: wishList,
                                userId,
                            }),
                        ];
                    }
                    else {
                        return [
                            new CreateWishList({
                                userId,
                                name: `wishlist${customerId}`,
                            }),
                        ];
                    }
                }
            })), catchError((/**
             * @param {?} error
             * @return {?}
             */
            error => from([new LoadCartFail(makeErrorSerializable(error))]))));
        })));
        this.resetWishList$ = this.actions$.pipe(ofType(LANGUAGE_CHANGE, CURRENCY_CHANGE), withLatestFrom(this.authService.getOccUserId(), this.store.pipe(select(getWishListId))), switchMap((/**
         * @param {?} __0
         * @return {?}
         */
        ([, userId, wishListId]) => {
            if (Boolean(wishListId)) {
                return this.cartConnector.load(userId, wishListId).pipe(switchMap((/**
                 * @param {?} wishList
                 * @return {?}
                 */
                wishList => [
                    new LoadWishListSuccess({ cart: wishList, userId }),
                ])), catchError((/**
                 * @param {?} error
                 * @return {?}
                 */
                error => from([new LoadCartFail(makeErrorSerializable(error))]))));
            }
            return EMPTY;
        })));
    }
}
WishListEffects.decorators = [
    { type: Injectable }
];
/** @nocollapse */
WishListEffects.ctorParameters = () => [
    { type: Actions },
    { type: CartConnector },
    { type: SaveCartConnector },
    { type: AuthService },
    { type: Store }
];
__decorate([
    Effect(),
    __metadata("design:type", Observable)
], WishListEffects.prototype, "createWishList$", void 0);
__decorate([
    Effect(),
    __metadata("design:type", Observable)
], WishListEffects.prototype, "loadWishList$", void 0);
__decorate([
    Effect(),
    __metadata("design:type", Observable)
], WishListEffects.prototype, "resetWishList$", void 0);
if (false) {
    /** @type {?} */
    WishListEffects.prototype.createWishList$;
    /** @type {?} */
    WishListEffects.prototype.loadWishList$;
    /** @type {?} */
    WishListEffects.prototype.resetWishList$;
    /**
     * @type {?}
     * @private
     */
    WishListEffects.prototype.actions$;
    /**
     * @type {?}
     * @private
     */
    WishListEffects.prototype.cartConnector;
    /**
     * @type {?}
     * @private
     */
    WishListEffects.prototype.saveCartConnector;
    /**
     * @type {?}
     * @private
     */
    WishListEffects.prototype.authService;
    /**
     * @type {?}
     * @private
     */
    WishListEffects.prototype.store;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const initialState$9 = {
    content: {},
    entries: {},
    refresh: false,
    cartMergeComplete: false,
};
/**
 * @param {?=} state
 * @param {?=} action
 * @return {?}
 */
function reducer$9(state = initialState$9, action) {
    switch (action.type) {
        case MERGE_CART: {
            return Object.assign({}, state, { cartMergeComplete: false });
        }
        case MERGE_CART_SUCCESS: {
            return Object.assign({}, state, { cartMergeComplete: true, refresh: true });
        }
        case LOAD_CART_SUCCESS:
        case CREATE_CART_SUCCESS: {
            /** @type {?} */
            const content = Object.assign({}, action.payload);
            /** @type {?} */
            let entries = {};
            if (content.entries) {
                entries = content.entries.reduce((/**
                 * @param {?} entryMap
                 * @param {?} entry
                 * @return {?}
                 */
                (entryMap, entry) => {
                    return Object.assign({}, entryMap, { [entry.product.code]: state.entries && state.entries[entry.product.code]
                            ? Object.assign({}, state.entries[entry.product.code], entry) : entry });
                }), Object.assign({}, entries));
                delete content['entries'];
            }
            return Object.assign({}, state, { content,
                entries, refresh: false });
        }
        case CART_ADD_VOUCHER_SUCCESS:
        case CART_REMOVE_VOUCHER_SUCCESS:
        case CART_REMOVE_ENTRY_SUCCESS:
        case CART_UPDATE_ENTRY_SUCCESS:
        case CART_ADD_ENTRY_SUCCESS:
        case ADD_EMAIL_TO_CART_SUCCESS: {
            return Object.assign({}, state, { refresh: true });
        }
        case RESET_CART_DETAILS: {
            return {
                content: {
                    guid: state.content.guid,
                    code: state.content.code,
                    user: state.content.user,
                },
                entries: {},
                refresh: false,
                cartMergeComplete: false,
            };
        }
        case CLEAR_CART: {
            return initialState$9;
        }
    }
    return state;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const activeCartInitialState = '';
/** @type {?} */
const wishListInitialState = '';
/**
 * @param {?=} state
 * @param {?=} action
 * @return {?}
 */
function activeCartReducer(state = activeCartInitialState, action) {
    switch (action.type) {
        case LOAD_MULTI_CART_SUCCESS:
        case CREATE_MULTI_CART_SUCCESS:
        // point to `temp-${uuid}` cart when we are creating/merging cart
        case CREATE_MULTI_CART:
            if (action.payload &&
                action.payload.extraData &&
                action.payload.extraData.active) {
                return (/** @type {?} */ (action.meta.entityId));
            }
            else {
                return state;
            }
        case REMOVE_CART:
            if (action.payload === state) {
                return activeCartInitialState;
            }
            else {
                return state;
            }
    }
    return state;
}
/** @type {?} */
const cartEntitiesInitialState = undefined;
/**
 * @param {?=} state
 * @param {?=} action
 * @return {?}
 */
function cartEntitiesReducer(state = cartEntitiesInitialState, action) {
    switch (action.type) {
        case LOAD_MULTI_CART_SUCCESS:
        case CREATE_MULTI_CART_SUCCESS:
        case CREATE_WISH_LIST_SUCCESS:
        case LOAD_WISH_LIST_SUCCESS:
        case SET_TEMP_CART:
            return action.payload.cart;
    }
    return state;
}
/**
 * @param {?=} state
 * @param {?=} action
 * @return {?}
 */
function wishListReducer(state = wishListInitialState, action) {
    switch (action.type) {
        case CREATE_WISH_LIST_SUCCESS:
        case LOAD_WISH_LIST_SUCCESS:
            return (/** @type {?} */ (action.meta.entityId));
    }
    return state;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @deprecated since version 1.5
 *
 * spartacus ngrx reducers will no longer be a part of public API
 *
 * TODO(issue:#4507)
 * @return {?}
 */
function getReducers$5() {
    return {
        active: loaderReducer(CART_DATA, reducer$9),
    };
}
/**
 * @deprecated since version 1.5
 *
 * spartacus ngrx reducers will no longer be a part of public API
 *
 * TODO(issue:#4507)
 * @type {?}
 */
const reducerToken$5 = new InjectionToken('CartReducers');
/**
 * @deprecated since version 1.5
 *
 * spartacus ngrx reducers will no longer be a part of public API
 *
 * TODO(issue:#4507)
 * @type {?}
 */
const reducerProvider$5 = {
    provide: reducerToken$5,
    useFactory: getReducers$5,
};
/**
 * @deprecated since version 1.5
 *
 * spartacus ngrx reducers will no longer be a part of public API
 *
 * TODO(issue:#4507)
 * @param {?} reducer
 * @return {?}
 */
function clearCartState(reducer) {
    return (/**
     * @param {?} state
     * @param {?} action
     * @return {?}
     */
    function (state, action) {
        if (action.type === LOGOUT ||
            action.type === PLACE_ORDER_SUCCESS) {
            state = undefined;
        }
        return reducer(state, action);
    });
}
/**
 * @deprecated since version 1.5
 *
 * spartacus ngrx reducers will no longer be a part of public API
 *
 * TODO(issue:#4507)
 * @type {?}
 */
const metaReducers$3 = [clearCartState];
/**
 * @deprecated since version 1.5
 *
 * spartacus ngrx reducers will no longer be a part of public API
 *
 * TODO(issue:#4507)
 * @param {?} reducer
 * @return {?}
 */
function clearMultiCartState(reducer) {
    return (/**
     * @param {?} state
     * @param {?} action
     * @return {?}
     */
    function (state, action) {
        if (action.type === LOGOUT) {
            state = undefined;
        }
        return reducer(state, action);
    });
}
/**
 * @deprecated since version 1.5
 *
 * spartacus ngrx reducers will no longer be a part of public API
 *
 * TODO(issue:#4507)
 * @type {?}
 */
const multiCartMetaReducers = [clearMultiCartState];
/**
 * @deprecated since version 1.5
 *
 * spartacus ngrx reducers will no longer be a part of public API
 *
 * TODO(issue:#4507)
 * @type {?}
 */
const multiCartReducerToken = new InjectionToken('MultiCartReducers');
/**
 * @deprecated since version 1.5
 *
 * spartacus ngrx reducers will no longer be a part of public API
 *
 * TODO(issue:#4507)
 * @return {?}
 */
function getMultiCartReducers() {
    return {
        carts: entityProcessesLoaderReducer(MULTI_CART_FEATURE, cartEntitiesReducer),
        active: activeCartReducer,
        wishList: wishListReducer,
    };
}
/**
 * @deprecated since version 1.5
 *
 * spartacus ngrx reducers will no longer be a part of public API
 *
 * TODO(issue:#4507)
 * @type {?}
 */
const multiCartReducerProvider = {
    provide: multiCartReducerToken,
    useFactory: getMultiCartReducers,
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const effects$4 = [
    CartEffects,
    CartEntryEffects,
    CartVoucherEffects,
    WishListEffects,
];
/**
 * @return {?}
 */
function cartStoreConfigFactory() {
    /** @type {?} */
    const config = {
        state: {
            storageSync: {
                keys: {
                    [`${CART_FEATURE}.active.value.content.guid`]: StorageSyncType.LOCAL_STORAGE,
                    [`${CART_FEATURE}.active.value.content.code`]: StorageSyncType.LOCAL_STORAGE,
                    [`${CART_FEATURE}.active.value.content.user`]: StorageSyncType.LOCAL_STORAGE,
                },
            },
        },
    };
    return config;
}
class CartStoreModule {
}
CartStoreModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    HttpClientModule,
                    StateModule,
                    StoreModule.forFeature(CART_FEATURE, reducerToken$5, { metaReducers: metaReducers$3 }),
                    EffectsModule.forFeature(effects$4),
                    ConfigModule.withConfigFactory(cartStoreConfigFactory),
                ],
                providers: [reducerProvider$5],
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class MultiCartEffects {
    /**
     * @param {?} actions$
     */
    constructor(actions$) {
        this.actions$ = actions$;
        this.loadCart2$ = this.actions$.pipe(ofType(LOAD_CART), map((/**
         * @param {?} action
         * @return {?}
         */
        (action) => new LoadMultiCart(action.payload))));
        this.createCart2$ = this.actions$.pipe(ofType(CREATE_CART), map((/**
         * @param {?} action
         * @return {?}
         */
        (action) => new CreateMultiCart(action.payload))));
        this.setTempCart$ = this.actions$.pipe(ofType(SET_TEMP_CART), map((/**
         * @param {?} action
         * @return {?}
         */
        (action) => {
            return new RemoveTempCart(action.payload);
        })));
        this.mergeCart2$ = this.actions$.pipe(ofType(MERGE_CART), map((/**
         * @param {?} action
         * @return {?}
         */
        (action) => new MergeMultiCart(action.payload))));
        this.addEmail2$ = this.actions$.pipe(ofType(ADD_EMAIL_TO_CART), map((/**
         * @param {?} action
         * @return {?}
         */
        (action) => new AddEmailToMultiCart(action.payload))));
        this.removeCart$ = this.actions$.pipe(ofType(DELETE_CART), map((/**
         * @param {?} action
         * @return {?}
         */
        (action) => action.payload)), map((/**
         * @param {?} payload
         * @return {?}
         */
        payload => new RemoveCart(payload.cartId))));
        // TODO: Change actions to extend Increment action instead of doing extra dispatch in this effect
        // Change for 2.0 release
        this.processesIncrement$ = this.actions$.pipe(ofType(CART_ADD_ENTRY, CART_UPDATE_ENTRY, CART_REMOVE_ENTRY, ADD_EMAIL_TO_CART, CLEAR_CHECKOUT_DELIVERY_MODE, CART_ADD_VOUCHER, CART_REMOVE_VOUCHER), map((/**
         * @param {?} action
         * @return {?}
         */
        (action) => action.payload)), map((/**
         * @param {?} payload
         * @return {?}
         */
        payload => new CartProcessesIncrement(payload.cartId))));
    }
}
MultiCartEffects.decorators = [
    { type: Injectable }
];
/** @nocollapse */
MultiCartEffects.ctorParameters = () => [
    { type: Actions }
];
__decorate([
    Effect(),
    __metadata("design:type", Observable)
], MultiCartEffects.prototype, "loadCart2$", void 0);
__decorate([
    Effect(),
    __metadata("design:type", Observable)
], MultiCartEffects.prototype, "createCart2$", void 0);
__decorate([
    Effect(),
    __metadata("design:type", Object)
], MultiCartEffects.prototype, "setTempCart$", void 0);
__decorate([
    Effect(),
    __metadata("design:type", Observable)
], MultiCartEffects.prototype, "mergeCart2$", void 0);
__decorate([
    Effect(),
    __metadata("design:type", Observable)
], MultiCartEffects.prototype, "addEmail2$", void 0);
__decorate([
    Effect(),
    __metadata("design:type", Observable)
], MultiCartEffects.prototype, "removeCart$", void 0);
__decorate([
    Effect(),
    __metadata("design:type", Observable)
], MultiCartEffects.prototype, "processesIncrement$", void 0);
if (false) {
    /** @type {?} */
    MultiCartEffects.prototype.loadCart2$;
    /** @type {?} */
    MultiCartEffects.prototype.createCart2$;
    /** @type {?} */
    MultiCartEffects.prototype.setTempCart$;
    /** @type {?} */
    MultiCartEffects.prototype.mergeCart2$;
    /** @type {?} */
    MultiCartEffects.prototype.addEmail2$;
    /** @type {?} */
    MultiCartEffects.prototype.removeCart$;
    /** @type {?} */
    MultiCartEffects.prototype.processesIncrement$;
    /**
     * @type {?}
     * @private
     */
    MultiCartEffects.prototype.actions$;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @return {?}
 */
function multiCartStoreConfigFactory() {
    /** @type {?} */
    const config = {
        state: {
            storageSync: {
                keys: {
                    [`${MULTI_CART_FEATURE}.active`]: StorageSyncType.LOCAL_STORAGE,
                },
            },
        },
    };
    return config;
}
class MultiCartStoreModule {
}
MultiCartStoreModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    StateModule,
                    StoreModule.forFeature(MULTI_CART_FEATURE, multiCartReducerToken, {
                        metaReducers: multiCartMetaReducers,
                    }),
                    EffectsModule.forFeature([MultiCartEffects]),
                    ConfigModule.withConfigFactory(multiCartStoreConfigFactory),
                ],
                providers: [multiCartReducerProvider],
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class CartModule {
    /**
     * @return {?}
     */
    static forRoot() {
        return {
            ngModule: CartModule,
            providers: [
                CartDataService,
                CartVoucherService,
                CartService,
                MultiCartService,
                WishListService,
                ActiveCartService,
                SelectiveCartService,
                {
                    provide: PageMetaResolver,
                    useExisting: CartPageMetaResolver,
                    multi: true,
                },
            ],
        };
    }
}
CartModule.decorators = [
    { type: NgModule, args: [{
                imports: [CartStoreModule, MultiCartStoreModule],
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @deprecated since version 1.5
 *
 * spartacus ngrx effects will no longer be a part of public API
 *
 * TODO(issue:#4507)
 * @type {?}
 */
const effects$5 = [
    CartEffects,
    CartEntryEffects,
    CartVoucherEffects,
    WishListEffects,
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const initialState$a = {
    results: {},
};
/**
 * @param {?=} state
 * @param {?=} action
 * @return {?}
 */
function reducer$a(state = initialState$a, action) {
    switch (action.type) {
        case VERIFY_ADDRESS_SUCCESS: {
            /** @type {?} */
            const results = action.payload;
            return Object.assign({}, state, { results });
        }
        case VERIFY_ADDRESS_FAIL: {
            return Object.assign({}, state, { results: 'FAIL' });
        }
        case CLEAR_ADDRESS_VERIFICATION_RESULTS: {
            return Object.assign({}, state, { results: {} });
        }
    }
    return state;
}
/** @type {?} */
const getAddressVerificationResults = (/**
 * @param {?} state
 * @return {?}
 */
(state) => state.results);

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const getDeliveryAddressSelector = (/**
 * @param {?} state
 * @return {?}
 */
(state) => state.address);
const ɵ0$A = getDeliveryAddressSelector;
/** @type {?} */
const getDeliveryModeSelector = (/**
 * @param {?} state
 * @return {?}
 */
(state) => state.deliveryMode);
const ɵ1$r = getDeliveryModeSelector;
/** @type {?} */
const getPaymentDetailsSelector = (/**
 * @param {?} state
 * @return {?}
 */
(state) => state.paymentDetails);
const ɵ2$k = getPaymentDetailsSelector;
/** @type {?} */
const getOrderDetailsSelector = (/**
 * @param {?} state
 * @return {?}
 */
(state) => state.orderDetails);
const ɵ3$b = getOrderDetailsSelector;
/** @type {?} */
const getCheckoutState = createFeatureSelector(CHECKOUT_FEATURE);
const ɵ4$4 = /**
 * @param {?} checkoutState
 * @return {?}
 */
(checkoutState) => checkoutState.steps;
/** @type {?} */
const getCheckoutStepsState = createSelector(getCheckoutState, (ɵ4$4));
const ɵ5$3 = /**
 * @param {?} state
 * @return {?}
 */
state => loaderValueSelector(state);
/** @type {?} */
const getCheckoutSteps = createSelector(getCheckoutStepsState, (ɵ5$3));
/** @type {?} */
const getDeliveryAddress = createSelector(getCheckoutSteps, getDeliveryAddressSelector);
/** @type {?} */
const getDeliveryMode = createSelector(getCheckoutSteps, getDeliveryModeSelector);
const ɵ6$1 = /**
 * @param {?} deliveryMode
 * @return {?}
 */
deliveryMode => {
    return (deliveryMode &&
        Object.keys(deliveryMode.supported).map((/**
         * @param {?} code
         * @return {?}
         */
        code => deliveryMode.supported[code])));
};
/** @type {?} */
const getSupportedDeliveryModes = createSelector(getDeliveryMode, (ɵ6$1));
const ɵ7$1 = /**
 * @param {?} deliveryMode
 * @return {?}
 */
deliveryMode => {
    return deliveryMode && deliveryMode.selected;
};
/** @type {?} */
const getSelectedDeliveryModeCode = createSelector(getDeliveryMode, (ɵ7$1));
const ɵ8$1 = /**
 * @param {?} deliveryMode
 * @return {?}
 */
deliveryMode => {
    if (deliveryMode.selected !== '') {
        if (Object.keys(deliveryMode.supported).length === 0) {
            return null;
        }
        return deliveryMode.supported[deliveryMode.selected];
    }
};
/** @type {?} */
const getSelectedDeliveryMode = createSelector(getDeliveryMode, (ɵ8$1));
/** @type {?} */
const getPaymentDetails = createSelector(getCheckoutSteps, getPaymentDetailsSelector);
/** @type {?} */
const getCheckoutOrderDetails = createSelector(getCheckoutSteps, getOrderDetailsSelector);
const ɵ9$1 = /**
 * @param {?} state
 * @return {?}
 */
state => loaderSuccessSelector(state) &&
    !loaderLoadingSelector(state);
/** @type {?} */
const getCheckoutDetailsLoaded = createSelector(getCheckoutStepsState, (ɵ9$1));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
const ɵ0$B = /**
 * @param {?} state
 * @return {?}
 */
(state) => state.addressVerification;
/** @type {?} */
const getAddressVerificationResultsState = createSelector(getCheckoutState, (ɵ0$B));
/** @type {?} */
const getAddressVerificationResults$1 = createSelector(getAddressVerificationResultsState, getAddressVerificationResults);

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const initialState$b = {
    entities: {},
};
/**
 * @param {?=} state
 * @param {?=} action
 * @return {?}
 */
function reducer$b(state = initialState$b, action) {
    switch (action.type) {
        case LOAD_CARD_TYPES_SUCCESS: {
            /** @type {?} */
            const cardTypes = action.payload;
            /** @type {?} */
            const entities = cardTypes.reduce((/**
             * @param {?} cardTypesEntities
             * @param {?} name
             * @return {?}
             */
            (cardTypesEntities, name) => {
                return Object.assign({}, cardTypesEntities, { [name.code]: name });
            }), Object.assign({}, state.entities));
            return Object.assign({}, state, { entities });
        }
        case CHECKOUT_CLEAR_MISCS_DATA: {
            return initialState$b;
        }
    }
    return state;
}
/** @type {?} */
const getCardTypesEntites = (/**
 * @param {?} state
 * @return {?}
 */
(state) => state.entities);

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
const ɵ0$C = /**
 * @param {?} state
 * @return {?}
 */
(state) => state.cardTypes;
/** @type {?} */
const getCardTypesState = createSelector(getCheckoutState, (ɵ0$C));
/** @type {?} */
const getCardTypesEntites$1 = createSelector(getCardTypesState, getCardTypesEntites);
const ɵ1$s = /**
 * @param {?} entites
 * @return {?}
 */
entites => {
    return Object.keys(entites).map((/**
     * @param {?} code
     * @return {?}
     */
    code => entites[code]));
};
/** @type {?} */
const getAllCardTypes = createSelector(getCardTypesEntites$1, (ɵ1$s));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

var checkoutGroup_selectors = /*#__PURE__*/Object.freeze({
    getAddressVerificationResultsState: getAddressVerificationResultsState,
    getAddressVerificationResults: getAddressVerificationResults$1,
    getCardTypesState: getCardTypesState,
    getCardTypesEntites: getCardTypesEntites$1,
    getAllCardTypes: getAllCardTypes,
    getCheckoutState: getCheckoutState,
    getCheckoutStepsState: getCheckoutStepsState,
    getCheckoutSteps: getCheckoutSteps,
    getDeliveryAddress: getDeliveryAddress,
    getDeliveryMode: getDeliveryMode,
    getSupportedDeliveryModes: getSupportedDeliveryModes,
    getSelectedDeliveryModeCode: getSelectedDeliveryModeCode,
    getSelectedDeliveryMode: getSelectedDeliveryMode,
    getPaymentDetails: getPaymentDetails,
    getCheckoutOrderDetails: getCheckoutOrderDetails,
    getCheckoutDetailsLoaded: getCheckoutDetailsLoaded
});

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class CheckoutService {
    /**
     * @param {?} checkoutStore
     * @param {?} cartData
     */
    constructor(checkoutStore, cartData) {
        this.checkoutStore = checkoutStore;
        this.cartData = cartData;
    }
    /**
     * Places an order
     * @return {?}
     */
    placeOrder() {
        if (this.actionAllowed()) {
            this.checkoutStore.dispatch(new PlaceOrder({
                userId: this.cartData.userId,
                cartId: this.cartData.cartId,
            }));
        }
    }
    /**
     * Clear checkout data
     * @return {?}
     */
    clearCheckoutData() {
        this.checkoutStore.dispatch(new ClearCheckoutData());
    }
    /**
     * Clear checkout step
     * @param {?} stepNumber : the step number to be cleared
     * @return {?}
     */
    clearCheckoutStep(stepNumber) {
        this.checkoutStore.dispatch(new ClearCheckoutStep(stepNumber));
    }
    /**
     * Load checkout details data
     * @param {?} cartId : string Cart ID of loaded cart
     * @return {?}
     */
    loadCheckoutDetails(cartId) {
        this.checkoutStore.dispatch(new LoadCheckoutDetails({
            userId: this.cartData.userId,
            cartId,
        }));
    }
    /**
     * Get status of checkout details loaded
     * @return {?}
     */
    getCheckoutDetailsLoaded() {
        return this.checkoutStore.pipe(select(getCheckoutDetailsLoaded));
    }
    /**
     * Get order details
     * @return {?}
     */
    getOrderDetails() {
        return this.checkoutStore.pipe(select(getCheckoutOrderDetails));
    }
    /**
     * @protected
     * @return {?}
     */
    actionAllowed() {
        return (this.cartData.userId !== OCC_USER_ID_ANONYMOUS ||
            this.cartData.isGuestCart);
    }
}
CheckoutService.decorators = [
    { type: Injectable }
];
/** @nocollapse */
CheckoutService.ctorParameters = () => [
    { type: Store },
    { type: CartDataService }
];
if (false) {
    /**
     * @type {?}
     * @protected
     */
    CheckoutService.prototype.checkoutStore;
    /**
     * @type {?}
     * @protected
     */
    CheckoutService.prototype.cartData;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @abstract
 */
class TranslationService {
}
if (false) {
    /**
     * Translates given key with options.
     * If key is missing, it tries to load the chunk and emits a value when chunk is loaded.
     * If key is missing after loaded chunk, a fallback value is emitted
     *
     * \@param key translation key
     * \@param options values for interpolation in translation
     * \@param whitespaceUntilLoaded if true, immediately emits a non-breaking space
     * @type {?}
     */
    TranslationService.prototype.translate;
    /**
     * Loads chunks with translations
     *
     * \@param chunkNames array of chunk names to be loaded
     * @type {?}
     */
    TranslationService.prototype.loadChunks;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Resolves the page data for all Content Pages based on the `PageType.CONTENT_PAGE`
 * and the `MultiStepCheckoutSummaryPageTemplate`. If the checkout page matches this template,
 * the more generic `ContentPageMetaResolver` is overriden by this resolver.
 *
 * The page title and robots are resolved in this implementation only.
 */
class CheckoutPageMetaResolver extends PageMetaResolver {
    /**
     * @param {?} cartService
     * @param {?} translation
     */
    constructor(cartService, translation) {
        super();
        this.cartService = cartService;
        this.translation = translation;
        this.cart$ = this.cartService.getActive();
        this.pageType = PageType.CONTENT_PAGE;
        this.pageTemplate = 'MultiStepCheckoutSummaryPageTemplate';
    }
    /**
     * @deprecated since version 1.3
     *
     * The resolve method is no longer preferred and will be removed with release 2.0.
     * The caller `PageMetaService` service is improved to expect all individual resolvers
     * instead, so that the code is easier extensible.
     * @return {?}
     */
    resolve() {
        return this.cart$.pipe(switchMap((/**
         * @param {?} cart
         * @return {?}
         */
        cart => combineLatest([this.resolveTitle(cart), this.resolveRobots()]))), map((/**
         * @param {?} __0
         * @return {?}
         */
        ([title, robots]) => ({ title, robots }))));
    }
    /**
     * @param {?=} cart
     * @return {?}
     */
    resolveTitle(cart) {
        /** @type {?} */
        const cart$ = cart ? of(cart) : this.cart$;
        return cart$.pipe(switchMap((/**
         * @param {?} c
         * @return {?}
         */
        c => this.translation.translate('pageMetaResolver.checkout.title', {
            count: c.totalItems,
        }))));
    }
    /**
     * @return {?}
     */
    resolveRobots() {
        return of([PageRobotsMeta.NOFOLLOW, PageRobotsMeta.NOINDEX]);
    }
}
CheckoutPageMetaResolver.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root',
            },] }
];
/** @nocollapse */
CheckoutPageMetaResolver.ctorParameters = () => [
    { type: CartService },
    { type: TranslationService }
];
/** @nocollapse */ CheckoutPageMetaResolver.ngInjectableDef = ɵɵdefineInjectable({ factory: function CheckoutPageMetaResolver_Factory() { return new CheckoutPageMetaResolver(ɵɵinject(CartService), ɵɵinject(TranslationService)); }, token: CheckoutPageMetaResolver, providedIn: "root" });
if (false) {
    /**
     * @type {?}
     * @private
     */
    CheckoutPageMetaResolver.prototype.cart$;
    /**
     * @type {?}
     * @protected
     */
    CheckoutPageMetaResolver.prototype.cartService;
    /**
     * @type {?}
     * @protected
     */
    CheckoutPageMetaResolver.prototype.translation;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const initialState$c = {
    address: {},
    deliveryMode: {
        supported: {},
        selected: '',
    },
    paymentDetails: {},
    orderDetails: {},
};
/**
 * @param {?=} state
 * @param {?=} action
 * @return {?}
 */
function reducer$c(state = initialState$c, action) {
    switch (action.type) {
        case ADD_DELIVERY_ADDRESS_SUCCESS:
        case SET_DELIVERY_ADDRESS_SUCCESS: {
            /** @type {?} */
            const address = action.payload;
            return Object.assign({}, state, { address });
        }
        case LOAD_SUPPORTED_DELIVERY_MODES_SUCCESS: {
            /** @type {?} */
            const supportedModes = action.payload;
            if (!supportedModes) {
                return state;
            }
            /** @type {?} */
            const supported = supportedModes.reduce((/**
             * @param {?} modes
             * @param {?} mode
             * @return {?}
             */
            (modes, mode) => {
                return Object.assign({}, modes, { [mode.code]: mode });
            }), Object.assign({}, state.deliveryMode.supported));
            return Object.assign({}, state, { deliveryMode: Object.assign({}, state.deliveryMode, { supported }) });
        }
        case SET_DELIVERY_MODE_SUCCESS: {
            /** @type {?} */
            const selected = action.payload;
            return Object.assign({}, state, { deliveryMode: Object.assign({}, state.deliveryMode, { selected }) });
        }
        case CREATE_PAYMENT_DETAILS_SUCCESS:
        case SET_PAYMENT_DETAILS_SUCCESS: {
            return Object.assign({}, state, { paymentDetails: action.payload });
        }
        case CREATE_PAYMENT_DETAILS_FAIL: {
            /** @type {?} */
            const paymentDetails = action.payload;
            if (paymentDetails['hasError']) {
                return Object.assign({}, state, { paymentDetails });
            }
            return state;
        }
        case PLACE_ORDER_SUCCESS: {
            /** @type {?} */
            const orderDetails = action.payload;
            return Object.assign({}, state, { orderDetails });
        }
        case CLEAR_CHECKOUT_DATA: {
            return initialState$c;
        }
        case CLEAR_CHECKOUT_STEP: {
            /** @type {?} */
            const stepNumber = action.payload;
            switch (stepNumber) {
                case 1: {
                    return Object.assign({}, state, { address: {} });
                }
                case 2: {
                    return Object.assign({}, state, { deliveryMode: Object.assign({}, state.deliveryMode, { supported: {}, selected: '' }) });
                }
                case 3: {
                    return Object.assign({}, state, { paymentDetails: {} });
                }
            }
            return state;
        }
        case CLEAR_SUPPORTED_DELIVERY_MODES:
        case CHECKOUT_CLEAR_MISCS_DATA: {
            return Object.assign({}, state, { deliveryMode: Object.assign({}, state.deliveryMode, { supported: {} }) });
        }
        case LOAD_CHECKOUT_DETAILS_SUCCESS: {
            return Object.assign({}, state, { address: action.payload.deliveryAddress, deliveryMode: Object.assign({}, state.deliveryMode, { selected: action.payload.deliveryMode && action.payload.deliveryMode.code }), paymentDetails: action.payload.paymentInfo });
        }
        case CLEAR_CHECKOUT_DELIVERY_ADDRESS: {
            return Object.assign({}, state, { address: {} });
        }
        case CLEAR_CHECKOUT_DELIVERY_MODE: {
            return Object.assign({}, state, { deliveryMode: Object.assign({}, state.deliveryMode, { selected: '' }) });
        }
    }
    return state;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @return {?}
 */
function getReducers$6() {
    return {
        steps: loaderReducer(CHECKOUT_DETAILS, reducer$c),
        cardTypes: reducer$b,
        addressVerification: reducer$a,
    };
}
/** @type {?} */
const reducerToken$6 = new InjectionToken('CheckoutReducers');
/** @type {?} */
const reducerProvider$6 = {
    provide: reducerToken$6,
    useFactory: getReducers$6,
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class UserAddressConnector {
    /**
     * @param {?} adapter
     */
    constructor(adapter) {
        this.adapter = adapter;
    }
    /**
     * @param {?} userId
     * @return {?}
     */
    getAll(userId) {
        return this.adapter.loadAll(userId);
    }
    /**
     * @param {?} userId
     * @param {?} address
     * @return {?}
     */
    add(userId, address) {
        return this.adapter.add(userId, address);
    }
    /**
     * @param {?} userId
     * @param {?} addressId
     * @param {?} address
     * @return {?}
     */
    update(userId, addressId, address) {
        return this.adapter.update(userId, addressId, address);
    }
    /**
     * @param {?} userId
     * @param {?} address
     * @return {?}
     */
    verify(userId, address) {
        return this.adapter.verify(userId, address);
    }
    /**
     * @param {?} userId
     * @param {?} addressId
     * @return {?}
     */
    delete(userId, addressId) {
        return this.adapter.delete(userId, addressId);
    }
}
UserAddressConnector.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root',
            },] }
];
/** @nocollapse */
UserAddressConnector.ctorParameters = () => [
    { type: UserAddressAdapter }
];
/** @nocollapse */ UserAddressConnector.ngInjectableDef = ɵɵdefineInjectable({ factory: function UserAddressConnector_Factory() { return new UserAddressConnector(ɵɵinject(UserAddressAdapter)); }, token: UserAddressConnector, providedIn: "root" });
if (false) {
    /**
     * @type {?}
     * @protected
     */
    UserAddressConnector.prototype.adapter;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class AddressVerificationEffect {
    /**
     * @param {?} actions$
     * @param {?} userAddressConnector
     */
    constructor(actions$, userAddressConnector) {
        this.actions$ = actions$;
        this.userAddressConnector = userAddressConnector;
        this.verifyAddress$ = this.actions$.pipe(ofType(VERIFY_ADDRESS), map((/**
         * @param {?} action
         * @return {?}
         */
        action => action.payload)), mergeMap((/**
         * @param {?} payload
         * @return {?}
         */
        payload => this.userAddressConnector.verify(payload.userId, payload.address).pipe(map((/**
         * @param {?} data
         * @return {?}
         */
        data => new VerifyAddressSuccess(data))), catchError((/**
         * @param {?} error
         * @return {?}
         */
        error => of(new VerifyAddressFail(makeErrorSerializable(error)))))))));
    }
}
AddressVerificationEffect.decorators = [
    { type: Injectable }
];
/** @nocollapse */
AddressVerificationEffect.ctorParameters = () => [
    { type: Actions },
    { type: UserAddressConnector }
];
__decorate([
    Effect(),
    __metadata("design:type", Observable)
], AddressVerificationEffect.prototype, "verifyAddress$", void 0);
if (false) {
    /** @type {?} */
    AddressVerificationEffect.prototype.verifyAddress$;
    /**
     * @type {?}
     * @private
     */
    AddressVerificationEffect.prototype.actions$;
    /**
     * @type {?}
     * @private
     */
    AddressVerificationEffect.prototype.userAddressConnector;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class CheckoutPaymentConnector {
    /**
     * @param {?} adapter
     */
    constructor(adapter) {
        this.adapter = adapter;
    }
    /**
     * @param {?} userId
     * @param {?} cartId
     * @param {?} paymentDetails
     * @return {?}
     */
    create(userId, cartId, paymentDetails) {
        return this.adapter.create(userId, cartId, paymentDetails);
    }
    /**
     * @param {?} userId
     * @param {?} cartId
     * @param {?} paymentDetailsId
     * @return {?}
     */
    set(userId, cartId, paymentDetailsId) {
        return this.adapter.set(userId, cartId, paymentDetailsId);
    }
    /**
     * @return {?}
     */
    getCardTypes() {
        return this.adapter.loadCardTypes();
    }
}
CheckoutPaymentConnector.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root',
            },] }
];
/** @nocollapse */
CheckoutPaymentConnector.ctorParameters = () => [
    { type: CheckoutPaymentAdapter }
];
/** @nocollapse */ CheckoutPaymentConnector.ngInjectableDef = ɵɵdefineInjectable({ factory: function CheckoutPaymentConnector_Factory() { return new CheckoutPaymentConnector(ɵɵinject(CheckoutPaymentAdapter)); }, token: CheckoutPaymentConnector, providedIn: "root" });
if (false) {
    /**
     * @type {?}
     * @protected
     */
    CheckoutPaymentConnector.prototype.adapter;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class CardTypesEffects {
    /**
     * @param {?} actions$
     * @param {?} checkoutPaymentConnector
     */
    constructor(actions$, checkoutPaymentConnector) {
        this.actions$ = actions$;
        this.checkoutPaymentConnector = checkoutPaymentConnector;
        this.loadCardTypes$ = this.actions$.pipe(ofType(LOAD_CARD_TYPES), switchMap((/**
         * @return {?}
         */
        () => {
            return this.checkoutPaymentConnector.getCardTypes().pipe(map((/**
             * @param {?} cardTypes
             * @return {?}
             */
            cardTypes => new LoadCardTypesSuccess(cardTypes))), catchError((/**
             * @param {?} error
             * @return {?}
             */
            error => of(new LoadCardTypesFail(makeErrorSerializable(error))))));
        })));
    }
}
CardTypesEffects.decorators = [
    { type: Injectable }
];
/** @nocollapse */
CardTypesEffects.ctorParameters = () => [
    { type: Actions },
    { type: CheckoutPaymentConnector }
];
__decorate([
    Effect(),
    __metadata("design:type", Observable)
], CardTypesEffects.prototype, "loadCardTypes$", void 0);
if (false) {
    /** @type {?} */
    CardTypesEffects.prototype.loadCardTypes$;
    /**
     * @type {?}
     * @private
     */
    CardTypesEffects.prototype.actions$;
    /**
     * @type {?}
     * @private
     */
    CardTypesEffects.prototype.checkoutPaymentConnector;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class CheckoutConnector {
    /**
     * @param {?} adapter
     */
    constructor(adapter) {
        this.adapter = adapter;
    }
    /**
     * @param {?} userId
     * @param {?} cartId
     * @return {?}
     */
    placeOrder(userId, cartId) {
        return this.adapter.placeOrder(userId, cartId);
    }
    /**
     * @param {?} userId
     * @param {?} cartId
     * @return {?}
     */
    loadCheckoutDetails(userId, cartId) {
        return this.adapter.loadCheckoutDetails(userId, cartId);
    }
    /**
     * @param {?} userId
     * @param {?} cartId
     * @return {?}
     */
    clearCheckoutDeliveryAddress(userId, cartId) {
        return this.adapter.clearCheckoutDeliveryAddress(userId, cartId);
    }
    /**
     * @param {?} userId
     * @param {?} cartId
     * @return {?}
     */
    clearCheckoutDeliveryMode(userId, cartId) {
        return this.adapter.clearCheckoutDeliveryMode(userId, cartId);
    }
}
CheckoutConnector.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root',
            },] }
];
/** @nocollapse */
CheckoutConnector.ctorParameters = () => [
    { type: CheckoutAdapter }
];
/** @nocollapse */ CheckoutConnector.ngInjectableDef = ɵɵdefineInjectable({ factory: function CheckoutConnector_Factory() { return new CheckoutConnector(ɵɵinject(CheckoutAdapter)); }, token: CheckoutConnector, providedIn: "root" });
if (false) {
    /**
     * @type {?}
     * @protected
     */
    CheckoutConnector.prototype.adapter;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class CheckoutDeliveryConnector {
    /**
     * @param {?} adapter
     */
    constructor(adapter) {
        this.adapter = adapter;
    }
    /**
     * @param {?} userId
     * @param {?} cartId
     * @param {?} address
     * @return {?}
     */
    createAddress(userId, cartId, address) {
        return this.adapter.createAddress(userId, cartId, address);
    }
    /**
     * @param {?} userId
     * @param {?} cartId
     * @param {?} addressId
     * @return {?}
     */
    setAddress(userId, cartId, addressId) {
        return this.adapter.setAddress(userId, cartId, addressId);
    }
    /**
     * @param {?} userId
     * @param {?} cartId
     * @param {?} deliveryModeId
     * @return {?}
     */
    setMode(userId, cartId, deliveryModeId) {
        return this.adapter.setMode(userId, cartId, deliveryModeId);
    }
    /**
     * @param {?} userId
     * @param {?} cartId
     * @return {?}
     */
    getMode(userId, cartId) {
        return this.adapter.getMode(userId, cartId);
    }
    /**
     * @param {?} userId
     * @param {?} cartId
     * @return {?}
     */
    getSupportedModes(userId, cartId) {
        return this.adapter.getSupportedModes(userId, cartId);
    }
}
CheckoutDeliveryConnector.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root',
            },] }
];
/** @nocollapse */
CheckoutDeliveryConnector.ctorParameters = () => [
    { type: CheckoutDeliveryAdapter }
];
/** @nocollapse */ CheckoutDeliveryConnector.ngInjectableDef = ɵɵdefineInjectable({ factory: function CheckoutDeliveryConnector_Factory() { return new CheckoutDeliveryConnector(ɵɵinject(CheckoutDeliveryAdapter)); }, token: CheckoutDeliveryConnector, providedIn: "root" });
if (false) {
    /**
     * @type {?}
     * @protected
     */
    CheckoutDeliveryConnector.prototype.adapter;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class CheckoutEffects {
    /**
     * @param {?} actions$
     * @param {?} checkoutDeliveryConnector
     * @param {?} checkoutPaymentConnector
     * @param {?} checkoutConnector
     */
    constructor(actions$, checkoutDeliveryConnector, checkoutPaymentConnector, checkoutConnector) {
        this.actions$ = actions$;
        this.checkoutDeliveryConnector = checkoutDeliveryConnector;
        this.checkoutPaymentConnector = checkoutPaymentConnector;
        this.checkoutConnector = checkoutConnector;
        this.contextChange$ = this.actions$.pipe(ofType(CURRENCY_CHANGE, LANGUAGE_CHANGE));
        this.addDeliveryAddress$ = this.actions$.pipe(ofType(ADD_DELIVERY_ADDRESS), map((/**
         * @param {?} action
         * @return {?}
         */
        (action) => action.payload)), mergeMap((/**
         * @param {?} payload
         * @return {?}
         */
        payload => this.checkoutDeliveryConnector
            .createAddress(payload.userId, payload.cartId, payload.address)
            .pipe(mergeMap((/**
         * @param {?} address
         * @return {?}
         */
        address => {
            address['titleCode'] = payload.address.titleCode;
            if (payload.address.region && payload.address.region.isocodeShort) {
                Object.assign(address.region, {
                    isocodeShort: payload.address.region.isocodeShort,
                });
            }
            if (payload.userId === OCC_USER_ID_ANONYMOUS) {
                return [
                    new SetDeliveryAddress({
                        userId: payload.userId,
                        cartId: payload.cartId,
                        address: address,
                    }),
                ];
            }
            else {
                return [
                    new LoadUserAddresses(payload.userId),
                    new SetDeliveryAddress({
                        userId: payload.userId,
                        cartId: payload.cartId,
                        address: address,
                    }),
                ];
            }
        })), catchError((/**
         * @param {?} error
         * @return {?}
         */
        error => of(new AddDeliveryAddressFail(makeErrorSerializable(error)))))))), withdrawOn(this.contextChange$));
        this.setDeliveryAddress$ = this.actions$.pipe(ofType(SET_DELIVERY_ADDRESS), map((/**
         * @param {?} action
         * @return {?}
         */
        (action) => action.payload)), mergeMap((/**
         * @param {?} payload
         * @return {?}
         */
        payload => {
            return this.checkoutDeliveryConnector
                .setAddress(payload.userId, payload.cartId, payload.address.id)
                .pipe(mergeMap((/**
             * @return {?}
             */
            () => [
                new SetDeliveryAddressSuccess(payload.address),
                new ClearCheckoutDeliveryMode({
                    userId: payload.userId,
                    cartId: payload.cartId,
                }),
                new ClearSupportedDeliveryModes(),
                new ResetLoadSupportedDeliveryModesProcess(),
                new LoadSupportedDeliveryModes({
                    userId: payload.userId,
                    cartId: payload.cartId,
                }),
            ])), catchError((/**
             * @param {?} error
             * @return {?}
             */
            error => of(new SetDeliveryAddressFail(makeErrorSerializable(error))))));
        })), withdrawOn(this.contextChange$));
        this.loadSupportedDeliveryModes$ = this.actions$.pipe(ofType(LOAD_SUPPORTED_DELIVERY_MODES), map((/**
         * @param {?} action
         * @return {?}
         */
        (action) => action.payload)), mergeMap((/**
         * @param {?} payload
         * @return {?}
         */
        payload => {
            return this.checkoutDeliveryConnector
                .getSupportedModes(payload.userId, payload.cartId)
                .pipe(map((/**
             * @param {?} data
             * @return {?}
             */
            data => {
                return new LoadSupportedDeliveryModesSuccess(data);
            })), catchError((/**
             * @param {?} error
             * @return {?}
             */
            error => of(new LoadSupportedDeliveryModesFail(makeErrorSerializable(error))))));
        })), withdrawOn(this.contextChange$));
        this.clearCheckoutMiscsDataOnLanguageChange$ = this.actions$.pipe(ofType(LANGUAGE_CHANGE), mergeMap((/**
         * @return {?}
         */
        () => [
            new CheckoutClearMiscsData(),
            new ResetLoadSupportedDeliveryModesProcess(),
        ])));
        this.clearDeliveryModesOnCurrencyChange$ = this.actions$.pipe(ofType(CURRENCY_CHANGE), map((/**
         * @return {?}
         */
        () => new ClearSupportedDeliveryModes())));
        this.clearCheckoutDataOnLogout$ = this.actions$.pipe(ofType(LOGOUT), map((/**
         * @return {?}
         */
        () => new ClearCheckoutData())));
        this.clearCheckoutDataOnLogin$ = this.actions$.pipe(ofType(LOGIN), map((/**
         * @return {?}
         */
        () => new ClearCheckoutData())));
        this.setDeliveryMode$ = this.actions$.pipe(ofType(SET_DELIVERY_MODE), map((/**
         * @param {?} action
         * @return {?}
         */
        (action) => action.payload)), mergeMap((/**
         * @param {?} payload
         * @return {?}
         */
        payload => {
            return this.checkoutDeliveryConnector
                .setMode(payload.userId, payload.cartId, payload.selectedModeId)
                .pipe(mergeMap((/**
             * @return {?}
             */
            () => {
                return [
                    new SetDeliveryModeSuccess(payload.selectedModeId),
                    new LoadCart({
                        userId: payload.userId,
                        cartId: payload.cartId,
                    }),
                ];
            })), catchError((/**
             * @param {?} error
             * @return {?}
             */
            error => of(new SetDeliveryModeFail(makeErrorSerializable(error))))));
        })), withdrawOn(this.contextChange$));
        this.createPaymentDetails$ = this.actions$.pipe(ofType(CREATE_PAYMENT_DETAILS), map((/**
         * @param {?} action
         * @return {?}
         */
        (action) => action.payload)), mergeMap((/**
         * @param {?} payload
         * @return {?}
         */
        payload => {
            // get information for creating a subscription directly with payment provider
            return this.checkoutPaymentConnector
                .create(payload.userId, payload.cartId, payload.paymentDetails)
                .pipe(mergeMap((/**
             * @param {?} details
             * @return {?}
             */
            details => {
                if (payload.userId === OCC_USER_ID_ANONYMOUS) {
                    return [new CreatePaymentDetailsSuccess(details)];
                }
                else {
                    return [
                        new LoadUserPaymentMethods(payload.userId),
                        new CreatePaymentDetailsSuccess(details),
                    ];
                }
            })), catchError((/**
             * @param {?} error
             * @return {?}
             */
            error => of(new CreatePaymentDetailsFail(makeErrorSerializable(error))))));
        })), withdrawOn(this.contextChange$));
        this.setPaymentDetails$ = this.actions$.pipe(ofType(SET_PAYMENT_DETAILS), map((/**
         * @param {?} action
         * @return {?}
         */
        (action) => action.payload)), mergeMap((/**
         * @param {?} payload
         * @return {?}
         */
        payload => {
            return this.checkoutPaymentConnector
                .set(payload.userId, payload.cartId, payload.paymentDetails.id)
                .pipe(map((/**
             * @return {?}
             */
            () => new SetPaymentDetailsSuccess(payload.paymentDetails))), catchError((/**
             * @param {?} error
             * @return {?}
             */
            error => of(new SetPaymentDetailsFail(makeErrorSerializable(error))))));
        })), withdrawOn(this.contextChange$));
        this.placeOrder$ = this.actions$.pipe(ofType(PLACE_ORDER), map((/**
         * @param {?} action
         * @return {?}
         */
        (action) => action.payload)), mergeMap((/**
         * @param {?} payload
         * @return {?}
         */
        payload => {
            return this.checkoutConnector
                .placeOrder(payload.userId, payload.cartId)
                .pipe(switchMap((/**
             * @param {?} data
             * @return {?}
             */
            data => [
                new RemoveCart(payload.cartId),
                new PlaceOrderSuccess(data),
            ])), catchError((/**
             * @param {?} error
             * @return {?}
             */
            error => of(new PlaceOrderFail(makeErrorSerializable(error))))));
        })), withdrawOn(this.contextChange$));
        this.loadCheckoutDetails$ = this.actions$.pipe(ofType(LOAD_CHECKOUT_DETAILS), map((/**
         * @param {?} action
         * @return {?}
         */
        (action) => action.payload)), mergeMap((/**
         * @param {?} payload
         * @return {?}
         */
        payload => {
            return this.checkoutConnector
                .loadCheckoutDetails(payload.userId, payload.cartId)
                .pipe(map((/**
             * @param {?} data
             * @return {?}
             */
            (data) => new LoadCheckoutDetailsSuccess(data))), catchError((/**
             * @param {?} error
             * @return {?}
             */
            error => of(new LoadCheckoutDetailsFail(makeErrorSerializable(error))))));
        })), withdrawOn(this.contextChange$));
        this.reloadDetailsOnMergeCart$ = this.actions$.pipe(ofType(MERGE_CART_SUCCESS), map((/**
         * @param {?} action
         * @return {?}
         */
        (action) => action.payload)), map((/**
         * @param {?} payload
         * @return {?}
         */
        payload => {
            return new LoadCheckoutDetails({
                userId: payload.userId,
                cartId: payload.cartId ? payload.cartId : OCC_CART_ID_CURRENT,
            });
        })));
        this.clearCheckoutDeliveryAddress$ = this.actions$.pipe(ofType(CLEAR_CHECKOUT_DELIVERY_ADDRESS), map((/**
         * @param {?} action
         * @return {?}
         */
        (action) => action.payload)), filter((/**
         * @param {?} payload
         * @return {?}
         */
        payload => Boolean(payload.cartId))), switchMap((/**
         * @param {?} payload
         * @return {?}
         */
        payload => {
            return this.checkoutConnector
                .clearCheckoutDeliveryAddress(payload.userId, payload.cartId)
                .pipe(map((/**
             * @return {?}
             */
            () => new ClearCheckoutDeliveryAddressSuccess())), catchError((/**
             * @param {?} error
             * @return {?}
             */
            error => of(new ClearCheckoutDeliveryAddressFail(makeErrorSerializable(error))))));
        })), withdrawOn(this.contextChange$));
        this.clearCheckoutDeliveryMode$ = this.actions$.pipe(ofType(CLEAR_CHECKOUT_DELIVERY_MODE), map((/**
         * @param {?} action
         * @return {?}
         */
        (action) => action.payload)), filter((/**
         * @param {?} payload
         * @return {?}
         */
        payload => Boolean(payload.cartId))), concatMap((/**
         * @param {?} payload
         * @return {?}
         */
        payload => {
            return this.checkoutConnector
                .clearCheckoutDeliveryMode(payload.userId, payload.cartId)
                .pipe(map((/**
             * @return {?}
             */
            () => new ClearCheckoutDeliveryModeSuccess({
                userId: payload.userId,
                cartId: payload.cartId,
            }))), catchError((/**
             * @param {?} error
             * @return {?}
             */
            error => from([
                new ClearCheckoutDeliveryModeFail(makeErrorSerializable(error)),
                new CartProcessesDecrement(payload.cartId),
                new LoadCart({
                    cartId: payload.cartId,
                    userId: payload.userId,
                }),
            ]))));
        })), withdrawOn(this.contextChange$));
    }
}
CheckoutEffects.decorators = [
    { type: Injectable }
];
/** @nocollapse */
CheckoutEffects.ctorParameters = () => [
    { type: Actions },
    { type: CheckoutDeliveryConnector },
    { type: CheckoutPaymentConnector },
    { type: CheckoutConnector }
];
__decorate([
    Effect(),
    __metadata("design:type", Observable)
], CheckoutEffects.prototype, "addDeliveryAddress$", void 0);
__decorate([
    Effect(),
    __metadata("design:type", Observable)
], CheckoutEffects.prototype, "setDeliveryAddress$", void 0);
__decorate([
    Effect(),
    __metadata("design:type", Observable)
], CheckoutEffects.prototype, "loadSupportedDeliveryModes$", void 0);
__decorate([
    Effect(),
    __metadata("design:type", Observable)
], CheckoutEffects.prototype, "clearCheckoutMiscsDataOnLanguageChange$", void 0);
__decorate([
    Effect(),
    __metadata("design:type", Observable)
], CheckoutEffects.prototype, "clearDeliveryModesOnCurrencyChange$", void 0);
__decorate([
    Effect(),
    __metadata("design:type", Observable)
], CheckoutEffects.prototype, "clearCheckoutDataOnLogout$", void 0);
__decorate([
    Effect(),
    __metadata("design:type", Observable)
], CheckoutEffects.prototype, "clearCheckoutDataOnLogin$", void 0);
__decorate([
    Effect(),
    __metadata("design:type", Observable)
], CheckoutEffects.prototype, "setDeliveryMode$", void 0);
__decorate([
    Effect(),
    __metadata("design:type", Observable)
], CheckoutEffects.prototype, "createPaymentDetails$", void 0);
__decorate([
    Effect(),
    __metadata("design:type", Observable)
], CheckoutEffects.prototype, "setPaymentDetails$", void 0);
__decorate([
    Effect(),
    __metadata("design:type", Observable)
], CheckoutEffects.prototype, "placeOrder$", void 0);
__decorate([
    Effect(),
    __metadata("design:type", Observable)
], CheckoutEffects.prototype, "loadCheckoutDetails$", void 0);
__decorate([
    Effect(),
    __metadata("design:type", Observable)
], CheckoutEffects.prototype, "reloadDetailsOnMergeCart$", void 0);
__decorate([
    Effect(),
    __metadata("design:type", Observable)
], CheckoutEffects.prototype, "clearCheckoutDeliveryAddress$", void 0);
__decorate([
    Effect(),
    __metadata("design:type", Observable)
], CheckoutEffects.prototype, "clearCheckoutDeliveryMode$", void 0);
if (false) {
    /**
     * @type {?}
     * @private
     */
    CheckoutEffects.prototype.contextChange$;
    /** @type {?} */
    CheckoutEffects.prototype.addDeliveryAddress$;
    /** @type {?} */
    CheckoutEffects.prototype.setDeliveryAddress$;
    /** @type {?} */
    CheckoutEffects.prototype.loadSupportedDeliveryModes$;
    /** @type {?} */
    CheckoutEffects.prototype.clearCheckoutMiscsDataOnLanguageChange$;
    /** @type {?} */
    CheckoutEffects.prototype.clearDeliveryModesOnCurrencyChange$;
    /** @type {?} */
    CheckoutEffects.prototype.clearCheckoutDataOnLogout$;
    /** @type {?} */
    CheckoutEffects.prototype.clearCheckoutDataOnLogin$;
    /** @type {?} */
    CheckoutEffects.prototype.setDeliveryMode$;
    /** @type {?} */
    CheckoutEffects.prototype.createPaymentDetails$;
    /** @type {?} */
    CheckoutEffects.prototype.setPaymentDetails$;
    /** @type {?} */
    CheckoutEffects.prototype.placeOrder$;
    /** @type {?} */
    CheckoutEffects.prototype.loadCheckoutDetails$;
    /** @type {?} */
    CheckoutEffects.prototype.reloadDetailsOnMergeCart$;
    /** @type {?} */
    CheckoutEffects.prototype.clearCheckoutDeliveryAddress$;
    /** @type {?} */
    CheckoutEffects.prototype.clearCheckoutDeliveryMode$;
    /**
     * @type {?}
     * @private
     */
    CheckoutEffects.prototype.actions$;
    /**
     * @type {?}
     * @private
     */
    CheckoutEffects.prototype.checkoutDeliveryConnector;
    /**
     * @type {?}
     * @private
     */
    CheckoutEffects.prototype.checkoutPaymentConnector;
    /**
     * @type {?}
     * @private
     */
    CheckoutEffects.prototype.checkoutConnector;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const effects$6 = [
    CheckoutEffects,
    AddressVerificationEffect,
    CardTypesEffects,
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class CheckoutStoreModule {
}
CheckoutStoreModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    HttpClientModule,
                    StoreModule.forFeature(CHECKOUT_FEATURE, reducerToken$6),
                    EffectsModule.forFeature(effects$6),
                ],
                providers: [reducerProvider$6],
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class CheckoutModule {
    /**
     * @return {?}
     */
    static forRoot() {
        return {
            ngModule: CheckoutModule,
            providers: [
                CheckoutService,
                {
                    provide: PageMetaResolver,
                    useExisting: CheckoutPageMetaResolver,
                    multi: true,
                },
            ],
        };
    }
}
CheckoutModule.decorators = [
    { type: NgModule, args: [{
                imports: [CheckoutStoreModule],
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class CheckoutDeliveryService {
    /**
     * @param {?} checkoutStore
     * @param {?} cartData
     */
    constructor(checkoutStore, cartData) {
        this.checkoutStore = checkoutStore;
        this.cartData = cartData;
    }
    /**
     * Get supported delivery modes
     * @return {?}
     */
    getSupportedDeliveryModes() {
        return this.checkoutStore.pipe(select(getSupportedDeliveryModes), withLatestFrom(this.checkoutStore.pipe(select(getProcessStateFactory(SET_SUPPORTED_DELIVERY_MODE_PROCESS_ID)))), tap((/**
         * @param {?} __0
         * @return {?}
         */
        ([, loadingState]) => {
            if (!(loadingState.loading || loadingState.success || loadingState.error)) {
                this.loadSupportedDeliveryModes();
            }
        })), pluck(0), shareReplay({ bufferSize: 1, refCount: true }));
    }
    /**
     * Get selected delivery mode
     * @return {?}
     */
    getSelectedDeliveryMode() {
        return this.checkoutStore.pipe(select(getSelectedDeliveryMode));
    }
    /**
     * Get selected delivery mode code
     * @return {?}
     */
    getSelectedDeliveryModeCode() {
        return this.checkoutStore.pipe(select(getSelectedDeliveryModeCode));
    }
    /**
     * Get delivery address
     * @return {?}
     */
    getDeliveryAddress() {
        return this.checkoutStore.pipe(select(getDeliveryAddress));
    }
    /**
     * Get status about successfully set Delivery Address
     * @return {?}
     */
    getSetDeliveryAddressProcess() {
        return this.checkoutStore.pipe(select(getProcessStateFactory(SET_DELIVERY_ADDRESS_PROCESS_ID)));
    }
    /**
     * Clear info about process of setting Delivery Address
     * @return {?}
     */
    resetSetDeliveryAddressProcess() {
        this.checkoutStore.dispatch(new ResetSetDeliveryAddressProcess());
    }
    /**
     * Get status about of set Delivery Mode process
     * @return {?}
     */
    getSetDeliveryModeProcess() {
        return this.checkoutStore.pipe(select(getProcessStateFactory(SET_DELIVERY_MODE_PROCESS_ID)));
    }
    /**
     * Clear info about process of setting Delivery Mode
     * @return {?}
     */
    resetSetDeliveryModeProcess() {
        this.checkoutStore.dispatch(new ResetSetDeliveryModeProcess());
    }
    /**
     * Clear info about process of setting Supported Delivery Modes
     * @return {?}
     */
    resetLoadSupportedDeliveryModesProcess() {
        this.checkoutStore.dispatch(new ResetLoadSupportedDeliveryModesProcess());
    }
    /**
     * Get status about of set supported Delivery Modes process
     * @return {?}
     */
    getLoadSupportedDeliveryModeProcess() {
        return this.checkoutStore.pipe(select(getProcessStateFactory(SET_SUPPORTED_DELIVERY_MODE_PROCESS_ID)));
    }
    /**
     * Clear supported delivery modes loaded in last checkout process
     * @return {?}
     */
    clearCheckoutDeliveryModes() {
        this.checkoutStore.dispatch(new ClearSupportedDeliveryModes());
    }
    /**
     * Get address verification results
     * @return {?}
     */
    getAddressVerificationResults() {
        return this.checkoutStore.pipe(select(getAddressVerificationResults$1), filter((/**
         * @param {?} results
         * @return {?}
         */
        results => Object.keys(results).length !== 0)));
    }
    /**
     * Create and set a delivery address using the address param
     * @param {?} address : the Address to be created and set
     * @return {?}
     */
    createAndSetAddress(address) {
        if (this.actionAllowed()) {
            this.checkoutStore.dispatch(new AddDeliveryAddress({
                userId: this.cartData.userId,
                cartId: this.cartData.cartId,
                address: address,
            }));
        }
    }
    /**
     * Load supported delivery modes
     * @return {?}
     */
    loadSupportedDeliveryModes() {
        if (this.actionAllowed()) {
            this.checkoutStore.dispatch(new LoadSupportedDeliveryModes({
                userId: this.cartData.userId,
                cartId: this.cartData.cartId,
            }));
        }
    }
    /**
     * Set delivery mode
     * @param {?} mode : The delivery mode to be set
     * @return {?}
     */
    setDeliveryMode(mode) {
        if (this.actionAllowed()) {
            this.checkoutStore.dispatch(new SetDeliveryMode({
                userId: this.cartData.userId,
                cartId: this.cartData.cartId,
                selectedModeId: mode,
            }));
        }
    }
    /**
     * Verifies the address
     * @param {?} address : the address to be verified
     * @return {?}
     */
    verifyAddress(address) {
        if (this.actionAllowed()) {
            this.checkoutStore.dispatch(new VerifyAddress({
                userId: this.cartData.userId,
                address,
            }));
        }
    }
    /**
     * Set delivery address
     * @param {?} address : The address to be set
     * @return {?}
     */
    setDeliveryAddress(address) {
        if (this.actionAllowed()) {
            this.checkoutStore.dispatch(new SetDeliveryAddress({
                userId: this.cartData.userId,
                cartId: this.cartData.cart.code,
                address: address,
            }));
        }
    }
    /**
     * Clear address verification results
     * @return {?}
     */
    clearAddressVerificationResults() {
        this.checkoutStore.dispatch(new ClearAddressVerificationResults());
    }
    /**
     * Clear address already setup in last checkout process
     * @return {?}
     */
    clearCheckoutDeliveryAddress() {
        this.checkoutStore.dispatch(new ClearCheckoutDeliveryAddress({
            userId: this.cartData.userId,
            cartId: this.cartData.cartId,
        }));
    }
    /**
     * Clear selected delivery mode setup in last checkout process
     * @return {?}
     */
    clearCheckoutDeliveryMode() {
        this.checkoutStore.dispatch(new ClearCheckoutDeliveryMode({
            userId: this.cartData.userId,
            cartId: this.cartData.cartId,
        }));
    }
    /**
     * Clear address and delivery mode already setup in last checkout process
     * @return {?}
     */
    clearCheckoutDeliveryDetails() {
        this.clearCheckoutDeliveryAddress();
        this.clearCheckoutDeliveryMode();
        this.clearCheckoutDeliveryModes();
    }
    /**
     * @protected
     * @return {?}
     */
    actionAllowed() {
        return (this.cartData.userId !== OCC_USER_ID_ANONYMOUS ||
            this.cartData.isGuestCart);
    }
}
CheckoutDeliveryService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root',
            },] }
];
/** @nocollapse */
CheckoutDeliveryService.ctorParameters = () => [
    { type: Store },
    { type: CartDataService }
];
/** @nocollapse */ CheckoutDeliveryService.ngInjectableDef = ɵɵdefineInjectable({ factory: function CheckoutDeliveryService_Factory() { return new CheckoutDeliveryService(ɵɵinject(Store), ɵɵinject(CartDataService)); }, token: CheckoutDeliveryService, providedIn: "root" });
if (false) {
    /**
     * @type {?}
     * @protected
     */
    CheckoutDeliveryService.prototype.checkoutStore;
    /**
     * @type {?}
     * @protected
     */
    CheckoutDeliveryService.prototype.cartData;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class CheckoutPaymentService {
    /**
     * @param {?} checkoutStore
     * @param {?} cartData
     */
    constructor(checkoutStore, cartData) {
        this.checkoutStore = checkoutStore;
        this.cartData = cartData;
    }
    /**
     * Get card types
     * @return {?}
     */
    getCardTypes() {
        return this.checkoutStore.pipe(select(getAllCardTypes));
    }
    /**
     * Get payment details
     * @return {?}
     */
    getPaymentDetails() {
        return this.checkoutStore.pipe(select(getPaymentDetails));
    }
    /**
     * Get status about set Payment Details process
     * @return {?}
     */
    getSetPaymentDetailsResultProcess() {
        return this.checkoutStore.pipe(select(getProcessStateFactory(SET_PAYMENT_DETAILS_PROCESS_ID)));
    }
    /**
     * Clear info about process of setting Payment Details
     * @return {?}
     */
    resetSetPaymentDetailsProcess() {
        this.checkoutStore.dispatch(new ResetSetPaymentDetailsProcess());
    }
    /**
     * Load the supported card types
     * @return {?}
     */
    loadSupportedCardTypes() {
        this.checkoutStore.dispatch(new LoadCardTypes());
    }
    /**
     * Create payment details using the given paymentDetails param
     * @param {?} paymentDetails
     * @return {?}
     */
    createPaymentDetails(paymentDetails) {
        if (this.actionAllowed()) {
            this.checkoutStore.dispatch(new CreatePaymentDetails({
                userId: this.cartData.userId,
                cartId: this.cartData.cartId,
                paymentDetails,
            }));
        }
    }
    /**
     * Set payment details
     * @param {?} paymentDetails : the PaymentDetails to be set
     * @return {?}
     */
    setPaymentDetails(paymentDetails) {
        if (this.actionAllowed()) {
            this.checkoutStore.dispatch(new SetPaymentDetails({
                userId: this.cartData.userId,
                cartId: this.cartData.cart.code,
                paymentDetails: paymentDetails,
            }));
        }
    }
    /**
     * Sets payment loading to true without having the flicker issue (GH-3102)
     * @return {?}
     */
    paymentProcessSuccess() {
        this.checkoutStore.dispatch(new PaymentProcessSuccess());
    }
    /**
     * @protected
     * @return {?}
     */
    actionAllowed() {
        return (this.cartData.userId !== OCC_USER_ID_ANONYMOUS ||
            this.cartData.isGuestCart);
    }
}
CheckoutPaymentService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root',
            },] }
];
/** @nocollapse */
CheckoutPaymentService.ctorParameters = () => [
    { type: Store },
    { type: CartDataService }
];
/** @nocollapse */ CheckoutPaymentService.ngInjectableDef = ɵɵdefineInjectable({ factory: function CheckoutPaymentService_Factory() { return new CheckoutPaymentService(ɵɵinject(Store), ɵɵinject(CartDataService)); }, token: CheckoutPaymentService, providedIn: "root" });
if (false) {
    /**
     * @type {?}
     * @protected
     */
    CheckoutPaymentService.prototype.checkoutStore;
    /**
     * @type {?}
     * @protected
     */
    CheckoutPaymentService.prototype.cartData;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * The `CmsPageConfig` is used to build pages by configuration.
 * The interfaces are designed to have a clean configuration for
 * static CMS structure. Ordinary attributes that are not
 * required for configurable pages have been left out and
 * will not be serialized in the adapter logic.
 * @record
 */
function CmsPageConfig() { }
if (false) {
    /**
     * When the `ignoreBackend` is set to true, the CMS backend
     * will not be consumed. This saves network latency and is
     * useful for commodity commerce pages.
     *
     * @type {?|undefined}
     */
    CmsPageConfig.prototype.ignoreBackend;
    /** @type {?|undefined} */
    CmsPageConfig.prototype.pageId;
    /** @type {?|undefined} */
    CmsPageConfig.prototype.type;
    /**
     * The page title is typically used to display the page heading
     * as well as for the page title tag. The latter is used for browser
     * navigation as well as SEO and social share platforms.
     * @type {?|undefined}
     */
    CmsPageConfig.prototype.title;
    /**
     * the template is used to bind to the layout
     * configuration and css layout class
     * @type {?|undefined}
     */
    CmsPageConfig.prototype.template;
    /**
     * The page slots represent various sections on the page that
     * can contain components.
     * @type {?}
     */
    CmsPageConfig.prototype.slots;
}
/**
 * The `CmsPageSlotsConfig` (plural) holds `CmsPageSlotConfig` objects.
 * @record
 */
function CmsPageSlotsConfig() { }
/**
 * The `CmsPageSlotConfig` is a simplified configuration model
 * that can be used to configure slots in static configuration,
 * rather than loading from a backend.
 * @record
 */
function CmsPageSlotConfig() { }
if (false) {
    /** @type {?|undefined} */
    CmsPageSlotConfig.prototype.componentIds;
    /** @type {?|undefined} */
    CmsPageSlotConfig.prototype.properties;
}
/**
 * The `CmsStructureConfig` is used to build pages in Spartacus by configuration
 * instead of using a backend CMS system. The configuration can be used to build
 * complete pages or parts of a page. The `CmsStructureConfig` is optimized to
 * only require the necessary properties. Adapter logic is applied to serialize
 * the `CmsStructureConfig` into the required UI model.
 * @abstract
 */
class CmsStructureConfig extends CmsConfig {
}
if (false) {
    /** @type {?} */
    CmsStructureConfig.prototype.cmsStructure;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const defaultCmsModuleConfig = {
    backend: {
        occ: {
            endpoints: {
                component: 'cms/components/${id}',
                components: 'cms/components',
                pages: 'cms/pages',
                page: 'cms/pages/${id}',
            },
            legacy: false,
        },
    },
    cmsComponents: {},
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Resolves the page data for all Content Pages based on the `PageType.CONTENT_PAGE`.
 * More specific resolvers for content pages can be implemented by making them more
 * specific, for example by using the page template (see `CartPageMetaResolver`).
 *
 * The page title, and breadcrumbs are resolved in this implementation only.
 */
class ContentPageMetaResolver extends PageMetaResolver {
    /**
     * @param {?} cms
     * @param {?} translation
     */
    constructor(cms, translation) {
        super();
        this.cms = cms;
        this.translation = translation;
        this.cms$ = this.cms
            .getCurrentPage()
            .pipe(filter((/**
         * @param {?} p
         * @return {?}
         */
        p => !!p)));
        this.pageType = PageType.CONTENT_PAGE;
    }
    /**
     * @deprecated since version 1.3
     *
     * The resolve method is no longer preferred and will be removed with release 2.0.
     * The caller `PageMetaService` service is improved to expect all individual resolvers
     * instead, so that the code is easier extensible.
     * @return {?}
     */
    resolve() {
        return this.cms$.pipe(switchMap((/**
         * @param {?} page
         * @return {?}
         */
        (page) => combineLatest([
            this.resolveTitle(page),
            this.resolveBreadcrumbLabel().pipe(switchMap((/**
             * @param {?} label
             * @return {?}
             */
            label => this.resolveBreadcrumbs(page, label)))),
        ]))), map((/**
         * @param {?} __0
         * @return {?}
         */
        ([title, breadcrumbs]) => ({ title, breadcrumbs }))));
    }
    /**
     * @param {?=} page
     * @return {?}
     */
    resolveTitle(page) {
        return page ? of(page.title) : this.cms$.pipe(map((/**
         * @param {?} p
         * @return {?}
         */
        p => p.title)));
    }
    /**
     * @deprecated since version 1.3
     * This method will removed with with 2.0
     * @return {?}
     */
    resolveBreadcrumbLabel() {
        return this.translation.translate('common.home');
    }
    /**
     * @param {?=} _page
     * @param {?=} breadcrumbLabel
     * @return {?}
     */
    resolveBreadcrumbs(_page, breadcrumbLabel) {
        if (breadcrumbLabel) {
            return of([{ label: breadcrumbLabel, link: '/' }]);
        }
        else {
            return this.translation
                .translate('common.home')
                .pipe(map((/**
             * @param {?} label
             * @return {?}
             */
            label => [{ label: label, link: '/' }])));
        }
    }
}
ContentPageMetaResolver.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root',
            },] }
];
/** @nocollapse */
ContentPageMetaResolver.ctorParameters = () => [
    { type: CmsService },
    { type: TranslationService }
];
/** @nocollapse */ ContentPageMetaResolver.ngInjectableDef = ɵɵdefineInjectable({ factory: function ContentPageMetaResolver_Factory() { return new ContentPageMetaResolver(ɵɵinject(CmsService), ɵɵinject(TranslationService)); }, token: ContentPageMetaResolver, providedIn: "root" });
if (false) {
    /**
     * @type {?}
     * @private
     */
    ContentPageMetaResolver.prototype.cms$;
    /**
     * @type {?}
     * @protected
     */
    ContentPageMetaResolver.prototype.cms;
    /**
     * @type {?}
     * @protected
     */
    ContentPageMetaResolver.prototype.translation;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class CmsPageTitleModule {
}
CmsPageTitleModule.decorators = [
    { type: NgModule, args: [{
                providers: [
                    {
                        provide: PageMetaResolver,
                        useExisting: ContentPageMetaResolver,
                        multi: true,
                    },
                ],
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class UrlMatcherFactoryService {
    /**
     * @param {?} globService
     */
    constructor(globService) {
        this.globService = globService;
    }
    /**
     * Returns a matcher that is always fails
     * @return {?}
     */
    getFalsyUrlMatcher() {
        return (/**
         * @return {?}
         */
        function falsyUrlMatcher() {
            return null;
        });
    }
    /**
     * Returns a matcher for given list of paths
     * @param {?} paths
     * @return {?}
     */
    getMultiplePathsUrlMatcher(paths) {
        /** @type {?} */
        const self = this;
        /** @type {?} */
        const matcher = (/**
         * @param {?} segments
         * @param {?} segmentGroup
         * @param {?} route
         * @return {?}
         */
        function multiplePathsUrlMatcher(segments, segmentGroup, route) {
            for (let i = 0; i < paths.length; i++) {
                /** @type {?} */
                const result = self.getPathUrlMatcher(paths[i])(segments, segmentGroup, route);
                if (result) {
                    return result;
                }
            }
            return null;
        });
        matcher.paths = paths; // property added for easier debugging of routes
        return matcher;
    }
    /**
     * Similar to Angular's defaultUrlMatcher. Differences:
     * - the `path` comes from function's argument, not from `route.path`
     * - the empty path `''` is handled here, but in Angular is handled one level higher in the match() function
     * @protected
     * @param {?=} path
     * @return {?}
     */
    getPathUrlMatcher(path = '') {
        return (/**
         * @param {?} segments
         * @param {?} segmentGroup
         * @param {?} route
         * @return {?}
         */
        (segments, segmentGroup, route) => {
            /**
             * @license
             * The MIT License
             * Copyright (c) 2010-2019 Google LLC. http://angular.io/license
             *
             * See:
             * - https://github.com/angular/angular/blob/6f5f481fdae03f1d8db36284b64c7b82d9519d85/packages/router/src/shared.ts#L121
             */
            // use function's argument, not the `route.path`
            if (path === '') {
                if (route.pathMatch === 'full' &&
                    (segmentGroup.hasChildren() || segments.length > 0)) {
                    return null;
                }
                return { consumed: [], posParams: {} };
            }
            /** @type {?} */
            const parts = path.split('/');
            if (parts.length > segments.length) {
                // The actual URL is shorter than the config, no match
                return null;
            }
            if (route.pathMatch === 'full' &&
                (segmentGroup.hasChildren() || parts.length < segments.length)) {
                // The config is longer than the actual URL but we are looking for a full match, return null
                return null;
            }
            /** @type {?} */
            const posParams = {};
            // Check each config part against the actual URL
            for (let index = 0; index < parts.length; index++) {
                /** @type {?} */
                const part = parts[index];
                /** @type {?} */
                const segment = segments[index];
                /** @type {?} */
                const isParameter = part.startsWith(':');
                if (isParameter) {
                    posParams[part.substring(1)] = segment;
                }
                else if (part !== segment.path) {
                    // The actual URL part does not match the config, no match
                    return null;
                }
            }
            return { consumed: segments.slice(0, parts.length), posParams };
        });
    }
    /**
     * Returns URL matcher that accepts almost everything (like `**` route), but not paths accepted by the given matcher
     * @param {?} originalMatcher
     * @return {?}
     */
    getOppositeUrlMatcher(originalMatcher) {
        /** @type {?} */
        const matcher = (/**
         * @param {?} segments
         * @param {?} group
         * @param {?} route
         * @return {?}
         */
        function oppositeUrlMatcher(segments, group, route) {
            return originalMatcher(segments, group, route)
                ? null
                : { consumed: segments, posParams: {} };
        });
        matcher.originalMatcher = originalMatcher; // property added for easier debugging of routes
        return matcher;
    }
    /**
     * Returns URL matcher for the given list of glob-like patterns. Each pattern must start with `/` or `!/`.
     * @param {?} globPatterns
     * @return {?}
     */
    getGlobUrlMatcher(globPatterns) {
        /** @type {?} */
        const globValidator = this.globService.getValidator(globPatterns);
        /** @type {?} */
        const matcher = (/**
         * @param {?} segments
         * @return {?}
         */
        function globUrlMatcher(segments) {
            /** @type {?} */
            const fullPath = `/${segments.map((/**
             * @param {?} s
             * @return {?}
             */
            s => s.path)).join('/')}`;
            return globValidator(fullPath)
                ? { consumed: segments, posParams: {} }
                : null;
        });
        matcher.globPatterns = globPatterns; // property added for easier debugging of routes
        return matcher;
    }
}
UrlMatcherFactoryService.decorators = [
    { type: Injectable, args: [{ providedIn: 'root' },] }
];
/** @nocollapse */
UrlMatcherFactoryService.ctorParameters = () => [
    { type: GlobService }
];
/** @nocollapse */ UrlMatcherFactoryService.ngInjectableDef = ɵɵdefineInjectable({ factory: function UrlMatcherFactoryService_Factory() { return new UrlMatcherFactoryService(ɵɵinject(GlobService)); }, token: UrlMatcherFactoryService, providedIn: "root" });
if (false) {
    /**
     * @type {?}
     * @protected
     */
    UrlMatcherFactoryService.prototype.globService;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ConfigurableRoutesService {
    /**
     * @param {?} injector
     * @param {?} routingConfigService
     * @param {?} urlMatcherFactory
     */
    constructor(injector, routingConfigService, urlMatcherFactory) {
        this.injector = injector;
        this.routingConfigService = routingConfigService;
        this.urlMatcherFactory = urlMatcherFactory;
        this.initCalled = false; // guard not to call init() more than once
    }
    // guard not to call init() more than once
    /**
     * Configures all existing Routes in the Router
     * @return {?}
     */
    init() {
        if (!this.initCalled) {
            this.initCalled = true;
            this.configureRouter();
        }
    }
    /**
     * @private
     * @return {?}
     */
    configureRouter() {
        // Router could not be injected in constructor due to cyclic dependency with APP_INITIALIZER:
        /** @type {?} */
        const router = this.injector.get(Router);
        /** @type {?} */
        const configuredRoutes = this.configureRoutes(router.config);
        router.resetConfig(configuredRoutes);
    }
    /**
     * @private
     * @param {?} routes
     * @return {?}
     */
    configureRoutes(routes) {
        /** @type {?} */
        const result = [];
        routes.forEach((/**
         * @param {?} route
         * @return {?}
         */
        route => {
            /** @type {?} */
            const configuredRoute = this.configureRoute(route);
            if (route.children && route.children.length) {
                configuredRoute.children = this.configureRoutes(route.children);
            }
            result.push(configuredRoute);
        }));
        return result;
    }
    /**
     * @private
     * @param {?} route
     * @return {?}
     */
    configureRoute(route) {
        /** @type {?} */
        const routeName = this.getRouteName(route);
        if (routeName) {
            /** @type {?} */
            const routeConfig = this.routingConfigService.getRouteConfig(routeName);
            /** @type {?} */
            const paths = this.getConfiguredPaths(routeConfig, routeName, route);
            /** @type {?} */
            const isDisabled = routeConfig && routeConfig.disabled;
            if (isDisabled || !paths.length) {
                delete route.path;
                return Object.assign({}, route, { matcher: this.urlMatcherFactory.getFalsyUrlMatcher() });
            }
            else if (paths.length === 1) {
                delete route.matcher;
                return Object.assign({}, route, { path: paths[0] });
            }
            else {
                delete route.path;
                return Object.assign({}, route, { matcher: this.urlMatcherFactory.getMultiplePathsUrlMatcher(paths) });
            }
        }
        return route; // if route doesn't have a name, just pass the original route
    }
    /**
     * @private
     * @param {?} route
     * @return {?}
     */
    getRouteName(route) {
        return route.data && route.data.cxRoute;
    }
    /**
     * @private
     * @param {?} routeConfig
     * @param {?} routeName
     * @param {?} route
     * @return {?}
     */
    getConfiguredPaths(routeConfig, routeName, route) {
        if (routeConfig === undefined) {
            this.warn(`Could not configure the named route '${routeName}'`, route, `due to undefined key '${routeName}' in the routes config`);
            return [];
        }
        if (routeConfig && routeConfig.paths === undefined) {
            this.warn(`Could not configure the named route '${routeName}'`, route, `due to undefined 'paths' for the named route '${routeName}' in the routes config`);
            return [];
        }
        // routeConfig or routeConfig.paths can be null - which means switching off the route
        return (routeConfig && routeConfig.paths) || [];
    }
    /**
     * @private
     * @param {...?} args
     * @return {?}
     */
    warn(...args) {
        if (isDevMode()) {
            console.warn(...args);
        }
    }
}
ConfigurableRoutesService.decorators = [
    { type: Injectable, args: [{ providedIn: 'root' },] }
];
/** @nocollapse */
ConfigurableRoutesService.ctorParameters = () => [
    { type: Injector },
    { type: RoutingConfigService },
    { type: UrlMatcherFactoryService }
];
/** @nocollapse */ ConfigurableRoutesService.ngInjectableDef = ɵɵdefineInjectable({ factory: function ConfigurableRoutesService_Factory() { return new ConfigurableRoutesService(ɵɵinject(INJECTOR), ɵɵinject(RoutingConfigService), ɵɵinject(UrlMatcherFactoryService)); }, token: ConfigurableRoutesService, providedIn: "root" });
if (false) {
    /**
     * @type {?}
     * @private
     */
    ConfigurableRoutesService.prototype.initCalled;
    /**
     * @type {?}
     * @private
     */
    ConfigurableRoutesService.prototype.injector;
    /**
     * @type {?}
     * @private
     */
    ConfigurableRoutesService.prototype.routingConfigService;
    /**
     * @type {?}
     * @private
     */
    ConfigurableRoutesService.prototype.urlMatcherFactory;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @record
 */
function RoutesConfig() { }
/**
 * @record
 */
function RouteConfig() { }
if (false) {
    /**
     * List of path aliases to match with URL. Also used to build the semantic links.
     * @type {?|undefined}
     */
    RouteConfig.prototype.paths;
    /**
     * Maps names of route params with params used to build the semantic link.
     * @type {?|undefined}
     */
    RouteConfig.prototype.paramsMapping;
    /**
     * Disables the url matcher for the route. But still allows for generation of semantic links.
     * @type {?|undefined}
     */
    RouteConfig.prototype.disabled;
    /**
     * When false, the route is public for unauthorized users even when the global flag `routing.protected` is true.
     * Other values (true, undefined) are ignored.
     * @type {?|undefined}
     */
    RouteConfig.prototype.protected;
}
/**
 * @record
 */
function ParamsMapping() { }

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class UrlPipe {
    /**
     * @param {?} urlService
     */
    constructor(urlService) {
        this.urlService = urlService;
    }
    /**
     * @param {?} commands
     * @return {?}
     */
    transform(commands) {
        return this.urlService.transform(commands);
    }
}
UrlPipe.decorators = [
    { type: Pipe, args: [{
                name: 'cxUrl',
            },] }
];
/** @nocollapse */
UrlPipe.ctorParameters = () => [
    { type: SemanticPathService }
];
if (false) {
    /**
     * @type {?}
     * @private
     */
    UrlPipe.prototype.urlService;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ProductURLPipe {
    /**
     * @param {?} semanticPath
     */
    constructor(semanticPath) {
        this.semanticPath = semanticPath;
    }
    /**
     * @param {?} product
     * @return {?}
     */
    transform(product) {
        return this.semanticPath.transform({ cxRoute: 'product', params: product });
    }
}
ProductURLPipe.decorators = [
    { type: Pipe, args: [{
                name: 'cxProductUrl',
            },] }
];
/** @nocollapse */
ProductURLPipe.ctorParameters = () => [
    { type: SemanticPathService }
];
if (false) {
    /**
     * @type {?}
     * @private
     */
    ProductURLPipe.prototype.semanticPath;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class UrlModule {
}
UrlModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule],
                declarations: [UrlPipe, ProductURLPipe],
                exports: [UrlPipe, ProductURLPipe],
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @record
 */
function UrlCommandRoute() { }
if (false) {
    /** @type {?|undefined} */
    UrlCommandRoute.prototype.cxRoute;
    /** @type {?|undefined} */
    UrlCommandRoute.prototype.params;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @abstract
 */
class ExternalRoutesConfig {
}
if (false) {
    /** @type {?} */
    ExternalRoutesConfig.prototype.routing;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ExternalRoutesGuard {
    /**
     * @param {?} winRef
     * @param {?} platformId
     */
    constructor(winRef, platformId) {
        this.winRef = winRef;
        this.platformId = platformId;
    }
    /**
     * Redirects to different storefront system for anticipated URL
     * @param {?} route
     * @param {?} state
     * @return {?}
     */
    canActivate(route, state) {
        if (isPlatformBrowser(this.platformId)) {
            this.redirect(route, state);
        }
        return false;
    }
    /**
     * Redirects to anticipated URL using full page reload, not Angular routing
     * @protected
     * @param {?} _
     * @param {?} state
     * @return {?}
     */
    redirect(_, state) {
        /** @type {?} */
        const window = this.winRef.nativeWindow;
        if (window && window.location) {
            window.location.href = state.url;
        }
    }
}
ExternalRoutesGuard.decorators = [
    { type: Injectable, args: [{ providedIn: 'root' },] }
];
/** @nocollapse */
ExternalRoutesGuard.ctorParameters = () => [
    { type: WindowRef },
    { type: Object, decorators: [{ type: Inject, args: [PLATFORM_ID,] }] }
];
/** @nocollapse */ ExternalRoutesGuard.ngInjectableDef = ɵɵdefineInjectable({ factory: function ExternalRoutesGuard_Factory() { return new ExternalRoutesGuard(ɵɵinject(WindowRef), ɵɵinject(PLATFORM_ID)); }, token: ExternalRoutesGuard, providedIn: "root" });
if (false) {
    /**
     * @type {?}
     * @protected
     */
    ExternalRoutesGuard.prototype.winRef;
    /**
     * @type {?}
     * @protected
     */
    ExternalRoutesGuard.prototype.platformId;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} service
 * @return {?}
 */
function addExternalRoutesFactory(service) {
    /** @type {?} */
    const result = (/**
     * @return {?}
     */
    () => {
        service.addRoutes();
    });
    return result;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Service that helps redirecting to different storefront systems for configured URLs
 */
class ExternalRoutesService {
    /**
     * @param {?} config
     * @param {?} matcherFactory
     * @param {?} injector
     */
    constructor(config, matcherFactory, injector) {
        this.config = config;
        this.matcherFactory = matcherFactory;
        this.injector = injector;
    }
    /**
     * @protected
     * @return {?}
     */
    get internalUrlPatterns() {
        return ((this.config && this.config.routing && this.config.routing.internal) || []);
    }
    /**
     * Prepends routes (to the Router.config) that are responsible for redirecting to a different storefront system
     * @return {?}
     */
    addRoutes() {
        /** @type {?} */
        const router = this.injector.get(Router);
        /** @type {?} */
        const newRoutes = this.getRoutes();
        if (newRoutes.length) {
            router.resetConfig([...newRoutes, ...router.config]);
        }
    }
    /**
     * Returns routes that are responsible for redirection to different storefront systems
     * @protected
     * @return {?}
     */
    getRoutes() {
        if (!this.internalUrlPatterns.length) {
            return [];
        }
        /** @type {?} */
        const routes = [];
        routes.push({
            pathMatch: 'full',
            matcher: this.getUrlMatcher(),
            canActivate: [ExternalRoutesGuard],
            component: (/** @type {?} */ ({})),
        });
        return routes;
    }
    /**
     * Returns the URL matcher for the external route
     * @protected
     * @return {?}
     */
    getUrlMatcher() {
        /** @type {?} */
        const matcher = this.matcherFactory.getGlobUrlMatcher(this.internalUrlPatterns);
        return this.matcherFactory.getOppositeUrlMatcher(matcher); // the external route should be activated only when it's NOT an internal route
    }
}
ExternalRoutesService.decorators = [
    { type: Injectable }
];
/** @nocollapse */
ExternalRoutesService.ctorParameters = () => [
    { type: ExternalRoutesConfig },
    { type: UrlMatcherFactoryService },
    { type: Injector }
];
if (false) {
    /**
     * @type {?}
     * @protected
     */
    ExternalRoutesService.prototype.config;
    /**
     * @type {?}
     * @protected
     */
    ExternalRoutesService.prototype.matcherFactory;
    /**
     * @type {?}
     * @protected
     */
    ExternalRoutesService.prototype.injector;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Prepends the external route that redirects to a different storefront system for configured URLs
 */
class ExternalRoutesModule {
    /**
     * @return {?}
     */
    static forRoot() {
        return {
            ngModule: ExternalRoutesModule,
            providers: [
                ExternalRoutesService,
                { provide: ExternalRoutesConfig, useExisting: Config },
                {
                    provide: APP_INITIALIZER,
                    multi: true,
                    useFactory: addExternalRoutesFactory,
                    deps: [ExternalRoutesService],
                },
            ],
        };
    }
}
ExternalRoutesModule.decorators = [
    { type: NgModule }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @record
 */
function CmsRouteData() { }
if (false) {
    /** @type {?|undefined} */
    CmsRouteData.prototype.cxCmsRouteContext;
    /** @type {?|undefined} */
    CmsRouteData.prototype.pageLabel;
}
/**
 * @record
 */
function CmsRoute() { }
if (false) {
    /** @type {?|undefined} */
    CmsRoute.prototype.data;
}
/**
 * @record
 */
function CmsActivatedRouteSnapshot() { }
if (false) {
    /** @type {?} */
    CmsActivatedRouteSnapshot.prototype.data;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class PageContext {
    /**
     * @param {?} id
     * @param {?=} type
     */
    constructor(id, type) {
        this.id = id;
        this.type = type;
    }
}
if (false) {
    /** @type {?} */
    PageContext.prototype.id;
    /** @type {?} */
    PageContext.prototype.type;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ProtectedRoutesService {
    /**
     * @param {?} config
     */
    constructor(config) {
        this.config = config;
        this.nonProtectedPaths = []; // arrays of paths' segments list
        if (this.shouldProtect) {
            // pre-process config for performance:
            this.nonProtectedPaths = this.getNonProtectedPaths().map((/**
             * @param {?} path
             * @return {?}
             */
            path => this.getSegments(path)));
        }
    }
    // arrays of paths' segments list
    /**
     * @protected
     * @return {?}
     */
    get routingConfig() {
        return this.config && this.config.routing;
    }
    /**
     * Returns 'protected' property (boolean) from routing config
     *
     * @return {?} boolean
     */
    get shouldProtect() {
        return this.routingConfig.protected;
    }
    /**
     * Tells if the url is protected
     * @param {?} urlSegments
     * @return {?}
     */
    isUrlProtected(urlSegments) {
        return (this.shouldProtect &&
            !this.matchAnyPath(urlSegments, this.nonProtectedPaths));
    }
    /**
     * Tells whether the url matches at least one of the paths
     * @protected
     * @param {?} urlSegments
     * @param {?} pathsSegments
     * @return {?}
     */
    matchAnyPath(urlSegments, pathsSegments) {
        return pathsSegments.some((/**
         * @param {?} pathSegments
         * @return {?}
         */
        pathSegments => this.matchPath(urlSegments, pathSegments)));
    }
    /**
     * Tells whether the url matches the path
     * @protected
     * @param {?} urlSegments
     * @param {?} pathSegments
     * @return {?}
     */
    matchPath(urlSegments, pathSegments) {
        if (urlSegments.length !== pathSegments.length) {
            return false;
        }
        for (let i = 0; i < pathSegments.length; i++) {
            /** @type {?} */
            const pathSeg = pathSegments[i];
            /** @type {?} */
            const urlSeg = urlSegments[i];
            // compare only static segments:
            if (!pathSeg.startsWith(':') && pathSeg !== urlSeg) {
                return false;
            }
        }
        return true;
    }
    /**
     * Returns a list of paths that are not protected
     * @protected
     * @return {?}
     */
    getNonProtectedPaths() {
        return Object.values(this.routingConfig.routes).reduce((/**
         * @param {?} acc
         * @param {?} routeConfig
         * @return {?}
         */
        (acc, routeConfig) => routeConfig.protected === false && // must be explicitly false, ignore undefined
            routeConfig.paths &&
            routeConfig.paths.length
            ? acc.concat(routeConfig.paths)
            : acc), []);
    }
    /**
     * Splits the url by slashes
     * @protected
     * @param {?} url
     * @return {?}
     */
    getSegments(url) {
        return (url || '').split('/');
    }
}
ProtectedRoutesService.decorators = [
    { type: Injectable, args: [{ providedIn: 'root' },] }
];
/** @nocollapse */
ProtectedRoutesService.ctorParameters = () => [
    { type: RoutingConfig }
];
/** @nocollapse */ ProtectedRoutesService.ngInjectableDef = ɵɵdefineInjectable({ factory: function ProtectedRoutesService_Factory() { return new ProtectedRoutesService(ɵɵinject(RoutingConfig)); }, token: ProtectedRoutesService, providedIn: "root" });
if (false) {
    /**
     * @type {?}
     * @private
     */
    ProtectedRoutesService.prototype.nonProtectedPaths;
    /**
     * @type {?}
     * @protected
     */
    ProtectedRoutesService.prototype.config;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ProtectedRoutesGuard {
    /**
     * @param {?} service
     * @param {?} authGuard
     */
    constructor(service, authGuard) {
        this.service = service;
        this.authGuard = authGuard;
    }
    /**
     * When the anticipated url is protected, it switches to the AuthGuard. Otherwise emits true.
     * @param {?} route
     * @return {?}
     */
    canActivate(route) {
        /** @type {?} */
        let urlSegments = route.url.map((/**
         * @param {?} seg
         * @return {?}
         */
        seg => seg.path));
        // For the root path `/` ActivatedRoute contains an empty array of segments:
        urlSegments = urlSegments.length ? urlSegments : [''];
        if (this.service.isUrlProtected(urlSegments)) {
            return this.authGuard.canActivate();
        }
        return of(true);
    }
}
ProtectedRoutesGuard.decorators = [
    { type: Injectable, args: [{ providedIn: 'root' },] }
];
/** @nocollapse */
ProtectedRoutesGuard.ctorParameters = () => [
    { type: ProtectedRoutesService },
    { type: AuthGuard }
];
/** @nocollapse */ ProtectedRoutesGuard.ngInjectableDef = ɵɵdefineInjectable({ factory: function ProtectedRoutesGuard_Factory() { return new ProtectedRoutesGuard(ɵɵinject(ProtectedRoutesService), ɵɵinject(AuthGuard)); }, token: ProtectedRoutesGuard, providedIn: "root" });
if (false) {
    /**
     * @type {?}
     * @protected
     */
    ProtectedRoutesGuard.prototype.service;
    /**
     * @type {?}
     * @protected
     */
    ProtectedRoutesGuard.prototype.authGuard;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class RouterEffects {
    /**
     * @param {?} actions$
     * @param {?} router
     * @param {?} location
     */
    constructor(actions$, router, location) {
        this.actions$ = actions$;
        this.router = router;
        this.location = location;
        this.navigate$ = this.actions$.pipe(ofType(ROUTER_GO), map((/**
         * @param {?} action
         * @return {?}
         */
        (action) => action.payload)), tap((/**
         * @param {?} __0
         * @return {?}
         */
        ({ path, query: queryParams, extras }) => {
            this.router.navigate(path, Object.assign({ queryParams }, extras));
        })));
        this.navigateBuUrl$ = this.actions$.pipe(ofType(ROUTER_GO_BY_URL), map((/**
         * @param {?} action
         * @return {?}
         */
        (action) => action.payload)), tap((/**
         * @param {?} url
         * @return {?}
         */
        url => {
            this.router.navigateByUrl(url);
        })));
        this.clearCmsRoutes$ = this.actions$.pipe(ofType(LANGUAGE_CHANGE, LOGOUT, LOGIN), tap((/**
         * @param {?} _
         * @return {?}
         */
        _ => {
            /** @type {?} */
            const filteredConfig = this.router.config.filter((/**
             * @param {?} route
             * @return {?}
             */
            (route) => !(route.data && route.data.cxCmsRouteContext)));
            if (filteredConfig.length !== this.router.config.length) {
                this.router.resetConfig(filteredConfig);
            }
        })));
        this.navigateBack$ = this.actions$.pipe(ofType(ROUTER_BACK), tap((/**
         * @return {?}
         */
        () => this.location.back())));
        this.navigateForward$ = this.actions$.pipe(ofType(ROUTER_FORWARD), tap((/**
         * @return {?}
         */
        () => this.location.forward())));
    }
}
RouterEffects.decorators = [
    { type: Injectable }
];
/** @nocollapse */
RouterEffects.ctorParameters = () => [
    { type: Actions },
    { type: Router },
    { type: Location }
];
__decorate([
    Effect({ dispatch: false }),
    __metadata("design:type", Observable)
], RouterEffects.prototype, "navigate$", void 0);
__decorate([
    Effect({ dispatch: false }),
    __metadata("design:type", Observable)
], RouterEffects.prototype, "navigateBuUrl$", void 0);
__decorate([
    Effect({ dispatch: false }),
    __metadata("design:type", Observable)
], RouterEffects.prototype, "clearCmsRoutes$", void 0);
__decorate([
    Effect({ dispatch: false }),
    __metadata("design:type", Observable)
], RouterEffects.prototype, "navigateBack$", void 0);
__decorate([
    Effect({ dispatch: false }),
    __metadata("design:type", Observable)
], RouterEffects.prototype, "navigateForward$", void 0);
if (false) {
    /** @type {?} */
    RouterEffects.prototype.navigate$;
    /** @type {?} */
    RouterEffects.prototype.navigateBuUrl$;
    /** @type {?} */
    RouterEffects.prototype.clearCmsRoutes$;
    /** @type {?} */
    RouterEffects.prototype.navigateBack$;
    /** @type {?} */
    RouterEffects.prototype.navigateForward$;
    /**
     * @type {?}
     * @private
     */
    RouterEffects.prototype.actions$;
    /**
     * @type {?}
     * @private
     */
    RouterEffects.prototype.router;
    /**
     * @type {?}
     * @private
     */
    RouterEffects.prototype.location;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const effects$7 = [RouterEffects];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const initialState$d = {
    navigationId: 0,
    state: {
        url: '',
        queryParams: {},
        params: {},
        context: {
            id: '',
        },
        cmsRequired: false,
    },
    nextState: undefined,
};
/**
 * @return {?}
 */
function getReducers$7() {
    return {
        router: reducer$d,
    };
}
/**
 * @param {?=} state
 * @param {?=} action
 * @return {?}
 */
function reducer$d(state = initialState$d, action) {
    switch (action.type) {
        case ROUTER_NAVIGATION: {
            return Object.assign({}, state, { nextState: action.payload.routerState, navigationId: action.payload.event.id });
        }
        case ROUTER_ERROR:
        case ROUTER_CANCEL: {
            return Object.assign({}, state, { nextState: undefined });
        }
        case ROUTER_NAVIGATED: {
            return {
                state: action.payload.routerState,
                navigationId: action.payload.event.id,
                nextState: undefined,
            };
        }
        default: {
            return state;
        }
    }
}
/** @type {?} */
const reducerToken$7 = new InjectionToken('RouterReducers');
/** @type {?} */
const reducerProvider$7 = {
    provide: reducerToken$7,
    useFactory: getReducers$7,
};
/* The serializer is there to parse the RouterStateSnapshot,
and to reduce the amount of properties to be passed to the reducer.
 */
class CustomSerializer {
    /**
     * @param {?} routerState
     * @return {?}
     */
    serialize(routerState) {
        const { url } = routerState;
        const { queryParams } = routerState.root;
        /** @type {?} */
        let state = (/** @type {?} */ (routerState.root));
        /** @type {?} */
        let cmsRequired = false;
        /** @type {?} */
        let context;
        while (state.firstChild) {
            state = (/** @type {?} */ (state.firstChild));
            // we use context information embedded in Cms driven routes from any parent route
            if (state.data && state.data.cxCmsRouteContext) {
                context = state.data.cxCmsRouteContext;
            }
            // we assume, that any route that has CmsPageGuard or it's child
            // is cmsRequired
            if (!cmsRequired &&
                (context ||
                    (state.routeConfig &&
                        state.routeConfig.canActivate &&
                        state.routeConfig.canActivate.find((/**
                         * @param {?} x
                         * @return {?}
                         */
                        x => x && x.guardName === 'CmsPageGuard'))))) {
                cmsRequired = true;
            }
        }
        const { params } = state;
        // we give smartedit preview page a PageContext
        if (state.url.length > 0 && state.url[0].path === 'cx-preview') {
            context = {
                id: 'smartedit-preview',
                type: PageType.CONTENT_PAGE,
            };
        }
        else {
            if (params['productCode']) {
                context = { id: params['productCode'], type: PageType.PRODUCT_PAGE };
            }
            else if (params['categoryCode']) {
                context = { id: params['categoryCode'], type: PageType.CATEGORY_PAGE };
            }
            else if (params['brandCode']) {
                context = { id: params['brandCode'], type: PageType.CATEGORY_PAGE };
            }
            else if (state.data.pageLabel !== undefined) {
                context = { id: state.data.pageLabel, type: PageType.CONTENT_PAGE };
            }
            else if (!context) {
                if (state.url.length > 0) {
                    /** @type {?} */
                    const pageLabel = '/' + state.url.map((/**
                     * @param {?} urlSegment
                     * @return {?}
                     */
                    urlSegment => urlSegment.path)).join('/');
                    context = {
                        id: pageLabel,
                        type: PageType.CONTENT_PAGE,
                    };
                }
                else {
                    context = {
                        id: 'homepage',
                        type: PageType.CONTENT_PAGE,
                    };
                }
            }
        }
        return { url, queryParams, params, context, cmsRequired };
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} service
 * @return {?}
 */
function initConfigurableRoutes(service) {
    /** @type {?} */
    const result = (/**
     * @return {?}
     */
    () => service.init());
    return result;
}
class RoutingModule {
    /**
     * @return {?}
     */
    static forRoot() {
        return {
            ngModule: RoutingModule,
            providers: [
                reducerProvider$7,
                {
                    provide: RouterStateSerializer,
                    useClass: CustomSerializer,
                },
                {
                    provide: APP_INITIALIZER,
                    useFactory: initConfigurableRoutes,
                    deps: [ConfigurableRoutesService],
                    multi: true,
                },
                { provide: RoutingConfig, useExisting: Config },
            ],
        };
    }
}
RoutingModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    StoreModule.forFeature(ROUTING_FEATURE, reducerToken$7),
                    EffectsModule.forFeature(effects$7),
                    StoreRouterConnectingModule.forRoot({
                        routerState: 1 /* Minimal */,
                        stateKey: ROUTING_FEATURE,
                    }),
                ],
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Service that provides access to CMS structure from a static
 * configuration or configuration file. This class uses static
 * configuration is designed in async fashion so that configurations
 * can be loaded from a file or stream.
 *
 * The intent of the `CmsStructureConfigService` however is to provide
 * fast loading pages and default cms structure for commodity commerce.
 * @abstract
 */
class CmsStructureConfigService {
    /**
     * @param {?} cmsDataConfig
     */
    constructor(cmsDataConfig) {
        this.cmsDataConfig = cmsDataConfig;
    }
    /**
     * Merge the cms structure to the pageStructure. The page structure
     * can either hold complete page structures or global structures that
     * might apply to all pages (such has header coponents).
     * @param {?} pageId
     * @param {?} pageStructure
     * @return {?}
     */
    mergePageStructure(pageId, pageStructure) {
        return this.mergePage(pageId, pageStructure).pipe(switchMap((/**
         * @param {?} page
         * @return {?}
         */
        page => this.mergeSlots(page))));
    }
    /**
     *
     * Returns boolean observable to indicate whether the page should not be
     * loaded from the backend. This is useful for pages which are comoditized
     * and follow best practice.
     *
     * By default, configurable pages are driven by static configuration,
     * in order to allow for fast loading pages (preventing network delays).
     * @param {?} pageId
     * @return {?}
     */
    shouldIgnoreBackend(pageId) {
        return this.getPageFromConfig(pageId).pipe(map((/**
         * @param {?} page
         * @return {?}
         */
        page => !!page && !!page.ignoreBackend)));
    }
    /**
     * returns an Observable component data from the static configuration.
     * @param {?} componentId
     * @return {?}
     */
    getComponentFromConfig(componentId) {
        return of(this.getComponentById(componentId));
    }
    /**
     * returns an Observable components data from the static configuration.
     * @param {?} ids
     * @return {?}
     */
    getComponentsFromConfig(ids) {
        return of(ids.map((/**
         * @param {?} id
         * @return {?}
         */
        id => this.getComponentById(id))));
    }
    /**
     * returns an observable with the `PageConfig`.
     * @protected
     * @param {?} pageId
     * @return {?}
     */
    getPageFromConfig(pageId) {
        return of(this.cmsDataConfig.cmsStructure && this.cmsDataConfig.cmsStructure.pages
            ? this.cmsDataConfig.cmsStructure.pages.find((/**
             * @param {?} p
             * @return {?}
             */
            p => p.pageId === pageId))
            : null);
    }
    /**
     * Merge page data from the configuration into the given structure, if any.
     * If the given page structure is empty, a page is created and the page slots are
     * are merged into the page.
     * @protected
     * @param {?} pageId
     * @param {?} pageStructure
     * @return {?}
     */
    mergePage(pageId, pageStructure) {
        return this.getPageFromConfig(pageId).pipe(switchMap((/**
         * @param {?} page
         * @return {?}
         */
        page => {
            if (page) {
                // serialize page data
                if (!pageStructure.page) {
                    pageStructure.page = Object.assign({}, page);
                    pageStructure.page.slots = {};
                }
                if (!pageStructure.page.slots) {
                    pageStructure.page.slots = {};
                }
                return this.mergeSlots(pageStructure, page.slots);
            }
            else {
                return of(pageStructure);
            }
        })));
    }
    /**
     * Adds any pre-configured slots for pages that do not use them.
     * If pages have a slot for the given position, the configiuration
     * is ingored. Even if the slot does not have inner structure (such as
     * components), so that the cms structure is able to override the (static)
     * configuration.
     * @protected
     * @param {?} pageStructure
     * @param {?=} slots
     * @return {?}
     */
    mergeSlots(pageStructure, slots) {
        // if no slots have been given, we use the global configured slots
        if (!slots &&
            this.cmsDataConfig.cmsStructure &&
            this.cmsDataConfig.cmsStructure.slots) {
            slots = this.cmsDataConfig.cmsStructure.slots;
        }
        if (!slots) {
            return of(pageStructure);
        }
        for (const position of Object.keys(slots)) {
            if (!Object.keys(pageStructure.page.slots).includes(position)) {
                // the global slot isn't yet part of the page structure
                pageStructure.page.slots[position] = {};
                for (const component of this.getComponentsByPosition(slots, position)) {
                    if (!pageStructure.page.slots[position].components) {
                        pageStructure.page.slots[position].components = [];
                    }
                    pageStructure.page.slots[position].components.push({
                        uid: component.uid,
                        flexType: component.flexType,
                        typeCode: component.typeCode,
                    });
                    if (!pageStructure.components) {
                        pageStructure.components = [];
                    }
                    pageStructure.components.push(component);
                }
            }
        }
        return of(pageStructure);
    }
    /**
     * @protected
     * @param {?} slots
     * @param {?} position
     * @return {?}
     */
    getComponentsByPosition(slots, position) {
        /** @type {?} */
        const components = [];
        if (slots[position] && slots[position].componentIds) {
            for (const componentId of slots[position].componentIds) {
                if (this.cmsDataConfig.cmsStructure &&
                    this.cmsDataConfig.cmsStructure.components) {
                    /** @type {?} */
                    const component = this.cmsDataConfig.cmsStructure.components[componentId];
                    if (component) {
                        components.push(Object.assign({ uid: componentId }, component));
                    }
                }
            }
        }
        return components;
    }
    /**
     * @protected
     * @param {?} componentId
     * @return {?}
     */
    getComponentById(componentId) {
        return this.cmsDataConfig.cmsStructure &&
            this.cmsDataConfig.cmsStructure.components
            ? this.cmsDataConfig.cmsStructure.components[componentId]
            : undefined;
    }
}
CmsStructureConfigService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root',
            },] }
];
/** @nocollapse */
CmsStructureConfigService.ctorParameters = () => [
    { type: CmsStructureConfig }
];
/** @nocollapse */ CmsStructureConfigService.ngInjectableDef = ɵɵdefineInjectable({ factory: function CmsStructureConfigService_Factory() { return new CmsStructureConfigService(ɵɵinject(CmsStructureConfig)); }, token: CmsStructureConfigService, providedIn: "root" });
if (false) {
    /**
     * @type {?}
     * @protected
     */
    CmsStructureConfigService.prototype.cmsDataConfig;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class CmsPageConnector {
    /**
     * @param {?} cmsPageAdapter
     * @param {?} cmsStructureConfigService
     */
    constructor(cmsPageAdapter, cmsStructureConfigService) {
        this.cmsPageAdapter = cmsPageAdapter;
        this.cmsStructureConfigService = cmsStructureConfigService;
    }
    /**
     * Returns an observable with the page structure. The page structure is
     * typically loaded from a backend, but can also be returned from static
     * configuration (see `CmsStructureConfigService`).
     * @param {?} pageContext
     * @return {?}
     */
    get(pageContext) {
        return this.cmsStructureConfigService
            .shouldIgnoreBackend(pageContext.id)
            .pipe(switchMap((/**
         * @param {?} loadFromConfig
         * @return {?}
         */
        loadFromConfig => {
            if (!loadFromConfig) {
                return this.cmsPageAdapter.load(pageContext).pipe(catchError((/**
                 * @param {?} error
                 * @return {?}
                 */
                error => {
                    if (error instanceof HttpErrorResponse &&
                        error.status === 400) {
                        return of({});
                    }
                    else {
                        return throwError(error);
                    }
                })));
            }
            else {
                return of({});
            }
        })), switchMap((/**
         * @param {?} page
         * @return {?}
         */
        page => this.mergeDefaultPageStructure(pageContext, page))));
    }
    /**
     *
     * Merge default page structure inot the given `CmsStructureModel`.
     * This is benefitial for a fast setup of the UI without necessary
     * finegrained CMS setup.
     * @private
     * @param {?} pageContext
     * @param {?} pageStructure
     * @return {?}
     */
    mergeDefaultPageStructure(pageContext, pageStructure) {
        return this.cmsStructureConfigService.mergePageStructure(pageContext.id, pageStructure);
    }
}
CmsPageConnector.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root',
            },] }
];
/** @nocollapse */
CmsPageConnector.ctorParameters = () => [
    { type: CmsPageAdapter },
    { type: CmsStructureConfigService }
];
/** @nocollapse */ CmsPageConnector.ngInjectableDef = ɵɵdefineInjectable({ factory: function CmsPageConnector_Factory() { return new CmsPageConnector(ɵɵinject(CmsPageAdapter), ɵɵinject(CmsStructureConfigService)); }, token: CmsPageConnector, providedIn: "root" });
if (false) {
    /**
     * @type {?}
     * @protected
     */
    CmsPageConnector.prototype.cmsPageAdapter;
    /**
     * @type {?}
     * @protected
     */
    CmsPageConnector.prototype.cmsStructureConfigService;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class PageEffects {
    /**
     * @param {?} actions$
     * @param {?} cmsPageConnector
     * @param {?} routingService
     */
    constructor(actions$, cmsPageConnector, routingService) {
        this.actions$ = actions$;
        this.cmsPageConnector = cmsPageConnector;
        this.routingService = routingService;
        this.refreshPage$ = this.actions$.pipe(ofType(LANGUAGE_CHANGE, LOGOUT, LOGIN), switchMap((/**
         * @param {?} _
         * @return {?}
         */
        _ => this.routingService.getRouterState().pipe(filter((/**
         * @param {?} routerState
         * @return {?}
         */
        routerState => routerState &&
            routerState.state &&
            routerState.state.cmsRequired &&
            !routerState.nextState)), take(1), map((/**
         * @param {?} routerState
         * @return {?}
         */
        routerState => routerState.state.context)), mergeMap((/**
         * @param {?} context
         * @return {?}
         */
        context => of(new LoadCmsPageData(context))))))));
        this.loadPageData$ = this.actions$.pipe(ofType(LOAD_CMS_PAGE_DATA), map((/**
         * @param {?} action
         * @return {?}
         */
        (action) => action.payload)), groupBy((/**
         * @param {?} pageContext
         * @return {?}
         */
        pageContext => serializePageContext(pageContext))), mergeMap((/**
         * @param {?} group
         * @return {?}
         */
        group => group.pipe(switchMap((/**
         * @param {?} pageContext
         * @return {?}
         */
        pageContext => this.cmsPageConnector.get(pageContext).pipe(mergeMap((/**
         * @param {?} cmsStructure
         * @return {?}
         */
        (cmsStructure) => {
            /** @type {?} */
            const actions = [
                new CmsGetComponentFromPage(cmsStructure.components, pageContext),
                new LoadCmsPageDataSuccess(pageContext, cmsStructure.page),
            ];
            /** @type {?} */
            const pageLabel = cmsStructure.page.label;
            // For content pages the page label returned from backend can be different than page ID initially assumed from route.
            // In such a case let's save the success response not only for initially assumed page ID, but also for correct page label.
            if (pageLabel && pageLabel !== pageContext.id) {
                actions.unshift(new CmsSetPageSuccessIndex({ id: pageLabel, type: pageContext.type }, cmsStructure.page));
            }
            return actions;
        })), catchError((/**
         * @param {?} error
         * @return {?}
         */
        error => of(new LoadCmsPageDataFail(pageContext, makeErrorSerializable(error))))))))))));
    }
}
PageEffects.decorators = [
    { type: Injectable }
];
/** @nocollapse */
PageEffects.ctorParameters = () => [
    { type: Actions },
    { type: CmsPageConnector },
    { type: RoutingService }
];
__decorate([
    Effect(),
    __metadata("design:type", Observable)
], PageEffects.prototype, "refreshPage$", void 0);
__decorate([
    Effect(),
    __metadata("design:type", Observable)
], PageEffects.prototype, "loadPageData$", void 0);
if (false) {
    /** @type {?} */
    PageEffects.prototype.refreshPage$;
    /** @type {?} */
    PageEffects.prototype.loadPageData$;
    /**
     * @type {?}
     * @private
     */
    PageEffects.prototype.actions$;
    /**
     * @type {?}
     * @private
     */
    PageEffects.prototype.cmsPageConnector;
    /**
     * @type {?}
     * @private
     */
    PageEffects.prototype.routingService;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @template T
 * @param {?=} time
 * @param {?=} scheduler
 * @return {?}
 */
function bufferDebounceTime(time = 0, scheduler) {
    return (/**
     * @param {?} source
     * @return {?}
     */
    (source) => {
        /** @type {?} */
        let bufferedValues = [];
        return source.pipe(tap((/**
         * @param {?} value
         * @return {?}
         */
        value => bufferedValues.push(value))), debounceTime(time, scheduler), map((/**
         * @return {?}
         */
        () => bufferedValues)), tap((/**
         * @return {?}
         */
        () => (bufferedValues = []))));
    });
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class CmsComponentConnector {
    /**
     * @param {?} cmsStructureConfigService
     * @param {?} adapter
     * @param {?} config
     */
    constructor(cmsStructureConfigService, adapter, config) {
        this.cmsStructureConfigService = cmsStructureConfigService;
        this.adapter = adapter;
        this.config = config;
    }
    /**
     * @template T
     * @param {?} id
     * @param {?} pageContext
     * @return {?}
     */
    get(id, pageContext) {
        return this.cmsStructureConfigService
            .getComponentFromConfig(id)
            .pipe(switchMap((/**
         * @param {?} configuredComponent
         * @return {?}
         */
        configuredComponent => configuredComponent
            ? of(configuredComponent)
            : this.adapter.load(id, pageContext))));
    }
    /**
     * @param {?} ids
     * @param {?} pageContext
     * @return {?}
     */
    getList(ids, pageContext) {
        return this.cmsStructureConfigService.getComponentsFromConfig(ids).pipe(switchMap((/**
         * @param {?} configuredComponents
         * @return {?}
         */
        configuredComponents => {
            // check if we have some components that are not loaded from configuration
            /** @type {?} */
            const missingIds = configuredComponents.reduce((/**
             * @param {?} acc
             * @param {?} component
             * @param {?} index
             * @return {?}
             */
            (acc, component, index) => {
                if (component === undefined) {
                    acc.push(ids[index]);
                }
                return acc;
            }), []);
            if (missingIds.length > 0) {
                return (this.config.backend.occ.legacy
                    ? this.adapter.findComponentsByIdsLegacy(missingIds, pageContext)
                    : this.adapter.findComponentsByIds(missingIds, pageContext)).pipe(map((/**
                 * @param {?} loadedComponents
                 * @return {?}
                 */
                loadedComponents => [
                    ...configuredComponents.filter(Boolean),
                    ...loadedComponents,
                ])));
            }
            else {
                return of(configuredComponents);
            }
        })));
    }
}
CmsComponentConnector.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root',
            },] }
];
/** @nocollapse */
CmsComponentConnector.ctorParameters = () => [
    { type: CmsStructureConfigService },
    { type: CmsComponentAdapter },
    { type: OccConfig }
];
/** @nocollapse */ CmsComponentConnector.ngInjectableDef = ɵɵdefineInjectable({ factory: function CmsComponentConnector_Factory() { return new CmsComponentConnector(ɵɵinject(CmsStructureConfigService), ɵɵinject(CmsComponentAdapter), ɵɵinject(OccConfig)); }, token: CmsComponentConnector, providedIn: "root" });
if (false) {
    /**
     * @type {?}
     * @protected
     */
    CmsComponentConnector.prototype.cmsStructureConfigService;
    /**
     * @type {?}
     * @protected
     */
    CmsComponentConnector.prototype.adapter;
    /**
     * @type {?}
     * @protected
     */
    CmsComponentConnector.prototype.config;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ComponentEffects {
    /**
     * @param {?} actions$
     * @param {?} cmsComponentLoader
     * @param {?} featureConfigService
     */
    constructor(actions$, cmsComponentLoader, featureConfigService) {
        this.actions$ = actions$;
        this.cmsComponentLoader = cmsComponentLoader;
        this.featureConfigService = featureConfigService;
        this.contextChange$ = this.actions$.pipe(ofType(LANGUAGE_CHANGE, LOGOUT, LOGIN));
        this.loadComponent$ = createEffect((/**
         * @return {?}
         */
        () => (/**
         * @param {?=} __0
         * @return {?}
         */
        ({ scheduler, debounce = 0 } = {}) => this.actions$.pipe(ofType(LOAD_CMS_COMPONENT), groupBy((/**
         * @param {?} actions
         * @return {?}
         */
        actions => serializePageContext(actions.pageContext))), mergeMap((/**
         * @param {?} actionGroup
         * @return {?}
         */
        actionGroup => actionGroup.pipe(bufferDebounceTime(debounce, scheduler), mergeMap((/**
         * @param {?} actions
         * @return {?}
         */
        actions => this.loadComponentsEffect(actions.map((/**
         * @param {?} action
         * @return {?}
         */
        action => action.payload)), actions[0].pageContext)))))), withdrawOn(this.contextChange$)))));
    }
    /**
     * @private
     * @param {?} componentUids
     * @param {?} pageContext
     * @return {?}
     */
    loadComponentsEffect(componentUids, pageContext) {
        // TODO: remove, deprecated behavior since 1.4
        if (!this.featureConfigService.isLevel('1.4')) {
            return merge(...componentUids.map((/**
             * @param {?} componentUid
             * @return {?}
             */
            componentUid => this.cmsComponentLoader.get(componentUid, pageContext).pipe(map((/**
             * @param {?} component
             * @return {?}
             */
            component => new LoadCmsComponentSuccess(component, component.uid, pageContext))), catchError((/**
             * @param {?} error
             * @return {?}
             */
            error => of(new LoadCmsComponentFail(componentUid, makeErrorSerializable(error), pageContext))))))));
        }
        // END OF (TODO: remove, deprecated behavior since 1.4)
        return this.cmsComponentLoader.getList(componentUids, pageContext).pipe(switchMap((/**
         * @param {?} components
         * @return {?}
         */
        components => from(components.map((/**
         * @param {?} component
         * @return {?}
         */
        component => new LoadCmsComponentSuccess(component, component.uid, pageContext)))))), catchError((/**
         * @param {?} error
         * @return {?}
         */
        error => from(componentUids.map((/**
         * @param {?} uid
         * @return {?}
         */
        uid => new LoadCmsComponentFail(uid, makeErrorSerializable(error), pageContext)))))));
    }
}
ComponentEffects.decorators = [
    { type: Injectable }
];
/** @nocollapse */
ComponentEffects.ctorParameters = () => [
    { type: Actions },
    { type: CmsComponentConnector },
    { type: FeatureConfigService }
];
if (false) {
    /**
     * @type {?}
     * @private
     */
    ComponentEffects.prototype.contextChange$;
    /** @type {?} */
    ComponentEffects.prototype.loadComponent$;
    /**
     * @type {?}
     * @private
     */
    ComponentEffects.prototype.actions$;
    /**
     * @type {?}
     * @private
     */
    ComponentEffects.prototype.cmsComponentLoader;
    /**
     * @type {?}
     * @private
     */
    ComponentEffects.prototype.featureConfigService;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NavigationEntryItemEffects {
    /**
     * @param {?} actions$
     * @param {?} cmsComponentConnector
     * @param {?} routingService
     */
    constructor(actions$, cmsComponentConnector, routingService) {
        this.actions$ = actions$;
        this.cmsComponentConnector = cmsComponentConnector;
        this.routingService = routingService;
        this.loadNavigationItems$ = this.actions$.pipe(ofType(LOAD_CMS_NAVIGATION_ITEMS), map((/**
         * @param {?} action
         * @return {?}
         */
        (action) => action.payload)), map((/**
         * @param {?} payload
         * @return {?}
         */
        payload => {
            return {
                ids: this.getIdListByItemType(payload.items),
                nodeId: payload.nodeId,
            };
        })), mergeMap((/**
         * @param {?} data
         * @return {?}
         */
        data => {
            if (data.ids.componentIds.length > 0) {
                return this.routingService.getRouterState().pipe(filter((/**
                 * @param {?} routerState
                 * @return {?}
                 */
                routerState => routerState !== undefined)), map((/**
                 * @param {?} routerState
                 * @return {?}
                 */
                routerState => routerState.state.context)), take(1), mergeMap((/**
                 * @param {?} pageContext
                 * @return {?}
                 */
                pageContext => 
                // download all items in one request
                this.cmsComponentConnector
                    .getList(data.ids.componentIds, pageContext)
                    .pipe(map((/**
                 * @param {?} components
                 * @return {?}
                 */
                components => new LoadCmsNavigationItemsSuccess({
                    nodeId: data.nodeId,
                    components: components,
                }))), catchError((/**
                 * @param {?} error
                 * @return {?}
                 */
                error => of(new LoadCmsNavigationItemsFail(data.nodeId, makeErrorSerializable(error)))))))));
            }
            else if (data.ids.pageIds.length > 0) {
                // TODO: future work
                // dispatch action to load cms page one by one
            }
            else if (data.ids.mediaIds.length > 0) {
                // TODO: future work
                // send request to get list of media
            }
            else {
                return of(new LoadCmsNavigationItemsFail(data.nodeId, 'navigation nodes are empty'));
            }
        })));
    }
    // We only consider 3 item types: cms page, cms component, and media.
    /**
     * @param {?} itemList
     * @return {?}
     */
    getIdListByItemType(itemList) {
        /** @type {?} */
        const pageIds = [];
        /** @type {?} */
        const componentIds = [];
        /** @type {?} */
        const mediaIds = [];
        itemList.forEach((/**
         * @param {?} item
         * @return {?}
         */
        item => {
            if (item.superType === 'AbstractCMSComponent') {
                componentIds.push(item.id);
            }
            else if (item.superType === 'AbstractPage') {
                pageIds.push(item.id);
            }
            else if (item.superType === 'AbstractMedia') {
                mediaIds.push(item.id);
            }
        }));
        return { pageIds: pageIds, componentIds: componentIds, mediaIds: mediaIds };
    }
}
NavigationEntryItemEffects.decorators = [
    { type: Injectable }
];
/** @nocollapse */
NavigationEntryItemEffects.ctorParameters = () => [
    { type: Actions },
    { type: CmsComponentConnector },
    { type: RoutingService }
];
__decorate([
    Effect(),
    __metadata("design:type", Observable)
], NavigationEntryItemEffects.prototype, "loadNavigationItems$", void 0);
if (false) {
    /** @type {?} */
    NavigationEntryItemEffects.prototype.loadNavigationItems$;
    /**
     * @type {?}
     * @private
     */
    NavigationEntryItemEffects.prototype.actions$;
    /**
     * @type {?}
     * @private
     */
    NavigationEntryItemEffects.prototype.cmsComponentConnector;
    /**
     * @type {?}
     * @private
     */
    NavigationEntryItemEffects.prototype.routingService;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const effects$8 = [
    PageEffects,
    ComponentEffects,
    NavigationEntryItemEffects,
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const initialState$e = {
    component: undefined,
    pageContext: {},
};
/**
 * @template T
 * @param {?=} state
 * @param {?=} action
 * @return {?}
 */
function componentExistsReducer(state = false, action) {
    switch (action.type) {
        case LOAD_CMS_COMPONENT_FAIL:
            return false;
        case CMS_GET_COMPONENET_FROM_PAGE:
        case LOAD_CMS_COMPONENT_SUCCESS:
            return true;
    }
    return state;
}
/**
 * @template T
 * @param {?=} state
 * @param {?=} action
 * @return {?}
 */
function reducer$e(state = initialState$e, action) {
    switch (action.type) {
        case LOAD_CMS_COMPONENT: {
            /** @type {?} */
            const pageContextReducer = loaderReducer(action.meta.entityType, componentExistsReducer);
            /** @type {?} */
            const context = serializePageContext(action.pageContext, true);
            return Object.assign({}, state, { pageContext: Object.assign({}, state.pageContext, { [context]: pageContextReducer(state.pageContext[context], action) }) });
        }
        case LOAD_CMS_COMPONENT_FAIL: {
            /** @type {?} */
            const pageContextReducer = loaderReducer(action.meta.entityType, componentExistsReducer);
            /** @type {?} */
            const context = serializePageContext(action.pageContext, true);
            return Object.assign({}, state, { pageContext: Object.assign({}, state.pageContext, { [context]: pageContextReducer(state.pageContext[context], action) }) });
        }
        case CMS_GET_COMPONENET_FROM_PAGE:
        case LOAD_CMS_COMPONENT_SUCCESS: {
            /** @type {?} */
            const pageContextReducer = loaderReducer(action.meta.entityType, componentExistsReducer);
            /** @type {?} */
            const context = serializePageContext(action.pageContext, true);
            return Object.assign({}, state, { component: (/** @type {?} */ (action.payload)), pageContext: Object.assign({}, state.pageContext, { [context]: pageContextReducer(state.pageContext[context], action) }) });
        }
    }
    return state;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const initialState$f = undefined;
/**
 * @param {?=} state
 * @param {?=} action
 * @return {?}
 */
function reducer$f(state = initialState$f, action) {
    switch (action.type) {
        case LOAD_CMS_NAVIGATION_ITEMS_SUCCESS: {
            if (action.payload.components) {
                /** @type {?} */
                const components = action.payload.components;
                /** @type {?} */
                const newItem = components.reduce((/**
                 * @param {?} compItems
                 * @param {?} component
                 * @return {?}
                 */
                (compItems, component) => {
                    return Object.assign({}, compItems, { [`${component.uid}_AbstractCMSComponent`]: component });
                }), Object.assign({}));
                return Object.assign({}, state, newItem);
            }
        }
    }
    return state;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const initialState$g = { entities: {} };
/**
 * @param {?=} state
 * @param {?=} action
 * @return {?}
 */
function reducer$g(state = initialState$g, action) {
    switch (action.type) {
        case LOAD_CMS_PAGE_DATA_SUCCESS: {
            /** @type {?} */
            const page = action.payload;
            return Object.assign({}, state, { entities: Object.assign({}, state.entities, { [page.pageId]: page }) });
        }
    }
    return state;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const initialState$h = undefined;
/**
 * @param {?} entityType
 * @return {?}
 */
function reducer$h(entityType) {
    return (/**
     * @param {?=} state
     * @param {?=} action
     * @return {?}
     */
    (state = initialState$h, action) => {
        if (action.meta && action.meta.entityType === entityType) {
            switch (action.type) {
                case LOAD_CMS_PAGE_DATA_SUCCESS: {
                    return action.payload.pageId;
                }
                case LOAD_CMS_PAGE_DATA_FAIL: {
                    return initialState$h;
                }
                case CMS_SET_PAGE_FAIL_INDEX: {
                    return action.payload;
                }
                case CMS_SET_PAGE_SUCCESS_INDEX: {
                    return action.payload.pageId;
                }
            }
        }
        return state;
    });
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @return {?}
 */
function getReducers$8() {
    return {
        page: combineReducers({
            pageData: reducer$g,
            index: combineReducers({
                content: entityLoaderReducer(PageType.CONTENT_PAGE, reducer$h(PageType.CONTENT_PAGE)),
                product: entityLoaderReducer(PageType.PRODUCT_PAGE, reducer$h(PageType.PRODUCT_PAGE)),
                category: entityLoaderReducer(PageType.CATEGORY_PAGE, reducer$h(PageType.CATEGORY_PAGE)),
                catalog: entityLoaderReducer(PageType.CATALOG_PAGE, reducer$h(PageType.CATALOG_PAGE)),
            }),
        }),
        /**
         * @deprecated in favour of `components`. From 2.0, this will be removed.
         */
        // TODO(issue:6027) - remove this `component` slice
        component: entityLoaderReducer(COMPONENT_ENTITY),
        components: entityReducer(COMPONENT_ENTITY, reducer$e),
        navigation: entityLoaderReducer(NAVIGATION_DETAIL_ENTITY, reducer$f),
    };
}
/** @type {?} */
const reducerToken$8 = new InjectionToken('CmsReducers');
/** @type {?} */
const reducerProvider$8 = {
    provide: reducerToken$8,
    useFactory: getReducers$8,
};
/**
 * @param {?} reducer
 * @return {?}
 */
function clearCmsState(reducer) {
    return (/**
     * @param {?} state
     * @param {?} action
     * @return {?}
     */
    function (state, action) {
        if (action.type === LANGUAGE_CHANGE ||
            action.type === LOGOUT ||
            action.type === LOGIN) {
            state = undefined;
        }
        return reducer(state, action);
    });
}
/** @type {?} */
const metaReducers$4 = [clearCmsState];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @return {?}
 */
function cmsStoreConfigFactory() {
    // if we want to reuse CMS_FEATURE const in config, we have to use factory instead of plain object
    /** @type {?} */
    const config = {
        state: {
            ssrTransfer: {
                keys: { [CMS_FEATURE]: StateTransferType.TRANSFER_STATE },
            },
        },
    };
    return config;
}
class CmsStoreModule {
}
CmsStoreModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    HttpClientModule,
                    StateModule,
                    StoreModule.forFeature(CMS_FEATURE, reducerToken$8, { metaReducers: metaReducers$4 }),
                    EffectsModule.forFeature(effects$8),
                    ConfigModule.withConfigFactory(cmsStoreConfigFactory),
                ],
                providers: [reducerProvider$8],
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class CmsModule {
    /**
     * @return {?}
     */
    static forRoot() {
        return {
            ngModule: CmsModule,
            providers: [
                CmsService,
                { provide: CmsConfig, useExisting: Config },
                { provide: CmsStructureConfig, useExisting: Config },
                provideConfig(defaultCmsModuleConfig),
            ],
        };
    }
}
CmsModule.decorators = [
    { type: NgModule, args: [{
                imports: [CmsStoreModule, CmsPageTitleModule],
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class PageMetaService {
    /**
     * @param {?} resolvers
     * @param {?} cms
     * @param {?=} featureConfigService
     */
    constructor(resolvers, cms, featureConfigService) {
        this.resolvers = resolvers;
        this.cms = cms;
        this.featureConfigService = featureConfigService;
        /**
         * The list of resolver interfaces will be evaluated for the pageResolvers.
         *
         * TOOD: optimize browser vs SSR resolvers; image, robots and description
         *       aren't needed during browsing.
         * TODO: we can make the list of resolver types configurable
         */
        this.resolverMethods = {
            title: 'resolveTitle',
            heading: 'resolveHeading',
            description: 'resolveDescription',
            breadcrumbs: 'resolveBreadcrumbs',
            image: 'resolveImage',
            robots: 'resolveRobots',
        };
        this.resolvers = this.resolvers || [];
    }
    /**
     * @return {?}
     */
    getMeta() {
        return this.cms.getCurrentPage().pipe(filter(Boolean), switchMap((/**
         * @param {?} page
         * @return {?}
         */
        (page) => {
            /** @type {?} */
            const metaResolver = this.getMetaResolver(page);
            if (metaResolver) {
                return this.resolve(metaResolver);
            }
            else {
                // we do not have a page resolver
                return of(null);
            }
        })));
    }
    /**
     * If a pageResolver has implemented a resolver interface, the resolved data
     * is merged into the `PageMeta` object.
     * @private
     * @param {?} metaResolver
     * @return {?}
     */
    resolve(metaResolver) {
        if (metaResolver.resolve &&
            (!this.featureConfigService || !this.featureConfigService.isLevel('1.3'))) {
            return metaResolver.resolve();
        }
        else {
            // resolve individual resolvers to make the extension mechanism more flexible
            /** @type {?} */
            const resolveMethods = Object.keys(this.resolverMethods)
                .filter((/**
             * @param {?} key
             * @return {?}
             */
            key => metaResolver[this.resolverMethods[key]]))
                .map((/**
             * @param {?} key
             * @return {?}
             */
            key => metaResolver[this.resolverMethods[key]]().pipe(map((/**
             * @param {?} data
             * @return {?}
             */
            data => ({
                [key]: data,
            }))))));
            return combineLatest(resolveMethods).pipe(map((/**
             * @param {?} data
             * @return {?}
             */
            data => Object.assign({}, ...data))));
        }
    }
    /**
     * return the resolver with the best match
     * resovers can by default match on PageType and page template
     * but custom match comparisors can be implemented.
     * @protected
     * @param {?} page
     * @return {?}
     */
    getMetaResolver(page) {
        /** @type {?} */
        const matchingResolvers = this.resolvers.filter((/**
         * @param {?} resolver
         * @return {?}
         */
        resolver => resolver.getScore(page) > 0));
        matchingResolvers.sort((/**
         * @param {?} a
         * @param {?} b
         * @return {?}
         */
        function (a, b) {
            return b.getScore(page) - a.getScore(page);
        }));
        return matchingResolvers[0];
    }
}
PageMetaService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root',
            },] }
];
/** @nocollapse */
PageMetaService.ctorParameters = () => [
    { type: Array, decorators: [{ type: Optional }, { type: Inject, args: [PageMetaResolver,] }] },
    { type: CmsService },
    { type: FeatureConfigService }
];
/** @nocollapse */ PageMetaService.ngInjectableDef = ɵɵdefineInjectable({ factory: function PageMetaService_Factory() { return new PageMetaService(ɵɵinject(PageMetaResolver, 8), ɵɵinject(CmsService), ɵɵinject(FeatureConfigService)); }, token: PageMetaService, providedIn: "root" });
if (false) {
    /**
     * The list of resolver interfaces will be evaluated for the pageResolvers.
     *
     * TOOD: optimize browser vs SSR resolvers; image, robots and description
     *       aren't needed during browsing.
     * TODO: we can make the list of resolver types configurable
     * @type {?}
     */
    PageMetaService.prototype.resolverMethods;
    /**
     * @type {?}
     * @protected
     */
    PageMetaService.prototype.resolvers;
    /**
     * @type {?}
     * @protected
     */
    PageMetaService.prototype.cms;
    /**
     * @type {?}
     * @protected
     */
    PageMetaService.prototype.featureConfigService;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @record
 */
function ContentSlotComponentData() { }
if (false) {
    /** @type {?|undefined} */
    ContentSlotComponentData.prototype.uid;
    /** @type {?|undefined} */
    ContentSlotComponentData.prototype.typeCode;
    /** @type {?|undefined} */
    ContentSlotComponentData.prototype.flexType;
    /** @type {?|undefined} */
    ContentSlotComponentData.prototype.properties;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @record
 */
function ContentSlotData() { }
if (false) {
    /** @type {?|undefined} */
    ContentSlotData.prototype.components;
    /** @type {?|undefined} */
    ContentSlotData.prototype.properties;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @record
 */
function NodeItem() { }

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Resolves the page heading which is used in the UI. The page
 * heading might differ from the page title, which is used to address
 * the page in the browser (history, tabs) and outside the storefront
 * (Goolge, bots, etc).
 * @record
 */
function PageHeadingResolver() { }
if (false) {
    /**
     * Resolves the page heading.
     *
     * @deprecated since version 1.3
     * Use `resolveHeading()` instead.
     * @param {...?} args
     * @return {?}
     */
    PageHeadingResolver.prototype.resolveHeading = function (args) { };
    /**
     * Resolves the page heading.
     * @return {?}
     */
    PageHeadingResolver.prototype.resolveHeading = function () { };
}
/**
 * Resolves the page title which is first and foremost used
 * for the page title tag, but could also be used for the
 * page heading in the UI.
 * @record
 */
function PageTitleResolver() { }
if (false) {
    /**
     * Resolves the page title.
     *
     * @deprecated since version 1.3
     * Use `resolveTitle()` instead.
     * @param {...?} args
     * @return {?}
     */
    PageTitleResolver.prototype.resolveTitle = function (args) { };
    /**
     * Resolves the page title.
     * @return {?}
     */
    PageTitleResolver.prototype.resolveTitle = function () { };
}
/**
 * Resolves the page description. The page description is typically used
 * in the Search Engine Result Page (SERP).
 * @record
 */
function PageDescriptionResolver() { }
if (false) {
    /**
     * Resolves the page description.
     *
     * @deprecated since version 1.3
     * Use `resolveHeading()` instead.
     * @param {...?} args
     * @return {?}
     */
    PageDescriptionResolver.prototype.resolveDescription = function (args) { };
    /**
     * Resolves the page description.
     * @return {?}
     */
    PageDescriptionResolver.prototype.resolveDescription = function () { };
}
/**
 * Resolves breadcrumbs for the page, which is used in the `BreadcrumbComponent`
 * @record
 */
function PageBreadcrumbResolver() { }
if (false) {
    /**
     * Resolves the breadcrumbs for the page.
     *
     * @deprecated since version 1.3
     * Use `resolveBreadcrumbs()` instead.
     * @param {...?} args
     * @return {?}
     */
    PageBreadcrumbResolver.prototype.resolveBreadcrumbs = function (args) { };
    /**
     * Resolves the breadcrumbs for the page.
     * @return {?}
     */
    PageBreadcrumbResolver.prototype.resolveBreadcrumbs = function () { };
}
/**
 * Provides a method to resolve the the main image for the page.
 * This is typically used for social sharing (for example by using
 * the `og:image` metatag).
 * @record
 */
function PageImageResolver() { }
if (false) {
    /**
     * Resolves the main image for the page.
     *
     * @deprecated since version 1.3
     * Use `resolveImage()` instead.
     * @param {...?} args
     * @return {?}
     */
    PageImageResolver.prototype.resolveImage = function (args) { };
    /**
     * Resolves the main image for the page.
     * @return {?}
     */
    PageImageResolver.prototype.resolveImage = function () { };
}
/**
 * Resolves the robot information for the page. This is used by
 * search engines to understand whether the page and subsequential links
 * should be indexed.
 *
 * @record
 */
function PageRobotsResolver() { }
if (false) {
    /**
     * Resolves the robots for the page.
     *
     * @deprecated since version 1.3
     * Use `resolveRobots()` instead.
     * @param {...?} args
     * @return {?}
     */
    PageRobotsResolver.prototype.resolveRobots = function (args) { };
    /**
     * Resolves the robots for the page.
     * @return {?}
     */
    PageRobotsResolver.prototype.resolveRobots = function () { };
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class DynamicAttributeService {
    /**
     * Add dynamic attributes to DOM. These attributes are extracted from the properties of cms items received from backend.
     * There can by many different groups of properties, one of them is smaredit. But EC allows addons to create different groups.
     * For example, personalization may add 'script' group etc.
     * @param {?} properties
     * @param {?} element
     * @param {?} renderer
     * @return {?}
     */
    addDynamicAttributes(properties, element, renderer) {
        if (properties) {
            // check each group of properties, e.g. smartedit
            Object.keys(properties).forEach((/**
             * @param {?} group
             * @return {?}
             */
            group => {
                /** @type {?} */
                const name = 'data-' + group + '-';
                /** @type {?} */
                const groupProps = properties[group];
                // check each property in the group
                Object.keys(groupProps).forEach((/**
                 * @param {?} propName
                 * @return {?}
                 */
                propName => {
                    /** @type {?} */
                    const propValue = groupProps[propName];
                    if (propName === 'classes') {
                        /** @type {?} */
                        const classes = propValue.split(' ');
                        classes.forEach((/**
                         * @param {?} classItem
                         * @return {?}
                         */
                        classItem => {
                            element.classList.add(classItem);
                        }));
                    }
                    else {
                        renderer.setAttribute(element, name +
                            propName
                                .split(/(?=[A-Z])/)
                                .join('-')
                                .toLowerCase(), propValue);
                    }
                }));
            }));
        }
    }
}
DynamicAttributeService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root',
            },] }
];
/** @nocollapse */ DynamicAttributeService.ngInjectableDef = ɵɵdefineInjectable({ factory: function DynamicAttributeService_Factory() { return new DynamicAttributeService(); }, token: DynamicAttributeService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @record
 */
function TranslationResources() { }

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @record
 */
function Translatable() { }
if (false) {
    /** @type {?|undefined} */
    Translatable.prototype.key;
    /** @type {?|undefined} */
    Translatable.prototype.params;
    /** @type {?|undefined} */
    Translatable.prototype.raw;
}
/**
 * @record
 */
function TranslatableParams() { }

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// type CxDatePipe, not DatePipe, due to conflict with Angular's DatePipe - problem occurs for the backward compatibility compiler of Ivy
class CxDatePipe extends DatePipe {
    /**
     * @param {?} language
     */
    constructor(language) {
        super(null);
        this.language = language;
    }
    /**
     * @param {?} value
     * @param {?=} format
     * @param {?=} timezone
     * @return {?}
     */
    transform(value, format, timezone) {
        return super.transform(value, format, timezone, this.getLang());
    }
    /**
     * @private
     * @return {?}
     */
    getLang() {
        /** @type {?} */
        const lang = this.getActiveLang();
        try {
            getLocaleId(lang);
            return lang;
        }
        catch (_a) {
            this.reportMissingLocaleData(lang);
            return 'en';
        }
    }
    /**
     * @private
     * @return {?}
     */
    getActiveLang() {
        /** @type {?} */
        let result;
        this.language
            .getActive()
            .subscribe((/**
         * @param {?} lang
         * @return {?}
         */
        lang => (result = lang)))
            .unsubscribe();
        return result;
    }
    /**
     * @private
     * @param {?} lang
     * @return {?}
     */
    reportMissingLocaleData(lang) {
        if (isDevMode()) {
            console.warn(`cxDate pipe: No locale data registered for '${lang}' (see https://angular.io/api/common/registerLocaleData).`);
        }
    }
}
CxDatePipe.decorators = [
    { type: Pipe, args: [{ name: 'cxDate' },] }
];
/** @nocollapse */
CxDatePipe.ctorParameters = () => [
    { type: LanguageService }
];
if (false) {
    /**
     * @type {?}
     * @protected
     */
    CxDatePipe.prototype.language;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class TranslatePipe {
    /**
     * @param {?} service
     * @param {?} cd
     */
    constructor(service, cd) {
        this.service = service;
        this.cd = cd;
    }
    /**
     * @param {?} input
     * @param {?=} options
     * @return {?}
     */
    transform(input, options = {}) {
        if (((/** @type {?} */ (input))).raw) {
            return ((/** @type {?} */ (input))).raw;
        }
        /** @type {?} */
        const key = typeof input === 'string' ? input : input.key;
        if (typeof input !== 'string') {
            options = Object.assign({}, options, input.params);
        }
        this.translate(key, options);
        return this.translatedValue;
    }
    /**
     * @private
     * @param {?} key
     * @param {?} options
     * @return {?}
     */
    translate(key, options) {
        if (key !== this.lastKey ||
            !shallowEqualObjects(options, this.lastOptions)) {
            this.lastKey = key;
            this.lastOptions = options;
            if (this.sub) {
                this.sub.unsubscribe();
            }
            this.sub = this.service
                .translate(key, options, true)
                .subscribe((/**
             * @param {?} val
             * @return {?}
             */
            val => this.markForCheck(val)));
        }
    }
    /**
     * @private
     * @param {?} value
     * @return {?}
     */
    markForCheck(value) {
        this.translatedValue = value;
        this.cd.markForCheck();
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (this.sub) {
            this.sub.unsubscribe();
        }
    }
}
TranslatePipe.decorators = [
    { type: Pipe, args: [{ name: 'cxTranslate', pure: false },] }
];
/** @nocollapse */
TranslatePipe.ctorParameters = () => [
    { type: TranslationService },
    { type: ChangeDetectorRef }
];
if (false) {
    /**
     * @type {?}
     * @private
     */
    TranslatePipe.prototype.lastKey;
    /**
     * @type {?}
     * @private
     */
    TranslatePipe.prototype.lastOptions;
    /**
     * @type {?}
     * @private
     */
    TranslatePipe.prototype.translatedValue;
    /**
     * @type {?}
     * @private
     */
    TranslatePipe.prototype.sub;
    /**
     * @type {?}
     * @protected
     */
    TranslatePipe.prototype.service;
    /**
     * @type {?}
     * @protected
     */
    TranslatePipe.prototype.cd;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @abstract
 */
class I18nConfig {
}
if (false) {
    /** @type {?} */
    I18nConfig.prototype.i18n;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class TranslationChunkService {
    /**
     * @param {?} config
     */
    constructor(config) {
        this.config = config;
        this.duplicates = {};
        this.chunks = {};
        this.KEY_SEPARATOR = '.';
        /** @type {?} */
        const chunks = (config.i18n && config.i18n.chunks) || {};
        Object.keys(chunks).forEach((/**
         * @param {?} chunk
         * @return {?}
         */
        chunk => {
            chunks[chunk].forEach((/**
             * @param {?} key
             * @return {?}
             */
            key => {
                if (this.chunks.hasOwnProperty(key)) {
                    if (!this.duplicates[key]) {
                        this.duplicates[key] = [this.chunks[key]];
                    }
                    this.duplicates[key].push(chunk);
                }
                else {
                    this.chunks[key] = chunk;
                }
            }));
        }));
        if (Object.keys(this.duplicates).length > 0 && isDevMode()) {
            this.warnDuplicates(this.duplicates);
        }
    }
    /**
     * @param {?} key
     * @return {?}
     */
    getChunkNameForKey(key) {
        /** @type {?} */
        const mainKey = (key || '').split(this.KEY_SEPARATOR)[0];
        /** @type {?} */
        const chunk = this.chunks && this.chunks[mainKey];
        if (!chunk) {
            return mainKey; // fallback to main key as a chunk
        }
        return chunk;
    }
    /**
     * @private
     * @param {?} items
     * @return {?}
     */
    warnDuplicates(items) {
        /** @type {?} */
        const dupes = [];
        Object.keys(items).forEach((/**
         * @param {?} key
         * @return {?}
         */
        key => {
            dupes.push(`* '${key}' found in chunks: ${items[key].join(', ')}. Used '${this.chunks[key]}.${key}'.`);
        }));
        console.warn(`Duplicated keys has been found in the config of i18n chunks:\n${dupes.join('\n')}`);
    }
}
TranslationChunkService.decorators = [
    { type: Injectable }
];
/** @nocollapse */
TranslationChunkService.ctorParameters = () => [
    { type: I18nConfig }
];
if (false) {
    /**
     * @type {?}
     * @protected
     */
    TranslationChunkService.prototype.duplicates;
    /**
     * @type {?}
     * @protected
     */
    TranslationChunkService.prototype.chunks;
    /**
     * @type {?}
     * @protected
     */
    TranslationChunkService.prototype.KEY_SEPARATOR;
    /**
     * @type {?}
     * @protected
     */
    TranslationChunkService.prototype.config;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} configInit
 * @param {?} languageService
 * @param {?} httpClient
 * @param {?} serverRequestOrigin
 * @return {?}
 */
function i18nextInit(configInit, languageService, httpClient, serverRequestOrigin) {
    return (/**
     * @return {?}
     */
    () => configInit.getStableConfig('i18n').then((/**
     * @param {?} config
     * @return {?}
     */
    config => {
        /** @type {?} */
        let i18nextConfig = {
            ns: [],
            // don't preload any namespaces
            fallbackLng: config.i18n.fallbackLang,
            debug: config.i18n.debug,
            interpolation: {
                escapeValue: false,
            },
        };
        if (config.i18n.backend) {
            i18next.use(i18nextXhrBackend);
            /** @type {?} */
            const loadPath = getLoadPath(config.i18n.backend.loadPath, serverRequestOrigin);
            /** @type {?} */
            const backend = {
                loadPath,
                ajax: i18nextGetHttpClient(httpClient),
            };
            i18nextConfig = Object.assign({}, i18nextConfig, { backend });
        }
        return i18next.init(i18nextConfig, (/**
         * @return {?}
         */
        () => {
            // Don't use i18next's 'resources' config key for adding static translations,
            // because it will disable loading chunks from backend. We add resources here, in the init's callback.
            i18nextAddTranslations(config.i18n.resources);
            syncI18nextWithSiteContext(languageService);
        }));
    })));
}
/**
 * @param {?=} resources
 * @return {?}
 */
function i18nextAddTranslations(resources = {}) {
    Object.keys(resources).forEach((/**
     * @param {?} lang
     * @return {?}
     */
    lang => {
        Object.keys(resources[lang]).forEach((/**
         * @param {?} chunkName
         * @return {?}
         */
        chunkName => {
            i18next.addResourceBundle(lang, chunkName, resources[lang][chunkName], true, true);
        }));
    }));
}
/**
 * @param {?} language
 * @return {?}
 */
function syncI18nextWithSiteContext(language) {
    // always update language of i18next on site context (language) change
    language.getActive().subscribe((/**
     * @param {?} lang
     * @return {?}
     */
    lang => i18next.changeLanguage(lang)));
}
/**
 * Returns a function appropriate for i18next to make http calls for JSON files.
 * See docs for `i18next-xhr-backend`: https://github.com/i18next/i18next-xhr-backend#backend-options
 *
 * It uses Angular HttpClient under the hood, so it works in SSR.
 * @param {?} httpClient Angular http client
 * @return {?}
 */
function i18nextGetHttpClient(httpClient) {
    return (/**
     * @param {?} url
     * @param {?} _options
     * @param {?} callback
     * @param {?} _data
     * @return {?}
     */
    (url, _options, callback, _data) => {
        httpClient
            .get(url, { responseType: 'text' })
            .subscribe((/**
         * @param {?} data
         * @return {?}
         */
        data => callback(data, { status: 200 })), (/**
         * @param {?} error
         * @return {?}
         */
        error => callback(null, { status: error.status })));
    });
}
/**
 * Resolves the relative path to the absolute one in SSR, using the server request's origin.
 * It's needed, because Angular Universal doesn't support relative URLs in HttpClient. See Angular issues:
 * - https://github.com/angular/angular/issues/19224
 * - https://github.com/angular/universal/issues/858
 * @param {?} path
 * @param {?} serverRequestOrigin
 * @return {?}
 */
function getLoadPath(path, serverRequestOrigin) {
    if (!path) {
        return undefined;
    }
    if (serverRequestOrigin && !path.match(/^http(s)?:\/\//)) {
        if (path.startsWith('/')) {
            path = path.slice(1);
        }
        if (path.startsWith('./')) {
            path = path.slice(2);
        }
        /** @type {?} */
        const result = `${serverRequestOrigin}/${path}`;
        return result;
    }
    return path;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
const ɵ0$D = i18nextInit;
/** @type {?} */
const i18nextProviders = [
    {
        provide: APP_INITIALIZER,
        useFactory: ɵ0$D,
        deps: [
            ConfigInitializerService,
            LanguageService,
            HttpClient,
            [new Optional(), SERVER_REQUEST_ORIGIN],
        ],
        multi: true,
    },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const defaultI18nConfig = {
    i18n: {
        fallbackLang: false,
        debug: false,
    },
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class I18nextTranslationService {
    /**
     * @param {?} config
     * @param {?} translationChunk
     */
    constructor(config, translationChunk) {
        this.config = config;
        this.translationChunk = translationChunk;
        this.NON_BREAKING_SPACE = String.fromCharCode(160);
        this.NAMESPACE_SEPARATOR = ':';
    }
    /**
     * @param {?} key
     * @param {?=} options
     * @param {?=} whitespaceUntilLoaded
     * @return {?}
     */
    translate(key, options = {}, whitespaceUntilLoaded = false) {
        // If we've already loaded the chunk (or failed to load), we should immediately emit the value
        // (or the fallback value in case the key is missing).
        // If we've already loaded the chunk (or failed to load), we should immediately emit the value
        // (or the fallback value in case the key is missing).
        // Moreover, we SHOULD emit a value (or a fallback value) synchronously (not in a promise/setTimeout).
        // Otherwise, we the will trigger additional deferred change detection in a view that consumes the returned observable,
        // which together with `switchMap` operator may lead to an infinite loop.
        /** @type {?} */
        const chunkName = this.translationChunk.getChunkNameForKey(key);
        /** @type {?} */
        const namespacedKey = this.getNamespacedKey(key, chunkName);
        return new Observable((/**
         * @param {?} subscriber
         * @return {?}
         */
        subscriber => {
            /** @type {?} */
            const translate = (/**
             * @return {?}
             */
            () => {
                if (i18next.exists(namespacedKey, options)) {
                    subscriber.next(i18next.t(namespacedKey, options));
                }
                else {
                    if (whitespaceUntilLoaded) {
                        subscriber.next(this.NON_BREAKING_SPACE);
                    }
                    i18next.loadNamespaces(chunkName, (/**
                     * @return {?}
                     */
                    () => {
                        if (!i18next.exists(namespacedKey, options)) {
                            this.reportMissingKey(key, chunkName);
                            subscriber.next(this.getFallbackValue(namespacedKey));
                        }
                        else {
                            subscriber.next(i18next.t(namespacedKey, options));
                        }
                    }));
                }
            });
            translate();
            i18next.on('languageChanged', translate);
            return (/**
             * @return {?}
             */
            () => i18next.off('languageChanged', translate));
        }));
    }
    /**
     * @param {?} chunkNames
     * @return {?}
     */
    loadChunks(chunkNames) {
        return i18next.loadNamespaces(chunkNames);
    }
    /**
     * Returns a fallback value in case when the given key is missing
     * @protected
     * @param {?} key
     * @return {?}
     */
    getFallbackValue(key) {
        return isDevMode() ? `[${key}]` : this.NON_BREAKING_SPACE;
    }
    /**
     * @private
     * @param {?} key
     * @param {?} chunkName
     * @return {?}
     */
    reportMissingKey(key, chunkName) {
        if (isDevMode()) {
            console.warn(`Translation key missing '${key}' in the chunk '${chunkName}'`);
        }
    }
    /**
     * @private
     * @param {?} key
     * @param {?} chunk
     * @return {?}
     */
    getNamespacedKey(key, chunk) {
        return chunk + this.NAMESPACE_SEPARATOR + key;
    }
}
I18nextTranslationService.decorators = [
    { type: Injectable }
];
/** @nocollapse */
I18nextTranslationService.ctorParameters = () => [
    { type: I18nConfig },
    { type: TranslationChunkService }
];
if (false) {
    /**
     * @type {?}
     * @private
     */
    I18nextTranslationService.prototype.NON_BREAKING_SPACE;
    /**
     * @type {?}
     * @protected
     */
    I18nextTranslationService.prototype.NAMESPACE_SEPARATOR;
    /**
     * @type {?}
     * @protected
     */
    I18nextTranslationService.prototype.config;
    /**
     * @type {?}
     * @protected
     */
    I18nextTranslationService.prototype.translationChunk;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class I18nModule {
    /**
     * @return {?}
     */
    static forRoot() {
        return {
            ngModule: I18nModule,
            providers: [
                provideConfig(defaultI18nConfig),
                { provide: I18nConfig, useExisting: Config },
                { provide: TranslationService, useClass: I18nextTranslationService },
                TranslationChunkService,
                ...i18nextProviders,
            ],
        };
    }
}
I18nModule.decorators = [
    { type: NgModule, args: [{
                declarations: [TranslatePipe, CxDatePipe],
                exports: [TranslatePipe, CxDatePipe],
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} key
 * @param {?=} options
 * @return {?}
 */
function mockTranslate(key, options = {}) {
    /** @type {?} */
    const optionsString = Object.keys(options)
        .sort()
        .map((/**
     * @param {?} optionName
     * @return {?}
     */
    optionName => `${optionName}:${options[optionName]}`))
        .join(' ');
    return optionsString ? `${key} ${optionsString}` : key;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class MockTranslatePipe {
    /**
     * @param {?} input
     * @param {?=} options
     * @return {?}
     */
    transform(input, options = {}) {
        if (((/** @type {?} */ (input))).raw) {
            return ((/** @type {?} */ (input))).raw;
        }
        /** @type {?} */
        const key = typeof input === 'string' ? input : input.key;
        if (typeof input !== 'string') {
            options = Object.assign({}, options, input.params);
        }
        return mockTranslate(key, options);
    }
}
MockTranslatePipe.decorators = [
    { type: Pipe, args: [{ name: 'cxTranslate' },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class MockTranslationService {
    /**
     * @param {?} key
     * @param {?=} options
     * @param {?=} _whitespaceUntilLoaded
     * @return {?}
     */
    translate(key, options = {}, _whitespaceUntilLoaded = false) {
        return new Observable((/**
         * @param {?} subscriber
         * @return {?}
         */
        subscriber => {
            /** @type {?} */
            const value = mockTranslate(key, options);
            subscriber.next(value);
            subscriber.complete();
        }));
    }
    /**
     * @param {?} _chunks
     * @return {?}
     */
    loadChunks(_chunks) {
        return Promise.resolve();
    }
}
MockTranslationService.decorators = [
    { type: Injectable }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class MockDatePipe extends DatePipe {
    /**
     * @param {?} value
     * @param {?=} format
     * @param {?=} timezone
     * @return {?}
     */
    transform(value, format, timezone) {
        return super.transform(value, format, timezone, 'en');
    }
}
MockDatePipe.decorators = [
    { type: Pipe, args: [{ name: 'cxDate' },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class I18nTestingModule {
}
I18nTestingModule.decorators = [
    { type: NgModule, args: [{
                declarations: [MockTranslatePipe, MockDatePipe],
                exports: [MockTranslatePipe, MockDatePipe],
                providers: [
                    { provide: TranslationService, useClass: MockTranslationService },
                ],
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @abstract
 */
class KymaConfig extends OccConfig {
}
if (false) {
    /** @type {?} */
    KymaConfig.prototype.authentication;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const KYMA_FEATURE = 'kyma';
/** @type {?} */
const OPEN_ID_TOKEN_DATA = '[Kyma Auth] Open ID Token Data';
/**
 * @record
 */
function StateWithKyma() { }
if (false) {
    /* Skipping unnamed member:
    [KYMA_FEATURE]: KymaState;*/
}
/**
 * @record
 */
function KymaState() { }
if (false) {
    /** @type {?} */
    KymaState.prototype.openIdToken;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const LOAD_OPEN_ID_TOKEN = '[Kyma] Load Open ID Token';
/** @type {?} */
const LOAD_OPEN_ID_TOKEN_FAIL = '[Kyma] Load Open ID Token Fail';
/** @type {?} */
const LOAD_OPEN_ID_TOKEN_SUCCESS = '[Kyma] Load Open ID Token Success';
class LoadOpenIdToken extends LoaderLoadAction {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        super(OPEN_ID_TOKEN_DATA);
        this.payload = payload;
        this.type = LOAD_OPEN_ID_TOKEN;
    }
}
if (false) {
    /** @type {?} */
    LoadOpenIdToken.prototype.type;
    /** @type {?} */
    LoadOpenIdToken.prototype.payload;
}
class LoadOpenIdTokenFail extends LoaderFailAction {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        super(OPEN_ID_TOKEN_DATA, payload);
        this.payload = payload;
        this.type = LOAD_OPEN_ID_TOKEN_FAIL;
    }
}
if (false) {
    /** @type {?} */
    LoadOpenIdTokenFail.prototype.type;
    /** @type {?} */
    LoadOpenIdTokenFail.prototype.payload;
}
class LoadOpenIdTokenSuccess extends LoaderSuccessAction {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        super(OPEN_ID_TOKEN_DATA);
        this.payload = payload;
        this.type = LOAD_OPEN_ID_TOKEN_SUCCESS;
    }
}
if (false) {
    /** @type {?} */
    LoadOpenIdTokenSuccess.prototype.type;
    /** @type {?} */
    LoadOpenIdTokenSuccess.prototype.payload;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

var kymaGroup_actions = /*#__PURE__*/Object.freeze({
    LOAD_OPEN_ID_TOKEN: LOAD_OPEN_ID_TOKEN,
    LOAD_OPEN_ID_TOKEN_FAIL: LOAD_OPEN_ID_TOKEN_FAIL,
    LOAD_OPEN_ID_TOKEN_SUCCESS: LOAD_OPEN_ID_TOKEN_SUCCESS,
    LoadOpenIdToken: LoadOpenIdToken,
    LoadOpenIdTokenFail: LoadOpenIdTokenFail,
    LoadOpenIdTokenSuccess: LoadOpenIdTokenSuccess
});

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const getKymaState = createFeatureSelector(KYMA_FEATURE);

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
const ɵ0$E = /**
 * @param {?} state
 * @return {?}
 */
state => state.openIdToken;
/** @type {?} */
const getOpenIdTokenState = createSelector(getKymaState, (ɵ0$E));
/** @type {?} */
const getOpenIdTokenValue = createSelector(getOpenIdTokenState, loaderValueSelector);
/** @type {?} */
const getOpenIdTokenLoading = createSelector(getOpenIdTokenState, loaderLoadingSelector);
/** @type {?} */
const getOpenIdTokenSuccess = createSelector(getOpenIdTokenState, loaderSuccessSelector);
/** @type {?} */
const getOpenIdTokenError = createSelector(getOpenIdTokenState, loaderErrorSelector);

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

var kymaGroup_selectors = /*#__PURE__*/Object.freeze({
    getKymaState: getKymaState,
    getOpenIdTokenState: getOpenIdTokenState,
    getOpenIdTokenValue: getOpenIdTokenValue,
    getOpenIdTokenLoading: getOpenIdTokenLoading,
    getOpenIdTokenSuccess: getOpenIdTokenSuccess,
    getOpenIdTokenError: getOpenIdTokenError
});

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class KymaService {
    /**
     * @param {?} store
     */
    constructor(store) {
        this.store = store;
    }
    /**
     * Authorizes using the Kyma OAuth client with scope `openid`.
     *
     * @param {?} username a username
     * @param {?} password a password
     * @return {?}
     */
    authorizeOpenId(username, password) {
        this.store.dispatch(new LoadOpenIdToken({ username, password }));
    }
    /**
     * Returns the `OpenIdToken`, which was previously retrieved using `authorizeOpenId` method.
     * @return {?}
     */
    getOpenIdToken() {
        return this.store.pipe(select(getOpenIdTokenValue));
    }
}
KymaService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root',
            },] }
];
/** @nocollapse */
KymaService.ctorParameters = () => [
    { type: Store }
];
/** @nocollapse */ KymaService.ngInjectableDef = ɵɵdefineInjectable({ factory: function KymaService_Factory() { return new KymaService(ɵɵinject(Store)); }, token: KymaService, providedIn: "root" });
if (false) {
    /**
     * @type {?}
     * @protected
     */
    KymaService.prototype.store;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const defaultKymaConfig = {
    authentication: {
        kyma_enabled: false,
        kyma_client_id: 'client4kyma',
        kyma_client_secret: 'secret',
    },
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const OAUTH_ENDPOINT$2 = '/authorizationserver/oauth/token';
class OpenIdAuthenticationTokenService {
    /**
     * @param {?} config
     * @param {?} http
     */
    constructor(config, http) {
        this.config = config;
        this.http = http;
    }
    /**
     * @param {?} username
     * @param {?} password
     * @return {?}
     */
    loadOpenIdAuthenticationToken(username, password) {
        /** @type {?} */
        const url = this.getOAuthEndpoint();
        /** @type {?} */
        const params = new HttpParams()
            .set('client_id', encodeURIComponent(this.config.authentication.kyma_client_id))
            .set('client_secret', encodeURIComponent(this.config.authentication.kyma_client_secret))
            .set('grant_type', 'password') // authorization_code, client_credentials, password
            .set('username', username)
            .set('password', password)
            .set('scope', 'openid');
        /** @type {?} */
        const headers = new HttpHeaders({
            'Content-Type': 'application/x-www-form-urlencoded',
        });
        return this.http
            .post(url, params, { headers })
            .pipe(catchError((/**
         * @param {?} error
         * @return {?}
         */
        error => throwError(error))));
    }
    /**
     * @private
     * @return {?}
     */
    getOAuthEndpoint() {
        return (this.config.backend.occ.baseUrl || '') + OAUTH_ENDPOINT$2;
    }
}
OpenIdAuthenticationTokenService.decorators = [
    { type: Injectable }
];
/** @nocollapse */
OpenIdAuthenticationTokenService.ctorParameters = () => [
    { type: KymaConfig },
    { type: HttpClient }
];
if (false) {
    /**
     * @type {?}
     * @private
     */
    OpenIdAuthenticationTokenService.prototype.config;
    /**
     * @type {?}
     * @private
     */
    OpenIdAuthenticationTokenService.prototype.http;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const KymaServices = [OpenIdAuthenticationTokenService];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class OpenIdTokenEffect {
    /**
     * @param {?} actions$
     * @param {?} openIdTokenService
     * @param {?} config
     */
    constructor(actions$, openIdTokenService, config) {
        this.actions$ = actions$;
        this.openIdTokenService = openIdTokenService;
        this.config = config;
        this.triggerOpenIdTokenLoading$ = iif((/**
         * @return {?}
         */
        () => this.config.authentication && this.config.authentication.kyma_enabled), this.actions$.pipe(ofType(LOAD_USER_TOKEN_SUCCESS), withLatestFrom(this.actions$.pipe(ofType(LOAD_USER_TOKEN))), map((/**
         * @param {?} __0
         * @return {?}
         */
        ([, loginAction]) => new LoadOpenIdToken({
            username: loginAction.payload.userId,
            password: loginAction.payload.password,
        })))));
        this.loadOpenIdToken$ = this.actions$.pipe(ofType(LOAD_OPEN_ID_TOKEN), map((/**
         * @param {?} action
         * @return {?}
         */
        (action) => action.payload)), exhaustMap((/**
         * @param {?} payload
         * @return {?}
         */
        payload => this.openIdTokenService
            .loadOpenIdAuthenticationToken(payload.username, payload.password)
            .pipe(map((/**
         * @param {?} token
         * @return {?}
         */
        token => new LoadOpenIdTokenSuccess(token))), catchError((/**
         * @param {?} error
         * @return {?}
         */
        error => of(new LoadOpenIdTokenFail(makeErrorSerializable(error)))))))));
    }
}
OpenIdTokenEffect.decorators = [
    { type: Injectable }
];
/** @nocollapse */
OpenIdTokenEffect.ctorParameters = () => [
    { type: Actions },
    { type: OpenIdAuthenticationTokenService },
    { type: KymaConfig }
];
__decorate([
    Effect(),
    __metadata("design:type", Observable)
], OpenIdTokenEffect.prototype, "triggerOpenIdTokenLoading$", void 0);
__decorate([
    Effect(),
    __metadata("design:type", Observable)
], OpenIdTokenEffect.prototype, "loadOpenIdToken$", void 0);
if (false) {
    /** @type {?} */
    OpenIdTokenEffect.prototype.triggerOpenIdTokenLoading$;
    /** @type {?} */
    OpenIdTokenEffect.prototype.loadOpenIdToken$;
    /**
     * @type {?}
     * @private
     */
    OpenIdTokenEffect.prototype.actions$;
    /**
     * @type {?}
     * @private
     */
    OpenIdTokenEffect.prototype.openIdTokenService;
    /**
     * @type {?}
     * @private
     */
    OpenIdTokenEffect.prototype.config;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const effects$9 = [OpenIdTokenEffect];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @return {?}
 */
function getReducers$9() {
    return {
        openIdToken: loaderReducer(OPEN_ID_TOKEN_DATA),
    };
}
/** @type {?} */
const reducerToken$9 = new InjectionToken('KymaReducers');
/** @type {?} */
const reducerProvider$9 = {
    provide: reducerToken$9,
    useFactory: getReducers$9,
};
/**
 * @param {?} reducer
 * @return {?}
 */
function clearKymaState(reducer) {
    return (/**
     * @param {?} state
     * @param {?} action
     * @return {?}
     */
    function (state, action) {
        if (action.type === LOGOUT) {
            state = Object.assign({}, state, { openIdToken: undefined });
        }
        return reducer(state, action);
    });
}
/** @type {?} */
const metaReducers$5 = [clearKymaState];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @return {?}
 */
function kymaStoreConfigFactory() {
    // if we want to reuse KYMA_FEATURE const in config, we have to use factory instead of plain object
    /** @type {?} */
    const config = {
        state: {
            storageSync: {
                keys: {
                    'kyma.openIdToken.value': StorageSyncType.LOCAL_STORAGE,
                },
            },
        },
    };
    return config;
}
class KymaStoreModule {
}
KymaStoreModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    HttpClientModule,
                    StateModule,
                    StoreModule.forFeature(KYMA_FEATURE, reducerToken$9, { metaReducers: metaReducers$5 }),
                    EffectsModule.forFeature(effects$9),
                    ConfigModule.withConfigFactory(kymaStoreConfigFactory),
                ],
                providers: [reducerProvider$9],
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class KymaModule {
}
KymaModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    HttpClientModule,
                    KymaStoreModule,
                    ConfigModule.withConfig(defaultKymaConfig),
                ],
                providers: [...KymaServices, { provide: KymaConfig, useExisting: Config }],
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @record
 */
function OpenIdToken() { }
if (false) {
    /** @type {?} */
    OpenIdToken.prototype.id_token;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @abstract
 */
class PersonalizationConfig {
}
if (false) {
    /** @type {?} */
    PersonalizationConfig.prototype.personalization;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const defaultPersonalizationConfig = {
    personalization: {
        enabled: false,
        httpHeaderName: {
            id: 'Occ-Personalization-Id',
            timestamp: 'Occ-Personalization-Time',
        },
        context: {
            slotPosition: 'PlaceholderContentSlot',
            componentId: 'PersonalizationScriptComponent',
        },
    },
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const PERSONALIZATION_ID_KEY = 'personalization-id';
class OccPersonalizationIdInterceptor {
    /**
     * @param {?} config
     * @param {?} occEndpoints
     * @param {?} winRef
     * @param {?} platform
     */
    constructor(config, occEndpoints, winRef, platform) {
        this.config = config;
        this.occEndpoints = occEndpoints;
        this.winRef = winRef;
        this.platform = platform;
        this.enabled = false;
        if (isPlatformBrowser(this.platform)) {
            this.enabled =
                (this.winRef.localStorage && this.config.personalization.enabled) ||
                    false;
            if (this.enabled) {
                this.requestHeader = this.config.personalization.httpHeaderName.id.toLowerCase();
                this.personalizationId = this.winRef.localStorage.getItem(PERSONALIZATION_ID_KEY);
            }
            else if (this.winRef.localStorage.getItem(PERSONALIZATION_ID_KEY)) {
                this.winRef.localStorage.removeItem(PERSONALIZATION_ID_KEY);
            }
        }
    }
    /**
     * @param {?} request
     * @param {?} next
     * @return {?}
     */
    intercept(request, next) {
        if (!this.enabled) {
            return next.handle(request);
        }
        if (this.personalizationId &&
            request.url.includes(this.occEndpoints.getBaseEndpoint())) {
            request = request.clone({
                setHeaders: {
                    [this.requestHeader]: this.personalizationId,
                },
            });
        }
        return next.handle(request).pipe(tap((/**
         * @param {?} event
         * @return {?}
         */
        event => {
            if (event instanceof HttpResponse) {
                if (event.headers.keys().includes(this.requestHeader)) {
                    /** @type {?} */
                    const receivedId = event.headers.get(this.requestHeader);
                    if (this.personalizationId !== receivedId) {
                        this.personalizationId = receivedId;
                        this.winRef.localStorage.setItem(PERSONALIZATION_ID_KEY, this.personalizationId);
                    }
                }
            }
        })));
    }
}
OccPersonalizationIdInterceptor.decorators = [
    { type: Injectable, args: [{ providedIn: 'root' },] }
];
/** @nocollapse */
OccPersonalizationIdInterceptor.ctorParameters = () => [
    { type: PersonalizationConfig },
    { type: OccEndpointsService },
    { type: WindowRef },
    { type: undefined, decorators: [{ type: Inject, args: [PLATFORM_ID,] }] }
];
/** @nocollapse */ OccPersonalizationIdInterceptor.ngInjectableDef = ɵɵdefineInjectable({ factory: function OccPersonalizationIdInterceptor_Factory() { return new OccPersonalizationIdInterceptor(ɵɵinject(PersonalizationConfig), ɵɵinject(OccEndpointsService), ɵɵinject(WindowRef), ɵɵinject(PLATFORM_ID)); }, token: OccPersonalizationIdInterceptor, providedIn: "root" });
if (false) {
    /**
     * @type {?}
     * @private
     */
    OccPersonalizationIdInterceptor.prototype.personalizationId;
    /**
     * @type {?}
     * @private
     */
    OccPersonalizationIdInterceptor.prototype.requestHeader;
    /**
     * @type {?}
     * @private
     */
    OccPersonalizationIdInterceptor.prototype.enabled;
    /**
     * @type {?}
     * @private
     */
    OccPersonalizationIdInterceptor.prototype.config;
    /**
     * @type {?}
     * @private
     */
    OccPersonalizationIdInterceptor.prototype.occEndpoints;
    /**
     * @type {?}
     * @private
     */
    OccPersonalizationIdInterceptor.prototype.winRef;
    /**
     * @type {?}
     * @private
     */
    OccPersonalizationIdInterceptor.prototype.platform;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const PERSONALIZATION_TIME_KEY = 'personalization-time';
class OccPersonalizationTimeInterceptor {
    /**
     * @param {?} config
     * @param {?} occEndpoints
     * @param {?} winRef
     * @param {?} platform
     */
    constructor(config, occEndpoints, winRef, platform) {
        this.config = config;
        this.occEndpoints = occEndpoints;
        this.winRef = winRef;
        this.platform = platform;
        this.enabled = false;
        if (isPlatformBrowser(this.platform)) {
            this.enabled =
                (this.winRef.localStorage && this.config.personalization.enabled) ||
                    false;
            if (this.enabled) {
                this.requestHeader = this.config.personalization.httpHeaderName.timestamp.toLowerCase();
                this.timestamp = this.winRef.localStorage.getItem(PERSONALIZATION_TIME_KEY);
            }
            else if (this.winRef.localStorage.getItem(PERSONALIZATION_TIME_KEY)) {
                this.winRef.localStorage.removeItem(PERSONALIZATION_TIME_KEY);
            }
        }
    }
    /**
     * @param {?} request
     * @param {?} next
     * @return {?}
     */
    intercept(request, next) {
        if (!this.enabled) {
            return next.handle(request);
        }
        if (this.timestamp &&
            request.url.includes(this.occEndpoints.getBaseEndpoint())) {
            request = request.clone({
                setHeaders: {
                    [this.requestHeader]: this.timestamp,
                },
            });
        }
        return next.handle(request).pipe(tap((/**
         * @param {?} event
         * @return {?}
         */
        event => {
            if (event instanceof HttpResponse) {
                if (event.headers.keys().includes(this.requestHeader)) {
                    /** @type {?} */
                    const receivedTimestamp = event.headers.get(this.requestHeader);
                    if (this.timestamp !== receivedTimestamp) {
                        this.timestamp = receivedTimestamp;
                        this.winRef.localStorage.setItem(PERSONALIZATION_TIME_KEY, this.timestamp);
                    }
                }
            }
        })));
    }
}
OccPersonalizationTimeInterceptor.decorators = [
    { type: Injectable, args: [{ providedIn: 'root' },] }
];
/** @nocollapse */
OccPersonalizationTimeInterceptor.ctorParameters = () => [
    { type: PersonalizationConfig },
    { type: OccEndpointsService },
    { type: WindowRef },
    { type: undefined, decorators: [{ type: Inject, args: [PLATFORM_ID,] }] }
];
/** @nocollapse */ OccPersonalizationTimeInterceptor.ngInjectableDef = ɵɵdefineInjectable({ factory: function OccPersonalizationTimeInterceptor_Factory() { return new OccPersonalizationTimeInterceptor(ɵɵinject(PersonalizationConfig), ɵɵinject(OccEndpointsService), ɵɵinject(WindowRef), ɵɵinject(PLATFORM_ID)); }, token: OccPersonalizationTimeInterceptor, providedIn: "root" });
if (false) {
    /**
     * @type {?}
     * @private
     */
    OccPersonalizationTimeInterceptor.prototype.timestamp;
    /**
     * @type {?}
     * @private
     */
    OccPersonalizationTimeInterceptor.prototype.requestHeader;
    /**
     * @type {?}
     * @private
     */
    OccPersonalizationTimeInterceptor.prototype.enabled;
    /**
     * @type {?}
     * @private
     */
    OccPersonalizationTimeInterceptor.prototype.config;
    /**
     * @type {?}
     * @private
     */
    OccPersonalizationTimeInterceptor.prototype.occEndpoints;
    /**
     * @type {?}
     * @private
     */
    OccPersonalizationTimeInterceptor.prototype.winRef;
    /**
     * @type {?}
     * @private
     */
    OccPersonalizationTimeInterceptor.prototype.platform;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const interceptors$3 = [
    {
        provide: HTTP_INTERCEPTORS,
        useExisting: OccPersonalizationIdInterceptor,
        multi: true,
    },
    {
        provide: HTTP_INTERCEPTORS,
        useExisting: OccPersonalizationTimeInterceptor,
        multi: true,
    },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class PersonalizationModule {
    /**
     * @return {?}
     */
    static forRoot() {
        return {
            ngModule: PersonalizationModule,
            providers: [...interceptors$3],
        };
    }
}
PersonalizationModule.decorators = [
    { type: NgModule, args: [{
                imports: [ConfigModule.withConfig(defaultPersonalizationConfig)],
                providers: [{ provide: PersonalizationConfig, useExisting: Config }],
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class PersonalizationContextService {
    /**
     * @param {?} config
     * @param {?} cmsService
     */
    constructor(config, cmsService) {
        this.config = config;
        this.cmsService = cmsService;
    }
    /**
     * @return {?}
     */
    getPersonalizationContext() {
        return this.cmsService.getCurrentPage().pipe(filter(Boolean), map((/**
         * @param {?} page
         * @return {?}
         */
        (page) => page.slots[this.config.personalization.context.slotPosition])), filter(Boolean), map((/**
         * @param {?} slot
         * @return {?}
         */
        (slot) => slot.components.find((/**
         * @param {?} i
         * @return {?}
         */
        i => i.uid === this.config.personalization.context.componentId)))), filter(Boolean), map((/**
         * @param {?} component
         * @return {?}
         */
        (component) => this.buildPersonalizationContext(component.properties.script.data))));
    }
    /**
     * @private
     * @param {?} data
     * @return {?}
     */
    buildPersonalizationContext(data) {
        /** @type {?} */
        const context = JSON.parse(atob(data));
        context.actions.forEach((/**
         * @param {?} action
         * @return {?}
         */
        action => {
            Object.keys(action).forEach((/**
             * @param {?} key
             * @return {?}
             */
            key => {
                action[key] = atob(action[key]);
            }));
        }));
        for (let i = 0; i < context.segments.length; i++) {
            context.segments[i] = atob(context.segments[i]);
        }
        return context;
    }
}
PersonalizationContextService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root',
            },] }
];
/** @nocollapse */
PersonalizationContextService.ctorParameters = () => [
    { type: PersonalizationConfig },
    { type: CmsService }
];
/** @nocollapse */ PersonalizationContextService.ngInjectableDef = ɵɵdefineInjectable({ factory: function PersonalizationContextService_Factory() { return new PersonalizationContextService(ɵɵinject(PersonalizationConfig), ɵɵinject(CmsService)); }, token: PersonalizationContextService, providedIn: "root" });
if (false) {
    /**
     * @type {?}
     * @protected
     */
    PersonalizationContextService.prototype.config;
    /**
     * @type {?}
     * @protected
     */
    PersonalizationContextService.prototype.cmsService;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @record
 */
function PersonalizationAction() { }
if (false) {
    /** @type {?} */
    PersonalizationAction.prototype.action_name;
    /** @type {?} */
    PersonalizationAction.prototype.action_type;
    /** @type {?|undefined} */
    PersonalizationAction.prototype.customization_name;
    /** @type {?|undefined} */
    PersonalizationAction.prototype.customization_code;
    /** @type {?|undefined} */
    PersonalizationAction.prototype.variation_name;
    /** @type {?|undefined} */
    PersonalizationAction.prototype.variation_code;
}
/**
 * @record
 */
function PersonalizationContext() { }
if (false) {
    /** @type {?} */
    PersonalizationContext.prototype.actions;
    /** @type {?} */
    PersonalizationContext.prototype.segments;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @template T
 * @return {?}
 */
function getReducers$a() {
    return entityLoaderReducer(PROCESS_FEATURE);
}
/** @type {?} */
const reducerToken$a = new InjectionToken('ProcessReducers');
/** @type {?} */
const reducerProvider$a = {
    provide: reducerToken$a,
    useFactory: getReducers$a,
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ProcessStoreModule {
}
ProcessStoreModule.decorators = [
    { type: NgModule, args: [{
                imports: [StateModule, StoreModule.forFeature(PROCESS_FEATURE, reducerToken$a)],
                providers: [reducerProvider$a],
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ProcessModule {
    /**
     * @return {?}
     */
    static forRoot() {
        return {
            ngModule: ProcessModule,
            providers: [],
        };
    }
}
ProcessModule.decorators = [
    { type: NgModule, args: [{
                imports: [ProcessStoreModule],
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ProductConnector {
    /**
     * @param {?} adapter
     */
    constructor(adapter) {
        this.adapter = adapter;
    }
    /**
     * @param {?} productCode
     * @param {?=} scope
     * @return {?}
     */
    get(productCode, scope = '') {
        return this.adapter.load(productCode, scope);
    }
    /**
     * @param {?} products
     * @return {?}
     */
    getMany(products) {
        if (!this.adapter.loadMany) {
            return products.map((/**
             * @param {?} product
             * @return {?}
             */
            product => (Object.assign({}, product, { data$: this.adapter.load(product.code, product.scope) }))));
        }
        return this.adapter.loadMany(products);
    }
}
ProductConnector.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root',
            },] }
];
/** @nocollapse */
ProductConnector.ctorParameters = () => [
    { type: ProductAdapter }
];
/** @nocollapse */ ProductConnector.ngInjectableDef = ɵɵdefineInjectable({ factory: function ProductConnector_Factory() { return new ProductConnector(ɵɵinject(ProductAdapter)); }, token: ProductConnector, providedIn: "root" });
if (false) {
    /**
     * @type {?}
     * @protected
     */
    ProductConnector.prototype.adapter;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Used in product connectors and adapter to load multiple product codes and scopes
 * @record
 */
function ScopedProductData() { }
if (false) {
    /** @type {?} */
    ScopedProductData.prototype.code;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ProductReferencesConnector {
    /**
     * @param {?} adapter
     */
    constructor(adapter) {
        this.adapter = adapter;
    }
    /**
     * @param {?} productCode
     * @param {?=} referenceType
     * @param {?=} pageSize
     * @return {?}
     */
    get(productCode, referenceType, pageSize) {
        return this.adapter.load(productCode, referenceType, pageSize);
    }
}
ProductReferencesConnector.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root',
            },] }
];
/** @nocollapse */
ProductReferencesConnector.ctorParameters = () => [
    { type: ProductReferencesAdapter }
];
/** @nocollapse */ ProductReferencesConnector.ngInjectableDef = ɵɵdefineInjectable({ factory: function ProductReferencesConnector_Factory() { return new ProductReferencesConnector(ɵɵinject(ProductReferencesAdapter)); }, token: ProductReferencesConnector, providedIn: "root" });
if (false) {
    /**
     * @type {?}
     * @protected
     */
    ProductReferencesConnector.prototype.adapter;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ProductReviewsConnector {
    /**
     * @param {?} adapter
     */
    constructor(adapter) {
        this.adapter = adapter;
    }
    /**
     * @param {?} productCode
     * @param {?=} maxCount
     * @return {?}
     */
    get(productCode, maxCount) {
        return this.adapter.load(productCode, maxCount);
    }
    /**
     * @param {?} productCode
     * @param {?} review
     * @return {?}
     */
    add(productCode, review) {
        return this.adapter.post(productCode, review);
    }
}
ProductReviewsConnector.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root',
            },] }
];
/** @nocollapse */
ProductReviewsConnector.ctorParameters = () => [
    { type: ProductReviewsAdapter }
];
/** @nocollapse */ ProductReviewsConnector.ngInjectableDef = ɵɵdefineInjectable({ factory: function ProductReviewsConnector_Factory() { return new ProductReviewsConnector(ɵɵinject(ProductReviewsAdapter)); }, token: ProductReviewsConnector, providedIn: "root" });
if (false) {
    /**
     * @type {?}
     * @protected
     */
    ProductReviewsConnector.prototype.adapter;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ProductSearchConnector {
    /**
     * @param {?} adapter
     */
    constructor(adapter) {
        this.adapter = adapter;
    }
    /**
     * @param {?} query
     * @param {?=} searchConfig
     * @return {?}
     */
    search(query, searchConfig) {
        return this.adapter.search(query, searchConfig);
    }
    /**
     * @param {?} term
     * @param {?=} pageSize
     * @return {?}
     */
    getSuggestions(term, pageSize) {
        return this.adapter.loadSuggestions(term, pageSize);
    }
}
ProductSearchConnector.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root',
            },] }
];
/** @nocollapse */
ProductSearchConnector.ctorParameters = () => [
    { type: ProductSearchAdapter }
];
/** @nocollapse */ ProductSearchConnector.ngInjectableDef = ɵɵdefineInjectable({ factory: function ProductSearchConnector_Factory() { return new ProductSearchConnector(ɵɵinject(ProductSearchAdapter)); }, token: ProductSearchConnector, providedIn: "root" });
if (false) {
    /**
     * @type {?}
     * @protected
     */
    ProductSearchConnector.prototype.adapter;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const LOAD_PRODUCT_REFERENCES = '[Product] Load Product References Data';
/** @type {?} */
const LOAD_PRODUCT_REFERENCES_FAIL = '[Product] Load Product References Data Fail';
/** @type {?} */
const LOAD_PRODUCT_REFERENCES_SUCCESS = '[Product] Load Product References Data Success';
/** @type {?} */
const CLEAN_PRODUCT_REFERENCES = '[Product] Clean Product References';
class LoadProductReferences {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        this.payload = payload;
        this.type = LOAD_PRODUCT_REFERENCES;
    }
}
if (false) {
    /** @type {?} */
    LoadProductReferences.prototype.type;
    /** @type {?} */
    LoadProductReferences.prototype.payload;
}
class LoadProductReferencesFail {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        this.payload = payload;
        this.type = LOAD_PRODUCT_REFERENCES_FAIL;
    }
}
if (false) {
    /** @type {?} */
    LoadProductReferencesFail.prototype.type;
    /** @type {?} */
    LoadProductReferencesFail.prototype.payload;
}
class LoadProductReferencesSuccess {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        this.payload = payload;
        this.type = LOAD_PRODUCT_REFERENCES_SUCCESS;
    }
}
if (false) {
    /** @type {?} */
    LoadProductReferencesSuccess.prototype.type;
    /** @type {?} */
    LoadProductReferencesSuccess.prototype.payload;
}
class CleanProductReferences {
    constructor() {
        this.type = CLEAN_PRODUCT_REFERENCES;
    }
}
if (false) {
    /** @type {?} */
    CleanProductReferences.prototype.type;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const LOAD_PRODUCT_REVIEWS = '[Product] Load Product Reviews Data';
/** @type {?} */
const LOAD_PRODUCT_REVIEWS_FAIL = '[Product] Load Product Reviews Data Fail';
/** @type {?} */
const LOAD_PRODUCT_REVIEWS_SUCCESS = '[Product] Load Product Reviews Data Success';
/** @type {?} */
const POST_PRODUCT_REVIEW = '[Product] Post Product Review';
/** @type {?} */
const POST_PRODUCT_REVIEW_FAIL = '[Product] Post Product Review Fail';
/** @type {?} */
const POST_PRODUCT_REVIEW_SUCCESS = '[Product] Post Product Review Success';
class LoadProductReviews {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        this.payload = payload;
        this.type = LOAD_PRODUCT_REVIEWS;
    }
}
if (false) {
    /** @type {?} */
    LoadProductReviews.prototype.type;
    /** @type {?} */
    LoadProductReviews.prototype.payload;
}
class LoadProductReviewsFail {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        this.payload = payload;
        this.type = LOAD_PRODUCT_REVIEWS_FAIL;
    }
}
if (false) {
    /** @type {?} */
    LoadProductReviewsFail.prototype.type;
    /** @type {?} */
    LoadProductReviewsFail.prototype.payload;
}
class LoadProductReviewsSuccess {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        this.payload = payload;
        this.type = LOAD_PRODUCT_REVIEWS_SUCCESS;
    }
}
if (false) {
    /** @type {?} */
    LoadProductReviewsSuccess.prototype.type;
    /** @type {?} */
    LoadProductReviewsSuccess.prototype.payload;
}
class PostProductReview {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        this.payload = payload;
        this.type = POST_PRODUCT_REVIEW;
    }
}
if (false) {
    /** @type {?} */
    PostProductReview.prototype.type;
    /** @type {?} */
    PostProductReview.prototype.payload;
}
class PostProductReviewFail {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        this.payload = payload;
        this.type = POST_PRODUCT_REVIEW_FAIL;
    }
}
if (false) {
    /** @type {?} */
    PostProductReviewFail.prototype.type;
    /** @type {?} */
    PostProductReviewFail.prototype.payload;
}
class PostProductReviewSuccess {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        this.payload = payload;
        this.type = POST_PRODUCT_REVIEW_SUCCESS;
    }
}
if (false) {
    /** @type {?} */
    PostProductReviewSuccess.prototype.type;
    /** @type {?} */
    PostProductReviewSuccess.prototype.payload;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const SEARCH_PRODUCTS = '[Product] Search Products';
/** @type {?} */
const SEARCH_PRODUCTS_FAIL = '[Product] Search Products Fail';
/** @type {?} */
const SEARCH_PRODUCTS_SUCCESS = '[Product] Search Products Success';
/** @type {?} */
const GET_PRODUCT_SUGGESTIONS = '[Product] Get Product Suggestions';
/** @type {?} */
const GET_PRODUCT_SUGGESTIONS_SUCCESS = '[Product] Get Product Suggestions Success';
/** @type {?} */
const GET_PRODUCT_SUGGESTIONS_FAIL = '[Product] Get Product Suggestions Fail';
/** @type {?} */
const CLEAR_PRODUCT_SEARCH_RESULT = '[Product] Clear Product Search Result';
class SearchProducts {
    /**
     * @param {?} payload
     * @param {?=} auxiliary
     */
    constructor(payload, auxiliary) {
        this.payload = payload;
        this.auxiliary = auxiliary;
        this.type = SEARCH_PRODUCTS;
    }
}
if (false) {
    /** @type {?} */
    SearchProducts.prototype.type;
    /** @type {?} */
    SearchProducts.prototype.payload;
    /** @type {?} */
    SearchProducts.prototype.auxiliary;
}
class SearchProductsFail {
    /**
     * @param {?} payload
     * @param {?=} auxiliary
     */
    constructor(payload, auxiliary) {
        this.payload = payload;
        this.auxiliary = auxiliary;
        this.type = SEARCH_PRODUCTS_FAIL;
    }
}
if (false) {
    /** @type {?} */
    SearchProductsFail.prototype.type;
    /** @type {?} */
    SearchProductsFail.prototype.payload;
    /** @type {?} */
    SearchProductsFail.prototype.auxiliary;
}
class SearchProductsSuccess {
    /**
     * @param {?} payload
     * @param {?=} auxiliary
     */
    constructor(payload, auxiliary) {
        this.payload = payload;
        this.auxiliary = auxiliary;
        this.type = SEARCH_PRODUCTS_SUCCESS;
    }
}
if (false) {
    /** @type {?} */
    SearchProductsSuccess.prototype.type;
    /** @type {?} */
    SearchProductsSuccess.prototype.payload;
    /** @type {?} */
    SearchProductsSuccess.prototype.auxiliary;
}
class GetProductSuggestions {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        this.payload = payload;
        this.type = GET_PRODUCT_SUGGESTIONS;
    }
}
if (false) {
    /** @type {?} */
    GetProductSuggestions.prototype.type;
    /** @type {?} */
    GetProductSuggestions.prototype.payload;
}
class GetProductSuggestionsSuccess {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        this.payload = payload;
        this.type = GET_PRODUCT_SUGGESTIONS_SUCCESS;
    }
}
if (false) {
    /** @type {?} */
    GetProductSuggestionsSuccess.prototype.type;
    /** @type {?} */
    GetProductSuggestionsSuccess.prototype.payload;
}
class GetProductSuggestionsFail {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        this.payload = payload;
        this.type = GET_PRODUCT_SUGGESTIONS_FAIL;
    }
}
if (false) {
    /** @type {?} */
    GetProductSuggestionsFail.prototype.type;
    /** @type {?} */
    GetProductSuggestionsFail.prototype.payload;
}
class ClearProductSearchResult {
    /**
     * @param {?=} payload
     */
    constructor(payload = {
        clearPageResults: false,
        clearSearchboxResults: false,
    }) {
        this.payload = payload;
        this.type = CLEAR_PRODUCT_SEARCH_RESULT;
    }
}
if (false) {
    /** @type {?} */
    ClearProductSearchResult.prototype.type;
    /** @type {?} */
    ClearProductSearchResult.prototype.payload;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const PRODUCT_FEATURE = 'product';
/** @type {?} */
const PRODUCT_DETAIL_ENTITY = '[Product] Detail Entity';
/**
 * @record
 */
function StateWithProduct() { }
if (false) {
    /* Skipping unnamed member:
    [PRODUCT_FEATURE]: ProductsState;*/
}
/**
 * @record
 */
function ProductsState() { }
if (false) {
    /** @type {?} */
    ProductsState.prototype.details;
    /** @type {?} */
    ProductsState.prototype.search;
    /** @type {?} */
    ProductsState.prototype.reviews;
    /** @type {?} */
    ProductsState.prototype.references;
}
/**
 * @record
 */
function ProductsSearchState() { }
if (false) {
    /** @type {?} */
    ProductsSearchState.prototype.results;
    /** @type {?} */
    ProductsSearchState.prototype.suggestions;
    /** @type {?} */
    ProductsSearchState.prototype.auxResults;
}
/**
 * @record
 */
function ProductReviewsState() { }
if (false) {
    /** @type {?} */
    ProductReviewsState.prototype.productCode;
    /** @type {?} */
    ProductReviewsState.prototype.list;
}
/**
 * @record
 */
function ProductReferencesState() { }
if (false) {
    /** @type {?} */
    ProductReferencesState.prototype.productCode;
    /** @type {?} */
    ProductReferencesState.prototype.list;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var EntityScopedLoaderActions;
(function (EntityScopedLoaderActions) {
    /**
     * @record
     */
    function EntityScopedLoaderMeta() { }
    EntityScopedLoaderActions.EntityScopedLoaderMeta = EntityScopedLoaderMeta;
    if (false) {
        /** @type {?|undefined} */
        EntityScopedLoaderMeta.prototype.scope;
    }
    /**
     * @record
     */
    function EntityScopedLoaderAction() { }
    EntityScopedLoaderActions.EntityScopedLoaderAction = EntityScopedLoaderAction;
    if (false) {
        /** @type {?|undefined} */
        EntityScopedLoaderAction.prototype.payload;
        /** @type {?|undefined} */
        EntityScopedLoaderAction.prototype.meta;
    }
    /**
     * @param {?} entityType
     * @param {?} id
     * @param {?=} scope
     * @return {?}
     */
    function entityScopedLoadMeta(entityType, id, scope) {
        return Object.assign({}, entityLoadMeta(entityType, id), { scope });
    }
    EntityScopedLoaderActions.entityScopedLoadMeta = entityScopedLoadMeta;
    /**
     * @param {?} entityType
     * @param {?} id
     * @param {?=} scope
     * @param {?=} error
     * @return {?}
     */
    function entityScopedFailMeta(entityType, id, scope, error) {
        return Object.assign({}, entityFailMeta(entityType, id, error), { scope });
    }
    EntityScopedLoaderActions.entityScopedFailMeta = entityScopedFailMeta;
    /**
     * @param {?} entityType
     * @param {?} id
     * @param {?=} scope
     * @return {?}
     */
    function entityScopedSuccessMeta(entityType, id, scope) {
        return Object.assign({}, entitySuccessMeta(entityType, id), { scope });
    }
    EntityScopedLoaderActions.entityScopedSuccessMeta = entityScopedSuccessMeta;
    /**
     * @param {?} entityType
     * @param {?} id
     * @param {?=} scope
     * @return {?}
     */
    function entityScopedResetMeta(entityType, id, scope) {
        return Object.assign({}, entityResetMeta(entityType, id), { scope });
    }
    EntityScopedLoaderActions.entityScopedResetMeta = entityScopedResetMeta;
    class EntityScopedLoadAction {
        /**
         * @param {?} entityType
         * @param {?} id
         * @param {?=} scope
         */
        constructor(entityType, id, scope) {
            this.type = ENTITY_LOAD_ACTION;
            this.meta = entityScopedLoadMeta(entityType, id, scope);
        }
    }
    EntityScopedLoaderActions.EntityScopedLoadAction = EntityScopedLoadAction;
    if (false) {
        /** @type {?} */
        EntityScopedLoadAction.prototype.type;
        /** @type {?} */
        EntityScopedLoadAction.prototype.meta;
    }
    class EntityScopedFailAction {
        /**
         * @param {?} entityType
         * @param {?} id
         * @param {?=} scope
         * @param {?=} error
         */
        constructor(entityType, id, scope, error) {
            this.type = ENTITY_FAIL_ACTION;
            this.meta = entityScopedFailMeta(entityType, id, scope, error);
        }
    }
    EntityScopedLoaderActions.EntityScopedFailAction = EntityScopedFailAction;
    if (false) {
        /** @type {?} */
        EntityScopedFailAction.prototype.type;
        /** @type {?} */
        EntityScopedFailAction.prototype.meta;
    }
    class EntityScopedSuccessAction {
        /**
         * @param {?} entityType
         * @param {?} id
         * @param {?=} scope
         * @param {?=} payload
         */
        constructor(entityType, id, scope, payload) {
            this.payload = payload;
            this.type = ENTITY_SUCCESS_ACTION;
            this.meta = entityScopedSuccessMeta(entityType, id, scope);
        }
    }
    EntityScopedLoaderActions.EntityScopedSuccessAction = EntityScopedSuccessAction;
    if (false) {
        /** @type {?} */
        EntityScopedSuccessAction.prototype.type;
        /** @type {?} */
        EntityScopedSuccessAction.prototype.meta;
        /** @type {?} */
        EntityScopedSuccessAction.prototype.payload;
    }
    class EntityScopedResetAction {
        /**
         * @param {?} entityType
         * @param {?} id
         * @param {?=} scope
         */
        constructor(entityType, id, scope) {
            this.type = ENTITY_RESET_ACTION;
            this.meta = entityScopedResetMeta(entityType, id, scope);
        }
    }
    EntityScopedLoaderActions.EntityScopedResetAction = EntityScopedResetAction;
    if (false) {
        /** @type {?} */
        EntityScopedResetAction.prototype.type;
        /** @type {?} */
        EntityScopedResetAction.prototype.meta;
    }
})(EntityScopedLoaderActions || (EntityScopedLoaderActions = {}));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const LOAD_PRODUCT = '[Product] Load Product Data';
/** @type {?} */
const LOAD_PRODUCT_FAIL = '[Product] Load Product Data Fail';
/** @type {?} */
const LOAD_PRODUCT_SUCCESS = '[Product] Load Product Data Success';
/**
 * @record
 */
function ProductMeta() { }
if (false) {
    /** @type {?|undefined} */
    ProductMeta.prototype.scope;
}
/**
 * @record
 */
function EntityScopedLoaderAction() { }
if (false) {
    /** @type {?|undefined} */
    EntityScopedLoaderAction.prototype.payload;
    /** @type {?|undefined} */
    EntityScopedLoaderAction.prototype.meta;
}
class LoadProduct extends EntityScopedLoaderActions.EntityScopedLoadAction {
    /**
     * @param {?} payload
     * @param {?=} scope
     */
    constructor(payload, scope = '') {
        super(PRODUCT_DETAIL_ENTITY, payload, scope);
        this.payload = payload;
        this.type = LOAD_PRODUCT;
    }
}
if (false) {
    /** @type {?} */
    LoadProduct.prototype.type;
    /** @type {?} */
    LoadProduct.prototype.payload;
}
class LoadProductFail extends EntityScopedLoaderActions.EntityScopedFailAction {
    /**
     * @param {?} productCode
     * @param {?} payload
     * @param {?=} scope
     */
    constructor(productCode, payload, scope = '') {
        super(PRODUCT_DETAIL_ENTITY, productCode, scope, payload);
        this.payload = payload;
        this.type = LOAD_PRODUCT_FAIL;
    }
}
if (false) {
    /** @type {?} */
    LoadProductFail.prototype.type;
    /** @type {?} */
    LoadProductFail.prototype.payload;
}
class LoadProductSuccess extends EntityScopedLoaderActions.EntityScopedSuccessAction {
    /**
     * @param {?} payload
     * @param {?=} scope
     */
    constructor(payload, scope = '') {
        super(PRODUCT_DETAIL_ENTITY, payload.code, scope);
        this.payload = payload;
        this.type = LOAD_PRODUCT_SUCCESS;
    }
}
if (false) {
    /** @type {?} */
    LoadProductSuccess.prototype.type;
    /** @type {?} */
    LoadProductSuccess.prototype.payload;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

var productGroup_actions = /*#__PURE__*/Object.freeze({
    LOAD_PRODUCT_REFERENCES: LOAD_PRODUCT_REFERENCES,
    LOAD_PRODUCT_REFERENCES_FAIL: LOAD_PRODUCT_REFERENCES_FAIL,
    LOAD_PRODUCT_REFERENCES_SUCCESS: LOAD_PRODUCT_REFERENCES_SUCCESS,
    CLEAN_PRODUCT_REFERENCES: CLEAN_PRODUCT_REFERENCES,
    LoadProductReferences: LoadProductReferences,
    LoadProductReferencesFail: LoadProductReferencesFail,
    LoadProductReferencesSuccess: LoadProductReferencesSuccess,
    CleanProductReferences: CleanProductReferences,
    LOAD_PRODUCT_REVIEWS: LOAD_PRODUCT_REVIEWS,
    LOAD_PRODUCT_REVIEWS_FAIL: LOAD_PRODUCT_REVIEWS_FAIL,
    LOAD_PRODUCT_REVIEWS_SUCCESS: LOAD_PRODUCT_REVIEWS_SUCCESS,
    POST_PRODUCT_REVIEW: POST_PRODUCT_REVIEW,
    POST_PRODUCT_REVIEW_FAIL: POST_PRODUCT_REVIEW_FAIL,
    POST_PRODUCT_REVIEW_SUCCESS: POST_PRODUCT_REVIEW_SUCCESS,
    LoadProductReviews: LoadProductReviews,
    LoadProductReviewsFail: LoadProductReviewsFail,
    LoadProductReviewsSuccess: LoadProductReviewsSuccess,
    PostProductReview: PostProductReview,
    PostProductReviewFail: PostProductReviewFail,
    PostProductReviewSuccess: PostProductReviewSuccess,
    SEARCH_PRODUCTS: SEARCH_PRODUCTS,
    SEARCH_PRODUCTS_FAIL: SEARCH_PRODUCTS_FAIL,
    SEARCH_PRODUCTS_SUCCESS: SEARCH_PRODUCTS_SUCCESS,
    GET_PRODUCT_SUGGESTIONS: GET_PRODUCT_SUGGESTIONS,
    GET_PRODUCT_SUGGESTIONS_SUCCESS: GET_PRODUCT_SUGGESTIONS_SUCCESS,
    GET_PRODUCT_SUGGESTIONS_FAIL: GET_PRODUCT_SUGGESTIONS_FAIL,
    CLEAR_PRODUCT_SEARCH_RESULT: CLEAR_PRODUCT_SEARCH_RESULT,
    SearchProducts: SearchProducts,
    SearchProductsFail: SearchProductsFail,
    SearchProductsSuccess: SearchProductsSuccess,
    GetProductSuggestions: GetProductSuggestions,
    GetProductSuggestionsSuccess: GetProductSuggestionsSuccess,
    GetProductSuggestionsFail: GetProductSuggestionsFail,
    ClearProductSearchResult: ClearProductSearchResult,
    LOAD_PRODUCT: LOAD_PRODUCT,
    LOAD_PRODUCT_FAIL: LOAD_PRODUCT_FAIL,
    LOAD_PRODUCT_SUCCESS: LOAD_PRODUCT_SUCCESS,
    LoadProduct: LoadProduct,
    LoadProductFail: LoadProductFail,
    LoadProductSuccess: LoadProductSuccess
});

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const getProductsState = createFeatureSelector(PRODUCT_FEATURE);

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
const ɵ0$F = /**
 * @param {?} state
 * @return {?}
 */
(state) => state.references;
/** @type {?} */
const getProductReferencesState = createSelector(getProductsState, (ɵ0$F));
/** @type {?} */
const getSelectedProductReferencesFactory = (/**
 * @param {?} productCode
 * @param {?} referenceType
 * @return {?}
 */
(productCode, referenceType) => {
    return createSelector(getProductReferencesState, (/**
     * @param {?} referenceTypeData
     * @return {?}
     */
    referenceTypeData => {
        if (referenceTypeData.productCode === productCode) {
            if (!!referenceTypeData.list) {
                if (referenceType) {
                    return referenceTypeData.list.filter((/**
                     * @param {?} item
                     * @return {?}
                     */
                    item => item.referenceType === referenceType));
                }
                return referenceTypeData.list;
            }
            else {
                return [];
            }
        }
    }));
});

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
const ɵ0$G = /**
 * @param {?} state
 * @return {?}
 */
(state) => state.reviews;
/** @type {?} */
const getProductReviewsState = createSelector(getProductsState, (ɵ0$G));
/** @type {?} */
const getSelectedProductReviewsFactory = (/**
 * @param {?} productCode
 * @return {?}
 */
(productCode) => {
    return createSelector(getProductReviewsState, (/**
     * @param {?} reviewData
     * @return {?}
     */
    reviewData => {
        if (reviewData.productCode === productCode) {
            return reviewData.list;
        }
    }));
});

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const initialState$i = {
    results: {},
    suggestions: [],
    auxResults: {},
};
/**
 * @param {?=} state
 * @param {?=} action
 * @return {?}
 */
function reducer$i(state = initialState$i, action) {
    switch (action.type) {
        case SEARCH_PRODUCTS_SUCCESS: {
            /** @type {?} */
            const results = action.payload;
            /** @type {?} */
            const res = action.auxiliary ? { auxResults: results } : { results };
            return Object.assign({}, state, res);
        }
        case GET_PRODUCT_SUGGESTIONS_SUCCESS: {
            /** @type {?} */
            const suggestions = action.payload;
            return Object.assign({}, state, { suggestions });
        }
        case CLEAR_PRODUCT_SEARCH_RESULT: {
            return Object.assign({}, state, { results: action.payload.clearPageResults ? {} : state.results, suggestions: action.payload.clearSearchboxResults
                    ? []
                    : state.suggestions, auxResults: action.payload.clearSearchboxResults
                    ? {}
                    : state.auxResults });
        }
    }
    return state;
}
/** @type {?} */
const getSearchResults = (/**
 * @param {?} state
 * @return {?}
 */
(state) => state.results);
/** @type {?} */
const getAuxSearchResults = (/**
 * @param {?} state
 * @return {?}
 */
(state) => state.auxResults);
/** @type {?} */
const getProductSuggestions = (/**
 * @param {?} state
 * @return {?}
 */
(state) => state.suggestions);

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
const ɵ0$H = /**
 * @param {?} state
 * @return {?}
 */
(state) => state.search;
/** @type {?} */
const getProductsSearchState = createSelector(getProductsState, (ɵ0$H));
/** @type {?} */
const getSearchResults$1 = createSelector(getProductsSearchState, getSearchResults);
/** @type {?} */
const getAuxSearchResults$1 = createSelector(getProductsSearchState, getAuxSearchResults);
/** @type {?} */
const getProductSuggestions$1 = createSelector(getProductsSearchState, getProductSuggestions);

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
const ɵ0$I = /**
 * @param {?} state
 * @return {?}
 */
(state) => state.details;
/** @type {?} */
const getProductState = createSelector(getProductsState, (ɵ0$I));
/** @type {?} */
const getSelectedProductsFactory = (/**
 * @param {?} codes
 * @return {?}
 */
(codes) => {
    return createSelector(getProductState, (/**
     * @param {?} details
     * @return {?}
     */
    (details) => {
        return codes
            .map((/**
         * @param {?} code
         * @return {?}
         */
        code => details.entities[code] ? details.entities[code].value : undefined))
            .filter((/**
         * @param {?} product
         * @return {?}
         */
        product => product !== undefined));
    }));
});
/** @type {?} */
const getSelectedProductStateFactory = (/**
 * @param {?} code
 * @param {?=} scope
 * @return {?}
 */
(code, scope) => {
    return createSelector(getProductState, (/**
     * @param {?} details
     * @return {?}
     */
    details => scope
        ? entityStateSelector(details, code)[scope] || initialLoaderState
        : entityStateSelector(details, code)));
});
/** @type {?} */
const getSelectedProductFactory = (/**
 * @param {?} code
 * @param {?=} scope
 * @return {?}
 */
(code, scope) => {
    return createSelector(getSelectedProductStateFactory(code, scope), (/**
     * @param {?} productState
     * @return {?}
     */
    productState => loaderValueSelector(productState)));
});
/** @type {?} */
const getSelectedProductLoadingFactory = (/**
 * @param {?} code
 * @param {?=} scope
 * @return {?}
 */
(code, scope) => {
    return createSelector(getSelectedProductStateFactory(code, scope), (/**
     * @param {?} productState
     * @return {?}
     */
    productState => loaderLoadingSelector(productState)));
});
/** @type {?} */
const getSelectedProductSuccessFactory = (/**
 * @param {?} code
 * @param {?=} scope
 * @return {?}
 */
(code, scope) => {
    return createSelector(getSelectedProductStateFactory(code, scope), (/**
     * @param {?} productState
     * @return {?}
     */
    productState => loaderSuccessSelector(productState)));
});
/** @type {?} */
const getSelectedProductErrorFactory = (/**
 * @param {?} code
 * @param {?=} scope
 * @return {?}
 */
(code, scope) => {
    return createSelector(getSelectedProductStateFactory(code, scope), (/**
     * @param {?} productState
     * @return {?}
     */
    productState => loaderErrorSelector(productState)));
});
const ɵ1$t = /**
 * @param {?} details
 * @return {?}
 */
details => {
    return Object.keys(details.entities);
};
/** @type {?} */
const getAllProductCodes = createSelector(getProductState, (ɵ1$t));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

var productGroup_selectors = /*#__PURE__*/Object.freeze({
    getProductsState: getProductsState,
    getProductReferencesState: getProductReferencesState,
    getSelectedProductReferencesFactory: getSelectedProductReferencesFactory,
    getProductReviewsState: getProductReviewsState,
    getSelectedProductReviewsFactory: getSelectedProductReviewsFactory,
    getProductsSearchState: getProductsSearchState,
    getSearchResults: getSearchResults$1,
    getAuxSearchResults: getAuxSearchResults$1,
    getProductSuggestions: getProductSuggestions$1,
    getProductState: getProductState,
    getSelectedProductsFactory: getSelectedProductsFactory,
    getSelectedProductStateFactory: getSelectedProductStateFactory,
    getSelectedProductFactory: getSelectedProductFactory,
    getSelectedProductLoadingFactory: getSelectedProductLoadingFactory,
    getSelectedProductSuccessFactory: getSelectedProductSuccessFactory,
    getSelectedProductErrorFactory: getSelectedProductErrorFactory,
    getAllProductCodes: getAllProductCodes
});

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ProductReferenceService {
    /**
     * @param {?} store
     */
    constructor(store) {
        this.store = store;
    }
    /**
     * @param {?} productCode
     * @param {?=} referenceType
     * @param {?=} pageSize
     * @return {?}
     */
    get(productCode, referenceType, pageSize) {
        return this.store.pipe(select(getSelectedProductReferencesFactory(productCode, referenceType)), tap((/**
         * @param {?} references
         * @return {?}
         */
        references => {
            if (references === undefined && productCode !== undefined) {
                this.store.dispatch(new LoadProductReferences({
                    productCode,
                    referenceType,
                    pageSize,
                }));
            }
        })));
    }
    /**
     * @return {?}
     */
    cleanReferences() {
        this.store.dispatch(new CleanProductReferences());
    }
}
ProductReferenceService.decorators = [
    { type: Injectable }
];
/** @nocollapse */
ProductReferenceService.ctorParameters = () => [
    { type: Store }
];
if (false) {
    /**
     * @type {?}
     * @protected
     */
    ProductReferenceService.prototype.store;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ProductReviewService {
    /**
     * @param {?} store
     */
    constructor(store) {
        this.store = store;
    }
    /**
     * @param {?} productCode
     * @return {?}
     */
    getByProductCode(productCode) {
        return this.store.pipe(select(getSelectedProductReviewsFactory(productCode)), tap((/**
         * @param {?} reviews
         * @return {?}
         */
        reviews => {
            if (reviews === undefined && productCode !== undefined) {
                this.store.dispatch(new LoadProductReviews(productCode));
            }
        })));
    }
    /**
     * @param {?} productCode
     * @param {?} review
     * @return {?}
     */
    add(productCode, review) {
        this.store.dispatch(new PostProductReview({
            productCode: productCode,
            review,
        }));
    }
}
ProductReviewService.decorators = [
    { type: Injectable }
];
/** @nocollapse */
ProductReviewService.ctorParameters = () => [
    { type: Store }
];
if (false) {
    /**
     * @type {?}
     * @protected
     */
    ProductReviewService.prototype.store;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ProductSearchService {
    /**
     * @param {?} store
     */
    constructor(store) {
        this.store = store;
    }
    /**
     * @param {?} query
     * @param {?=} searchConfig
     * @return {?}
     */
    search(query, searchConfig) {
        this.store.dispatch(new SearchProducts({
            queryText: query,
            searchConfig: searchConfig,
        }));
    }
    /**
     * @return {?}
     */
    getResults() {
        return this.store.pipe(select(getSearchResults$1));
    }
    /**
     * @return {?}
     */
    clearResults() {
        this.store.dispatch(new ClearProductSearchResult({
            clearPageResults: true,
        }));
    }
}
ProductSearchService.decorators = [
    { type: Injectable }
];
/** @nocollapse */
ProductSearchService.ctorParameters = () => [
    { type: Store }
];
if (false) {
    /**
     * @type {?}
     * @protected
     */
    ProductSearchService.prototype.store;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ProductLoadingService {
    /**
     * @param {?} store
     * @param {?} loadingScopes
     * @param {?} actions$
     * @param {?} platformId
     */
    constructor(store, loadingScopes, actions$, platformId) {
        this.store = store;
        this.loadingScopes = loadingScopes;
        this.actions$ = actions$;
        this.platformId = platformId;
        this.products = {};
    }
    /**
     * @param {?} productCode
     * @param {?} scopes
     * @return {?}
     */
    get(productCode, scopes) {
        scopes = this.loadingScopes.expand('product', scopes);
        this.initProductScopes(productCode, scopes);
        return this.products[productCode][this.getScopesIndex(scopes)];
    }
    /**
     * @protected
     * @param {?} productCode
     * @param {?} scopes
     * @return {?}
     */
    initProductScopes(productCode, scopes) {
        if (!this.products[productCode]) {
            this.products[productCode] = {};
        }
        for (const scope of scopes) {
            if (!this.products[productCode][scope]) {
                this.products[productCode][scope] = this.getProductForScope(productCode, scope);
            }
        }
        if (scopes.length > 1) {
            this.products[productCode][this.getScopesIndex(scopes)] = combineLatest(scopes.map((/**
             * @param {?} scope
             * @return {?}
             */
            scope => this.products[productCode][scope]))).pipe(auditTime(0), map((/**
             * @param {?} productParts
             * @return {?}
             */
            productParts => productParts.every(Boolean)
                ? deepMerge({}, ...productParts)
                : undefined)), distinctUntilChanged());
        }
    }
    /**
     * @protected
     * @param {?} scopes
     * @return {?}
     */
    getScopesIndex(scopes) {
        return scopes.join('ɵ');
    }
    /**
     * Creates observable for providing specified product data for the scope
     *
     * @protected
     * @param {?} productCode
     * @param {?} scope
     * @return {?}
     */
    getProductForScope(productCode, scope) {
        /** @type {?} */
        const shouldLoad$ = this.store.pipe(select(getSelectedProductStateFactory(productCode, scope)), map((/**
         * @param {?} productState
         * @return {?}
         */
        productState => !productState.loading && !productState.success && !productState.error)), distinctUntilChanged(), filter((/**
         * @param {?} x
         * @return {?}
         */
        x => x)));
        /** @type {?} */
        const isLoading$ = this.store.pipe(select(getSelectedProductLoadingFactory(productCode, scope)));
        /** @type {?} */
        const productLoadLogic$ = merge(shouldLoad$, ...this.getProductReloadTriggers(productCode, scope)).pipe(debounceTime(0), withLatestFrom(isLoading$), tap((/**
         * @param {?} __0
         * @return {?}
         */
        ([, isLoading]) => {
            if (!isLoading) {
                this.store.dispatch(new LoadProduct(productCode, scope));
            }
        })));
        /** @type {?} */
        const productData$ = this.store.pipe(select(getSelectedProductFactory(productCode, scope)));
        return using((/**
         * @return {?}
         */
        () => productLoadLogic$.subscribe()), (/**
         * @return {?}
         */
        () => productData$)).pipe(shareReplay({ bufferSize: 1, refCount: true }));
    }
    /**
     * Returns reload triggers for product per scope
     *
     * @protected
     * @param {?} productCode
     * @param {?} scope
     * @return {?}
     */
    getProductReloadTriggers(productCode, scope) {
        /** @type {?} */
        const triggers = [];
        // max age trigger add
        /** @type {?} */
        const maxAge = this.loadingScopes.getMaxAge('product', scope);
        if (maxAge && isPlatformBrowser(this.platformId)) {
            // we want to grab load product success and load product fail for this product and scope
            /** @type {?} */
            const loadFinish$ = this.actions$.pipe(filter((/**
             * @param {?} action
             * @return {?}
             */
            (action) => (action.type === LOAD_PRODUCT_SUCCESS ||
                action.type === LOAD_PRODUCT_FAIL) &&
                action.meta.entityId === productCode &&
                action.meta.scope === scope)));
            /** @type {?} */
            const loadStart$ = this.actions$.pipe(ofType(LOAD_PRODUCT), filter((/**
             * @param {?} action
             * @return {?}
             */
            (action) => action.payload === productCode && action.meta.scope === scope)));
            triggers.push(this.getMaxAgeTrigger(loadStart$, loadFinish$, maxAge));
        }
        return triggers;
    }
    /**
     * Generic method that returns stream triggering reload by maxAge
     *
     * Could be refactored to separate service in future to use in other
     * max age reload implementations
     *
     * @private
     * @param {?} loadStart$ Stream that emits on load start
     * @param {?} loadFinish$ Stream that emits on load finish
     * @param {?} maxAge max age
     * @param {?=} scheduler
     * @return {?}
     */
    getMaxAgeTrigger(loadStart$, loadFinish$, maxAge, scheduler) {
        /** @type {?} */
        let timestamp = 0;
        /** @type {?} */
        const now = (/**
         * @return {?}
         */
        () => (scheduler ? scheduler.now() : Date.now()));
        /** @type {?} */
        const timestamp$ = loadFinish$.pipe(tap((/**
         * @return {?}
         */
        () => (timestamp = now()))));
        /** @type {?} */
        const shouldReload$ = defer((/**
         * @return {?}
         */
        () => {
            /** @type {?} */
            const age = now() - timestamp;
            /** @type {?} */
            const timestampRefresh$ = timestamp$.pipe(delay(maxAge, scheduler), mapTo(true), withdrawOn(loadStart$));
            if (age > maxAge) {
                // we should emit first value immediately
                return merge(of(true), timestampRefresh$);
            }
            else if (age === 0) {
                // edge case, we should emit max age timeout after next load success
                // could happen with artificial schedulers
                return timestampRefresh$;
            }
            else {
                // we should emit first value when age will expire
                return merge(of(true).pipe(delay(maxAge - age, scheduler)), timestampRefresh$);
            }
        }));
        return shouldReload$;
    }
}
ProductLoadingService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root',
            },] }
];
/** @nocollapse */
ProductLoadingService.ctorParameters = () => [
    { type: Store },
    { type: LoadingScopesService },
    { type: Actions },
    { type: undefined, decorators: [{ type: Inject, args: [PLATFORM_ID,] }] }
];
/** @nocollapse */ ProductLoadingService.ngInjectableDef = ɵɵdefineInjectable({ factory: function ProductLoadingService_Factory() { return new ProductLoadingService(ɵɵinject(Store), ɵɵinject(LoadingScopesService), ɵɵinject(Actions), ɵɵinject(PLATFORM_ID)); }, token: ProductLoadingService, providedIn: "root" });
if (false) {
    /**
     * @type {?}
     * @protected
     */
    ProductLoadingService.prototype.products;
    /**
     * @type {?}
     * @protected
     */
    ProductLoadingService.prototype.store;
    /**
     * @type {?}
     * @protected
     */
    ProductLoadingService.prototype.loadingScopes;
    /**
     * @type {?}
     * @protected
     */
    ProductLoadingService.prototype.actions$;
    /**
     * @type {?}
     * @protected
     */
    ProductLoadingService.prototype.platformId;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ProductService {
    /**
     * @param {?} store
     * @param {?=} productLoading
     */
    constructor(store, productLoading) {
        this.store = store;
        this.productLoading = productLoading;
        /**
         * @deprecated since 1.4
         */
        this.products = {};
    }
    /**
     * Returns the product observable. The product will be loaded
     * whenever there's no value observed.
     *
     * The underlying product loader ensures that the product is
     * only loaded once, even in case of parallel observers.
     *
     * You should provide product data scope you are interested in to not load all
     * the data if not needed. You can provide more than one scope.
     *
     * @param {?} productCode Product code to load
     * @param {?=} scopes Scope or scopes of the product data
     * @return {?}
     */
    get(productCode, scopes = '') {
        // TODO: Remove, deprecated since 1.4
        if (!this.productLoading) {
            if (!this.products[productCode]) {
                this.products[productCode] = this.store.pipe(select(getSelectedProductStateFactory(productCode)), observeOn(queueScheduler), tap((/**
                 * @param {?} productState
                 * @return {?}
                 */
                productState => {
                    /** @type {?} */
                    const attemptedLoad = productState.loading ||
                        productState.success ||
                        productState.error;
                    if (!attemptedLoad) {
                        this.store.dispatch(new LoadProduct(productCode));
                    }
                })), map((/**
                 * @param {?} productState
                 * @return {?}
                 */
                productState => productState.value)), shareReplay({ bufferSize: 1, refCount: true }));
            }
            return this.products[productCode];
        }
        // END OF (TODO: Remove, deprecated since 1.4)
        return this.productLoading.get(productCode, [].concat(scopes));
    }
    /**
     * Returns boolean observable for product's loading state
     * @param {?} productCode
     * @param {?=} scope
     * @return {?}
     */
    isLoading(productCode, scope = '') {
        return this.store.pipe(select(getSelectedProductLoadingFactory(productCode, scope)));
    }
    /**
     * Returns boolean observable for product's load success state
     * @param {?} productCode
     * @param {?=} scope
     * @return {?}
     */
    isSuccess(productCode, scope = '') {
        return this.store.pipe(select(getSelectedProductSuccessFactory(productCode, scope)));
    }
    /**
     * Returns boolean observable for product's load error state
     * @param {?} productCode
     * @param {?=} scope
     * @return {?}
     */
    hasError(productCode, scope = '') {
        return this.store.pipe(select(getSelectedProductErrorFactory(productCode, scope)));
    }
    /**
     * Reloads the product. The product is loaded implicetly
     * whenever selected by the `get`, but in some cases an
     * explicit reload might be needed.
     * @param {?} productCode
     * @param {?=} scope
     * @return {?}
     */
    reload(productCode, scope = '') {
        this.store.dispatch(new LoadProduct(productCode, scope));
    }
}
ProductService.decorators = [
    { type: Injectable }
];
/** @nocollapse */
ProductService.ctorParameters = () => [
    { type: Store },
    { type: ProductLoadingService }
];
if (false) {
    /**
     * @deprecated since 1.4
     * @type {?}
     * @private
     */
    ProductService.prototype.products;
    /**
     * @type {?}
     * @protected
     */
    ProductService.prototype.store;
    /**
     * @type {?}
     * @protected
     */
    ProductService.prototype.productLoading;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SearchboxService extends ProductSearchService {
    /**
     * dispatch the search for the search box
     * @param {?} query
     * @param {?=} searchConfig
     * @return {?}
     */
    search(query, searchConfig) {
        this.store.dispatch(new SearchProducts({
            queryText: query,
            searchConfig: searchConfig,
        }, true));
    }
    /**
     * @return {?}
     */
    getResults() {
        return this.store.pipe(select(getAuxSearchResults$1));
    }
    /**
     * clears the products and suggestions
     * @return {?}
     */
    clearResults() {
        this.store.dispatch(new ClearProductSearchResult({
            clearSearchboxResults: true,
        }));
    }
    /**
     * @return {?}
     */
    getSuggestionResults() {
        return this.store.pipe(select(getProductSuggestions$1));
    }
    /**
     * @param {?} query
     * @param {?=} searchConfig
     * @return {?}
     */
    searchSuggestions(query, searchConfig) {
        this.store.dispatch(new GetProductSuggestions({
            term: query,
            searchConfig: searchConfig,
        }));
    }
}
SearchboxService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root',
            },] }
];
/** @nocollapse */ SearchboxService.ngInjectableDef = ɵɵdefineInjectable({ factory: function SearchboxService_Factory() { return new SearchboxService(ɵɵinject(Store)); }, token: SearchboxService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @record
 */
function SearchConfig() { }
if (false) {
    /** @type {?|undefined} */
    SearchConfig.prototype.pageSize;
    /** @type {?|undefined} */
    SearchConfig.prototype.currentPage;
    /** @type {?|undefined} */
    SearchConfig.prototype.sortCode;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Resolves the page data for the Product Listing Page
 * based on the `PageType.CATEGORY_PAGE`.
 *
 * The page title, and breadcrumbs are resolved in this implementation only.
 */
class CategoryPageMetaResolver extends PageMetaResolver {
    /**
     * @param {?} routingService
     * @param {?} productSearchService
     * @param {?} cms
     * @param {?} translation
     */
    constructor(routingService, productSearchService, cms, translation) {
        super();
        this.routingService = routingService;
        this.productSearchService = productSearchService;
        this.cms = cms;
        this.translation = translation;
        // reusable observable for search page data
        this.searchPage$ = this.cms.getCurrentPage().pipe(filter(Boolean), switchMap((/**
         * @param {?} page
         * @return {?}
         */
        (page) => 
        // only the existence of a plp component tells us if products
        // are rendered or if this is an ordinary content page
        this.hasProductListComponent(page)
            ? this.productSearchService.getResults().pipe(filter(Boolean))
            : of(page))));
        this.pageType = PageType.CATEGORY_PAGE;
    }
    /**
     * @deprecated since version 1.3
     *
     * The resolve method is no longer preferred and will be removed with release 2.0.
     * The caller `PageMetaService` service is improved to expect all individual resolvers
     * instead, so that the code is easier extensible.
     * @return {?}
     */
    resolve() {
        return this.cms.getCurrentPage().pipe(filter(Boolean), switchMap((/**
         * @param {?} page
         * @return {?}
         */
        (page) => {
            // only the existence of a plp component tells us if products
            // are rendered or if this is an ordinary content page
            if (this.hasProductListComponent(page)) {
                return this.productSearchService.getResults().pipe(filter((/**
                 * @param {?} data
                 * @return {?}
                 */
                data => data.breadcrumbs && data.breadcrumbs.length > 0)), switchMap((/**
                 * @param {?} data
                 * @return {?}
                 */
                data => combineLatest([
                    this.resolveTitle(data),
                    this.resolveBreadcrumbLabel().pipe(switchMap((/**
                     * @param {?} label
                     * @return {?}
                     */
                    label => this.resolveBreadcrumbs(data, label)))),
                ]))), map((/**
                 * @param {?} __0
                 * @return {?}
                 */
                ([title, breadcrumbs]) => ({ title, breadcrumbs }))));
            }
            else {
                return of({
                    title: page.title || page.name,
                });
            }
        })));
    }
    /**
     * @param {?=} searchPage
     * @return {?}
     */
    resolveTitle(searchPage) {
        /** @type {?} */
        const searchPage$ = searchPage ? of(searchPage) : this.searchPage$;
        return searchPage$.pipe(filter((/**
         * @param {?} page
         * @return {?}
         */
        (page) => !!page.pagination)), switchMap((/**
         * @param {?} p
         * @return {?}
         */
        p => this.translation.translate('pageMetaResolver.category.title', {
            count: ((/** @type {?} */ (p))).pagination.totalResults,
            query: ((/** @type {?} */ (p))).breadcrumbs[0].facetValueName,
        }))));
    }
    /**
     * @deprecated since version 1.3
     * This method will removed with with 2.0
     * @return {?}
     */
    resolveBreadcrumbLabel() {
        return this.translation.translate('common.home');
    }
    /**
     * @param {?=} searchPage
     * @param {?=} breadcrumbLabel
     * @return {?}
     */
    resolveBreadcrumbs(searchPage, breadcrumbLabel) {
        /** @type {?} */
        const sources = searchPage && breadcrumbLabel
            ? [of(searchPage), of(breadcrumbLabel)]
            : [this.searchPage$.pipe(), this.translation.translate('common.home')];
        return combineLatest(sources).pipe(map((/**
         * @param {?} __0
         * @return {?}
         */
        ([p, label]) => p.breadcrumbs
            ? this.resolveBreadcrumbData((/** @type {?} */ (p)), label)
            : null)));
    }
    /**
     * @private
     * @param {?} page
     * @param {?} label
     * @return {?}
     */
    resolveBreadcrumbData(page, label) {
        /** @type {?} */
        const breadcrumbs = [];
        breadcrumbs.push({ label: label, link: '/' });
        for (const br of page.breadcrumbs) {
            if (br.facetCode === 'category') {
                breadcrumbs.push({
                    label: br.facetValueName,
                    link: `/c/${br.facetValueCode}`,
                });
            }
            if (br.facetCode === 'brand') {
                breadcrumbs.push({
                    label: br.facetValueName,
                    link: `/Brands/${br.facetValueName}/c/${br.facetValueCode}`,
                });
            }
        }
        return breadcrumbs;
    }
    /**
     * @private
     * @param {?} page
     * @return {?}
     */
    hasProductListComponent(page) {
        return !!Object.keys(page.slots).find((/**
         * @param {?} key
         * @return {?}
         */
        key => !!page.slots[key].components.find((/**
         * @param {?} comp
         * @return {?}
         */
        comp => comp.typeCode === 'CMSProductListComponent' ||
            comp.typeCode === 'ProductGridComponent'))));
    }
}
CategoryPageMetaResolver.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root',
            },] }
];
/** @nocollapse */
CategoryPageMetaResolver.ctorParameters = () => [
    { type: RoutingService },
    { type: ProductSearchService },
    { type: CmsService },
    { type: TranslationService }
];
/** @nocollapse */ CategoryPageMetaResolver.ngInjectableDef = ɵɵdefineInjectable({ factory: function CategoryPageMetaResolver_Factory() { return new CategoryPageMetaResolver(ɵɵinject(RoutingService), ɵɵinject(ProductSearchService), ɵɵinject(CmsService), ɵɵinject(TranslationService)); }, token: CategoryPageMetaResolver, providedIn: "root" });
if (false) {
    /**
     * @type {?}
     * @private
     */
    CategoryPageMetaResolver.prototype.searchPage$;
    /**
     * @type {?}
     * @protected
     */
    CategoryPageMetaResolver.prototype.routingService;
    /**
     * @type {?}
     * @protected
     */
    CategoryPageMetaResolver.prototype.productSearchService;
    /**
     * @type {?}
     * @protected
     */
    CategoryPageMetaResolver.prototype.cms;
    /**
     * @type {?}
     * @protected
     */
    CategoryPageMetaResolver.prototype.translation;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Resolves the page data for the Product Detail Page
 * based on the `PageType.PRODUCT_PAGE`.
 *
 * The page title, heading, description, breadcrumbs and
 * first GALLERY image are resolved if available in the data.
 */
class ProductPageMetaResolver extends PageMetaResolver {
    /**
     * @param {?} routingService
     * @param {?} productService
     * @param {?} translation
     * @param {?=} features
     */
    constructor(routingService, productService, translation, features) {
        super();
        this.routingService = routingService;
        this.productService = productService;
        this.translation = translation;
        this.features = features;
        this.PRODUCT_SCOPE = this.features && this.features.isLevel('1.4') ? ProductScope.DETAILS : '';
        // reusable observable for product data based on the current page
        this.product$ = this.routingService.getRouterState().pipe(map((/**
         * @param {?} state
         * @return {?}
         */
        state => state.state.params['productCode'])), filter((/**
         * @param {?} code
         * @return {?}
         */
        code => !!code)), switchMap((/**
         * @param {?} code
         * @return {?}
         */
        code => this.productService.get(code, this.PRODUCT_SCOPE))), filter(Boolean));
        this.pageType = PageType.PRODUCT_PAGE;
    }
    /**
     * @deprecated since version 1.3
     *
     * The resolve method is no longer preferred and will be removed with release 2.0.
     * The caller `PageMetaService` service is improved to expect all individual resolvers
     * instead, so that the code is easier extensible.
     * @return {?}
     */
    resolve() {
        return this.product$.pipe(switchMap((/**
         * @param {?} p
         * @return {?}
         */
        (p) => combineLatest([
            this.resolveHeading(p),
            this.resolveTitle(p),
            this.resolveDescription(p),
            this.resolveBreadcrumbLabel().pipe(switchMap((/**
             * @param {?} label
             * @return {?}
             */
            label => this.resolveBreadcrumbs(p, label)))),
            this.resolveImage(p),
            this.resolveRobots(p),
        ]))), map((/**
         * @param {?} __0
         * @return {?}
         */
        ([heading, title, description, breadcrumbs, image, robots]) => ({
            heading,
            title,
            description,
            breadcrumbs,
            image,
            robots,
        }))));
    }
    /**
     * @param {?=} product
     * @return {?}
     */
    resolveHeading(product) {
        /** @type {?} */
        const product$ = product ? of(product) : this.product$;
        return product$.pipe(switchMap((/**
         * @param {?} p
         * @return {?}
         */
        (p) => this.translation.translate('pageMetaResolver.product.heading', {
            heading: p.name,
        }))));
    }
    /**
     * @param {?=} product
     * @return {?}
     */
    resolveTitle(product) {
        /** @type {?} */
        const product$ = product ? of(product) : this.product$;
        return product$.pipe(switchMap((/**
         * @param {?} p
         * @return {?}
         */
        (p) => {
            /** @type {?} */
            let title = p.name;
            title += this.resolveFirstCategory(p);
            title += this.resolveManufacturer(p);
            return this.translation.translate('pageMetaResolver.product.title', {
                title: title,
            });
        })));
    }
    /**
     * @param {?=} product
     * @return {?}
     */
    resolveDescription(product) {
        /** @type {?} */
        const product$ = product ? of(product) : this.product$;
        return product$.pipe(switchMap((/**
         * @param {?} p
         * @return {?}
         */
        (p) => this.translation.translate('pageMetaResolver.product.description', {
            description: p.summary,
        }))));
    }
    /**
     * @deprecated since version 1.3
     * This method will be removed with with 2.0
     * @return {?}
     */
    resolveBreadcrumbLabel() {
        return this.translation.translate('common.home');
    }
    /**
     * @param {?=} product
     * @param {?=} breadcrumbLabel
     * @return {?}
     */
    resolveBreadcrumbs(product, breadcrumbLabel) {
        /** @type {?} */
        const sources = product && breadcrumbLabel
            ? [of(product), of(breadcrumbLabel)]
            : [this.product$.pipe(), this.translation.translate('common.home')];
        return combineLatest(sources).pipe(map((/**
         * @param {?} __0
         * @return {?}
         */
        ([p, label]) => {
            /** @type {?} */
            const breadcrumbs = [];
            breadcrumbs.push({ label: label, link: '/' });
            for (const { name, code, url } of p.categories || []) {
                breadcrumbs.push({
                    label: name || code,
                    link: url,
                });
            }
            return breadcrumbs;
        })));
    }
    /**
     * @param {?=} product
     * @return {?}
     */
    resolveImage(product) {
        /** @type {?} */
        const product$ = product ? of(product) : this.product$;
        return product$.pipe(map((/**
         * @param {?} p
         * @return {?}
         */
        (p) => p.images &&
            p.images.PRIMARY &&
            ((/** @type {?} */ (p.images.PRIMARY))).zoom &&
            ((/** @type {?} */ (p.images.PRIMARY))).zoom.url
            ? ((/** @type {?} */ (p.images.PRIMARY))).zoom.url
            : null)));
    }
    /**
     * @private
     * @param {?} product
     * @return {?}
     */
    resolveFirstCategory(product) {
        /** @type {?} */
        let firstCategory;
        if (product.categories && product.categories.length > 0) {
            firstCategory = product.categories[0];
        }
        return firstCategory
            ? ` | ${firstCategory.name || firstCategory.code}`
            : '';
    }
    /**
     * @private
     * @param {?} product
     * @return {?}
     */
    resolveManufacturer(product) {
        return product.manufacturer ? ` | ${product.manufacturer}` : '';
    }
    /**
     * @param {?=} product
     * @return {?}
     */
    resolveRobots(product) {
        /** @type {?} */
        const product$ = product ? of(product) : this.product$;
        return product$.pipe(switchMap((/**
         * @param {?} p
         * @return {?}
         */
        (p) => {
            if (!p.purchasable) {
                return of([PageRobotsMeta.FOLLOW, PageRobotsMeta.NOINDEX]);
            }
            else {
                return of([PageRobotsMeta.FOLLOW, PageRobotsMeta.INDEX]);
            }
        })));
    }
}
ProductPageMetaResolver.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root',
            },] }
];
/** @nocollapse */
ProductPageMetaResolver.ctorParameters = () => [
    { type: RoutingService },
    { type: ProductService },
    { type: TranslationService },
    { type: FeatureConfigService }
];
/** @nocollapse */ ProductPageMetaResolver.ngInjectableDef = ɵɵdefineInjectable({ factory: function ProductPageMetaResolver_Factory() { return new ProductPageMetaResolver(ɵɵinject(RoutingService), ɵɵinject(ProductService), ɵɵinject(TranslationService), ɵɵinject(FeatureConfigService)); }, token: ProductPageMetaResolver, providedIn: "root" });
if (false) {
    /**
     * @type {?}
     * @protected
     */
    ProductPageMetaResolver.prototype.PRODUCT_SCOPE;
    /**
     * @type {?}
     * @private
     */
    ProductPageMetaResolver.prototype.product$;
    /**
     * @type {?}
     * @protected
     */
    ProductPageMetaResolver.prototype.routingService;
    /**
     * @type {?}
     * @protected
     */
    ProductPageMetaResolver.prototype.productService;
    /**
     * @type {?}
     * @protected
     */
    ProductPageMetaResolver.prototype.translation;
    /**
     * @type {?}
     * @protected
     */
    ProductPageMetaResolver.prototype.features;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Resolves the page data for the Search Result Page based on the
 * `PageType.CATEGORY_PAGE` and the `SearchResultsListPageTemplate` template.
 *
 * Only the page title is resolved in the implemenation.
 */
class SearchPageMetaResolver extends PageMetaResolver {
    /**
     * @param {?} routingService
     * @param {?} productSearchService
     * @param {?} translation
     */
    constructor(routingService, productSearchService, translation) {
        super();
        this.routingService = routingService;
        this.productSearchService = productSearchService;
        this.translation = translation;
        this.total$ = this.productSearchService.getResults().pipe(filter((/**
         * @param {?} data
         * @return {?}
         */
        data => !!(data && data.pagination))), map((/**
         * @param {?} results
         * @return {?}
         */
        results => results.pagination.totalResults)));
        this.query$ = this.routingService
            .getRouterState()
            .pipe(map((/**
         * @param {?} state
         * @return {?}
         */
        state => state.state.params['query'])));
        this.pageType = PageType.CONTENT_PAGE;
        this.pageTemplate = 'SearchResultsListPageTemplate';
    }
    /**
     * @deprecated since version 1.3
     *
     * The resolve method is no longer preferred and will be removed with release 2.0.
     * The caller `PageMetaService` service is improved to expect all individual resolvers
     * instead, so that the code is easier extensible.
     * @return {?}
     */
    resolve() {
        return this.resolveTitle();
    }
    /**
     * @param {?=} total
     * @param {?=} query
     * @return {?}
     */
    resolveTitle(total, query) {
        /** @type {?} */
        const sources = total && query ? [of(total), of(query)] : [this.total$, this.query$];
        return combineLatest(sources).pipe(switchMap((/**
         * @param {?} __0
         * @return {?}
         */
        ([t, q]) => this.translation.translate('pageMetaResolver.search.title', {
            count: t,
            query: q,
        }))));
    }
}
SearchPageMetaResolver.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root',
            },] }
];
/** @nocollapse */
SearchPageMetaResolver.ctorParameters = () => [
    { type: RoutingService },
    { type: ProductSearchService },
    { type: TranslationService }
];
/** @nocollapse */ SearchPageMetaResolver.ngInjectableDef = ɵɵdefineInjectable({ factory: function SearchPageMetaResolver_Factory() { return new SearchPageMetaResolver(ɵɵinject(RoutingService), ɵɵinject(ProductSearchService), ɵɵinject(TranslationService)); }, token: SearchPageMetaResolver, providedIn: "root" });
if (false) {
    /** @type {?} */
    SearchPageMetaResolver.prototype.total$;
    /** @type {?} */
    SearchPageMetaResolver.prototype.query$;
    /**
     * @type {?}
     * @protected
     */
    SearchPageMetaResolver.prototype.routingService;
    /**
     * @type {?}
     * @protected
     */
    SearchPageMetaResolver.prototype.productSearchService;
    /**
     * @type {?}
     * @protected
     */
    SearchPageMetaResolver.prototype.translation;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ProductReferencesEffects {
    /**
     * @param {?} actions$
     * @param {?} productReferencesConnector
     */
    constructor(actions$, productReferencesConnector) {
        this.actions$ = actions$;
        this.productReferencesConnector = productReferencesConnector;
        this.loadProductReferences$ = this.actions$.pipe(ofType(LOAD_PRODUCT_REFERENCES), map((/**
         * @param {?} action
         * @return {?}
         */
        (action) => action.payload)), mergeMap((/**
         * @param {?} payload
         * @return {?}
         */
        payload => {
            return this.productReferencesConnector
                .get(payload.productCode, payload.referenceType, payload.pageSize)
                .pipe(map((/**
             * @param {?} data
             * @return {?}
             */
            data => {
                return new LoadProductReferencesSuccess({
                    productCode: payload.productCode,
                    list: data,
                });
            })), catchError((/**
             * @param {?} _error
             * @return {?}
             */
            _error => of(new LoadProductReferencesFail((/** @type {?} */ ({
                message: payload.productCode,
            })))))));
        })));
    }
}
ProductReferencesEffects.decorators = [
    { type: Injectable }
];
/** @nocollapse */
ProductReferencesEffects.ctorParameters = () => [
    { type: Actions },
    { type: ProductReferencesConnector }
];
__decorate([
    Effect(),
    __metadata("design:type", Observable)
], ProductReferencesEffects.prototype, "loadProductReferences$", void 0);
if (false) {
    /** @type {?} */
    ProductReferencesEffects.prototype.loadProductReferences$;
    /**
     * @type {?}
     * @private
     */
    ProductReferencesEffects.prototype.actions$;
    /**
     * @type {?}
     * @private
     */
    ProductReferencesEffects.prototype.productReferencesConnector;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ProductReviewsEffects {
    /**
     * @param {?} actions$
     * @param {?} productReviewsConnector
     * @param {?} globalMessageService
     */
    constructor(actions$, productReviewsConnector, globalMessageService) {
        this.actions$ = actions$;
        this.productReviewsConnector = productReviewsConnector;
        this.globalMessageService = globalMessageService;
        this.loadProductReviews$ = this.actions$.pipe(ofType(LOAD_PRODUCT_REVIEWS), map((/**
         * @param {?} action
         * @return {?}
         */
        (action) => action.payload)), mergeMap((/**
         * @param {?} productCode
         * @return {?}
         */
        productCode => {
            return this.productReviewsConnector.get(productCode).pipe(map((/**
             * @param {?} data
             * @return {?}
             */
            data => {
                return new LoadProductReviewsSuccess({
                    productCode,
                    list: data,
                });
            })), catchError((/**
             * @param {?} _error
             * @return {?}
             */
            _error => of(new LoadProductReviewsFail((/** @type {?} */ ({
                message: productCode,
            })))))));
        })));
        this.postProductReview = this.actions$.pipe(ofType(POST_PRODUCT_REVIEW), map((/**
         * @param {?} action
         * @return {?}
         */
        (action) => action.payload)), mergeMap((/**
         * @param {?} payload
         * @return {?}
         */
        payload => {
            return this.productReviewsConnector
                .add(payload.productCode, payload.review)
                .pipe(map((/**
             * @param {?} reviewResponse
             * @return {?}
             */
            reviewResponse => {
                return new PostProductReviewSuccess(reviewResponse);
            })), catchError((/**
             * @param {?} _error
             * @return {?}
             */
            _error => of(new PostProductReviewFail(payload.productCode)))));
        })));
        this.showGlobalMessageOnPostProductReviewSuccess$ = this.actions$.pipe(ofType(POST_PRODUCT_REVIEW_SUCCESS), tap((/**
         * @return {?}
         */
        () => {
            this.globalMessageService.add({ key: 'productReview.thankYouForReview' }, GlobalMessageType.MSG_TYPE_CONFIRMATION);
        })));
    }
}
ProductReviewsEffects.decorators = [
    { type: Injectable }
];
/** @nocollapse */
ProductReviewsEffects.ctorParameters = () => [
    { type: Actions },
    { type: ProductReviewsConnector },
    { type: GlobalMessageService }
];
__decorate([
    Effect(),
    __metadata("design:type", Observable)
], ProductReviewsEffects.prototype, "loadProductReviews$", void 0);
__decorate([
    Effect(),
    __metadata("design:type", Observable)
], ProductReviewsEffects.prototype, "postProductReview", void 0);
__decorate([
    Effect({ dispatch: false }),
    __metadata("design:type", Object)
], ProductReviewsEffects.prototype, "showGlobalMessageOnPostProductReviewSuccess$", void 0);
if (false) {
    /** @type {?} */
    ProductReviewsEffects.prototype.loadProductReviews$;
    /** @type {?} */
    ProductReviewsEffects.prototype.postProductReview;
    /** @type {?} */
    ProductReviewsEffects.prototype.showGlobalMessageOnPostProductReviewSuccess$;
    /**
     * @type {?}
     * @private
     */
    ProductReviewsEffects.prototype.actions$;
    /**
     * @type {?}
     * @private
     */
    ProductReviewsEffects.prototype.productReviewsConnector;
    /**
     * @type {?}
     * @private
     */
    ProductReviewsEffects.prototype.globalMessageService;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ProductsSearchEffects {
    /**
     * @param {?} actions$
     * @param {?} productSearchConnector
     */
    constructor(actions$, productSearchConnector) {
        this.actions$ = actions$;
        this.productSearchConnector = productSearchConnector;
        this.searchProducts$ = this.actions$.pipe(ofType(SEARCH_PRODUCTS), groupBy((/**
         * @param {?} action
         * @return {?}
         */
        (action) => action.auxiliary)), mergeMap((/**
         * @param {?} group
         * @return {?}
         */
        group => group.pipe(switchMap((/**
         * @param {?} action
         * @return {?}
         */
        (action) => {
            return this.productSearchConnector
                .search(action.payload.queryText, action.payload.searchConfig)
                .pipe(map((/**
             * @param {?} data
             * @return {?}
             */
            data => {
                return new SearchProductsSuccess(data, action.auxiliary);
            })), catchError((/**
             * @param {?} error
             * @return {?}
             */
            error => of(new SearchProductsFail(makeErrorSerializable(error), action.auxiliary)))));
        }))))));
        this.getProductSuggestions$ = this.actions$.pipe(ofType(GET_PRODUCT_SUGGESTIONS), map((/**
         * @param {?} action
         * @return {?}
         */
        (action) => action.payload)), switchMap((/**
         * @param {?} payload
         * @return {?}
         */
        payload => {
            return this.productSearchConnector
                .getSuggestions(payload.term, payload.searchConfig.pageSize)
                .pipe(map((/**
             * @param {?} suggestions
             * @return {?}
             */
            suggestions => {
                if (suggestions === undefined) {
                    return new GetProductSuggestionsSuccess([]);
                }
                return new GetProductSuggestionsSuccess(suggestions);
            })), catchError((/**
             * @param {?} error
             * @return {?}
             */
            error => of(new GetProductSuggestionsFail(makeErrorSerializable(error))))));
        })));
    }
}
ProductsSearchEffects.decorators = [
    { type: Injectable }
];
/** @nocollapse */
ProductsSearchEffects.ctorParameters = () => [
    { type: Actions },
    { type: ProductSearchConnector }
];
__decorate([
    Effect(),
    __metadata("design:type", Observable)
], ProductsSearchEffects.prototype, "searchProducts$", void 0);
__decorate([
    Effect(),
    __metadata("design:type", Observable)
], ProductsSearchEffects.prototype, "getProductSuggestions$", void 0);
if (false) {
    /** @type {?} */
    ProductsSearchEffects.prototype.searchProducts$;
    /** @type {?} */
    ProductsSearchEffects.prototype.getProductSuggestions$;
    /**
     * @type {?}
     * @private
     */
    ProductsSearchEffects.prototype.actions$;
    /**
     * @type {?}
     * @private
     */
    ProductsSearchEffects.prototype.productSearchConnector;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ProductEffects {
    /**
     * @param {?} actions$
     * @param {?} productConnector
     */
    constructor(actions$, productConnector) {
        this.actions$ = actions$;
        this.productConnector = productConnector;
        // we want to cancel all ongoing requests when currency or language changes,
        this.contextChange$ = this.actions$.pipe(ofType(CURRENCY_CHANGE, LANGUAGE_CHANGE));
        this.loadProduct$ = createEffect((/**
         * @return {?}
         */
        () => (/**
         * @param {?=} __0
         * @return {?}
         */
        ({ scheduler, debounce = 0 } = {}) => this.actions$.pipe(ofType(LOAD_PRODUCT), map((/**
         * @param {?} action
         * @return {?}
         */
        (action) => ({
            code: action.payload,
            scope: action.meta.scope,
        }))), 
        // we are grouping all load actions that happens at the same time
        // to optimize loading and pass them all to productConnector.getMany
        bufferDebounceTime(debounce, scheduler), mergeMap((/**
         * @param {?} products
         * @return {?}
         */
        products => merge(...this.productConnector
            .getMany(products)
            .map(this.productLoadEffect)))), withdrawOn(this.contextChange$)))));
    }
    /**
     * @private
     * @param {?} productLoad
     * @return {?}
     */
    productLoadEffect(productLoad) {
        return productLoad.data$.pipe(map((/**
         * @param {?} data
         * @return {?}
         */
        data => new LoadProductSuccess(Object.assign({ code: productLoad.code }, data), productLoad.scope))), catchError((/**
         * @param {?} error
         * @return {?}
         */
        error => {
            return of(new LoadProductFail(productLoad.code, makeErrorSerializable(error), productLoad.scope));
        })));
    }
}
ProductEffects.decorators = [
    { type: Injectable }
];
/** @nocollapse */
ProductEffects.ctorParameters = () => [
    { type: Actions },
    { type: ProductConnector }
];
if (false) {
    /**
     * @type {?}
     * @private
     */
    ProductEffects.prototype.contextChange$;
    /** @type {?} */
    ProductEffects.prototype.loadProduct$;
    /**
     * @type {?}
     * @private
     */
    ProductEffects.prototype.actions$;
    /**
     * @type {?}
     * @private
     */
    ProductEffects.prototype.productConnector;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const effects$a = [
    ProductsSearchEffects,
    ProductEffects,
    ProductReviewsEffects,
    ProductReferencesEffects,
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const initialState$j = {
    productCode: '',
    list: [],
};
/**
 * @param {?=} state
 * @param {?=} action
 * @return {?}
 */
function reducer$j(state = initialState$j, action) {
    switch (action.type) {
        case LOAD_PRODUCT_REFERENCES_SUCCESS: {
            /** @type {?} */
            const productCode = action.payload.productCode;
            /** @type {?} */
            const list = action.payload.list;
            return Object.assign({}, state, { list: [...state.list, ...(list ? list : [])].reduce((/**
                 * @param {?} productReferences
                 * @param {?} productReference
                 * @return {?}
                 */
                (productReferences, productReference) => {
                    if (!productReferences.some((/**
                     * @param {?} obj
                     * @return {?}
                     */
                    obj => obj.referenceType === productReference.referenceType &&
                        obj.target.code === productReference.target.code))) {
                        productReferences.push(productReference);
                    }
                    return productReferences;
                }), []), productCode });
        }
        case CLEAN_PRODUCT_REFERENCES: {
            return initialState$j;
        }
    }
    return state;
}
/** @type {?} */
const getProductReferenceList = (/**
 * @param {?} state
 * @return {?}
 */
(state) => state.list);
/** @type {?} */
const getProductReferenceProductCode = (/**
 * @param {?} state
 * @return {?}
 */
(state) => state.productCode);

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const initialState$k = {
    productCode: '',
    list: [],
};
/**
 * @param {?=} state
 * @param {?=} action
 * @return {?}
 */
function reducer$k(state = initialState$k, action) {
    switch (action.type) {
        case LOAD_PRODUCT_REVIEWS_SUCCESS: {
            /** @type {?} */
            const productCode = action.payload.productCode;
            /** @type {?} */
            const list = action.payload.list;
            return Object.assign({}, state, { productCode,
                list });
        }
    }
    return state;
}
/** @type {?} */
const getReviewList = (/**
 * @param {?} state
 * @return {?}
 */
(state) => state.list);
/** @type {?} */
const getReviewProductCode = (/**
 * @param {?} state
 * @return {?}
 */
(state) => state.productCode);

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Higher order reducer designed to add scope support for loader reducer
 *
 * For backward compatibility, we accommodate scopes alongside current
 * loading/error/success/value flags, thus those names can't be used as scope
 * names.
 *
 * TODO: Improve, issue #5445
 *
 * @template T
 * @param {?} entityType
 * @param {?=} reducer
 * @return {?}
 */
function scopedLoaderReducer(entityType, reducer) {
    /** @type {?} */
    const loader = loaderReducer(entityType, reducer);
    return (/**
     * @param {?=} state
     * @param {?=} action
     * @return {?}
     */
    (state = initialLoaderState, action) => {
        if (action &&
            action.meta &&
            action.meta.entityType === entityType &&
            action.meta.scope) {
            return Object.assign({}, state, { [action.meta.scope]: loader(state[action.meta.scope], action) });
        }
        else {
            return loader(state, action);
        }
    });
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Higher order reducer that wraps scopedLoaderReducer and EntityReducer enhancing
 * single state reducer to support multiple entities with generic loading flags and scopes
 * @template T
 * @param {?} entityType
 * @param {?=} reducer
 * @return {?}
 */
function entityScopedLoaderReducer(entityType, reducer) {
    return entityReducer(entityType, scopedLoaderReducer(entityType, reducer));
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @return {?}
 */
function getReducers$b() {
    return {
        search: reducer$i,
        details: entityScopedLoaderReducer(PRODUCT_DETAIL_ENTITY),
        reviews: reducer$k,
        references: reducer$j,
    };
}
/** @type {?} */
const reducerToken$b = new InjectionToken('ProductReducers');
/** @type {?} */
const reducerProvider$b = {
    provide: reducerToken$b,
    useFactory: getReducers$b,
};
/**
 * @param {?} reducer
 * @return {?}
 */
function clearProductsState(reducer) {
    return (/**
     * @param {?} state
     * @param {?} action
     * @return {?}
     */
    function (state, action) {
        if (action.type === CURRENCY_CHANGE ||
            action.type === LANGUAGE_CHANGE) {
            state = undefined;
        }
        return reducer(state, action);
    });
}
/** @type {?} */
const metaReducers$6 = [clearProductsState];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @return {?}
 */
function productStoreConfigFactory() {
    // if we want to reuse PRODUCT_FEATURE const in config, we have to use factory instead of plain object
    /** @type {?} */
    const config = {
        state: {
            ssrTransfer: {
                keys: { [PRODUCT_FEATURE]: StateTransferType.TRANSFER_STATE },
            },
        },
    };
    return config;
}
class ProductStoreModule {
}
ProductStoreModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    HttpClientModule,
                    StoreModule.forFeature(PRODUCT_FEATURE, reducerToken$b, { metaReducers: metaReducers$6 }),
                    EffectsModule.forFeature(effects$a),
                    ConfigModule.withConfigFactory(productStoreConfigFactory),
                ],
                providers: [reducerProvider$b],
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const pageTitleResolvers = [
    {
        provide: PageMetaResolver,
        useExisting: ProductPageMetaResolver,
        multi: true,
    },
    {
        provide: PageMetaResolver,
        useExisting: CategoryPageMetaResolver,
        multi: true,
    },
    {
        provide: PageMetaResolver,
        useExisting: SearchPageMetaResolver,
        multi: true,
    },
];
class ProductModule {
    /**
     * @return {?}
     */
    static forRoot() {
        return {
            ngModule: ProductModule,
            providers: [
                ProductService,
                ProductSearchService,
                ProductReviewService,
                ProductReferenceService,
                ...pageTitleResolvers,
            ],
        };
    }
}
ProductModule.decorators = [
    { type: NgModule, args: [{
                imports: [ProductStoreModule],
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SmartEditService {
    /**
     * @param {?} cmsService
     * @param {?} routingService
     * @param {?} baseSiteService
     * @param {?} zone
     * @param {?} winRef
     */
    constructor(cmsService, routingService, baseSiteService, zone, winRef) {
        this.cmsService = cmsService;
        this.routingService = routingService;
        this.baseSiteService = baseSiteService;
        this.zone = zone;
        this.winRef = winRef;
        this.isPreviewPage = false;
        this.getCmsTicket();
        if (winRef.nativeWindow) {
            /** @type {?} */
            const window = (/** @type {?} */ (winRef.nativeWindow));
            // rerender components and slots after editing
            window.smartedit = window.smartedit || {};
            window.smartedit.renderComponent = (/**
             * @param {?} componentId
             * @param {?} componentType
             * @param {?} parentId
             * @return {?}
             */
            (componentId, componentType, parentId) => {
                return this.renderComponent(componentId, componentType, parentId);
            });
            // reprocess page
            window.smartedit.reprocessPage = this.reprocessPage;
        }
    }
    /**
     * @return {?}
     */
    get cmsTicketId() {
        return this._cmsTicketId;
    }
    /**
     * @protected
     * @return {?}
     */
    getCmsTicket() {
        combineLatest([
            this.cmsService.getCurrentPage(),
            this.routingService.getRouterState(),
        ])
            .pipe(takeWhile((/**
         * @param {?} __0
         * @return {?}
         */
        ([cmsPage]) => cmsPage === undefined)), filter((/**
         * @param {?} __0
         * @return {?}
         */
        ([, routerState]) => {
            if (routerState.nextState && !this._cmsTicketId) {
                this._cmsTicketId =
                    routerState.nextState.queryParams['cmsTicketId'];
                if (this._cmsTicketId) {
                    return true;
                }
            }
            return false;
        })), take(1))
            .subscribe((/**
         * @param {?} _
         * @return {?}
         */
        _ => {
            this.cmsService.launchInSmartEdit = true;
            this.getDefaultPreviewCode();
        }));
    }
    /**
     * @protected
     * @return {?}
     */
    getDefaultPreviewCode() {
        this.baseSiteService
            .getBaseSiteData()
            .pipe(filter((/**
         * @param {?} site
         * @return {?}
         */
        site => Object.keys(site).length !== 0)), take(1))
            .subscribe((/**
         * @param {?} site
         * @return {?}
         */
        site => {
            this.defaultPreviewCategoryCode = site.defaultPreviewCategoryCode;
            this.defaultPreviewProductCode = site.defaultPreviewProductCode;
            this.addPageContract();
        }));
    }
    /**
     * @protected
     * @return {?}
     */
    addPageContract() {
        this.cmsService.getCurrentPage().subscribe((/**
         * @param {?} cmsPage
         * @return {?}
         */
        cmsPage => {
            if (cmsPage && this._cmsTicketId) {
                this._currentPageId = cmsPage.pageId;
                // before adding contract to page, we need redirect to that page
                this.goToPreviewPage(cmsPage);
                // remove old page contract
                /** @type {?} */
                const previousContract = [];
                Array.from(this.winRef.document.body.classList).forEach((/**
                 * @param {?} attr
                 * @return {?}
                 */
                attr => previousContract.push(attr)));
                previousContract.forEach((/**
                 * @param {?} attr
                 * @return {?}
                 */
                attr => this.winRef.document.body.classList.remove(attr)));
                // add new page contract
                if (cmsPage.properties && cmsPage.properties.smartedit) {
                    /** @type {?} */
                    const seClasses = cmsPage.properties.smartedit.classes.split(' ');
                    seClasses.forEach((/**
                     * @param {?} classItem
                     * @return {?}
                     */
                    classItem => {
                        this.winRef.document.body.classList.add(classItem);
                    }));
                }
            }
        }));
    }
    /**
     * @protected
     * @param {?} cmsPage
     * @return {?}
     */
    goToPreviewPage(cmsPage) {
        // only the first page is the smartedit preview page
        if (!this.isPreviewPage) {
            this.isPreviewPage = true;
            if (cmsPage.type === PageType.PRODUCT_PAGE &&
                this.defaultPreviewProductCode) {
                this.routingService.go({
                    cxRoute: 'product',
                    params: { code: this.defaultPreviewProductCode, name: '' },
                });
            }
            else if (cmsPage.type === PageType.CATEGORY_PAGE &&
                this.defaultPreviewCategoryCode) {
                this.routingService.go({
                    cxRoute: 'category',
                    params: { code: this.defaultPreviewCategoryCode },
                });
            }
        }
    }
    /**
     * @protected
     * @param {?} componentId
     * @param {?=} componentType
     * @param {?=} parentId
     * @return {?}
     */
    renderComponent(componentId, componentType, parentId) {
        if (componentId) {
            this.zone.run((/**
             * @return {?}
             */
            () => {
                // without parentId, it is slot
                if (!parentId) {
                    if (this._currentPageId) {
                        this.cmsService.refreshPageById(this._currentPageId);
                    }
                    else {
                        this.cmsService.refreshLatestPage();
                    }
                }
                else if (componentType) {
                    this.cmsService.refreshComponent(componentId);
                }
            }));
        }
        return true;
    }
    /**
     * @protected
     * @return {?}
     */
    reprocessPage() {
        // TODO: reprocess page API
    }
}
SmartEditService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root',
            },] }
];
/** @nocollapse */
SmartEditService.ctorParameters = () => [
    { type: CmsService },
    { type: RoutingService },
    { type: BaseSiteService },
    { type: NgZone },
    { type: WindowRef }
];
/** @nocollapse */ SmartEditService.ngInjectableDef = ɵɵdefineInjectable({ factory: function SmartEditService_Factory() { return new SmartEditService(ɵɵinject(CmsService), ɵɵinject(RoutingService), ɵɵinject(BaseSiteService), ɵɵinject(NgZone), ɵɵinject(WindowRef)); }, token: SmartEditService, providedIn: "root" });
if (false) {
    /**
     * @type {?}
     * @private
     */
    SmartEditService.prototype._cmsTicketId;
    /**
     * @type {?}
     * @private
     */
    SmartEditService.prototype.isPreviewPage;
    /**
     * @type {?}
     * @private
     */
    SmartEditService.prototype._currentPageId;
    /**
     * @type {?}
     * @private
     */
    SmartEditService.prototype.defaultPreviewProductCode;
    /**
     * @type {?}
     * @private
     */
    SmartEditService.prototype.defaultPreviewCategoryCode;
    /**
     * @type {?}
     * @protected
     */
    SmartEditService.prototype.cmsService;
    /**
     * @type {?}
     * @protected
     */
    SmartEditService.prototype.routingService;
    /**
     * @type {?}
     * @protected
     */
    SmartEditService.prototype.baseSiteService;
    /**
     * @type {?}
     * @protected
     */
    SmartEditService.prototype.zone;
    /**
     * @type {?}
     * @protected
     */
    SmartEditService.prototype.winRef;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class CmsTicketInterceptor {
    /**
     * @param {?} service
     */
    constructor(service) {
        this.service = service;
    }
    /**
     * @param {?} request
     * @param {?} next
     * @return {?}
     */
    intercept(request, next) {
        if (request.url.includes('/cms/') && this.service.cmsTicketId) {
            request = request.clone({
                setParams: {
                    cmsTicketId: this.service.cmsTicketId,
                },
            });
        }
        return next.handle(request);
    }
}
CmsTicketInterceptor.decorators = [
    { type: Injectable, args: [{ providedIn: 'root' },] }
];
/** @nocollapse */
CmsTicketInterceptor.ctorParameters = () => [
    { type: SmartEditService }
];
/** @nocollapse */ CmsTicketInterceptor.ngInjectableDef = ɵɵdefineInjectable({ factory: function CmsTicketInterceptor_Factory() { return new CmsTicketInterceptor(ɵɵinject(SmartEditService)); }, token: CmsTicketInterceptor, providedIn: "root" });
if (false) {
    /**
     * @type {?}
     * @private
     */
    CmsTicketInterceptor.prototype.service;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const interceptors$4 = [
    {
        provide: HTTP_INTERCEPTORS,
        useExisting: CmsTicketInterceptor,
        multi: true,
    },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SmartEditModule {
    /**
     * @return {?}
     */
    static forRoot() {
        return {
            ngModule: SmartEditModule,
            providers: [...interceptors$4],
        };
    }
}
SmartEditModule.decorators = [
    { type: NgModule, args: [{},] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * These are the allowed options for the engine
 * @record
 */
function NgSetupOptions() { }
if (false) {
    /** @type {?} */
    NgSetupOptions.prototype.bootstrap;
    /** @type {?|undefined} */
    NgSetupOptions.prototype.providers;
}
/**
 * These are the allowed options for the render
 * @record
 */
function RenderOptions() { }
if (false) {
    /** @type {?} */
    RenderOptions.prototype.req;
    /** @type {?|undefined} */
    RenderOptions.prototype.res;
    /** @type {?|undefined} */
    RenderOptions.prototype.url;
    /** @type {?|undefined} */
    RenderOptions.prototype.document;
}
/**
 * The wrapper over the standard ngExpressEngine, that provides tokens for Spartacus
 * @param ngExpressEngine
 */
class NgExpressEngineDecorator {
    /**
     * Returns the higher order ngExpressEngine with provided tokens for Spartacus
     *
     * @param {?} ngExpressEngine
     * @return {?}
     */
    static get(ngExpressEngine) {
        /** @type {?} */
        const result = (/**
         * @param {?} setupOptions
         * @return {?}
         */
        function cxNgExpressEngine(setupOptions) {
            return (/**
             * @param {?} filePath
             * @param {?} options
             * @param {?} callback
             * @return {?}
             */
            (filePath, options, callback) => {
                /** @type {?} */
                const engineInstance = ngExpressEngine(Object.assign({}, setupOptions, { providers: [
                        ...getServerRequestProviders(options),
                        ...(setupOptions.providers || []),
                    ] }));
                return engineInstance(filePath, options, callback);
            });
        });
        return result;
    }
}
/**
 * Returns Spartacus' providers to be passed to the Angular express engine (in SSR)
 *
 * @param {?} options
 * @return {?}
 */
function getServerRequestProviders(options) {
    return [
        {
            provide: SERVER_REQUEST_URL,
            useValue: getRequestUrl(options.req),
        },
        {
            provide: SERVER_REQUEST_ORIGIN,
            useValue: getRequestOrigin(options.req),
        },
    ];
}
/**
 * @param {?} req
 * @return {?}
 */
function getRequestUrl(req) {
    return getRequestOrigin(req) + req.originalUrl;
}
/**
 * @param {?} req
 * @return {?}
 */
function getRequestOrigin(req) {
    return req.protocol + '://' + req.get('host');
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @abstract
 */
class StoreFinderConfig {
}
if (false) {
    /** @type {?} */
    StoreFinderConfig.prototype.googleMaps;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const STORE_FINDER_FEATURE = 'stores';
/** @type {?} */
const STORE_FINDER_DATA = '[StoreFinder] Store Finder Data';
/**
 * @record
 */
function StateWithStoreFinder() { }
if (false) {
    /* Skipping unnamed member:
    [STORE_FINDER_FEATURE]: StoresState;*/
}
/**
 * @record
 */
function StoresState() { }
if (false) {
    /** @type {?} */
    StoresState.prototype.findStores;
    /** @type {?} */
    StoresState.prototype.viewAllStores;
}
/**
 * @record
 */
function FindStoresState() { }
if (false) {
    /** @type {?} */
    FindStoresState.prototype.findStoresEntities;
}
/**
 * @record
 */
function ViewAllStoresState() { }
if (false) {
    /** @type {?} */
    ViewAllStoresState.prototype.viewAllStoresEntities;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const FIND_STORES_ON_HOLD = '[StoreFinder] On Hold';
/** @type {?} */
const FIND_STORES = '[StoreFinder] Find Stores';
/** @type {?} */
const FIND_STORES_FAIL = '[StoreFinder] Find Stores Fail';
/** @type {?} */
const FIND_STORES_SUCCESS = '[StoreFinder] Find Stores Success';
/** @type {?} */
const FIND_STORE_BY_ID = '[StoreFinder] Find a Store by Id';
/** @type {?} */
const FIND_STORE_BY_ID_FAIL = '[StoreFinder] Find a Store by Id Fail';
/** @type {?} */
const FIND_STORE_BY_ID_SUCCESS = '[StoreFinder] Find a Store by Id Success';
class FindStoresOnHold extends LoaderLoadAction {
    constructor() {
        super(STORE_FINDER_DATA);
        this.type = FIND_STORES_ON_HOLD;
    }
}
if (false) {
    /** @type {?} */
    FindStoresOnHold.prototype.type;
}
class FindStores extends LoaderLoadAction {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        super(STORE_FINDER_DATA);
        this.payload = payload;
        this.type = FIND_STORES;
    }
}
if (false) {
    /** @type {?} */
    FindStores.prototype.type;
    /** @type {?} */
    FindStores.prototype.payload;
}
class FindStoresFail extends LoaderFailAction {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        super(STORE_FINDER_DATA, payload);
        this.payload = payload;
        this.type = FIND_STORES_FAIL;
    }
}
if (false) {
    /** @type {?} */
    FindStoresFail.prototype.type;
    /** @type {?} */
    FindStoresFail.prototype.payload;
}
class FindStoresSuccess extends LoaderSuccessAction {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        super(STORE_FINDER_DATA);
        this.payload = payload;
        this.type = FIND_STORES_SUCCESS;
    }
}
if (false) {
    /** @type {?} */
    FindStoresSuccess.prototype.type;
    /** @type {?} */
    FindStoresSuccess.prototype.payload;
}
class FindStoreById extends LoaderLoadAction {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        super(STORE_FINDER_DATA);
        this.payload = payload;
        this.type = FIND_STORE_BY_ID;
    }
}
if (false) {
    /** @type {?} */
    FindStoreById.prototype.type;
    /** @type {?} */
    FindStoreById.prototype.payload;
}
class FindStoreByIdFail extends LoaderFailAction {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        super(STORE_FINDER_DATA, payload);
        this.payload = payload;
        this.type = FIND_STORE_BY_ID_FAIL;
    }
}
if (false) {
    /** @type {?} */
    FindStoreByIdFail.prototype.type;
    /** @type {?} */
    FindStoreByIdFail.prototype.payload;
}
class FindStoreByIdSuccess extends LoaderSuccessAction {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        super(STORE_FINDER_DATA);
        this.payload = payload;
        this.type = FIND_STORE_BY_ID_SUCCESS;
    }
}
if (false) {
    /** @type {?} */
    FindStoreByIdSuccess.prototype.type;
    /** @type {?} */
    FindStoreByIdSuccess.prototype.payload;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const VIEW_ALL_STORES = '[StoreFinder] View All Stores';
/** @type {?} */
const VIEW_ALL_STORES_FAIL = '[StoreFinder] View All Stores Fail';
/** @type {?} */
const VIEW_ALL_STORES_SUCCESS = '[StoreFinder] View All Stores Success';
class ViewAllStores extends LoaderLoadAction {
    constructor() {
        super(STORE_FINDER_DATA);
        this.type = VIEW_ALL_STORES;
    }
}
if (false) {
    /** @type {?} */
    ViewAllStores.prototype.type;
}
class ViewAllStoresFail extends LoaderFailAction {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        super(STORE_FINDER_DATA, payload);
        this.payload = payload;
        this.type = VIEW_ALL_STORES_FAIL;
    }
}
if (false) {
    /** @type {?} */
    ViewAllStoresFail.prototype.type;
    /** @type {?} */
    ViewAllStoresFail.prototype.payload;
}
class ViewAllStoresSuccess extends LoaderSuccessAction {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        super(STORE_FINDER_DATA);
        this.payload = payload;
        this.type = VIEW_ALL_STORES_SUCCESS;
    }
}
if (false) {
    /** @type {?} */
    ViewAllStoresSuccess.prototype.type;
    /** @type {?} */
    ViewAllStoresSuccess.prototype.payload;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

var storeFinderGroup_actions = /*#__PURE__*/Object.freeze({
    FIND_STORES_ON_HOLD: FIND_STORES_ON_HOLD,
    FIND_STORES: FIND_STORES,
    FIND_STORES_FAIL: FIND_STORES_FAIL,
    FIND_STORES_SUCCESS: FIND_STORES_SUCCESS,
    FIND_STORE_BY_ID: FIND_STORE_BY_ID,
    FIND_STORE_BY_ID_FAIL: FIND_STORE_BY_ID_FAIL,
    FIND_STORE_BY_ID_SUCCESS: FIND_STORE_BY_ID_SUCCESS,
    FindStoresOnHold: FindStoresOnHold,
    FindStores: FindStores,
    FindStoresFail: FindStoresFail,
    FindStoresSuccess: FindStoresSuccess,
    FindStoreById: FindStoreById,
    FindStoreByIdFail: FindStoreByIdFail,
    FindStoreByIdSuccess: FindStoreByIdSuccess,
    VIEW_ALL_STORES: VIEW_ALL_STORES,
    VIEW_ALL_STORES_FAIL: VIEW_ALL_STORES_FAIL,
    VIEW_ALL_STORES_SUCCESS: VIEW_ALL_STORES_SUCCESS,
    ViewAllStores: ViewAllStores,
    ViewAllStoresFail: ViewAllStoresFail,
    ViewAllStoresSuccess: ViewAllStoresSuccess
});

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const getStoreFinderState = createFeatureSelector(STORE_FINDER_FEATURE);

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
const ɵ0$J = /**
 * @param {?} storesState
 * @return {?}
 */
(storesState) => storesState.findStores;
/** @type {?} */
const getFindStoresState = createSelector(getStoreFinderState, (ɵ0$J));
const ɵ1$u = /**
 * @param {?} state
 * @return {?}
 */
state => loaderValueSelector(state);
/** @type {?} */
const getFindStoresEntities = createSelector(getFindStoresState, (ɵ1$u));
const ɵ2$l = /**
 * @param {?} state
 * @return {?}
 */
state => loaderLoadingSelector(state);
/** @type {?} */
const getStoresLoading = createSelector(getFindStoresState, (ɵ2$l));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
const ɵ0$K = /**
 * @param {?} storesState
 * @return {?}
 */
(storesState) => storesState.viewAllStores;
/** @type {?} */
const getViewAllStoresState = createSelector(getStoreFinderState, (ɵ0$K));
const ɵ1$v = /**
 * @param {?} state
 * @return {?}
 */
state => loaderValueSelector(state);
/** @type {?} */
const getViewAllStoresEntities = createSelector(getViewAllStoresState, (ɵ1$v));
const ɵ2$m = /**
 * @param {?} state
 * @return {?}
 */
state => loaderLoadingSelector(state);
/** @type {?} */
const getViewAllStoresLoading = createSelector(getViewAllStoresState, (ɵ2$m));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

var storeFinderGroup_selectors = /*#__PURE__*/Object.freeze({
    getFindStoresState: getFindStoresState,
    getFindStoresEntities: getFindStoresEntities,
    getStoresLoading: getStoresLoading,
    getViewAllStoresState: getViewAllStoresState,
    getViewAllStoresEntities: getViewAllStoresEntities,
    getViewAllStoresLoading: getViewAllStoresLoading
});

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class StoreFinderService {
    /**
     * @param {?} store
     * @param {?} winRef
     * @param {?} globalMessageService
     * @param {?} routingService
     */
    constructor(store, winRef, globalMessageService, routingService) {
        this.store = store;
        this.winRef = winRef;
        this.globalMessageService = globalMessageService;
        this.routingService = routingService;
        this.geolocationWatchId = null;
    }
    /**
     * Returns boolean observable for store's loading state
     * @return {?}
     */
    getStoresLoading() {
        return this.store.pipe(select(getStoresLoading));
    }
    /**
     * Returns observable for store's entities
     * @return {?}
     */
    getFindStoresEntities() {
        return this.store.pipe(select(getFindStoresEntities));
    }
    /**
     * Returns boolean observable for view all store's loading state
     * @return {?}
     */
    getViewAllStoresLoading() {
        return this.store.pipe(select(getViewAllStoresLoading));
    }
    /**
     * Returns observable for view all store's entities
     * @return {?}
     */
    getViewAllStoresEntities() {
        return this.store.pipe(select(getViewAllStoresEntities));
    }
    /**
     * Store finding action functionality
     * @param {?} queryText text query
     * @param {?=} searchConfig search configuration
     * @param {?=} longitudeLatitude longitude and latitude coordinates
     * @param {?=} countryIsoCode country ISO code
     * @param {?=} useMyLocation current location coordinates
     * @return {?}
     */
    findStoresAction(queryText, searchConfig, longitudeLatitude, countryIsoCode, useMyLocation) {
        if (useMyLocation && this.winRef.nativeWindow) {
            this.clearWatchGeolocation(new FindStoresOnHold());
            this.geolocationWatchId = this.winRef.nativeWindow.navigator.geolocation.watchPosition((/**
             * @param {?} pos
             * @return {?}
             */
            (pos) => {
                /** @type {?} */
                const position = {
                    longitude: pos.coords.longitude,
                    latitude: pos.coords.latitude,
                };
                this.clearWatchGeolocation(new FindStores({
                    queryText: queryText,
                    searchConfig: searchConfig,
                    longitudeLatitude: position,
                    countryIsoCode: countryIsoCode,
                }));
            }), (/**
             * @return {?}
             */
            () => {
                this.globalMessageService.add({ key: 'storeFinder.geolocationNotEnabled' }, GlobalMessageType.MSG_TYPE_ERROR);
                this.routingService.go(['/store-finder']);
            }));
        }
        else {
            this.clearWatchGeolocation(new FindStores({
                queryText: queryText,
                searchConfig: searchConfig,
                longitudeLatitude: longitudeLatitude,
                countryIsoCode: countryIsoCode,
            }));
        }
    }
    /**
     * View all stores
     * @return {?}
     */
    viewAllStores() {
        this.clearWatchGeolocation(new ViewAllStores());
    }
    /**
     * View all stores by id
     * @param {?} storeId store id
     * @return {?}
     */
    viewStoreById(storeId) {
        this.clearWatchGeolocation(new FindStoreById({ storeId }));
    }
    /**
     * @private
     * @param {?} callbackAction
     * @return {?}
     */
    clearWatchGeolocation(callbackAction) {
        if (this.geolocationWatchId !== null) {
            this.winRef.nativeWindow.navigator.geolocation.clearWatch(this.geolocationWatchId);
            this.geolocationWatchId = null;
        }
        this.store.dispatch(callbackAction);
    }
}
StoreFinderService.decorators = [
    { type: Injectable }
];
/** @nocollapse */
StoreFinderService.ctorParameters = () => [
    { type: Store },
    { type: WindowRef },
    { type: GlobalMessageService },
    { type: RoutingService }
];
if (false) {
    /**
     * @type {?}
     * @private
     */
    StoreFinderService.prototype.geolocationWatchId;
    /**
     * @type {?}
     * @protected
     */
    StoreFinderService.prototype.store;
    /**
     * @type {?}
     * @protected
     */
    StoreFinderService.prototype.winRef;
    /**
     * @type {?}
     * @protected
     */
    StoreFinderService.prototype.globalMessageService;
    /**
     * @type {?}
     * @protected
     */
    StoreFinderService.prototype.routingService;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class StoreDataService {
    constructor() {
        this.weekDays = {
            0: 'Sun',
            1: 'Mon',
            2: 'Tue',
            3: 'Wed',
            4: 'Thu',
            5: 'Fri',
            6: 'Sat',
        };
    }
    /**
     * Returns store latitude
     * @param {?} location store location
     * @return {?}
     */
    getStoreLatitude(location) {
        return location.geoPoint.latitude;
    }
    /**
     * Returns store longitude
     * @param {?} location store location
     * @return {?}
     */
    getStoreLongitude(location) {
        return location.geoPoint.longitude;
    }
    /**
     * Returns store closing time
     * @param {?} location store location
     * @param {?} date date to compare
     * @return {?}
     */
    getStoreClosingTime(location, date) {
        /** @type {?} */
        const requestedDaySchedule = this.getSchedule(location, date);
        if (requestedDaySchedule) {
            if (requestedDaySchedule.closed && requestedDaySchedule.closed === true) {
                return 'closed';
            }
            if (requestedDaySchedule.closingTime) {
                return requestedDaySchedule.closingTime.formattedHour;
            }
        }
    }
    /**
     * Returns store opening time
     * @param {?} location store location
     * @param {?} date date to compare
     * @return {?}
     */
    getStoreOpeningTime(location, date) {
        /** @type {?} */
        const requestedDaySchedule = this.getSchedule(location, date);
        if (requestedDaySchedule) {
            if (requestedDaySchedule.closed && requestedDaySchedule.closed === true) {
                return 'closed';
            }
            if (requestedDaySchedule.openingTime) {
                return requestedDaySchedule.openingTime.formattedHour;
            }
        }
    }
    /**
     * Extracts schedule from the given location for the given date
     * @protected
     * @param {?} location location
     * @param {?} date date
     *
     * @return {?} payload describing the store's schedule for the given day.
     */
    getSchedule(location, date) {
        /** @type {?} */
        const weekday = this.weekDays[date.getDay()];
        return location.openingHours.weekDayOpeningList.find((/**
         * @param {?} weekDayOpeningListItem
         * @return {?}
         */
        weekDayOpeningListItem => weekDayOpeningListItem.weekDay === weekday));
    }
}
StoreDataService.decorators = [
    { type: Injectable }
];
if (false) {
    /** @type {?} */
    StoreDataService.prototype.DECIMAL_BASE;
    /** @type {?} */
    StoreDataService.prototype.weekDays;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @record
 */
function StoreEntities() { }
if (false) {
    /** @type {?|undefined} */
    StoreEntities.prototype.pointOfServices;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @record
 */
function StoreFinderSearchConfig() { }
if (false) {
    /** @type {?|undefined} */
    StoreFinderSearchConfig.prototype.pageSize;
    /** @type {?|undefined} */
    StoreFinderSearchConfig.prototype.currentPage;
    /** @type {?|undefined} */
    StoreFinderSearchConfig.prototype.sort;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @record
 */
function StoreFinderSearchQuery() { }
if (false) {
    /** @type {?|undefined} */
    StoreFinderSearchQuery.prototype.queryText;
    /** @type {?|undefined} */
    StoreFinderSearchQuery.prototype.longitudeLatitude;
    /** @type {?|undefined} */
    StoreFinderSearchQuery.prototype.useMyLocation;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ExternalJsFileLoader {
    /**
     * @param {?} document
     */
    constructor(document) {
        this.document = document;
    }
    /**
     * Loads a javascript from an external URL
     * @param {?} src URL for the script to be loaded
     * @param {?=} params additional parameters to be attached to the given URL
     * @param {?=} callback a function to be invoked after the script has been loaded
     * @return {?}
     */
    load(src, params, callback) {
        /** @type {?} */
        const script = this.document.createElement('script');
        script.type = 'text/javascript';
        if (params) {
            script.src = src + this.parseParams(params);
        }
        else {
            script.src = src;
        }
        script.async = true;
        script.defer = true;
        if (callback) {
            script.addEventListener('load', callback);
        }
        document.head.appendChild(script);
    }
    /**
     * Parses the given object with parameters to a string "param1=value1&param2=value2"
     * @private
     * @param {?} params object containing parameters
     * @return {?}
     */
    parseParams(params) {
        /** @type {?} */
        let result = '';
        /** @type {?} */
        const keysArray = Object.keys(params);
        if (keysArray.length > 0) {
            result =
                '?' +
                    keysArray
                        .map((/**
                     * @param {?} key
                     * @return {?}
                     */
                    key => encodeURI(key) + '=' + encodeURI(params[key])))
                        .join('&');
        }
        return result;
    }
}
ExternalJsFileLoader.decorators = [
    { type: Injectable }
];
/** @nocollapse */
ExternalJsFileLoader.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] }
];
if (false) {
    /**
     * @type {?}
     * @protected
     */
    ExternalJsFileLoader.prototype.document;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class GoogleMapRendererService {
    /**
     * @param {?} config
     * @param {?} externalJsFileLoader
     * @param {?} storeDataService
     */
    constructor(config, externalJsFileLoader, storeDataService) {
        this.config = config;
        this.externalJsFileLoader = externalJsFileLoader;
        this.storeDataService = storeDataService;
        this.googleMap = null;
    }
    /**
     * Renders google map on the given element and draws markers on it.
     * If map already exists it will use an existing map otherwise it will create one
     * @param {?} mapElement HTML element inside of which the map will be displayed
     * @param {?} locations array containign geo data to be displayed on the map
     * @param {?=} selectMarkerHandler function to handle whenever a marker on a map is clicked
     * @return {?}
     */
    renderMap(mapElement, locations, selectMarkerHandler) {
        if (this.googleMap === null) {
            this.externalJsFileLoader.load(this.config.googleMaps.apiUrl, { key: this.config.googleMaps.apiKey }, (/**
             * @return {?}
             */
            () => {
                this.drawMap(mapElement, locations, selectMarkerHandler);
            }));
        }
        else {
            this.drawMap(mapElement, locations, selectMarkerHandler);
        }
    }
    /**
     * Centers the map to the given point
     * @param {?} latitute latitude of the new center
     * @param {?} longitude longitude of the new center
     * @return {?}
     */
    centerMap(latitute, longitude) {
        this.googleMap.panTo({ lat: latitute, lng: longitude });
        this.googleMap.setZoom(this.config.googleMaps.selectedMarkerScale);
    }
    /**
     * Defines and returns {\@link google.maps.LatLng} representing a point where the map will be centered
     * @private
     * @param {?} locations list of locations
     * @return {?}
     */
    defineMapCenter(locations) {
        return new google.maps.LatLng(this.storeDataService.getStoreLatitude(locations[0]), this.storeDataService.getStoreLongitude(locations[0]));
    }
    /**
     * Creates google map inside if the given HTML element centered to the given point
     * @private
     * @param {?} mapElement {\@link HTMLElement} inside of which the map will be created
     * @param {?} mapCenter {\@link google.maps.LatLng} the point where the map will be centered
     * @return {?}
     */
    initMap(mapElement, mapCenter) {
        /** @type {?} */
        const gestureOption = 'greedy';
        /** @type {?} */
        const mapProp = {
            center: mapCenter,
            zoom: this.config.googleMaps.scale,
            mapTypeId: google.maps.MapTypeId.ROADMAP,
            gestureHandling: gestureOption,
        };
        this.googleMap = new google.maps.Map(mapElement, mapProp);
    }
    /**
     * Erases the current map's markers and create a new one based on the given locations
     * @private
     * @param {?} locations array of locations to be displayed on the map
     * @param {?=} selectMarkerHandler function to handle whenever a marker on a map is clicked
     * @return {?}
     */
    createMarkers(locations, selectMarkerHandler) {
        this.markers = [];
        locations.forEach((/**
         * @param {?} element
         * @param {?} index
         * @return {?}
         */
        (element, index) => {
            /** @type {?} */
            const marker = new google.maps.Marker({
                position: new google.maps.LatLng(this.storeDataService.getStoreLatitude(element), this.storeDataService.getStoreLongitude(element)),
                label: index + 1 + '',
            });
            this.markers.push(marker);
            marker.setMap(this.googleMap);
            marker.addListener('mouseover', (/**
             * @return {?}
             */
            function () {
                marker.setAnimation(google.maps.Animation.BOUNCE);
            }));
            marker.addListener('mouseout', (/**
             * @return {?}
             */
            function () {
                marker.setAnimation(null);
            }));
            if (selectMarkerHandler) {
                marker.addListener('click', (/**
                 * @return {?}
                 */
                function () {
                    selectMarkerHandler(index);
                }));
            }
        }));
    }
    /**
     * Initialize and draw the map
     * @private
     * @param {?} mapElement {\@link HTMLElement} inside of which the map will be drawn
     * @param {?} locations array of locations to be displayed on the map
     * @param {?} selectMarkerHandler function to handle whenever a marker on a map is clicked
     * @return {?}
     */
    drawMap(mapElement, locations, selectMarkerHandler) {
        this.initMap(mapElement, this.defineMapCenter(locations));
        this.createMarkers(locations, selectMarkerHandler);
    }
}
GoogleMapRendererService.decorators = [
    { type: Injectable }
];
/** @nocollapse */
GoogleMapRendererService.ctorParameters = () => [
    { type: StoreFinderConfig },
    { type: ExternalJsFileLoader },
    { type: StoreDataService }
];
if (false) {
    /**
     * @type {?}
     * @private
     */
    GoogleMapRendererService.prototype.googleMap;
    /**
     * @type {?}
     * @private
     */
    GoogleMapRendererService.prototype.markers;
    /**
     * @type {?}
     * @protected
     */
    GoogleMapRendererService.prototype.config;
    /**
     * @type {?}
     * @protected
     */
    GoogleMapRendererService.prototype.externalJsFileLoader;
    /**
     * @type {?}
     * @protected
     */
    GoogleMapRendererService.prototype.storeDataService;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const defaultStoreFinderConfig = {
    googleMaps: {
        apiUrl: 'https://maps.googleapis.com/maps/api/js',
        apiKey: '',
        scale: 5,
        selectedMarkerScale: 17,
    },
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @return {?}
 */
function getReducers$c() {
    return {
        findStores: loaderReducer(STORE_FINDER_DATA),
        viewAllStores: loaderReducer(STORE_FINDER_DATA),
    };
}
/** @type {?} */
const reducerToken$c = new InjectionToken('StoreFinderReducers');
/** @type {?} */
const reducerProvider$c = {
    provide: reducerToken$c,
    useFactory: getReducers$c,
};
/** @type {?} */
const metaReducers$7 = [];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FindStoresEffect {
    /**
     * @param {?} actions$
     * @param {?} storeFinderConnector
     */
    constructor(actions$, storeFinderConnector) {
        this.actions$ = actions$;
        this.storeFinderConnector = storeFinderConnector;
        this.findStores$ = this.actions$.pipe(ofType(FIND_STORES), map((/**
         * @param {?} action
         * @return {?}
         */
        (action) => action.payload)), mergeMap((/**
         * @param {?} payload
         * @return {?}
         */
        payload => this.storeFinderConnector
            .search(payload.queryText, payload.searchConfig, payload.longitudeLatitude)
            .pipe(map((/**
         * @param {?} data
         * @return {?}
         */
        data => {
            if (payload.countryIsoCode) {
                data.stores = data.stores.filter((/**
                 * @param {?} store
                 * @return {?}
                 */
                store => store.address.country.isocode === payload.countryIsoCode));
            }
            return new FindStoresSuccess(data);
        })), catchError((/**
         * @param {?} error
         * @return {?}
         */
        error => of(new FindStoresFail(makeErrorSerializable(error)))))))));
        this.findStoreById$ = this.actions$.pipe(ofType(FIND_STORE_BY_ID), map((/**
         * @param {?} action
         * @return {?}
         */
        (action) => action.payload)), switchMap((/**
         * @param {?} payload
         * @return {?}
         */
        payload => this.storeFinderConnector.get(payload.storeId).pipe(map((/**
         * @param {?} data
         * @return {?}
         */
        data => new FindStoreByIdSuccess(data))), catchError((/**
         * @param {?} error
         * @return {?}
         */
        error => of(new FindStoreByIdFail(makeErrorSerializable(error)))))))));
    }
}
FindStoresEffect.decorators = [
    { type: Injectable }
];
/** @nocollapse */
FindStoresEffect.ctorParameters = () => [
    { type: Actions },
    { type: StoreFinderConnector }
];
__decorate([
    Effect(),
    __metadata("design:type", Observable)
], FindStoresEffect.prototype, "findStores$", void 0);
__decorate([
    Effect(),
    __metadata("design:type", Observable)
], FindStoresEffect.prototype, "findStoreById$", void 0);
if (false) {
    /** @type {?} */
    FindStoresEffect.prototype.findStores$;
    /** @type {?} */
    FindStoresEffect.prototype.findStoreById$;
    /**
     * @type {?}
     * @private
     */
    FindStoresEffect.prototype.actions$;
    /**
     * @type {?}
     * @private
     */
    FindStoresEffect.prototype.storeFinderConnector;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ViewAllStoresEffect {
    /**
     * @param {?} actions$
     * @param {?} storeFinderConnector
     */
    constructor(actions$, storeFinderConnector) {
        this.actions$ = actions$;
        this.storeFinderConnector = storeFinderConnector;
        this.viewAllStores$ = this.actions$.pipe(ofType(VIEW_ALL_STORES), switchMap((/**
         * @return {?}
         */
        () => {
            return this.storeFinderConnector.getCounts().pipe(map((/**
             * @param {?} data
             * @return {?}
             */
            data => {
                data.sort((/**
                 * @param {?} a
                 * @param {?} b
                 * @return {?}
                 */
                (a, b) => (a.name < b.name ? -1 : a.name > b.name ? 1 : 0)));
                return new ViewAllStoresSuccess(data);
            })), catchError((/**
             * @param {?} error
             * @return {?}
             */
            error => of(new ViewAllStoresFail(makeErrorSerializable(error))))));
        })));
    }
}
ViewAllStoresEffect.decorators = [
    { type: Injectable }
];
/** @nocollapse */
ViewAllStoresEffect.ctorParameters = () => [
    { type: Actions },
    { type: StoreFinderConnector }
];
__decorate([
    Effect(),
    __metadata("design:type", Observable)
], ViewAllStoresEffect.prototype, "viewAllStores$", void 0);
if (false) {
    /** @type {?} */
    ViewAllStoresEffect.prototype.viewAllStores$;
    /**
     * @type {?}
     * @private
     */
    ViewAllStoresEffect.prototype.actions$;
    /**
     * @type {?}
     * @private
     */
    ViewAllStoresEffect.prototype.storeFinderConnector;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const effects$b = [FindStoresEffect, ViewAllStoresEffect];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class StoreFinderStoreModule {
}
StoreFinderStoreModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    HttpClientModule,
                    StoreModule.forFeature(STORE_FINDER_FEATURE, reducerToken$c),
                    EffectsModule.forFeature(effects$b),
                ],
                providers: [reducerProvider$c],
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class StoreFinderCoreModule {
}
StoreFinderCoreModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    ConfigModule.withConfig(defaultStoreFinderConfig),
                    StoreFinderStoreModule,
                ],
                providers: [
                    StoreFinderService,
                    StoreDataService,
                    GoogleMapRendererService,
                    ExternalJsFileLoader,
                    { provide: StoreFinderConfig, useExisting: Config },
                ],
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class UserConnector {
    /**
     * @param {?} adapter
     */
    constructor(adapter) {
        this.adapter = adapter;
    }
    /**
     * @param {?} userId
     * @return {?}
     */
    get(userId) {
        return this.adapter.load(userId);
    }
    /**
     * @param {?} username
     * @param {?} user
     * @return {?}
     */
    update(username, user) {
        return this.adapter.update(username, user);
    }
    /**
     * @param {?} user
     * @return {?}
     */
    register(user) {
        return this.adapter.register(user);
    }
    /**
     * @param {?} guid
     * @param {?} password
     * @return {?}
     */
    registerGuest(guid, password) {
        return this.adapter.registerGuest(guid, password);
    }
    /**
     * @param {?} userEmailAddress
     * @return {?}
     */
    requestForgotPasswordEmail(userEmailAddress) {
        return this.adapter.requestForgotPasswordEmail(userEmailAddress);
    }
    /**
     * @param {?} token
     * @param {?} newPassword
     * @return {?}
     */
    resetPassword(token, newPassword) {
        return this.adapter.resetPassword(token, newPassword);
    }
    /**
     * @param {?} userId
     * @param {?} currentPassword
     * @param {?} newUserId
     * @return {?}
     */
    updateEmail(userId, currentPassword, newUserId) {
        return this.adapter.updateEmail(userId, currentPassword, newUserId);
    }
    /**
     * @param {?} userId
     * @param {?} oldPassword
     * @param {?} newPassword
     * @return {?}
     */
    updatePassword(userId, oldPassword, newPassword) {
        return this.adapter.updatePassword(userId, oldPassword, newPassword);
    }
    /**
     * @param {?} userId
     * @return {?}
     */
    remove(userId) {
        return this.adapter.remove(userId);
    }
    /**
     * @return {?}
     */
    getTitles() {
        return this.adapter.loadTitles();
    }
}
UserConnector.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root',
            },] }
];
/** @nocollapse */
UserConnector.ctorParameters = () => [
    { type: UserAdapter }
];
/** @nocollapse */ UserConnector.ngInjectableDef = ɵɵdefineInjectable({ factory: function UserConnector_Factory() { return new UserConnector(ɵɵinject(UserAdapter)); }, token: UserConnector, providedIn: "root" });
if (false) {
    /**
     * @type {?}
     * @protected
     */
    UserConnector.prototype.adapter;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class UserConsentConnector {
    /**
     * @param {?} adapter
     */
    constructor(adapter) {
        this.adapter = adapter;
    }
    /**
     * @param {?} userId
     * @return {?}
     */
    loadConsents(userId) {
        return this.adapter.loadConsents(userId);
    }
    /**
     * @param {?} userId
     * @param {?} consentTemplateId
     * @param {?} consentTemplateVersion
     * @return {?}
     */
    giveConsent(userId, consentTemplateId, consentTemplateVersion) {
        return this.adapter.giveConsent(userId, consentTemplateId, consentTemplateVersion);
    }
    /**
     * @param {?} userId
     * @param {?} consentCode
     * @return {?}
     */
    withdrawConsent(userId, consentCode) {
        return this.adapter.withdrawConsent(userId, consentCode);
    }
}
UserConsentConnector.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root',
            },] }
];
/** @nocollapse */
UserConsentConnector.ctorParameters = () => [
    { type: UserConsentAdapter }
];
/** @nocollapse */ UserConsentConnector.ngInjectableDef = ɵɵdefineInjectable({ factory: function UserConsentConnector_Factory() { return new UserConsentConnector(ɵɵinject(UserConsentAdapter)); }, token: UserConsentConnector, providedIn: "root" });
if (false) {
    /**
     * @type {?}
     * @protected
     */
    UserConsentConnector.prototype.adapter;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class UserPaymentConnector {
    /**
     * @param {?} adapter
     */
    constructor(adapter) {
        this.adapter = adapter;
    }
    /**
     * @param {?} userId
     * @return {?}
     */
    getAll(userId) {
        return this.adapter.loadAll(userId);
    }
    /**
     * @param {?} userId
     * @param {?} paymentMethodID
     * @return {?}
     */
    delete(userId, paymentMethodID) {
        return this.adapter.delete(userId, paymentMethodID);
    }
    /**
     * @param {?} userId
     * @param {?} paymentMethodID
     * @return {?}
     */
    setDefault(userId, paymentMethodID) {
        return this.adapter.setDefault(userId, paymentMethodID);
    }
}
UserPaymentConnector.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root',
            },] }
];
/** @nocollapse */
UserPaymentConnector.ctorParameters = () => [
    { type: UserPaymentAdapter }
];
/** @nocollapse */ UserPaymentConnector.ngInjectableDef = ɵɵdefineInjectable({ factory: function UserPaymentConnector_Factory() { return new UserPaymentConnector(ɵɵinject(UserPaymentAdapter)); }, token: UserPaymentConnector, providedIn: "root" });
if (false) {
    /**
     * @type {?}
     * @protected
     */
    UserPaymentConnector.prototype.adapter;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class UserOrderConnector {
    /**
     * @param {?} adapter
     */
    constructor(adapter) {
        this.adapter = adapter;
    }
    /**
     * @param {?} userId
     * @param {?} orderCode
     * @return {?}
     */
    get(userId, orderCode) {
        return this.adapter.load(userId, orderCode);
    }
    /**
     * @param {?} userId
     * @param {?=} pageSize
     * @param {?=} currentPage
     * @param {?=} sort
     * @return {?}
     */
    getHistory(userId, pageSize, currentPage, sort) {
        return this.adapter.loadHistory(userId, pageSize, currentPage, sort);
    }
    /**
     * @param {?} orderCode
     * @param {?} consignmentCode
     * @param {?=} userId
     * @return {?}
     */
    getConsignmentTracking(orderCode, consignmentCode, userId) {
        return this.adapter.getConsignmentTracking(orderCode, consignmentCode, userId);
    }
    /**
     * @param {?} userId
     * @param {?} orderCode
     * @param {?} cancelRequestInput
     * @return {?}
     */
    cancel(userId, orderCode, cancelRequestInput) {
        return this.adapter.cancel(userId, orderCode, cancelRequestInput);
    }
    /**
     * @param {?} userId
     * @param {?} returnRequestInput
     * @return {?}
     */
    return(userId, returnRequestInput) {
        return this.adapter.createReturnRequest(userId, returnRequestInput);
    }
    /**
     * @param {?} userId
     * @param {?} returnRequestCode
     * @return {?}
     */
    getReturnRequestDetail(userId, returnRequestCode) {
        return this.adapter.loadReturnRequestDetail(userId, returnRequestCode);
    }
    /**
     * @param {?} userId
     * @param {?=} pageSize
     * @param {?=} currentPage
     * @param {?=} sort
     * @return {?}
     */
    getReturnRequestList(userId, pageSize, currentPage, sort) {
        return this.adapter.loadReturnRequestList(userId, pageSize, currentPage, sort);
    }
    /**
     * @param {?} userId
     * @param {?} returnRequestCode
     * @param {?} returnRequestModification
     * @return {?}
     */
    cancelReturnRequest(userId, returnRequestCode, returnRequestModification) {
        return this.adapter.cancelReturnRequest(userId, returnRequestCode, returnRequestModification);
    }
}
UserOrderConnector.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root',
            },] }
];
/** @nocollapse */
UserOrderConnector.ctorParameters = () => [
    { type: UserOrderAdapter }
];
/** @nocollapse */ UserOrderConnector.ngInjectableDef = ɵɵdefineInjectable({ factory: function UserOrderConnector_Factory() { return new UserOrderConnector(ɵɵinject(UserOrderAdapter)); }, token: UserOrderConnector, providedIn: "root" });
if (false) {
    /**
     * @type {?}
     * @protected
     */
    UserOrderConnector.prototype.adapter;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class CustomerCouponConnector {
    /**
     * @param {?} adapter
     */
    constructor(adapter) {
        this.adapter = adapter;
    }
    /**
     * @param {?} userId
     * @param {?} pageSize
     * @param {?} currentPage
     * @param {?} sort
     * @return {?}
     */
    getCustomerCoupons(userId, pageSize, currentPage, sort) {
        return this.adapter.getCustomerCoupons(userId, pageSize, currentPage, sort);
    }
    /**
     * @param {?} userId
     * @param {?} couponCode
     * @return {?}
     */
    turnOnNotification(userId, couponCode) {
        return this.adapter.turnOnNotification(userId, couponCode);
    }
    /**
     * @param {?} userId
     * @param {?} couponCode
     * @return {?}
     */
    turnOffNotification(userId, couponCode) {
        return this.adapter.turnOffNotification(userId, couponCode);
    }
    /**
     * @param {?} userId
     * @param {?} couponCode
     * @return {?}
     */
    claimCustomerCoupon(userId, couponCode) {
        return this.adapter.claimCustomerCoupon(userId, couponCode);
    }
}
CustomerCouponConnector.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root',
            },] }
];
/** @nocollapse */
CustomerCouponConnector.ctorParameters = () => [
    { type: CustomerCouponAdapter }
];
/** @nocollapse */ CustomerCouponConnector.ngInjectableDef = ɵɵdefineInjectable({ factory: function CustomerCouponConnector_Factory() { return new CustomerCouponConnector(ɵɵinject(CustomerCouponAdapter)); }, token: CustomerCouponConnector, providedIn: "root" });
if (false) {
    /**
     * @type {?}
     * @protected
     */
    CustomerCouponConnector.prototype.adapter;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class UserInterestsConnector {
    /**
     * @param {?} adapter
     */
    constructor(adapter) {
        this.adapter = adapter;
    }
    /**
     * @param {?} userId
     * @param {?=} pageSize
     * @param {?=} currentPage
     * @param {?=} sort
     * @param {?=} productCode
     * @param {?=} notificationType
     * @return {?}
     */
    getInterests(userId, pageSize, currentPage, sort, productCode, notificationType) {
        return this.adapter.getInterests(userId, pageSize, currentPage, sort, productCode, notificationType);
    }
    /**
     * @param {?} userId
     * @param {?} item
     * @return {?}
     */
    removeInterest(userId, item) {
        return this.adapter.removeInterest(userId, item);
    }
    /**
     * @param {?} userId
     * @param {?} productCode
     * @param {?} notificationType
     * @return {?}
     */
    addInterest(userId, productCode, notificationType) {
        return this.adapter.addInterest(userId, productCode, notificationType);
    }
}
UserInterestsConnector.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root',
            },] }
];
/** @nocollapse */
UserInterestsConnector.ctorParameters = () => [
    { type: UserInterestsAdapter }
];
/** @nocollapse */ UserInterestsConnector.ngInjectableDef = ɵɵdefineInjectable({ factory: function UserInterestsConnector_Factory() { return new UserInterestsConnector(ɵɵinject(UserInterestsAdapter)); }, token: UserInterestsConnector, providedIn: "root" });
if (false) {
    /**
     * @type {?}
     * @protected
     */
    UserInterestsConnector.prototype.adapter;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Unified facade for both anonymous and registered user consents.
 */
class ConsentService {
    /**
     * @param {?} anonymousConsentsService
     * @param {?} userConsentService
     */
    constructor(anonymousConsentsService, userConsentService) {
        this.anonymousConsentsService = anonymousConsentsService;
        this.userConsentService = userConsentService;
    }
    /**
     * Returns either anonymous consent or registered consent as they are emmited.
     * @param {?} templateCode for which to return either anonymous or registered consent.
     * @return {?}
     */
    getConsent(templateCode) {
        return merge(this.userConsentService.getConsent(templateCode), this.anonymousConsentsService.getConsent(templateCode));
    }
    /**
     * Checks if the `templateId`'s template has a given consent.
     * The method returns `false` if the consent doesn't exist or if it's withdrawn. Otherwise, `true` is returned.
     *
     * @param {?} templateId of a template which's consent should be checked
     * @return {?}
     */
    checkConsentGivenByTemplateId(templateId) {
        return this.getConsent(templateId).pipe(map((/**
         * @param {?} consent
         * @return {?}
         */
        consent => {
            if (!consent) {
                return false;
            }
            return this.isAnonymousConsentType(consent)
                ? this.anonymousConsentsService.isConsentGiven(consent)
                : this.userConsentService.isConsentGiven(consent);
        })), distinctUntilChanged());
    }
    /**
     * Checks if the `templateId`'s template has a withdrawn consent.
     * The method returns `true` if the consent doesn't exist or if it's withdrawn. Otherwise, `false` is returned.
     *
     * @param {?} templateId of a template which's consent should be checked
     * @return {?}
     */
    checkConsentWithdrawnByTemplateId(templateId) {
        return this.getConsent(templateId).pipe(map((/**
         * @param {?} consent
         * @return {?}
         */
        consent => {
            if (!consent) {
                return true;
            }
            return this.isAnonymousConsentType(consent)
                ? this.anonymousConsentsService.isConsentWithdrawn(consent)
                : this.userConsentService.isConsentWithdrawn(consent);
        })), distinctUntilChanged());
    }
    /**
     *
     * Checks the provided `consent`'s type and delegates to an appropriate method - `anonymousConsentsService.isConsentGiven(consent)` or `this.userConsentService.isConsentGiven`
     *
     * @param {?} consent a consent to check
     * @return {?}
     */
    isConsentGiven(consent) {
        return this.isAnonymousConsentType(consent)
            ? this.anonymousConsentsService.isConsentGiven(consent)
            : this.userConsentService.isConsentGiven(consent);
    }
    /**
     *
     * Checks the provided `consent`'s type and delegates to an appropriate method - `anonymousConsentsService.isConsentWithdrawn(consent)` or `this.userConsentService.isConsentWithdrawn`
     *
     * @param {?} consent a consent to check
     * @return {?}
     */
    isConsentWithdrawn(consent) {
        return this.isAnonymousConsentType(consent)
            ? this.anonymousConsentsService.isConsentWithdrawn(consent)
            : this.userConsentService.isConsentWithdrawn(consent);
    }
    /**
     * Returns `true` if the provided consent is of type `AnonymousConsent`. Otherwise, `false` is returned.
     * @param {?} consent
     * @return {?}
     */
    isAnonymousConsentType(consent) {
        if (!consent) {
            return false;
        }
        return ((/** @type {?} */ (consent))).templateCode !== undefined;
    }
    /**
     * Returns `true` if the provided consent is of type `Consent`. Otherwise, `false` is returned.
     * @param {?} consent
     * @return {?}
     */
    isConsentType(consent) {
        if (!consent) {
            return false;
        }
        return ((/** @type {?} */ (consent))).code !== undefined;
    }
}
ConsentService.decorators = [
    { type: Injectable, args: [{ providedIn: 'root' },] }
];
/** @nocollapse */
ConsentService.ctorParameters = () => [
    { type: AnonymousConsentsService },
    { type: UserConsentService }
];
/** @nocollapse */ ConsentService.ngInjectableDef = ɵɵdefineInjectable({ factory: function ConsentService_Factory() { return new ConsentService(ɵɵinject(AnonymousConsentsService), ɵɵinject(UserConsentService)); }, token: ConsentService, providedIn: "root" });
if (false) {
    /**
     * @type {?}
     * @protected
     */
    ConsentService.prototype.anonymousConsentsService;
    /**
     * @type {?}
     * @protected
     */
    ConsentService.prototype.userConsentService;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class UserAddressService {
    /**
     * @param {?} store
     * @param {?=} authService
     */
    constructor(store, authService) {
        this.store = store;
        this.authService = authService;
    }
    /**
     * Retrieves user's addresses
     * @return {?}
     */
    loadAddresses() {
        this.withUserId((/**
         * @param {?} userId
         * @return {?}
         */
        userId => this.store.dispatch(new LoadUserAddresses(userId))));
    }
    /**
     * Adds user address
     * @param {?} address a user address
     * @return {?}
     */
    addUserAddress(address) {
        this.withUserId((/**
         * @param {?} userId
         * @return {?}
         */
        userId => this.store.dispatch(new AddUserAddress({
            userId,
            address,
        }))));
    }
    /**
     * Sets user address as default
     * @param {?} addressId a user address ID
     * @return {?}
     */
    setAddressAsDefault(addressId) {
        this.withUserId((/**
         * @param {?} userId
         * @return {?}
         */
        userId => this.store.dispatch(new UpdateUserAddress({
            userId,
            addressId,
            address: { defaultAddress: true },
        }))));
    }
    /**
     * Updates existing user address
     * @param {?} addressId a user address ID
     * @param {?} address a user address
     * @return {?}
     */
    updateUserAddress(addressId, address) {
        this.withUserId((/**
         * @param {?} userId
         * @return {?}
         */
        userId => this.store.dispatch(new UpdateUserAddress({
            userId,
            addressId,
            address,
        }))));
    }
    /**
     * Deletes existing user address
     * @param {?} addressId a user address ID
     * @return {?}
     */
    deleteUserAddress(addressId) {
        this.withUserId((/**
         * @param {?} userId
         * @return {?}
         */
        userId => this.store.dispatch(new DeleteUserAddress({
            userId,
            addressId,
        }))));
    }
    /**
     * Returns addresses
     * @return {?}
     */
    getAddresses() {
        return this.store.pipe(select(getAddresses));
    }
    /**
     * Returns a loading flag for addresses
     * @return {?}
     */
    getAddressesLoading() {
        return this.store.pipe(select(getAddressesLoading));
    }
    /**
     * @return {?}
     */
    getAddressesLoadedSuccess() {
        return this.store.pipe(select(getAddressesLoadedSuccess));
    }
    /**
     * Retrieves delivery countries
     * @return {?}
     */
    loadDeliveryCountries() {
        this.store.dispatch(new LoadDeliveryCountries());
    }
    /**
     * Returns all delivery countries
     * @return {?}
     */
    getDeliveryCountries() {
        return this.store.pipe(select(getAllDeliveryCountries));
    }
    /**
     * Returns a country based on the provided `isocode`
     * @param {?} isocode an isocode for a country
     * @return {?}
     */
    getCountry(isocode) {
        return this.store.pipe(select(countrySelectorFactory(isocode)));
    }
    /**
     * Retrieves regions for specified country by `countryIsoCode`
     * @param {?} countryIsoCode
     * @return {?}
     */
    loadRegions(countryIsoCode) {
        this.store.dispatch(new LoadRegions(countryIsoCode));
    }
    /**
     * Clear regions in store - useful when changing country
     * @return {?}
     */
    clearRegions() {
        this.store.dispatch(new ClearRegions());
    }
    /**
     * Returns all regions
     * @param {?} countryIsoCode
     * @return {?}
     */
    getRegions(countryIsoCode) {
        return this.store.pipe(select(getRegionsDataAndLoading), map((/**
         * @param {?} __0
         * @return {?}
         */
        ({ regions, country, loading, loaded }) => {
            if (!countryIsoCode && (loading || loaded)) {
                this.clearRegions();
                return [];
            }
            else if (loading && !loaded) {
                // don't interrupt loading
                return [];
            }
            else if (!loading && countryIsoCode !== country && countryIsoCode) {
                // country changed - clear store and load new regions
                if (country) {
                    this.clearRegions();
                }
                this.loadRegions(countryIsoCode);
                return [];
            }
            return regions;
        })));
    }
    /**
     * Utility method to distinquish pre / post 1.3.0 in a convenient way.
     *
     * @private
     * @param {?} callback
     * @return {?}
     */
    withUserId(callback) {
        if (this.authService) {
            this.authService
                .getOccUserId()
                .pipe(take(1))
                .subscribe((/**
             * @param {?} userId
             * @return {?}
             */
            userId => callback(userId)));
        }
        else {
            // TODO(issue:#5628) Deprecated since 1.3.0
            callback(OCC_USER_ID_CURRENT);
        }
    }
}
UserAddressService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root',
            },] }
];
/** @nocollapse */
UserAddressService.ctorParameters = () => [
    { type: Store },
    { type: AuthService }
];
/** @nocollapse */ UserAddressService.ngInjectableDef = ɵɵdefineInjectable({ factory: function UserAddressService_Factory() { return new UserAddressService(ɵɵinject(Store), ɵɵinject(AuthService)); }, token: UserAddressService, providedIn: "root" });
if (false) {
    /**
     * @type {?}
     * @protected
     */
    UserAddressService.prototype.store;
    /**
     * @type {?}
     * @protected
     */
    UserAddressService.prototype.authService;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class UserOrderService {
    /**
     * @param {?} store
     * @param {?=} authService
     */
    constructor(store, authService) {
        this.store = store;
        this.authService = authService;
    }
    /**
     * Returns an order's detail
     * @return {?}
     */
    getOrderDetails() {
        return this.store.pipe(select(getOrderDetails));
    }
    /**
     * Retrieves order's details
     *
     * @param {?} orderCode an order code
     * @return {?}
     */
    loadOrderDetails(orderCode) {
        this.withUserId((/**
         * @param {?} userId
         * @return {?}
         */
        userId => this.store.dispatch(new LoadOrderDetails({
            userId,
            orderCode,
        }))));
    }
    /**
     * Clears order's details
     * @return {?}
     */
    clearOrderDetails() {
        this.store.dispatch(new ClearOrderDetails());
    }
    /**
     * Returns order history list
     * @param {?} pageSize
     * @return {?}
     */
    getOrderHistoryList(pageSize) {
        return this.store.pipe(select(getOrdersState), tap((/**
         * @param {?} orderListState
         * @return {?}
         */
        orderListState => {
            /** @type {?} */
            const attemptedLoad = orderListState.loading ||
                orderListState.success ||
                orderListState.error;
            if (!attemptedLoad) {
                this.loadOrderList(pageSize);
            }
        })), map((/**
         * @param {?} orderListState
         * @return {?}
         */
        orderListState => orderListState.value)));
    }
    /**
     * Returns a loaded flag for order history list
     * @return {?}
     */
    getOrderHistoryListLoaded() {
        return this.store.pipe(select(getOrdersLoaded));
    }
    /**
     * Retrieves an order list
     * @param {?} pageSize page size
     * @param {?=} currentPage current page
     * @param {?=} sort sort
     * @return {?}
     */
    loadOrderList(pageSize, currentPage, sort) {
        this.withUserId((/**
         * @param {?} userId
         * @return {?}
         */
        userId => this.store.dispatch(new LoadUserOrders({
            userId,
            pageSize,
            currentPage,
            sort,
        }))));
    }
    /**
     * Cleaning order list
     * @return {?}
     */
    clearOrderList() {
        this.store.dispatch(new ClearUserOrders());
    }
    /**
     *  Returns a consignment tracking detail
     * @return {?}
     */
    getConsignmentTracking() {
        return this.store.pipe(select(getConsignmentTracking));
    }
    /**
     * Retrieves consignment tracking details
     * @param {?} orderCode an order code
     * @param {?} consignmentCode a consignment code
     * @return {?}
     */
    loadConsignmentTracking(orderCode, consignmentCode) {
        this.withUserId((/**
         * @param {?} userId
         * @return {?}
         */
        userId => this.store.dispatch(new LoadConsignmentTracking({
            userId,
            orderCode,
            consignmentCode,
        }))));
    }
    /**
     * Cleaning consignment tracking
     * @return {?}
     */
    clearConsignmentTracking() {
        this.store.dispatch(new ClearConsignmentTracking());
    }
    /*
       * Cancel an order
       */
    /**
     * @param {?} orderCode
     * @param {?} cancelRequestInput
     * @return {?}
     */
    cancelOrder(orderCode, cancelRequestInput) {
        this.withUserId((/**
         * @param {?} userId
         * @return {?}
         */
        userId => {
            this.store.dispatch(new CancelOrder({
                userId,
                orderCode,
                cancelRequestInput,
            }));
        }));
    }
    /**
     * Returns the cancel order loading flag
     * @return {?}
     */
    getCancelOrderLoading() {
        return this.store.pipe(select(getProcessLoadingFactory(CANCEL_ORDER_PROCESS_ID)));
    }
    /**
     * Returns the cancel order success flag
     * @return {?}
     */
    getCancelOrderSuccess() {
        return this.store.pipe(select(getProcessSuccessFactory(CANCEL_ORDER_PROCESS_ID)));
    }
    /**
     * Resets the cancel order process flags
     * @return {?}
     */
    resetCancelOrderProcessState() {
        return this.store.dispatch(new ResetCancelOrderProcess());
    }
    /**
     * Utility method to distinquish pre / post 1.3.0 in a convenient way.
     *
     * @private
     * @param {?} callback
     * @return {?}
     */
    withUserId(callback) {
        if (this.authService) {
            this.authService
                .getOccUserId()
                .pipe(take(1))
                .subscribe((/**
             * @param {?} userId
             * @return {?}
             */
            userId => callback(userId)));
        }
        else {
            // TODO(issue:#5628) Deprecated since 1.3.0
            callback(OCC_USER_ID_CURRENT);
        }
    }
}
UserOrderService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root',
            },] }
];
/** @nocollapse */
UserOrderService.ctorParameters = () => [
    { type: Store },
    { type: AuthService }
];
/** @nocollapse */ UserOrderService.ngInjectableDef = ɵɵdefineInjectable({ factory: function UserOrderService_Factory() { return new UserOrderService(ɵɵinject(Store), ɵɵinject(AuthService)); }, token: UserOrderService, providedIn: "root" });
if (false) {
    /**
     * @type {?}
     * @protected
     */
    UserOrderService.prototype.store;
    /**
     * @type {?}
     * @protected
     */
    UserOrderService.prototype.authService;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class CustomerCouponService {
    /**
     * @param {?} store
     */
    constructor(store) {
        this.store = store;
    }
    /**
     * Retrieves customer's coupons
     * @param {?} pageSize page size
     * @param {?=} currentPage current page
     * @param {?=} sort sort
     * @return {?}
     */
    loadCustomerCoupons(pageSize, currentPage, sort) {
        this.store.dispatch(new LoadCustomerCoupons({
            userId: OCC_USER_ID_CURRENT,
            pageSize: pageSize,
            currentPage: currentPage,
            sort: sort,
        }));
    }
    /**
     * Returns customer coupon search result
     * @param {?} pageSize page size
     * @return {?}
     */
    getCustomerCoupons(pageSize) {
        return this.store.pipe(select(getCustomerCouponsState), tap((/**
         * @param {?} customerCouponsState
         * @return {?}
         */
        customerCouponsState => {
            /** @type {?} */
            const attemptedLoad = customerCouponsState.loading ||
                customerCouponsState.success ||
                customerCouponsState.error;
            if (!attemptedLoad) {
                this.loadCustomerCoupons(pageSize);
            }
        })), map((/**
         * @param {?} customerCouponsState
         * @return {?}
         */
        customerCouponsState => customerCouponsState.value)));
    }
    /**
     * Returns a loaded flag for customer coupons
     * @return {?}
     */
    getCustomerCouponsLoaded() {
        return this.store.pipe(select(getCustomerCouponsLoaded));
    }
    /**
     * Returns a loading flag for customer coupons
     * @return {?}
     */
    getCustomerCouponsLoading() {
        return this.store.pipe(select(getCustomerCouponsLoading));
    }
    /**
     * Subscribe a CustomerCoupon Notification
     * @param {?} couponCode a customer coupon code
     * @return {?}
     */
    subscribeCustomerCoupon(couponCode) {
        this.store.dispatch(new SubscribeCustomerCoupon({
            userId: OCC_USER_ID_CURRENT,
            couponCode: couponCode,
        }));
    }
    /**
     * Returns the subscribe customer coupon notification process loading flag
     * @return {?}
     */
    getSubscribeCustomerCouponResultLoading() {
        return this.store.pipe(select(getProcessLoadingFactory(SUBSCRIBE_CUSTOMER_COUPON_PROCESS_ID)));
    }
    /**
     * Returns the subscribe customer coupon notification process success flag
     * @return {?}
     */
    getSubscribeCustomerCouponResultSuccess() {
        return this.store.pipe(select(getProcessSuccessFactory(SUBSCRIBE_CUSTOMER_COUPON_PROCESS_ID)));
    }
    /**
     * Returns the subscribe customer coupon notification process error flag
     * @return {?}
     */
    getSubscribeCustomerCouponResultError() {
        return this.store.pipe(select(getProcessErrorFactory(SUBSCRIBE_CUSTOMER_COUPON_PROCESS_ID)));
    }
    /**
     * Unsubscribe a CustomerCoupon Notification
     * @param {?} couponCode a customer coupon code
     * @return {?}
     */
    unsubscribeCustomerCoupon(couponCode) {
        this.store.dispatch(new UnsubscribeCustomerCoupon({
            userId: OCC_USER_ID_CURRENT,
            couponCode: couponCode,
        }));
    }
    /**
     * Returns the unsubscribe customer coupon notification process loading flag
     * @return {?}
     */
    getUnsubscribeCustomerCouponResultLoading() {
        return this.store.pipe(select(getProcessLoadingFactory(UNSUBSCRIBE_CUSTOMER_COUPON_PROCESS_ID)));
    }
    /**
     * Returns the unsubscribe customer coupon notification process success flag
     * @return {?}
     */
    getUnsubscribeCustomerCouponResultSuccess() {
        return this.store.pipe(select(getProcessSuccessFactory(UNSUBSCRIBE_CUSTOMER_COUPON_PROCESS_ID)));
    }
    /**
     * Returns the unsubscribe customer coupon notification process error flag
     * @return {?}
     */
    getUnsubscribeCustomerCouponResultError() {
        return this.store.pipe(select(getProcessErrorFactory(UNSUBSCRIBE_CUSTOMER_COUPON_PROCESS_ID)));
    }
    /**
     * Claim a CustomerCoupon
     * @param {?} couponCode a customer coupon code
     * @return {?}
     */
    claimCustomerCoupon(couponCode) {
        this.store.dispatch(new ClaimCustomerCoupon({
            userId: OCC_USER_ID_CURRENT,
            couponCode: couponCode,
        }));
    }
    /**
     * Returns the claim customer coupon notification process success flag
     * @return {?}
     */
    getClaimCustomerCouponResultSuccess() {
        return this.store.pipe(select(getProcessSuccessFactory(CLAIM_CUSTOMER_COUPON_PROCESS_ID)));
    }
}
CustomerCouponService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root',
            },] }
];
/** @nocollapse */
CustomerCouponService.ctorParameters = () => [
    { type: Store }
];
/** @nocollapse */ CustomerCouponService.ngInjectableDef = ɵɵdefineInjectable({ factory: function CustomerCouponService_Factory() { return new CustomerCouponService(ɵɵinject(Store)); }, token: CustomerCouponService, providedIn: "root" });
if (false) {
    /**
     * @type {?}
     * @protected
     */
    CustomerCouponService.prototype.store;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class UserPaymentService {
    /**
     * @param {?} store
     * @param {?=} authService
     */
    constructor(store, authService) {
        this.store = store;
        this.authService = authService;
    }
    /**
     * Loads all user's payment methods.
     * @return {?}
     */
    loadPaymentMethods() {
        this.withUserId((/**
         * @param {?} userId
         * @return {?}
         */
        userId => this.store.dispatch(new LoadUserPaymentMethods(userId))));
    }
    /**
     * Returns all user's payment methods
     * @return {?}
     */
    getPaymentMethods() {
        return this.store.pipe(select(getPaymentMethods));
    }
    /**
     * Returns a loading flag for payment methods
     * @return {?}
     */
    getPaymentMethodsLoading() {
        return this.store.pipe(select(getPaymentMethodsLoading));
    }
    /**
     * @return {?}
     */
    getPaymentMethodsLoadedSuccess() {
        return this.store.pipe(select(getPaymentMethodsLoadedSuccess));
    }
    /**
     * Sets the payment as a default one
     * @param {?} paymentMethodId a payment method ID
     * @return {?}
     */
    setPaymentMethodAsDefault(paymentMethodId) {
        this.withUserId((/**
         * @param {?} userId
         * @return {?}
         */
        userId => this.store.dispatch(new SetDefaultUserPaymentMethod({
            userId,
            paymentMethodId,
        }))));
    }
    /**
     * Deletes the payment method
     *
     * @param {?} paymentMethodId a payment method ID
     * @return {?}
     */
    deletePaymentMethod(paymentMethodId) {
        this.withUserId((/**
         * @param {?} userId
         * @return {?}
         */
        userId => this.store.dispatch(new DeleteUserPaymentMethod({
            userId,
            paymentMethodId,
        }))));
    }
    /**
     * Returns all billing countries
     * @return {?}
     */
    getAllBillingCountries() {
        return this.store.pipe(select(getAllBillingCountries));
    }
    /**
     * Retrieves billing countries
     * @return {?}
     */
    loadBillingCountries() {
        this.store.dispatch(new LoadBillingCountries());
    }
    /**
     * Utility method to distinquish pre / post 1.3.0 in a convenient way.
     *
     * @private
     * @param {?} callback
     * @return {?}
     */
    withUserId(callback) {
        if (this.authService) {
            this.authService
                .getOccUserId()
                .pipe(take(1))
                .subscribe((/**
             * @param {?} userId
             * @return {?}
             */
            userId => callback(userId)));
        }
        else {
            // TODO(issue:#5628) Deprecated since 1.3.0
            callback(OCC_USER_ID_CURRENT);
        }
    }
}
UserPaymentService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root',
            },] }
];
/** @nocollapse */
UserPaymentService.ctorParameters = () => [
    { type: Store },
    { type: AuthService }
];
/** @nocollapse */ UserPaymentService.ngInjectableDef = ɵɵdefineInjectable({ factory: function UserPaymentService_Factory() { return new UserPaymentService(ɵɵinject(Store), ɵɵinject(AuthService)); }, token: UserPaymentService, providedIn: "root" });
if (false) {
    /**
     * @type {?}
     * @protected
     */
    UserPaymentService.prototype.store;
    /**
     * @type {?}
     * @protected
     */
    UserPaymentService.prototype.authService;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class OrderReturnRequestService {
    /**
     * @param {?} store
     * @param {?} authService
     */
    constructor(store, authService) {
        this.store = store;
        this.authService = authService;
    }
    /**
     * Create order return request
     * @param {?} returnRequestInput order return request entry input
     * @return {?}
     */
    createOrderReturnRequest(returnRequestInput) {
        this.withUserId((/**
         * @param {?} userId
         * @return {?}
         */
        userId => {
            this.store.dispatch(new CreateOrderReturnRequest({
                userId,
                returnRequestInput,
            }));
        }));
    }
    /**
     * Return an order return request
     * @return {?}
     */
    getOrderReturnRequest() {
        return this.store.pipe(select(getOrderReturnRequest));
    }
    /**
     * Gets order return request list
     * @param {?} pageSize
     * @return {?}
     */
    getOrderReturnRequestList(pageSize) {
        return this.store.pipe(select(getOrderReturnRequestListState), tap((/**
         * @param {?} returnListState
         * @return {?}
         */
        returnListState => {
            /** @type {?} */
            const attemptedLoad = returnListState.loading ||
                returnListState.success ||
                returnListState.error;
            if (!attemptedLoad) {
                this.loadOrderReturnRequestList(pageSize);
            }
        })), map((/**
         * @param {?} returnListState
         * @return {?}
         */
        returnListState => returnListState.value)));
    }
    /**
     * Loads order return request detail
     * @param {?} returnRequestCode
     * @return {?}
     */
    loadOrderReturnRequestDetail(returnRequestCode) {
        this.withUserId((/**
         * @param {?} userId
         * @return {?}
         */
        userId => {
            this.store.dispatch(new LoadOrderReturnRequest({
                userId: userId,
                returnRequestCode,
            }));
        }));
    }
    /**
     * Loads order return request list
     * @param {?} pageSize page size
     * @param {?=} currentPage current page
     * @param {?=} sort sort
     * @return {?}
     */
    loadOrderReturnRequestList(pageSize, currentPage, sort) {
        this.withUserId((/**
         * @param {?} userId
         * @return {?}
         */
        userId => {
            this.store.dispatch(new LoadOrderReturnRequestList({
                userId: userId,
                pageSize: pageSize,
                currentPage: currentPage,
                sort: sort,
            }));
        }));
    }
    /**
     * Cleaning order return request list
     * @return {?}
     */
    clearOrderReturnRequestList() {
        this.store.dispatch(new ClearOrderReturnRequestList());
    }
    /**
     * Get the order return request loading flag
     * @return {?}
     */
    getReturnRequestLoading() {
        return this.store.pipe(select(getOrderReturnRequestLoading));
    }
    /**
     * Get the order return request success flag
     * @return {?}
     */
    getReturnRequestSuccess() {
        return this.store.pipe(select(getOrderReturnRequestSuccess));
    }
    /**
     * Cleaning order return request details
     * @return {?}
     */
    clearOrderReturnRequestDetail() {
        this.store.dispatch(new ClearOrderReturnRequest());
    }
    /*
       * Cancel order return request
       */
    /**
     * @param {?} returnRequestCode
     * @param {?} returnRequestModification
     * @return {?}
     */
    cancelOrderReturnRequest(returnRequestCode, returnRequestModification) {
        this.withUserId((/**
         * @param {?} userId
         * @return {?}
         */
        userId => {
            this.store.dispatch(new CancelOrderReturnRequest({
                userId,
                returnRequestCode,
                returnRequestModification,
            }));
        }));
    }
    /**
     * Returns the cancel return request loading flag
     * @return {?}
     */
    getCancelReturnRequestLoading() {
        return this.store.pipe(select(getProcessLoadingFactory(CANCEL_RETURN_PROCESS_ID)));
    }
    /**
     * Returns the cancel return request success flag
     * @return {?}
     */
    getCancelReturnRequestSuccess() {
        return this.store.pipe(select(getProcessSuccessFactory(CANCEL_RETURN_PROCESS_ID)));
    }
    /**
     * Resets the cancel return request process flags
     * @return {?}
     */
    resetCancelReturnRequestProcessState() {
        return this.store.dispatch(new ResetCancelReturnProcess());
    }
    /*
       * Utility method to distinquish pre / post 1.3.0 in a convenient way.
       *
       */
    /**
     * @private
     * @param {?} callback
     * @return {?}
     */
    withUserId(callback) {
        if (this.authService) {
            this.authService
                .getOccUserId()
                .pipe(take(1))
                .subscribe((/**
             * @param {?} userId
             * @return {?}
             */
            userId => callback(userId)));
        }
        else {
            // TODO(issue:#5628) Deprecated since 1.3.0
            callback(OCC_USER_ID_CURRENT);
        }
    }
}
OrderReturnRequestService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root',
            },] }
];
/** @nocollapse */
OrderReturnRequestService.ctorParameters = () => [
    { type: Store },
    { type: AuthService }
];
/** @nocollapse */ OrderReturnRequestService.ngInjectableDef = ɵɵdefineInjectable({ factory: function OrderReturnRequestService_Factory() { return new OrderReturnRequestService(ɵɵinject(Store), ɵɵinject(AuthService)); }, token: OrderReturnRequestService, providedIn: "root" });
if (false) {
    /**
     * @type {?}
     * @protected
     */
    OrderReturnRequestService.prototype.store;
    /**
     * @type {?}
     * @protected
     */
    OrderReturnRequestService.prototype.authService;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class UserNotificationPreferenceService {
    /**
     * @param {?} store
     */
    constructor(store) {
        this.store = store;
    }
    /**
     * Returns all notification preferences.
     * @return {?}
     */
    getPreferences() {
        return this.store.pipe(select(getPreferences));
    }
    /**
     * Returns all enabled notification preferences.
     * @return {?}
     */
    getEnabledPreferences() {
        return this.store.pipe(select(getEnabledPreferences));
    }
    /**
     * Loads all notification preferences.
     * @return {?}
     */
    loadPreferences() {
        this.store.dispatch(new LoadNotificationPreferences(OCC_USER_ID_CURRENT));
    }
    /**
     * Clear all notification preferences.
     * @return {?}
     */
    clearPreferences() {
        this.store.dispatch(new ClearNotificationPreferences());
    }
    /**
     * Returns a loading flag for notification preferences.
     * @return {?}
     */
    getPreferencesLoading() {
        return this.store.pipe(select(getPreferencesLoading));
    }
    /**
     * Updating notification preferences.
     * @param {?} preferences a preference list
     * @return {?}
     */
    updatePreferences(preferences) {
        this.store.dispatch(new UpdateNotificationPreferences({
            userId: OCC_USER_ID_CURRENT,
            preferences: preferences,
        }));
    }
    /**
     * Returns a loading flag for updating preferences.
     * @return {?}
     */
    getUpdatePreferencesResultLoading() {
        return this.store.select(getProcessLoadingFactory(UPDATE_NOTIFICATION_PREFERENCES_PROCESS_ID));
    }
    /**
     * Resets the update notification preferences process state. The state needs to be
     * reset after the process concludes, regardless if it's a success or an error.
     * @return {?}
     */
    resetNotificationPreferences() {
        this.store.dispatch(new ResetNotificationPreferences());
    }
}
UserNotificationPreferenceService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root',
            },] }
];
/** @nocollapse */
UserNotificationPreferenceService.ctorParameters = () => [
    { type: Store }
];
/** @nocollapse */ UserNotificationPreferenceService.ngInjectableDef = ɵɵdefineInjectable({ factory: function UserNotificationPreferenceService_Factory() { return new UserNotificationPreferenceService(ɵɵinject(Store)); }, token: UserNotificationPreferenceService, providedIn: "root" });
if (false) {
    /**
     * @type {?}
     * @protected
     */
    UserNotificationPreferenceService.prototype.store;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class UserInterestsService {
    /**
     * @param {?} store
     */
    constructor(store) {
        this.store = store;
    }
    /**
     * Retrieves an product interest list
     * @param {?=} pageSize page size
     * @param {?=} currentPage current page
     * @param {?=} sort sort
     * @param {?=} productCode
     * @param {?=} notificationType
     * @return {?}
     */
    loadProductInterests(pageSize, currentPage, sort, productCode, notificationType) {
        this.store.dispatch(new LoadProductInterests({
            userId: OCC_USER_ID_CURRENT,
            pageSize: pageSize,
            currentPage: currentPage,
            sort: sort,
            productCode: productCode,
            notificationType: notificationType,
        }));
    }
    /**
     * Returns product interests
     * @return {?}
     */
    getProductInterests() {
        return this.store.pipe(select(getInterests));
    }
    /**
     * Returns product interests
     * @param {?=} pageSize the page size
     * @return {?}
     */
    getAndLoadProductInterests(pageSize) {
        return this.store.pipe(select(getInterestsState), tap((/**
         * @param {?} interestListState
         * @return {?}
         */
        interestListState => {
            /** @type {?} */
            const attemptedLoad = interestListState.loading ||
                interestListState.success ||
                interestListState.error;
            if (!attemptedLoad) {
                this.loadProductInterests(pageSize);
            }
        })), map((/**
         * @param {?} interestListState
         * @return {?}
         */
        interestListState => interestListState.value)));
    }
    /**
     * Returns a loading flag for product interests
     * @return {?}
     */
    getProdutInterestsLoading() {
        return this.store.pipe(select(getInterestsLoading));
    }
    /**
     * Removes a ProductInterestRelation
     * @param {?} item product interest relation item
     * @param {?=} singleDelete flag to delete only one interest
     * @return {?}
     */
    removeProdutInterest(item, singleDelete) {
        this.store.dispatch(new RemoveProductInterest({
            userId: OCC_USER_ID_CURRENT,
            item: item,
            singleDelete: singleDelete,
        }));
    }
    /**
     * Returns a loading flag for removing product interests.
     * @return {?}
     */
    getRemoveProdutInterestLoading() {
        return this.store.pipe(select(getProcessLoadingFactory(REMOVE_PRODUCT_INTERESTS_PROCESS_ID)));
    }
    /**
     * Returns a success flag for removing a product interests.
     * @return {?}
     */
    getRemoveProdutInterestSuccess() {
        return this.store.pipe(select(getProcessSuccessFactory(REMOVE_PRODUCT_INTERESTS_PROCESS_ID)));
    }
    /**
     * Add a new product interest.
     *
     * @param {?} productCode the product code
     * @param {?} notificationType the notification type
     * @return {?}
     */
    addProductInterest(productCode, notificationType) {
        this.store.dispatch(new AddProductInterest({
            userId: OCC_USER_ID_CURRENT,
            productCode: productCode,
            notificationType: notificationType,
        }));
    }
    /**
     * Returns a success flag for adding a product interest.
     * @return {?}
     */
    getAddProductInterestSuccess() {
        return this.store.pipe(select(getProcessSuccessFactory(ADD_PRODUCT_INTEREST_PROCESS_ID)));
    }
    /**
     * Returns a error flag for adding a product interest.
     * @return {?}
     */
    getAddProductInterestError() {
        return this.store.pipe(select(getProcessErrorFactory(ADD_PRODUCT_INTEREST_PROCESS_ID)));
    }
    /**
     * Reset product interest adding state.
     * @return {?}
     */
    resetAddInterestState() {
        this.store.dispatch(new ResetAddInterestState());
    }
    /**
     * Reset product interest removing state.
     * @return {?}
     */
    resetRemoveInterestState() {
        this.store.dispatch(new ResetRemoveInterestState());
    }
    /**
     * Clears product interests
     * @return {?}
     */
    clearProductInterests() {
        this.store.dispatch(new ClearProductInterests());
    }
}
UserInterestsService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root',
            },] }
];
/** @nocollapse */
UserInterestsService.ctorParameters = () => [
    { type: Store }
];
/** @nocollapse */ UserInterestsService.ngInjectableDef = ɵɵdefineInjectable({ factory: function UserInterestsService_Factory() { return new UserInterestsService(ɵɵinject(Store)); }, token: UserInterestsService, providedIn: "root" });
if (false) {
    /**
     * @type {?}
     * @protected
     */
    UserInterestsService.prototype.store;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const initialState$l = {
    entities: {},
};
/**
 * @param {?=} state
 * @param {?=} action
 * @return {?}
 */
function reducer$l(state = initialState$l, action) {
    switch (action.type) {
        case LOAD_BILLING_COUNTRIES_SUCCESS: {
            /** @type {?} */
            const billingCountries = action.payload;
            /** @type {?} */
            const entities = billingCountries.reduce((/**
             * @param {?} countryEntities
             * @param {?} name
             * @return {?}
             */
            (countryEntities, name) => {
                return Object.assign({}, countryEntities, { [name.isocode]: name });
            }), Object.assign({}, state.entities));
            return Object.assign({}, state, { entities });
        }
        case CLEAR_USER_MISCS_DATA: {
            return initialState$l;
        }
    }
    return state;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const initialState$m = {};
/**
 * @param {?=} state
 * @param {?=} action
 * @return {?}
 */
function reducer$m(state = initialState$m, action) {
    switch (action.type) {
        case LOAD_CONSIGNMENT_TRACKING_SUCCESS: {
            /** @type {?} */
            const tracking = action.payload;
            return {
                tracking,
            };
        }
        case CLEAR_CONSIGNMENT_TRACKING: {
            return initialState$m;
        }
    }
    return state;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const initialState$n = {
    entities: {},
};
/**
 * @param {?=} state
 * @param {?=} action
 * @return {?}
 */
function reducer$n(state = initialState$n, action) {
    switch (action.type) {
        case LOAD_DELIVERY_COUNTRIES_SUCCESS: {
            /** @type {?} */
            const deliveryCountries = action.payload;
            /** @type {?} */
            const entities = deliveryCountries.reduce((/**
             * @param {?} countryEntities
             * @param {?} country
             * @return {?}
             */
            (countryEntities, country) => {
                return Object.assign({}, countryEntities, { [country.isocode]: country });
            }), Object.assign({}, state.entities));
            return Object.assign({}, state, { entities });
        }
        case CLEAR_USER_MISCS_DATA: {
            return initialState$n;
        }
    }
    return state;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const initialState$o = [];
/**
 * @param {?=} state
 * @param {?=} action
 * @return {?}
 */
function reducer$o(state = initialState$o, action) {
    switch (action.type) {
        case LOAD_NOTIFICATION_PREFERENCES_FAIL: {
            return initialState$o;
        }
        case LOAD_NOTIFICATION_PREFERENCES_SUCCESS:
        case UPDATE_NOTIFICATION_PREFERENCES_SUCCESS: {
            return action.payload ? action.payload : initialState$o;
        }
    }
    return state;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const initialState$p = {};
/**
 * @param {?=} state
 * @param {?=} action
 * @return {?}
 */
function reducer$p(state = initialState$p, action) {
    switch (action.type) {
        case LOAD_ORDER_DETAILS_SUCCESS: {
            /** @type {?} */
            const order = action.payload;
            return order;
        }
    }
    return state;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const initialState$q = [];
/**
 * @param {?=} state
 * @param {?=} action
 * @return {?}
 */
function reducer$q(state = initialState$q, action) {
    switch (action.type) {
        case LOAD_USER_PAYMENT_METHODS_SUCCESS: {
            return action.payload ? action.payload : initialState$q;
        }
        case LOAD_USER_PAYMENT_METHODS_FAIL: {
            return initialState$q;
        }
    }
    return state;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const initialState$r = {
    entities: [],
    country: null,
};
/**
 * @param {?=} state
 * @param {?=} action
 * @return {?}
 */
function reducer$r(state = initialState$r, action) {
    switch (action.type) {
        case LOAD_REGIONS_SUCCESS: {
            /** @type {?} */
            const entities = action.payload.entities;
            /** @type {?} */
            const country = action.payload.country;
            if (entities || country) {
                return Object.assign({}, state, { entities,
                    country });
            }
            return initialState$r;
        }
    }
    return state;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const initialState$s = false;
/**
 * @param {?=} state
 * @param {?=} action
 * @return {?}
 */
function reducer$s(state = initialState$s, action) {
    switch (action.type) {
        case RESET_PASSWORD_SUCCESS: {
            return true;
        }
    }
    return state;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const initialState$t = {
    entities: {},
};
/**
 * @param {?=} state
 * @param {?=} action
 * @return {?}
 */
function reducer$t(state = initialState$t, action) {
    switch (action.type) {
        case LOAD_TITLES_SUCCESS: {
            /** @type {?} */
            const titles = action.payload;
            /** @type {?} */
            const entities = titles.reduce((/**
             * @param {?} titleEntities
             * @param {?} name
             * @return {?}
             */
            (titleEntities, name) => {
                return Object.assign({}, titleEntities, { [name.code]: name });
            }), Object.assign({}, state.entities));
            return Object.assign({}, state, { entities });
        }
        case CLEAR_USER_MISCS_DATA: {
            return initialState$t;
        }
    }
    return state;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const initialState$u = [];
/**
 * @param {?=} state
 * @param {?=} action
 * @return {?}
 */
function reducer$u(state = initialState$u, action) {
    switch (action.type) {
        case LOAD_USER_ADDRESSES_FAIL: {
            return initialState$u;
        }
        case LOAD_USER_ADDRESSES_SUCCESS: {
            return action.payload ? action.payload : initialState$u;
        }
    }
    return state;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const initialState$v = [];
/**
 * @param {?=} state
 * @param {?=} action
 * @return {?}
 */
function reducer$v(state = initialState$v, action) {
    switch (action.type) {
        case LOAD_USER_CONSENTS_SUCCESS: {
            /** @type {?} */
            const consents = action.payload;
            return consents ? consents : initialState$v;
        }
        case GIVE_USER_CONSENT_SUCCESS: {
            /** @type {?} */
            const updatedConsentTemplate = action.consentTemplate;
            return state.map((/**
             * @param {?} consentTemplate
             * @return {?}
             */
            consentTemplate => consentTemplate.id === updatedConsentTemplate.id
                ? updatedConsentTemplate
                : consentTemplate));
        }
    }
    return state;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const initialState$w = (/** @type {?} */ ({}));
/**
 * @param {?=} state
 * @param {?=} action
 * @return {?}
 */
function reducer$w(state = initialState$w, action) {
    switch (action.type) {
        case LOAD_USER_DETAILS_SUCCESS: {
            return action.payload;
        }
        case UPDATE_USER_DETAILS_SUCCESS: {
            /** @type {?} */
            const updatedDetails = Object.assign({}, state, action.userUpdates);
            return Object.assign({}, updatedDetails, { name: `${updatedDetails.firstName} ${updatedDetails.lastName}` });
        }
    }
    return state;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const initialState$x = {
    orders: [],
    pagination: {},
    sorts: [],
};
/**
 * @param {?=} state
 * @param {?=} action
 * @return {?}
 */
function reducer$x(state = initialState$x, action) {
    switch (action.type) {
        case LOAD_USER_ORDERS_SUCCESS: {
            return action.payload ? action.payload : initialState$x;
        }
        case LOAD_USER_ORDERS_FAIL: {
            return initialState$x;
        }
    }
    return state;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const initialState$y = {
    coupons: [],
    sorts: [],
    pagination: {},
};
/**
 * @param {?=} state
 * @param {?=} action
 * @return {?}
 */
function reducer$y(state = initialState$y, action) {
    switch (action.type) {
        case LOAD_CUSTOMER_COUPONS_SUCCESS: {
            return action.payload;
        }
        case SUBSCRIBE_CUSTOMER_COUPON_SUCCESS: {
            /** @type {?} */
            const updatedCustomerCoupon = action.payload.coupon;
            /** @type {?} */
            const customerCoupons = new Array(state.coupons.length);
            state.coupons.forEach((/**
             * @param {?} customerCoupon
             * @param {?} index
             * @return {?}
             */
            (customerCoupon, index) => customerCoupon.couponId === updatedCustomerCoupon.couponId
                ? (customerCoupons[index] = updatedCustomerCoupon)
                : (customerCoupons[index] = customerCoupon)));
            return Object.assign({}, state, { coupons: customerCoupons });
        }
        case UNSUBSCRIBE_CUSTOMER_COUPON_SUCCESS: {
            /** @type {?} */
            const updatedCouponCode = action.payload;
            /** @type {?} */
            const customerCoupons = new Array(state.coupons.length);
            state.coupons.forEach((/**
             * @param {?} customerCoupon
             * @param {?} index
             * @return {?}
             */
            (customerCoupon, index) => customerCoupon.couponId === updatedCouponCode
                ? (customerCoupons[index] = Object.assign({}, customerCoupon, { notificationOn: false }))
                : (customerCoupons[index] = customerCoupon)));
            return Object.assign({}, state, { coupons: customerCoupons });
        }
    }
    return state;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const initialState$z = {
    results: [],
    pagination: {},
    sorts: [],
};
/**
 * @param {?=} state
 * @param {?=} action
 * @return {?}
 */
function reducer$z(state = initialState$z, action) {
    switch (action.type) {
        case LOAD_PRODUCT_INTERESTS_SUCCESS: {
            return action.payload ? action.payload : initialState$z;
        }
        case LOAD_PRODUCT_INTERESTS_FAIL: {
            return initialState$z;
        }
    }
    return state;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const initialState$A = {
    returnRequests: [],
    pagination: {},
    sorts: [],
};
/**
 * @param {?=} state
 * @param {?=} action
 * @return {?}
 */
function reducer$A(state = initialState$A, action) {
    switch (action.type) {
        case LOAD_ORDER_RETURN_REQUEST_LIST_SUCCESS: {
            return action.payload ? action.payload : initialState$A;
        }
    }
    return state;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @return {?}
 */
function getReducers$d() {
    return {
        account: combineReducers({
            details: reducer$w,
        }),
        addresses: loaderReducer(USER_ADDRESSES, reducer$u),
        billingCountries: reducer$l,
        consents: loaderReducer(USER_CONSENTS, reducer$v),
        payments: loaderReducer(USER_PAYMENT_METHODS, reducer$q),
        orders: loaderReducer(USER_ORDERS, reducer$x),
        order: loaderReducer(USER_ORDER_DETAILS, reducer$p),
        orderReturn: loaderReducer(USER_RETURN_REQUEST_DETAILS),
        orderReturnList: loaderReducer(USER_RETURN_REQUESTS, reducer$A),
        countries: reducer$n,
        titles: reducer$t,
        regions: loaderReducer(REGIONS, reducer$r),
        resetPassword: reducer$s,
        consignmentTracking: reducer$m,
        customerCoupons: loaderReducer(CUSTOMER_COUPONS, reducer$y),
        notificationPreferences: loaderReducer(NOTIFICATION_PREFERENCES, reducer$o),
        productInterests: loaderReducer(PRODUCT_INTERESTS, reducer$z),
    };
}
/** @type {?} */
const reducerToken$d = new InjectionToken('UserReducers');
/** @type {?} */
const reducerProvider$d = {
    provide: reducerToken$d,
    useFactory: getReducers$d,
};
/**
 * @param {?} reducer
 * @return {?}
 */
function clearUserState(reducer) {
    return (/**
     * @param {?} state
     * @param {?} action
     * @return {?}
     */
    function (state, action) {
        if (action.type === LOGOUT) {
            state = undefined;
        }
        return reducer(state, action);
    });
}
/** @type {?} */
const metaReducers$8 = [clearUserState];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class BillingCountriesEffect {
    /**
     * @param {?} actions$
     * @param {?} siteConnector
     */
    constructor(actions$, siteConnector) {
        this.actions$ = actions$;
        this.siteConnector = siteConnector;
        this.loadBillingCountries$ = this.actions$.pipe(ofType(LOAD_BILLING_COUNTRIES), switchMap((/**
         * @return {?}
         */
        () => {
            return this.siteConnector.getCountries(CountryType.BILLING).pipe(map((/**
             * @param {?} countries
             * @return {?}
             */
            countries => new LoadBillingCountriesSuccess(countries))), catchError((/**
             * @param {?} error
             * @return {?}
             */
            error => of(new LoadBillingCountriesFail(makeErrorSerializable(error))))));
        })));
    }
}
BillingCountriesEffect.decorators = [
    { type: Injectable }
];
/** @nocollapse */
BillingCountriesEffect.ctorParameters = () => [
    { type: Actions },
    { type: SiteConnector }
];
__decorate([
    Effect(),
    __metadata("design:type", Observable)
], BillingCountriesEffect.prototype, "loadBillingCountries$", void 0);
if (false) {
    /** @type {?} */
    BillingCountriesEffect.prototype.loadBillingCountries$;
    /**
     * @type {?}
     * @private
     */
    BillingCountriesEffect.prototype.actions$;
    /**
     * @type {?}
     * @private
     */
    BillingCountriesEffect.prototype.siteConnector;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ClearMiscsDataEffect {
    /**
     * @param {?} actions$
     */
    constructor(actions$) {
        this.actions$ = actions$;
        this.clearMiscsData$ = this.actions$.pipe(ofType(LANGUAGE_CHANGE, CURRENCY_CHANGE), map((/**
         * @return {?}
         */
        () => {
            return new ClearUserMiscsData();
        })));
    }
}
ClearMiscsDataEffect.decorators = [
    { type: Injectable }
];
/** @nocollapse */
ClearMiscsDataEffect.ctorParameters = () => [
    { type: Actions }
];
__decorate([
    Effect(),
    __metadata("design:type", Observable)
], ClearMiscsDataEffect.prototype, "clearMiscsData$", void 0);
if (false) {
    /** @type {?} */
    ClearMiscsDataEffect.prototype.clearMiscsData$;
    /**
     * @type {?}
     * @private
     */
    ClearMiscsDataEffect.prototype.actions$;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ConsignmentTrackingEffects {
    /**
     * @param {?} actions$
     * @param {?} userOrderConnector
     */
    constructor(actions$, userOrderConnector) {
        this.actions$ = actions$;
        this.userOrderConnector = userOrderConnector;
        this.loadConsignmentTracking$ = this.actions$.pipe(ofType(LOAD_CONSIGNMENT_TRACKING), map((/**
         * @param {?} action
         * @return {?}
         */
        (action) => action.payload)), switchMap((/**
         * @param {?} payload
         * @return {?}
         */
        payload => {
            return this.userOrderConnector
                .getConsignmentTracking(payload.orderCode, payload.consignmentCode, payload.userId)
                .pipe(map((/**
             * @param {?} tracking
             * @return {?}
             */
            (tracking) => new LoadConsignmentTrackingSuccess(tracking))), catchError((/**
             * @param {?} error
             * @return {?}
             */
            error => of(new LoadConsignmentTrackingFail(makeErrorSerializable(error))))));
        })));
    }
}
ConsignmentTrackingEffects.decorators = [
    { type: Injectable }
];
/** @nocollapse */
ConsignmentTrackingEffects.ctorParameters = () => [
    { type: Actions },
    { type: UserOrderConnector }
];
__decorate([
    Effect(),
    __metadata("design:type", Observable)
], ConsignmentTrackingEffects.prototype, "loadConsignmentTracking$", void 0);
if (false) {
    /** @type {?} */
    ConsignmentTrackingEffects.prototype.loadConsignmentTracking$;
    /**
     * @type {?}
     * @private
     */
    ConsignmentTrackingEffects.prototype.actions$;
    /**
     * @type {?}
     * @private
     */
    ConsignmentTrackingEffects.prototype.userOrderConnector;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class DeliveryCountriesEffects {
    /**
     * @param {?} actions$
     * @param {?} siteConnector
     */
    constructor(actions$, siteConnector) {
        this.actions$ = actions$;
        this.siteConnector = siteConnector;
        this.loadDeliveryCountries$ = this.actions$.pipe(ofType(LOAD_DELIVERY_COUNTRIES), switchMap((/**
         * @return {?}
         */
        () => {
            return this.siteConnector.getCountries(CountryType.SHIPPING).pipe(map((/**
             * @param {?} countries
             * @return {?}
             */
            countries => new LoadDeliveryCountriesSuccess(countries))), catchError((/**
             * @param {?} error
             * @return {?}
             */
            error => of(new LoadDeliveryCountriesFail(makeErrorSerializable(error))))));
        })));
    }
}
DeliveryCountriesEffects.decorators = [
    { type: Injectable }
];
/** @nocollapse */
DeliveryCountriesEffects.ctorParameters = () => [
    { type: Actions },
    { type: SiteConnector }
];
__decorate([
    Effect(),
    __metadata("design:type", Observable)
], DeliveryCountriesEffects.prototype, "loadDeliveryCountries$", void 0);
if (false) {
    /** @type {?} */
    DeliveryCountriesEffects.prototype.loadDeliveryCountries$;
    /**
     * @type {?}
     * @private
     */
    DeliveryCountriesEffects.prototype.actions$;
    /**
     * @type {?}
     * @private
     */
    DeliveryCountriesEffects.prototype.siteConnector;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ForgotPasswordEffects {
    /**
     * @param {?} actions$
     * @param {?} userAccountConnector
     */
    constructor(actions$, userAccountConnector) {
        this.actions$ = actions$;
        this.userAccountConnector = userAccountConnector;
        this.requestForgotPasswordEmail$ = this.actions$.pipe(ofType(FORGOT_PASSWORD_EMAIL_REQUEST), map((/**
         * @param {?} action
         * @return {?}
         */
        (action) => {
            return action.payload;
        })), concatMap((/**
         * @param {?} userEmailAddress
         * @return {?}
         */
        userEmailAddress => {
            return this.userAccountConnector
                .requestForgotPasswordEmail(userEmailAddress)
                .pipe(switchMap((/**
             * @return {?}
             */
            () => [
                new ForgotPasswordEmailRequestSuccess(),
                new AddMessage({
                    text: { key: 'forgottenPassword.passwordResetEmailSent' },
                    type: GlobalMessageType.MSG_TYPE_CONFIRMATION,
                }),
            ])), catchError((/**
             * @param {?} error
             * @return {?}
             */
            error => of(new ForgotPasswordEmailRequestFail(makeErrorSerializable(error))))));
        })));
    }
}
ForgotPasswordEffects.decorators = [
    { type: Injectable }
];
/** @nocollapse */
ForgotPasswordEffects.ctorParameters = () => [
    { type: Actions },
    { type: UserConnector }
];
__decorate([
    Effect(),
    __metadata("design:type", Observable)
], ForgotPasswordEffects.prototype, "requestForgotPasswordEmail$", void 0);
if (false) {
    /** @type {?} */
    ForgotPasswordEffects.prototype.requestForgotPasswordEmail$;
    /**
     * @type {?}
     * @private
     */
    ForgotPasswordEffects.prototype.actions$;
    /**
     * @type {?}
     * @private
     */
    ForgotPasswordEffects.prototype.userAccountConnector;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NotificationPreferenceEffects {
    /**
     * @param {?} actions$
     * @param {?} connector
     */
    constructor(actions$, connector) {
        this.actions$ = actions$;
        this.connector = connector;
        this.loadPreferences$ = this.actions$.pipe(ofType(LOAD_NOTIFICATION_PREFERENCES), map((/**
         * @param {?} action
         * @return {?}
         */
        (action) => action.payload)), switchMap((/**
         * @param {?} payload
         * @return {?}
         */
        payload => this.connector.loadAll(payload).pipe(map((/**
         * @param {?} preferences
         * @return {?}
         */
        preferences => new LoadNotificationPreferencesSuccess(preferences))), catchError((/**
         * @param {?} error
         * @return {?}
         */
        error => of(new LoadNotificationPreferencesFail(makeErrorSerializable(error)))))))));
        this.updatePreferences$ = this.actions$.pipe(ofType(UPDATE_NOTIFICATION_PREFERENCES), map((/**
         * @param {?} action
         * @return {?}
         */
        (action) => action.payload)), mergeMap((/**
         * @param {?} payload
         * @return {?}
         */
        payload => this.connector.update(payload.userId, payload.preferences).pipe(map((/**
         * @return {?}
         */
        () => new UpdateNotificationPreferencesSuccess(payload.preferences))), catchError((/**
         * @param {?} error
         * @return {?}
         */
        error => of(new UpdateNotificationPreferencesFail(makeErrorSerializable(error)))))))));
    }
}
NotificationPreferenceEffects.decorators = [
    { type: Injectable }
];
/** @nocollapse */
NotificationPreferenceEffects.ctorParameters = () => [
    { type: Actions },
    { type: UserNotificationPreferenceConnector }
];
__decorate([
    Effect(),
    __metadata("design:type", Observable)
], NotificationPreferenceEffects.prototype, "loadPreferences$", void 0);
__decorate([
    Effect(),
    __metadata("design:type", Observable)
], NotificationPreferenceEffects.prototype, "updatePreferences$", void 0);
if (false) {
    /** @type {?} */
    NotificationPreferenceEffects.prototype.loadPreferences$;
    /** @type {?} */
    NotificationPreferenceEffects.prototype.updatePreferences$;
    /**
     * @type {?}
     * @private
     */
    NotificationPreferenceEffects.prototype.actions$;
    /**
     * @type {?}
     * @private
     */
    NotificationPreferenceEffects.prototype.connector;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class OrderDetailsEffect {
    /**
     * @param {?} actions$
     * @param {?} orderConnector
     */
    constructor(actions$, orderConnector) {
        this.actions$ = actions$;
        this.orderConnector = orderConnector;
        this.loadOrderDetails$ = this.actions$.pipe(ofType(LOAD_ORDER_DETAILS), map((/**
         * @param {?} action
         * @return {?}
         */
        (action) => action.payload)), switchMap((/**
         * @param {?} payload
         * @return {?}
         */
        payload => {
            return this.orderConnector.get(payload.userId, payload.orderCode).pipe(map((/**
             * @param {?} order
             * @return {?}
             */
            (order) => {
                return new LoadOrderDetailsSuccess(order);
            })), catchError((/**
             * @param {?} error
             * @return {?}
             */
            error => of(new LoadOrderDetailsFail(makeErrorSerializable(error))))));
        })));
        this.cancelOrder$ = this.actions$.pipe(ofType(CANCEL_ORDER), map((/**
         * @param {?} action
         * @return {?}
         */
        (action) => action.payload)), switchMap((/**
         * @param {?} payload
         * @return {?}
         */
        payload => {
            return this.orderConnector
                .cancel(payload.userId, payload.orderCode, payload.cancelRequestInput)
                .pipe(map((/**
             * @param {?} _
             * @return {?}
             */
            _ => new CancelOrderSuccess())), catchError((/**
             * @param {?} error
             * @return {?}
             */
            error => of(new CancelOrderFail(makeErrorSerializable(error))))));
        })));
    }
}
OrderDetailsEffect.decorators = [
    { type: Injectable }
];
/** @nocollapse */
OrderDetailsEffect.ctorParameters = () => [
    { type: Actions },
    { type: UserOrderConnector }
];
__decorate([
    Effect(),
    __metadata("design:type", Observable)
], OrderDetailsEffect.prototype, "loadOrderDetails$", void 0);
__decorate([
    Effect(),
    __metadata("design:type", Observable)
], OrderDetailsEffect.prototype, "cancelOrder$", void 0);
if (false) {
    /** @type {?} */
    OrderDetailsEffect.prototype.loadOrderDetails$;
    /** @type {?} */
    OrderDetailsEffect.prototype.cancelOrder$;
    /**
     * @type {?}
     * @private
     */
    OrderDetailsEffect.prototype.actions$;
    /**
     * @type {?}
     * @private
     */
    OrderDetailsEffect.prototype.orderConnector;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class OrderReturnRequestEffect {
    /**
     * @param {?} actions$
     * @param {?} orderConnector
     */
    constructor(actions$, orderConnector) {
        this.actions$ = actions$;
        this.orderConnector = orderConnector;
        this.createReturnRequest$ = this.actions$.pipe(ofType(CREATE_ORDER_RETURN_REQUEST), map((/**
         * @param {?} action
         * @return {?}
         */
        (action) => action.payload)), switchMap((/**
         * @param {?} payload
         * @return {?}
         */
        payload => {
            return this.orderConnector
                .return(payload.userId, payload.returnRequestInput)
                .pipe(map((/**
             * @param {?} returnRequest
             * @return {?}
             */
            (returnRequest) => new CreateOrderReturnRequestSuccess(returnRequest))), catchError((/**
             * @param {?} error
             * @return {?}
             */
            error => of(new CreateOrderReturnRequestFail(makeErrorSerializable(error))))));
        })));
        this.loadReturnRequest$ = this.actions$.pipe(ofType(LOAD_ORDER_RETURN_REQUEST), map((/**
         * @param {?} action
         * @return {?}
         */
        (action) => action.payload)), switchMap((/**
         * @param {?} payload
         * @return {?}
         */
        payload => {
            return this.orderConnector
                .getReturnRequestDetail(payload.userId, payload.returnRequestCode)
                .pipe(map((/**
             * @param {?} returnRequest
             * @return {?}
             */
            (returnRequest) => new LoadOrderReturnRequestSuccess(returnRequest))), catchError((/**
             * @param {?} error
             * @return {?}
             */
            error => of(new LoadOrderReturnRequestFail(makeErrorSerializable(error))))));
        })));
        this.cancelReturnRequest$ = this.actions$.pipe(ofType(CANCEL_ORDER_RETURN_REQUEST), map((/**
         * @param {?} action
         * @return {?}
         */
        (action) => action.payload)), switchMap((/**
         * @param {?} payload
         * @return {?}
         */
        payload => {
            return this.orderConnector
                .cancelReturnRequest(payload.userId, payload.returnRequestCode, payload.returnRequestModification)
                .pipe(map((/**
             * @param {?} _
             * @return {?}
             */
            _ => new CancelOrderReturnRequestSuccess())), catchError((/**
             * @param {?} error
             * @return {?}
             */
            error => of(new CancelOrderReturnRequestFail(makeErrorSerializable(error))))));
        })));
        this.loadReturnRequestList$ = this.actions$.pipe(ofType(LOAD_ORDER_RETURN_REQUEST_LIST), map((/**
         * @param {?} action
         * @return {?}
         */
        (action) => action.payload)), switchMap((/**
         * @param {?} payload
         * @return {?}
         */
        payload => {
            return this.orderConnector
                .getReturnRequestList(payload.userId, payload.pageSize, payload.currentPage, payload.sort)
                .pipe(map((/**
             * @param {?} returnRequestList
             * @return {?}
             */
            (returnRequestList) => new LoadOrderReturnRequestListSuccess(returnRequestList))), catchError((/**
             * @param {?} error
             * @return {?}
             */
            error => of(new LoadOrderReturnRequestListFail(makeErrorSerializable(error))))));
        })));
    }
}
OrderReturnRequestEffect.decorators = [
    { type: Injectable }
];
/** @nocollapse */
OrderReturnRequestEffect.ctorParameters = () => [
    { type: Actions },
    { type: UserOrderConnector }
];
__decorate([
    Effect(),
    __metadata("design:type", Observable)
], OrderReturnRequestEffect.prototype, "createReturnRequest$", void 0);
__decorate([
    Effect(),
    __metadata("design:type", Observable)
], OrderReturnRequestEffect.prototype, "loadReturnRequest$", void 0);
__decorate([
    Effect(),
    __metadata("design:type", Observable)
], OrderReturnRequestEffect.prototype, "cancelReturnRequest$", void 0);
__decorate([
    Effect(),
    __metadata("design:type", Observable)
], OrderReturnRequestEffect.prototype, "loadReturnRequestList$", void 0);
if (false) {
    /** @type {?} */
    OrderReturnRequestEffect.prototype.createReturnRequest$;
    /** @type {?} */
    OrderReturnRequestEffect.prototype.loadReturnRequest$;
    /** @type {?} */
    OrderReturnRequestEffect.prototype.cancelReturnRequest$;
    /** @type {?} */
    OrderReturnRequestEffect.prototype.loadReturnRequestList$;
    /**
     * @type {?}
     * @private
     */
    OrderReturnRequestEffect.prototype.actions$;
    /**
     * @type {?}
     * @private
     */
    OrderReturnRequestEffect.prototype.orderConnector;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class UserPaymentMethodsEffects {
    /**
     * @param {?} actions$
     * @param {?} userPaymentMethodConnector
     */
    constructor(actions$, userPaymentMethodConnector) {
        this.actions$ = actions$;
        this.userPaymentMethodConnector = userPaymentMethodConnector;
        this.loadUserPaymentMethods$ = this.actions$.pipe(ofType(LOAD_USER_PAYMENT_METHODS), map((/**
         * @param {?} action
         * @return {?}
         */
        (action) => action.payload)), mergeMap((/**
         * @param {?} payload
         * @return {?}
         */
        payload => {
            return this.userPaymentMethodConnector.getAll(payload).pipe(map((/**
             * @param {?} payments
             * @return {?}
             */
            (payments) => {
                return new LoadUserPaymentMethodsSuccess(payments);
            })), catchError((/**
             * @param {?} error
             * @return {?}
             */
            error => of(new LoadUserPaymentMethodsFail(makeErrorSerializable(error))))));
        })));
        this.setDefaultUserPaymentMethod$ = this.actions$.pipe(ofType(SET_DEFAULT_USER_PAYMENT_METHOD), map((/**
         * @param {?} action
         * @return {?}
         */
        (action) => action.payload)), mergeMap((/**
         * @param {?} payload
         * @return {?}
         */
        payload => {
            return this.userPaymentMethodConnector
                .setDefault(payload.userId, payload.paymentMethodId)
                .pipe(switchMap((/**
             * @param {?} data
             * @return {?}
             */
            data => [
                new SetDefaultUserPaymentMethodSuccess(data),
                new LoadUserPaymentMethods(payload.userId),
            ])), catchError((/**
             * @param {?} error
             * @return {?}
             */
            error => of(new SetDefaultUserPaymentMethodFail(makeErrorSerializable(error))))));
        })));
        this.deleteUserPaymentMethod$ = this.actions$.pipe(ofType(DELETE_USER_PAYMENT_METHOD), map((/**
         * @param {?} action
         * @return {?}
         */
        (action) => action.payload)), mergeMap((/**
         * @param {?} payload
         * @return {?}
         */
        payload => {
            return this.userPaymentMethodConnector
                .delete(payload.userId, payload.paymentMethodId)
                .pipe(switchMap((/**
             * @param {?} data
             * @return {?}
             */
            data => [
                new DeleteUserPaymentMethodSuccess(data),
                new LoadUserPaymentMethods(payload.userId),
            ])), catchError((/**
             * @param {?} error
             * @return {?}
             */
            error => of(new DeleteUserPaymentMethodFail(makeErrorSerializable(error))))));
        })));
    }
}
UserPaymentMethodsEffects.decorators = [
    { type: Injectable }
];
/** @nocollapse */
UserPaymentMethodsEffects.ctorParameters = () => [
    { type: Actions },
    { type: UserPaymentConnector }
];
__decorate([
    Effect(),
    __metadata("design:type", Observable)
], UserPaymentMethodsEffects.prototype, "loadUserPaymentMethods$", void 0);
__decorate([
    Effect(),
    __metadata("design:type", Observable)
], UserPaymentMethodsEffects.prototype, "setDefaultUserPaymentMethod$", void 0);
__decorate([
    Effect(),
    __metadata("design:type", Observable)
], UserPaymentMethodsEffects.prototype, "deleteUserPaymentMethod$", void 0);
if (false) {
    /** @type {?} */
    UserPaymentMethodsEffects.prototype.loadUserPaymentMethods$;
    /** @type {?} */
    UserPaymentMethodsEffects.prototype.setDefaultUserPaymentMethod$;
    /** @type {?} */
    UserPaymentMethodsEffects.prototype.deleteUserPaymentMethod$;
    /**
     * @type {?}
     * @private
     */
    UserPaymentMethodsEffects.prototype.actions$;
    /**
     * @type {?}
     * @private
     */
    UserPaymentMethodsEffects.prototype.userPaymentMethodConnector;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class RegionsEffects {
    /**
     * @param {?} actions$
     * @param {?} siteConnector
     */
    constructor(actions$, siteConnector) {
        this.actions$ = actions$;
        this.siteConnector = siteConnector;
        this.loadRegions$ = this.actions$.pipe(ofType(LOAD_REGIONS), map((/**
         * @param {?} action
         * @return {?}
         */
        (action) => {
            return action.payload;
        })), switchMap((/**
         * @param {?} countryCode
         * @return {?}
         */
        (countryCode) => {
            return this.siteConnector.getRegions(countryCode).pipe(map((/**
             * @param {?} regions
             * @return {?}
             */
            regions => new LoadRegionsSuccess({
                entities: regions,
                country: countryCode,
            }))), catchError((/**
             * @param {?} error
             * @return {?}
             */
            error => of(new LoadRegionsFail(makeErrorSerializable(error))))));
        })));
        this.resetRegions$ = this.actions$.pipe(ofType(CLEAR_USER_MISCS_DATA, CLEAR_REGIONS), map((/**
         * @return {?}
         */
        () => {
            return new LoaderResetAction(REGIONS);
        })));
    }
}
RegionsEffects.decorators = [
    { type: Injectable }
];
/** @nocollapse */
RegionsEffects.ctorParameters = () => [
    { type: Actions },
    { type: SiteConnector }
];
__decorate([
    Effect(),
    __metadata("design:type", Observable)
], RegionsEffects.prototype, "loadRegions$", void 0);
__decorate([
    Effect(),
    __metadata("design:type", Observable)
], RegionsEffects.prototype, "resetRegions$", void 0);
if (false) {
    /** @type {?} */
    RegionsEffects.prototype.loadRegions$;
    /** @type {?} */
    RegionsEffects.prototype.resetRegions$;
    /**
     * @type {?}
     * @private
     */
    RegionsEffects.prototype.actions$;
    /**
     * @type {?}
     * @private
     */
    RegionsEffects.prototype.siteConnector;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ResetPasswordEffects {
    /**
     * @param {?} actions$
     * @param {?} userAccountConnector
     */
    constructor(actions$, userAccountConnector) {
        this.actions$ = actions$;
        this.userAccountConnector = userAccountConnector;
        this.resetPassword$ = this.actions$.pipe(ofType(RESET_PASSWORD), map((/**
         * @param {?} action
         * @return {?}
         */
        (action) => action.payload)), switchMap((/**
         * @param {?} __0
         * @return {?}
         */
        ({ token, password }) => {
            return this.userAccountConnector.resetPassword(token, password).pipe(switchMap((/**
             * @return {?}
             */
            () => [
                new ResetPasswordSuccess(),
                new AddMessage({
                    text: { key: 'forgottenPassword.passwordResetSuccess' },
                    type: GlobalMessageType.MSG_TYPE_CONFIRMATION,
                }),
            ])), catchError((/**
             * @param {?} error
             * @return {?}
             */
            error => of(new ResetPasswordFail(makeErrorSerializable(error))))));
        })));
    }
}
ResetPasswordEffects.decorators = [
    { type: Injectable }
];
/** @nocollapse */
ResetPasswordEffects.ctorParameters = () => [
    { type: Actions },
    { type: UserConnector }
];
__decorate([
    Effect(),
    __metadata("design:type", Observable)
], ResetPasswordEffects.prototype, "resetPassword$", void 0);
if (false) {
    /** @type {?} */
    ResetPasswordEffects.prototype.resetPassword$;
    /**
     * @type {?}
     * @private
     */
    ResetPasswordEffects.prototype.actions$;
    /**
     * @type {?}
     * @private
     */
    ResetPasswordEffects.prototype.userAccountConnector;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class TitlesEffects {
    /**
     * @param {?} actions$
     * @param {?} userAccountConnector
     */
    constructor(actions$, userAccountConnector) {
        this.actions$ = actions$;
        this.userAccountConnector = userAccountConnector;
        this.loadTitles$ = this.actions$.pipe(ofType(LOAD_TITLES), switchMap((/**
         * @return {?}
         */
        () => {
            return this.userAccountConnector.getTitles().pipe(map((/**
             * @param {?} titles
             * @return {?}
             */
            titles => {
                return new LoadTitlesSuccess(titles);
            })), catchError((/**
             * @param {?} error
             * @return {?}
             */
            error => of(new LoadTitlesFail(makeErrorSerializable(error))))));
        })));
    }
}
TitlesEffects.decorators = [
    { type: Injectable }
];
/** @nocollapse */
TitlesEffects.ctorParameters = () => [
    { type: Actions },
    { type: UserConnector }
];
__decorate([
    Effect(),
    __metadata("design:type", Observable)
], TitlesEffects.prototype, "loadTitles$", void 0);
if (false) {
    /** @type {?} */
    TitlesEffects.prototype.loadTitles$;
    /**
     * @type {?}
     * @private
     */
    TitlesEffects.prototype.actions$;
    /**
     * @type {?}
     * @private
     */
    TitlesEffects.prototype.userAccountConnector;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class UpdateEmailEffects {
    /**
     * @param {?} actions$
     * @param {?} userAccountConnector
     */
    constructor(actions$, userAccountConnector) {
        this.actions$ = actions$;
        this.userAccountConnector = userAccountConnector;
        this.updateEmail$ = this.actions$.pipe(ofType(UPDATE_EMAIL), map((/**
         * @param {?} action
         * @return {?}
         */
        (action) => action.payload)), concatMap((/**
         * @param {?} payload
         * @return {?}
         */
        payload => this.userAccountConnector
            .updateEmail(payload.uid, payload.password, payload.newUid)
            .pipe(map((/**
         * @return {?}
         */
        () => new UpdateEmailSuccessAction(payload.newUid))), catchError((/**
         * @param {?} error
         * @return {?}
         */
        error => of(new UpdateEmailErrorAction(makeErrorSerializable(error)))))))));
    }
}
UpdateEmailEffects.decorators = [
    { type: Injectable }
];
/** @nocollapse */
UpdateEmailEffects.ctorParameters = () => [
    { type: Actions },
    { type: UserConnector }
];
__decorate([
    Effect(),
    __metadata("design:type", Observable)
], UpdateEmailEffects.prototype, "updateEmail$", void 0);
if (false) {
    /** @type {?} */
    UpdateEmailEffects.prototype.updateEmail$;
    /**
     * @type {?}
     * @private
     */
    UpdateEmailEffects.prototype.actions$;
    /**
     * @type {?}
     * @private
     */
    UpdateEmailEffects.prototype.userAccountConnector;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class UpdatePasswordEffects {
    /**
     * @param {?} actions$
     * @param {?} userAccountConnector
     */
    constructor(actions$, userAccountConnector) {
        this.actions$ = actions$;
        this.userAccountConnector = userAccountConnector;
        this.updatePassword$ = this.actions$.pipe(ofType(UPDATE_PASSWORD), map((/**
         * @param {?} action
         * @return {?}
         */
        (action) => action.payload)), concatMap((/**
         * @param {?} payload
         * @return {?}
         */
        payload => this.userAccountConnector
            .updatePassword(payload.userId, payload.oldPassword, payload.newPassword)
            .pipe(map((/**
         * @param {?} _
         * @return {?}
         */
        _ => new UpdatePasswordSuccess())), catchError((/**
         * @param {?} error
         * @return {?}
         */
        error => of(new UpdatePasswordFail(makeErrorSerializable(error)))))))));
    }
}
UpdatePasswordEffects.decorators = [
    { type: Injectable }
];
/** @nocollapse */
UpdatePasswordEffects.ctorParameters = () => [
    { type: Actions },
    { type: UserConnector }
];
__decorate([
    Effect(),
    __metadata("design:type", Observable)
], UpdatePasswordEffects.prototype, "updatePassword$", void 0);
if (false) {
    /** @type {?} */
    UpdatePasswordEffects.prototype.updatePassword$;
    /**
     * @type {?}
     * @private
     */
    UpdatePasswordEffects.prototype.actions$;
    /**
     * @type {?}
     * @private
     */
    UpdatePasswordEffects.prototype.userAccountConnector;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class UserAddressesEffects {
    /**
     * @param {?} actions$
     * @param {?} userAddressConnector
     * @param {?} userAddressService
     * @param {?} messageService
     */
    constructor(actions$, userAddressConnector, userAddressService, messageService) {
        this.actions$ = actions$;
        this.userAddressConnector = userAddressConnector;
        this.userAddressService = userAddressService;
        this.messageService = messageService;
        this.loadUserAddresses$ = this.actions$.pipe(ofType(LOAD_USER_ADDRESSES), map((/**
         * @param {?} action
         * @return {?}
         */
        (action) => action.payload)), mergeMap((/**
         * @param {?} payload
         * @return {?}
         */
        payload => {
            return this.userAddressConnector.getAll(payload).pipe(map((/**
             * @param {?} addresses
             * @return {?}
             */
            (addresses) => {
                return new LoadUserAddressesSuccess(addresses);
            })), catchError((/**
             * @param {?} error
             * @return {?}
             */
            error => of(new LoadUserAddressesFail(makeErrorSerializable(error))))));
        })));
        this.addUserAddress$ = this.actions$.pipe(ofType(ADD_USER_ADDRESS), map((/**
         * @param {?} action
         * @return {?}
         */
        (action) => action.payload)), mergeMap((/**
         * @param {?} payload
         * @return {?}
         */
        payload => {
            return this.userAddressConnector
                .add(payload.userId, payload.address)
                .pipe(map((/**
             * @param {?} data
             * @return {?}
             */
            (data) => {
                return new AddUserAddressSuccess(data);
            })), catchError((/**
             * @param {?} error
             * @return {?}
             */
            error => of(new AddUserAddressFail(makeErrorSerializable(error))))));
        })));
        this.updateUserAddress$ = this.actions$.pipe(ofType(UPDATE_USER_ADDRESS), map((/**
         * @param {?} action
         * @return {?}
         */
        (action) => action.payload)), mergeMap((/**
         * @param {?} payload
         * @return {?}
         */
        payload => {
            return this.userAddressConnector
                .update(payload.userId, payload.addressId, payload.address)
                .pipe(map((/**
             * @param {?} data
             * @return {?}
             */
            data => {
                // don't show the message if just setting address as default
                if (payload.address &&
                    Object.keys(payload.address).length === 1 &&
                    payload.address.defaultAddress) {
                    return new LoadUserAddresses(payload.userId);
                }
                else {
                    return new UpdateUserAddressSuccess(data);
                }
            })), catchError((/**
             * @param {?} error
             * @return {?}
             */
            error => of(new UpdateUserAddressFail(makeErrorSerializable(error))))));
        })));
        this.deleteUserAddress$ = this.actions$.pipe(ofType(DELETE_USER_ADDRESS), map((/**
         * @param {?} action
         * @return {?}
         */
        (action) => action.payload)), mergeMap((/**
         * @param {?} payload
         * @return {?}
         */
        payload => {
            return this.userAddressConnector
                .delete(payload.userId, payload.addressId)
                .pipe(map((/**
             * @param {?} data
             * @return {?}
             */
            data => {
                return new DeleteUserAddressSuccess(data);
            })), catchError((/**
             * @param {?} error
             * @return {?}
             */
            error => of(new DeleteUserAddressFail(makeErrorSerializable(error))))));
        })));
        /**
         *  Reload addresses and notify about add success
         */
        this.showGlobalMessageOnAddSuccess$ = this.actions$.pipe(ofType(ADD_USER_ADDRESS_SUCCESS), tap((/**
         * @return {?}
         */
        () => {
            this.loadAddresses();
            this.showGlobalMessage('addressForm.userAddressAddSuccess');
        })));
        /**
         *  Reload addresses and notify about update success
         */
        this.showGlobalMessageOnUpdateSuccess$ = this.actions$.pipe(ofType(UPDATE_USER_ADDRESS_SUCCESS), tap((/**
         * @return {?}
         */
        () => {
            this.loadAddresses();
            this.showGlobalMessage('addressForm.userAddressUpdateSuccess');
        })));
        /**
         *  Reload addresses and notify about delete success
         */
        this.showGlobalMessageOnDeleteSuccess$ = this.actions$.pipe(ofType(DELETE_USER_ADDRESS_SUCCESS), tap((/**
         * @return {?}
         */
        () => {
            this.loadAddresses();
            this.showGlobalMessage('addressForm.userAddressDeleteSuccess');
        })));
    }
    /**
     * Show global confirmation message with provided text
     * @private
     * @param {?} text
     * @return {?}
     */
    showGlobalMessage(text) {
        this.messageService.add({ key: text }, GlobalMessageType.MSG_TYPE_CONFIRMATION);
    }
    /**
     * @private
     * @return {?}
     */
    loadAddresses() {
        this.userAddressService.loadAddresses();
    }
}
UserAddressesEffects.decorators = [
    { type: Injectable }
];
/** @nocollapse */
UserAddressesEffects.ctorParameters = () => [
    { type: Actions },
    { type: UserAddressConnector },
    { type: UserAddressService },
    { type: GlobalMessageService }
];
__decorate([
    Effect(),
    __metadata("design:type", Observable)
], UserAddressesEffects.prototype, "loadUserAddresses$", void 0);
__decorate([
    Effect(),
    __metadata("design:type", Observable)
], UserAddressesEffects.prototype, "addUserAddress$", void 0);
__decorate([
    Effect(),
    __metadata("design:type", Observable)
], UserAddressesEffects.prototype, "updateUserAddress$", void 0);
__decorate([
    Effect(),
    __metadata("design:type", Observable)
], UserAddressesEffects.prototype, "deleteUserAddress$", void 0);
__decorate([
    Effect({ dispatch: false }),
    __metadata("design:type", Object)
], UserAddressesEffects.prototype, "showGlobalMessageOnAddSuccess$", void 0);
__decorate([
    Effect({ dispatch: false }),
    __metadata("design:type", Object)
], UserAddressesEffects.prototype, "showGlobalMessageOnUpdateSuccess$", void 0);
__decorate([
    Effect({ dispatch: false }),
    __metadata("design:type", Object)
], UserAddressesEffects.prototype, "showGlobalMessageOnDeleteSuccess$", void 0);
if (false) {
    /** @type {?} */
    UserAddressesEffects.prototype.loadUserAddresses$;
    /** @type {?} */
    UserAddressesEffects.prototype.addUserAddress$;
    /** @type {?} */
    UserAddressesEffects.prototype.updateUserAddress$;
    /** @type {?} */
    UserAddressesEffects.prototype.deleteUserAddress$;
    /**
     *  Reload addresses and notify about add success
     * @type {?}
     */
    UserAddressesEffects.prototype.showGlobalMessageOnAddSuccess$;
    /**
     *  Reload addresses and notify about update success
     * @type {?}
     */
    UserAddressesEffects.prototype.showGlobalMessageOnUpdateSuccess$;
    /**
     *  Reload addresses and notify about delete success
     * @type {?}
     */
    UserAddressesEffects.prototype.showGlobalMessageOnDeleteSuccess$;
    /**
     * @type {?}
     * @private
     */
    UserAddressesEffects.prototype.actions$;
    /**
     * @type {?}
     * @private
     */
    UserAddressesEffects.prototype.userAddressConnector;
    /**
     * @type {?}
     * @private
     */
    UserAddressesEffects.prototype.userAddressService;
    /**
     * @type {?}
     * @private
     */
    UserAddressesEffects.prototype.messageService;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class UserConsentsEffect {
    /**
     * @param {?} actions$
     * @param {?} userConsentConnector
     */
    constructor(actions$, userConsentConnector) {
        this.actions$ = actions$;
        this.userConsentConnector = userConsentConnector;
        this.resetConsents$ = this.actions$.pipe(ofType(LANGUAGE_CHANGE), map((/**
         * @return {?}
         */
        () => new ResetLoadUserConsents())));
        this.getConsents$ = this.actions$.pipe(ofType(LOAD_USER_CONSENTS), map((/**
         * @param {?} action
         * @return {?}
         */
        (action) => action.payload)), concatMap((/**
         * @param {?} userId
         * @return {?}
         */
        userId => this.userConsentConnector.loadConsents(userId).pipe(map((/**
         * @param {?} consents
         * @return {?}
         */
        consents => new LoadUserConsentsSuccess(consents))), catchError((/**
         * @param {?} error
         * @return {?}
         */
        error => of(new LoadUserConsentsFail(makeErrorSerializable(error)))))))));
        this.giveConsent$ = this.actions$.pipe(ofType(GIVE_USER_CONSENT, TRANSFER_ANONYMOUS_CONSENT), concatMap((/**
         * @param {?} action
         * @return {?}
         */
        action => this.userConsentConnector
            .giveConsent(action.payload.userId, action.payload.consentTemplateId, action.payload.consentTemplateVersion)
            .pipe(map((/**
         * @param {?} consent
         * @return {?}
         */
        consent => new GiveUserConsentSuccess(consent))), catchError((/**
         * @param {?} error
         * @return {?}
         */
        error => {
            /** @type {?} */
            const errors = [
                new GiveUserConsentFail(makeErrorSerializable(error)),
            ];
            if (action.type === TRANSFER_ANONYMOUS_CONSENT &&
                error.status === 409) {
                errors.push(new RemoveMessagesByType(GlobalMessageType.MSG_TYPE_ERROR));
            }
            return of(...errors);
        }))))));
        this.withdrawConsent$ = this.actions$.pipe(ofType(WITHDRAW_USER_CONSENT), map((/**
         * @param {?} action
         * @return {?}
         */
        (action) => action.payload)), concatMap((/**
         * @param {?} __0
         * @return {?}
         */
        ({ userId, consentCode }) => this.userConsentConnector.withdrawConsent(userId, consentCode).pipe(map((/**
         * @return {?}
         */
        () => new WithdrawUserConsentSuccess())), catchError((/**
         * @param {?} error
         * @return {?}
         */
        error => of(new WithdrawUserConsentFail(makeErrorSerializable(error)))))))));
    }
}
UserConsentsEffect.decorators = [
    { type: Injectable }
];
/** @nocollapse */
UserConsentsEffect.ctorParameters = () => [
    { type: Actions },
    { type: UserConsentConnector }
];
__decorate([
    Effect(),
    __metadata("design:type", Observable)
], UserConsentsEffect.prototype, "resetConsents$", void 0);
__decorate([
    Effect(),
    __metadata("design:type", Observable)
], UserConsentsEffect.prototype, "getConsents$", void 0);
__decorate([
    Effect(),
    __metadata("design:type", Observable)
], UserConsentsEffect.prototype, "giveConsent$", void 0);
__decorate([
    Effect(),
    __metadata("design:type", Observable)
], UserConsentsEffect.prototype, "withdrawConsent$", void 0);
if (false) {
    /** @type {?} */
    UserConsentsEffect.prototype.resetConsents$;
    /** @type {?} */
    UserConsentsEffect.prototype.getConsents$;
    /** @type {?} */
    UserConsentsEffect.prototype.giveConsent$;
    /** @type {?} */
    UserConsentsEffect.prototype.withdrawConsent$;
    /**
     * @type {?}
     * @private
     */
    UserConsentsEffect.prototype.actions$;
    /**
     * @type {?}
     * @private
     */
    UserConsentsEffect.prototype.userConsentConnector;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class UserDetailsEffects {
    /**
     * @param {?} actions$
     * @param {?} userConnector
     */
    constructor(actions$, userConnector) {
        this.actions$ = actions$;
        this.userConnector = userConnector;
        this.loadUserDetails$ = this.actions$.pipe(ofType(LOAD_USER_DETAILS), map((/**
         * @param {?} action
         * @return {?}
         */
        (action) => action.payload)), mergeMap((/**
         * @param {?} userId
         * @return {?}
         */
        userId => {
            return this.userConnector.get(userId).pipe(map((/**
             * @param {?} user
             * @return {?}
             */
            (user) => {
                return new LoadUserDetailsSuccess(user);
            })), catchError((/**
             * @param {?} error
             * @return {?}
             */
            error => of(new LoadUserDetailsFail(makeErrorSerializable(error))))));
        })));
        this.updateUserDetails$ = this.actions$.pipe(ofType(UPDATE_USER_DETAILS), map((/**
         * @param {?} action
         * @return {?}
         */
        (action) => action.payload)), concatMap((/**
         * @param {?} payload
         * @return {?}
         */
        payload => this.userConnector.update(payload.username, payload.userDetails).pipe(map((/**
         * @param {?} _
         * @return {?}
         */
        _ => new UpdateUserDetailsSuccess(payload.userDetails))), catchError((/**
         * @param {?} error
         * @return {?}
         */
        error => of(new UpdateUserDetailsFail(makeErrorSerializable(error)))))))));
    }
}
UserDetailsEffects.decorators = [
    { type: Injectable }
];
/** @nocollapse */
UserDetailsEffects.ctorParameters = () => [
    { type: Actions },
    { type: UserConnector }
];
__decorate([
    Effect(),
    __metadata("design:type", Observable)
], UserDetailsEffects.prototype, "loadUserDetails$", void 0);
__decorate([
    Effect(),
    __metadata("design:type", Observable)
], UserDetailsEffects.prototype, "updateUserDetails$", void 0);
if (false) {
    /** @type {?} */
    UserDetailsEffects.prototype.loadUserDetails$;
    /** @type {?} */
    UserDetailsEffects.prototype.updateUserDetails$;
    /**
     * @type {?}
     * @private
     */
    UserDetailsEffects.prototype.actions$;
    /**
     * @type {?}
     * @private
     */
    UserDetailsEffects.prototype.userConnector;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class UserOrdersEffect {
    /**
     * @param {?} actions$
     * @param {?} orderConnector
     */
    constructor(actions$, orderConnector) {
        this.actions$ = actions$;
        this.orderConnector = orderConnector;
        this.loadUserOrders$ = this.actions$.pipe(ofType(LOAD_USER_ORDERS), map((/**
         * @param {?} action
         * @return {?}
         */
        (action) => action.payload)), switchMap((/**
         * @param {?} payload
         * @return {?}
         */
        payload => {
            return this.orderConnector
                .getHistory(payload.userId, payload.pageSize, payload.currentPage, payload.sort)
                .pipe(map((/**
             * @param {?} orders
             * @return {?}
             */
            (orders) => {
                return new LoadUserOrdersSuccess(orders);
            })), catchError((/**
             * @param {?} error
             * @return {?}
             */
            error => of(new LoadUserOrdersFail(makeErrorSerializable(error))))));
        })));
        this.resetUserOrders$ = this.actions$.pipe(ofType(LANGUAGE_CHANGE), map((/**
         * @return {?}
         */
        () => {
            return new ClearUserOrders();
        })));
    }
}
UserOrdersEffect.decorators = [
    { type: Injectable }
];
/** @nocollapse */
UserOrdersEffect.ctorParameters = () => [
    { type: Actions },
    { type: UserOrderConnector }
];
__decorate([
    Effect(),
    __metadata("design:type", Observable)
], UserOrdersEffect.prototype, "loadUserOrders$", void 0);
__decorate([
    Effect(),
    __metadata("design:type", Observable)
], UserOrdersEffect.prototype, "resetUserOrders$", void 0);
if (false) {
    /** @type {?} */
    UserOrdersEffect.prototype.loadUserOrders$;
    /** @type {?} */
    UserOrdersEffect.prototype.resetUserOrders$;
    /**
     * @type {?}
     * @private
     */
    UserOrdersEffect.prototype.actions$;
    /**
     * @type {?}
     * @private
     */
    UserOrdersEffect.prototype.orderConnector;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class UserRegisterEffects {
    /**
     * @param {?} actions$
     * @param {?} userConnector
     */
    constructor(actions$, userConnector) {
        this.actions$ = actions$;
        this.userConnector = userConnector;
        this.registerUser$ = this.actions$.pipe(ofType(REGISTER_USER), map((/**
         * @param {?} action
         * @return {?}
         */
        (action) => action.payload)), mergeMap((/**
         * @param {?} user
         * @return {?}
         */
        (user) => this.userConnector.register(user).pipe(map((/**
         * @return {?}
         */
        () => new RegisterUserSuccess())), catchError((/**
         * @param {?} error
         * @return {?}
         */
        error => of(new RegisterUserFail(makeErrorSerializable(error)))))))));
        this.registerGuest$ = this.actions$.pipe(ofType(REGISTER_GUEST), map((/**
         * @param {?} action
         * @return {?}
         */
        (action) => action.payload)), mergeMap((/**
         * @param {?} __0
         * @return {?}
         */
        ({ guid, password }) => this.userConnector.registerGuest(guid, password).pipe(switchMap((/**
         * @param {?} user
         * @return {?}
         */
        user => [
            new LoadUserToken({
                userId: user.uid,
                password: password,
            }),
            new RegisterGuestSuccess(),
        ])), catchError((/**
         * @param {?} error
         * @return {?}
         */
        error => of(new RegisterGuestFail(makeErrorSerializable(error)))))))));
        this.removeUser$ = this.actions$.pipe(ofType(REMOVE_USER), map((/**
         * @param {?} action
         * @return {?}
         */
        (action) => action.payload)), mergeMap((/**
         * @param {?} userId
         * @return {?}
         */
        (userId) => {
            return this.userConnector.remove(userId).pipe(switchMap((/**
             * @param {?} _result
             * @return {?}
             */
            _result => [
                new RemoveUserSuccess(),
                new Logout(),
            ])), catchError((/**
             * @param {?} error
             * @return {?}
             */
            error => of(new RemoveUserFail(makeErrorSerializable(error))))));
        })));
    }
}
UserRegisterEffects.decorators = [
    { type: Injectable }
];
/** @nocollapse */
UserRegisterEffects.ctorParameters = () => [
    { type: Actions },
    { type: UserConnector }
];
__decorate([
    Effect(),
    __metadata("design:type", Observable)
], UserRegisterEffects.prototype, "registerUser$", void 0);
__decorate([
    Effect(),
    __metadata("design:type", Observable)
], UserRegisterEffects.prototype, "registerGuest$", void 0);
__decorate([
    Effect(),
    __metadata("design:type", Observable)
], UserRegisterEffects.prototype, "removeUser$", void 0);
if (false) {
    /** @type {?} */
    UserRegisterEffects.prototype.registerUser$;
    /** @type {?} */
    UserRegisterEffects.prototype.registerGuest$;
    /** @type {?} */
    UserRegisterEffects.prototype.removeUser$;
    /**
     * @type {?}
     * @private
     */
    UserRegisterEffects.prototype.actions$;
    /**
     * @type {?}
     * @private
     */
    UserRegisterEffects.prototype.userConnector;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class CustomerCouponEffects {
    /**
     * @param {?} actions$
     * @param {?} customerCouponConnector
     */
    constructor(actions$, customerCouponConnector) {
        this.actions$ = actions$;
        this.customerCouponConnector = customerCouponConnector;
        this.loadCustomerCoupons$ = this.actions$.pipe(ofType(LOAD_CUSTOMER_COUPONS), map((/**
         * @param {?} action
         * @return {?}
         */
        (action) => action.payload)), mergeMap((/**
         * @param {?} payload
         * @return {?}
         */
        payload => {
            return this.customerCouponConnector
                .getCustomerCoupons(payload.userId, payload.pageSize, payload.currentPage, payload.sort)
                .pipe(map((/**
             * @param {?} coupons
             * @return {?}
             */
            (coupons) => {
                return new LoadCustomerCouponsSuccess(coupons);
            })), catchError((/**
             * @param {?} error
             * @return {?}
             */
            error => of(new LoadCustomerCouponsFail(makeErrorSerializable(error))))));
        })));
        this.subscribeCustomerCoupon$ = this.actions$.pipe(ofType(SUBSCRIBE_CUSTOMER_COUPON), map((/**
         * @param {?} action
         * @return {?}
         */
        (action) => action.payload)), mergeMap((/**
         * @param {?} payload
         * @return {?}
         */
        payload => {
            return this.customerCouponConnector
                .turnOnNotification(payload.userId, payload.couponCode)
                .pipe(map((/**
             * @param {?} data
             * @return {?}
             */
            (data) => {
                return new SubscribeCustomerCouponSuccess(data);
            })), catchError((/**
             * @param {?} error
             * @return {?}
             */
            error => of(new SubscribeCustomerCouponFail(makeErrorSerializable(error))))));
        })));
        this.unsubscribeCustomerCoupon$ = this.actions$.pipe(ofType(UNSUBSCRIBE_CUSTOMER_COUPON), map((/**
         * @param {?} action
         * @return {?}
         */
        (action) => action.payload)), mergeMap((/**
         * @param {?} payload
         * @return {?}
         */
        payload => {
            return this.customerCouponConnector
                .turnOffNotification(payload.userId, payload.couponCode)
                .pipe(map((/**
             * @return {?}
             */
            () => {
                return new UnsubscribeCustomerCouponSuccess(payload.couponCode);
            })), catchError((/**
             * @param {?} error
             * @return {?}
             */
            error => of(new UnsubscribeCustomerCouponFail(makeErrorSerializable(error))))));
        })));
        this.claimCustomerCoupon$ = this.actions$.pipe(ofType(CLAIM_CUSTOMER_COUPON), map((/**
         * @param {?} action
         * @return {?}
         */
        (action) => action.payload)), mergeMap((/**
         * @param {?} payload
         * @return {?}
         */
        payload => {
            return this.customerCouponConnector
                .claimCustomerCoupon(payload.userId, payload.couponCode)
                .pipe(map((/**
             * @param {?} data
             * @return {?}
             */
            data => {
                return new ClaimCustomerCouponSuccess(data);
            })), catchError((/**
             * @param {?} error
             * @return {?}
             */
            error => of(new ClaimCustomerCouponFail(makeErrorSerializable(error))))));
        })));
    }
}
CustomerCouponEffects.decorators = [
    { type: Injectable }
];
/** @nocollapse */
CustomerCouponEffects.ctorParameters = () => [
    { type: Actions },
    { type: CustomerCouponConnector }
];
__decorate([
    Effect(),
    __metadata("design:type", Observable)
], CustomerCouponEffects.prototype, "loadCustomerCoupons$", void 0);
__decorate([
    Effect(),
    __metadata("design:type", Observable)
], CustomerCouponEffects.prototype, "subscribeCustomerCoupon$", void 0);
__decorate([
    Effect(),
    __metadata("design:type", Observable)
], CustomerCouponEffects.prototype, "unsubscribeCustomerCoupon$", void 0);
__decorate([
    Effect(),
    __metadata("design:type", Observable)
], CustomerCouponEffects.prototype, "claimCustomerCoupon$", void 0);
if (false) {
    /** @type {?} */
    CustomerCouponEffects.prototype.loadCustomerCoupons$;
    /** @type {?} */
    CustomerCouponEffects.prototype.subscribeCustomerCoupon$;
    /** @type {?} */
    CustomerCouponEffects.prototype.unsubscribeCustomerCoupon$;
    /** @type {?} */
    CustomerCouponEffects.prototype.claimCustomerCoupon$;
    /**
     * @type {?}
     * @private
     */
    CustomerCouponEffects.prototype.actions$;
    /**
     * @type {?}
     * @private
     */
    CustomerCouponEffects.prototype.customerCouponConnector;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ProductInterestsEffect {
    /**
     * @param {?} actions$
     * @param {?} userInterestsConnector
     */
    constructor(actions$, userInterestsConnector) {
        this.actions$ = actions$;
        this.userInterestsConnector = userInterestsConnector;
        this.loadProductInteres$ = this.actions$.pipe(ofType(LOAD_PRODUCT_INTERESTS), map((/**
         * @param {?} action
         * @return {?}
         */
        (action) => action.payload)), switchMap((/**
         * @param {?} payload
         * @return {?}
         */
        payload => {
            return this.userInterestsConnector
                .getInterests(payload.userId, payload.pageSize, payload.currentPage, payload.sort, payload.productCode, payload.notificationType)
                .pipe(map((/**
             * @param {?} interests
             * @return {?}
             */
            (interests) => {
                return new LoadProductInterestsSuccess(interests);
            })), catchError((/**
             * @param {?} error
             * @return {?}
             */
            error => of(new LoadProductInterestsFail(makeErrorSerializable(error))))));
        })));
        this.removeProductInterest$ = this.actions$.pipe(ofType(REMOVE_PRODUCT_INTEREST), map((/**
         * @param {?} action
         * @return {?}
         */
        (action) => action.payload)), switchMap((/**
         * @param {?} payload
         * @return {?}
         */
        payload => this.userInterestsConnector
            .removeInterest(payload.userId, payload.item)
            .pipe(switchMap((/**
         * @param {?} data
         * @return {?}
         */
        data => [
            new LoadProductInterests(payload.singleDelete
                ? {
                    userId: payload.userId,
                    productCode: payload.item.product.code,
                    notificationType: payload.item.productInterestEntry[0].interestType,
                }
                : { userId: payload.userId }),
            new RemoveProductInterestSuccess(data),
        ])), catchError((/**
         * @param {?} error
         * @return {?}
         */
        error => of(new RemoveProductInterestFail(makeErrorSerializable(error)))))))));
        this.addProductInterest$ = this.actions$.pipe(ofType(ADD_PRODUCT_INTEREST), map((/**
         * @param {?} action
         * @return {?}
         */
        (action) => action.payload)), switchMap((/**
         * @param {?} payload
         * @return {?}
         */
        payload => this.userInterestsConnector
            .addInterest(payload.userId, payload.productCode, payload.notificationType)
            .pipe(switchMap((/**
         * @param {?} res
         * @return {?}
         */
        (res) => [
            new LoadProductInterests({
                userId: payload.userId,
                productCode: payload.productCode,
                notificationType: payload.notificationType,
            }),
            new AddProductInterestSuccess(res),
        ])), catchError((/**
         * @param {?} error
         * @return {?}
         */
        error => of(new AddProductInterestFail(makeErrorSerializable(error)))))))));
    }
}
ProductInterestsEffect.decorators = [
    { type: Injectable }
];
/** @nocollapse */
ProductInterestsEffect.ctorParameters = () => [
    { type: Actions },
    { type: UserInterestsConnector }
];
__decorate([
    Effect(),
    __metadata("design:type", Observable)
], ProductInterestsEffect.prototype, "loadProductInteres$", void 0);
__decorate([
    Effect(),
    __metadata("design:type", Observable)
], ProductInterestsEffect.prototype, "removeProductInterest$", void 0);
__decorate([
    Effect(),
    __metadata("design:type", Observable)
], ProductInterestsEffect.prototype, "addProductInterest$", void 0);
if (false) {
    /** @type {?} */
    ProductInterestsEffect.prototype.loadProductInteres$;
    /** @type {?} */
    ProductInterestsEffect.prototype.removeProductInterest$;
    /** @type {?} */
    ProductInterestsEffect.prototype.addProductInterest$;
    /**
     * @type {?}
     * @private
     */
    ProductInterestsEffect.prototype.actions$;
    /**
     * @type {?}
     * @private
     */
    ProductInterestsEffect.prototype.userInterestsConnector;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const effects$c = [
    ClearMiscsDataEffect,
    DeliveryCountriesEffects,
    RegionsEffects,
    TitlesEffects,
    UserDetailsEffects,
    UserAddressesEffects,
    UserPaymentMethodsEffects,
    UserRegisterEffects,
    UserOrdersEffect,
    OrderDetailsEffect,
    BillingCountriesEffect,
    ResetPasswordEffects,
    ForgotPasswordEffects,
    UpdateEmailEffects,
    UpdatePasswordEffects,
    UserConsentsEffect,
    ConsignmentTrackingEffects,
    CustomerCouponEffects,
    NotificationPreferenceEffects,
    ProductInterestsEffect,
    OrderReturnRequestEffect,
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class UserStoreModule {
}
UserStoreModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    ReactiveFormsModule,
                    StateModule,
                    StoreModule.forFeature(USER_FEATURE, reducerToken$d, { metaReducers: metaReducers$8 }),
                    EffectsModule.forFeature(effects$c),
                    RouterModule,
                ],
                providers: [reducerProvider$d],
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FindProductPageMetaResolver extends PageMetaResolver {
    /**
     * @param {?} routingService
     * @param {?} productSearchService
     * @param {?} translation
     * @param {?} authService
     */
    constructor(routingService, productSearchService, translation, authService) {
        super();
        this.routingService = routingService;
        this.productSearchService = productSearchService;
        this.translation = translation;
        this.authService = authService;
        this.totalAndCode$ = combineLatest([
            this.productSearchService.getResults().pipe(filter((/**
             * @param {?} data
             * @return {?}
             */
            data => !!(data && data.pagination))), map((/**
             * @param {?} results
             * @return {?}
             */
            results => results.pagination.totalResults))),
            this.routingService.getRouterState().pipe(map((/**
             * @param {?} state
             * @return {?}
             */
            state => state.state.queryParams['couponcode'])), filter(Boolean)),
        ]);
        this.pageType = PageType.CONTENT_PAGE;
        this.pageTemplate = 'SearchResultsListPageTemplate';
    }
    /**
     * @deprecated since version 1.3
     *
     * The resolve method is no longer preferred and will be removed with release 2.0.
     * The caller `PageMetaService` service is improved to expect all individual resolvers
     * instead, so that the code is easier extensible.
     * @return {?}
     */
    resolve() {
        return combineLatest([this.resolveTitle(), this.resolveBreadcrumbs()]).pipe(map((/**
         * @param {?} __0
         * @return {?}
         */
        ([title, breadcrumbs]) => ({
            title,
            breadcrumbs,
        }))));
    }
    /**
     * @return {?}
     */
    resolveBreadcrumbs() {
        /** @type {?} */
        const breadcrumbs = [{ label: 'Home', link: '/' }];
        this.authService.isUserLoggedIn().subscribe((/**
         * @param {?} login
         * @return {?}
         */
        login => {
            if (login)
                breadcrumbs.push({ label: 'My Coupons', link: '/my-account/coupons' });
        }));
        return of(breadcrumbs);
    }
    /**
     * @return {?}
     */
    resolveTitle() {
        return this.totalAndCode$.pipe(switchMap((/**
         * @param {?} __0
         * @return {?}
         */
        ([total, code]) => this.translation.translate('pageMetaResolver.search.findProductTitle', {
            count: total,
            coupon: code,
        }))));
    }
    /**
     * @param {?} page
     * @return {?}
     */
    getScore(page) {
        /** @type {?} */
        let score = 0;
        if (this.pageType) {
            score += page.type === this.pageType ? 1 : -1;
        }
        if (this.pageTemplate) {
            score += page.template === this.pageTemplate ? 1 : -1;
        }
        this.routingService
            .getRouterState()
            .pipe(map((/**
         * @param {?} state
         * @return {?}
         */
        state => {
            return state.state.queryParams;
        })), filter(Boolean))
            .subscribe((/**
         * @param {?} queryParams
         * @return {?}
         */
        (queryParams) => {
            if (queryParams) {
                score += queryParams['couponcode'] ? 1 : -1;
            }
        }))
            .unsubscribe();
        return score;
    }
}
FindProductPageMetaResolver.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root',
            },] }
];
/** @nocollapse */
FindProductPageMetaResolver.ctorParameters = () => [
    { type: RoutingService },
    { type: ProductSearchService },
    { type: TranslationService },
    { type: AuthService }
];
/** @nocollapse */ FindProductPageMetaResolver.ngInjectableDef = ɵɵdefineInjectable({ factory: function FindProductPageMetaResolver_Factory() { return new FindProductPageMetaResolver(ɵɵinject(RoutingService), ɵɵinject(ProductSearchService), ɵɵinject(TranslationService), ɵɵinject(AuthService)); }, token: FindProductPageMetaResolver, providedIn: "root" });
if (false) {
    /** @type {?} */
    FindProductPageMetaResolver.prototype.totalAndCode$;
    /**
     * @type {?}
     * @protected
     */
    FindProductPageMetaResolver.prototype.routingService;
    /**
     * @type {?}
     * @protected
     */
    FindProductPageMetaResolver.prototype.productSearchService;
    /**
     * @type {?}
     * @protected
     */
    FindProductPageMetaResolver.prototype.translation;
    /**
     * @type {?}
     * @protected
     */
    FindProductPageMetaResolver.prototype.authService;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class UserModule {
    /**
     * @return {?}
     */
    static forRoot() {
        return {
            ngModule: UserModule,
            providers: [
                UserService,
                {
                    provide: PageMetaResolver,
                    useExisting: FindProductPageMetaResolver,
                    multi: true,
                },
            ],
        };
    }
}
UserModule.decorators = [
    { type: NgModule, args: [{
                imports: [UserStoreModule],
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { ADDRESS_NORMALIZER, ADDRESS_SERIALIZER, ADDRESS_VALIDATION_NORMALIZER, ADD_PRODUCT_INTEREST_PROCESS_ID, ADD_VOUCHER_PROCESS_ID, ANONYMOUS_CONSENTS, ANONYMOUS_CONSENTS_FEATURE, ANONYMOUS_CONSENTS_STORE_FEATURE, ANONYMOUS_CONSENT_STATUS, ANONYMOUS_USERID, ASM_FEATURE, AUTH_FEATURE, ActiveCartService, AnonymousConsentTemplatesAdapter, AnonymousConsentTemplatesConnector, anonymousConsentsGroup as AnonymousConsentsActions, AnonymousConsentsConfig, AnonymousConsentsModule, anonymousConsentsGroup_selectors as AnonymousConsentsSelectors, AnonymousConsentsService, customerGroup_actions as AsmActions, AsmAdapter, AsmAuthService, AsmConfig, AsmConnector, AsmModule, AsmOccModule, asmGroup_selectors as AsmSelectors, AsmService, authGroup_actions as AuthActions, AuthConfig, AuthGuard, AuthModule, AuthRedirectService, authGroup_selectors as AuthSelectors, AuthService, BASE_SITE_CONTEXT_ID, BadGatewayHandler, BadRequestHandler, BaseSiteService, CANCEL_ORDER_PROCESS_ID, CANCEL_RETURN_PROCESS_ID, CARD_TYPE_NORMALIZER, CART_DATA, CART_FEATURE, CART_MODIFICATION_NORMALIZER, CART_NORMALIZER, CART_VOUCHER_NORMALIZER, CHECKOUT_DETAILS, CHECKOUT_FEATURE, CLAIM_CUSTOMER_COUPON_PROCESS_ID, CLIENT_TOKEN_DATA, CMS_COMPONENT_NORMALIZER, CMS_FEATURE, CMS_FLEX_COMPONENT_TYPE, CMS_PAGE_NORMALIZER, COMPONENT_ENTITY, CONFIG_INITIALIZER, CONSENT_TEMPLATE_NORMALIZER, CONSIGNMENT_TRACKING_NORMALIZER, COUNTRY_NORMALIZER, CSAGENT_TOKEN_DATA, CURRENCY_CONTEXT_ID, CURRENCY_NORMALIZER, CUSTOMER_COUPONS, CUSTOMER_COUPON_SEARCH_RESULT_NORMALIZER, CUSTOMER_SEARCH_DATA, CUSTOMER_SEARCH_PAGE_NORMALIZER, cartGroup_actions as CartActions, CartAdapter, CartConnector, CartDataService, CartEffects, CartEntryAdapter, CartEntryConnector, CartEntryEffects, CartModule, CartOccModule, cartGroup_selectors as CartSelectors, CartService, CartVoucherAdapter, CartVoucherConnector, CartVoucherEffects, CartVoucherService, CategoryPageMetaResolver, checkoutGroup_actions as CheckoutActions, CheckoutAdapter, CheckoutConnector, CheckoutDeliveryAdapter, CheckoutDeliveryConnector, CheckoutDeliveryService, CheckoutModule, CheckoutOccModule, CheckoutPageMetaResolver, CheckoutPaymentAdapter, CheckoutPaymentConnector, CheckoutPaymentService, checkoutGroup_selectors as CheckoutSelectors, CheckoutService, cmsGroup_actions as CmsActions, CmsBannerCarouselEffect, CmsComponentAdapter, CmsComponentConnector, CmsConfig, CmsModule, CmsOccModule, CmsPageAdapter, CmsPageConnector, CmsPageTitleModule, cmsGroup_selectors as CmsSelectors, CmsService, CmsStructureConfig, CmsStructureConfigService, Config, ConfigChunk, ConfigInitializerModule, ConfigInitializerService, ConfigModule, ConfigValidatorToken, ConfigurableRoutesService, ConflictHandler, ConsentService, ContentPageMetaResolver, ContextServiceMap, ConverterService, CountryType, CurrencyService, CustomerCouponAdapter, CustomerCouponConnector, CustomerCouponService, CustomerSupportAgentTokenInterceptor, CxDatePipe, DEFAULT_LOCAL_STORAGE_KEY, DEFAULT_SESSION_STORAGE_KEY, DELIVERY_MODE_NORMALIZER, DeferLoadingStrategy, DynamicAttributeService, EMAIL_PATTERN, EXTERNAL_CONFIG_TRANSFER_ID, ExternalJsFileLoader, ExternalRoutesConfig, ExternalRoutesGuard, ExternalRoutesModule, ExternalRoutesService, FeatureConfigService, FeatureDirective, FeatureLevelDirective, FeaturesConfig, FeaturesConfigModule, ForbiddenHandler, GIVE_CONSENT_PROCESS_ID, GLOBAL_MESSAGE_FEATURE, GatewayTimeoutHandler, GlobService, globalMessageGroup_actions as GlobalMessageActions, GlobalMessageConfig, GlobalMessageModule, globalMessageGroup_selectors as GlobalMessageSelectors, GlobalMessageService, GlobalMessageType, GoogleMapRendererService, HttpErrorHandler, I18nConfig, I18nModule, I18nTestingModule, I18nextTranslationService, ImageType, InterceptorUtil, JSP_INCLUDE_CMS_COMPONENT_TYPE, JavaRegExpConverter, KYMA_FEATURE, kymaGroup_actions as KymaActions, KymaConfig, KymaModule, kymaGroup_selectors as KymaSelectors, KymaService, KymaServices, LANGUAGE_CONTEXT_ID, LANGUAGE_NORMALIZER, LanguageService, LoadingScopesService, MEDIA_BASE_URL_META_TAG_NAME, MEDIA_BASE_URL_META_TAG_PLACEHOLDER, MULTI_CART_DATA, MULTI_CART_FEATURE, MockDatePipe, MockTranslatePipe, multiCartGroup_selectors as MultiCartSelectors, MultiCartService, NAVIGATION_DETAIL_ENTITY, NOTIFICATION_PREFERENCES, NgExpressEngineDecorator, NotAuthGuard, NotFoundHandler, NotificationType, OCC_BASE_URL_META_TAG_NAME, OCC_BASE_URL_META_TAG_PLACEHOLDER, OCC_CART_ID_CURRENT, OCC_USER_ID_ANONYMOUS, OCC_USER_ID_CURRENT, OCC_USER_ID_GUEST, OPEN_ID_TOKEN_DATA, ORDER_HISTORY_NORMALIZER, ORDER_NORMALIZER, ORDER_RETURNS_NORMALIZER, ORDER_RETURN_REQUEST_INPUT_SERIALIZER, ORDER_RETURN_REQUEST_NORMALIZER, Occ, OccAnonymousConsentTemplatesAdapter, OccAsmAdapter, OccCartAdapter, OccCartEntryAdapter, OccCartNormalizer, OccCartVoucherAdapter, OccCheckoutAdapter, OccCheckoutDeliveryAdapter, OccCheckoutPaymentAdapter, OccCmsComponentAdapter, OccCmsPageAdapter, OccCmsPageNormalizer, OccConfig, OccConfigLoaderModule, OccConfigLoaderService, OccCustomerCouponAdapter, OccEndpointsService, OccFieldsService, OccLoadedConfigConverter, OccModule, OccOrderNormalizer, OccProductAdapter, OccProductReferencesAdapter, OccProductReferencesListNormalizer, OccProductReviewsAdapter, OccProductSearchAdapter, OccProductSearchPageNormalizer, OccRequestsOptimizerService, OccReturnRequestNormalizer, OccSiteAdapter, OccSitesConfigLoader, OccStoreFinderAdapter, OccUserAdapter, OccUserAddressAdapter, OccUserConsentAdapter, OccUserInterestsAdapter, OccUserInterestsNormalizer, OccUserNotificationPreferenceAdapter, OccUserOrderAdapter, OccUserPaymentAdapter, OrderReturnRequestService, PASSWORD_PATTERN, PAYMENT_DETAILS_NORMALIZER, PAYMENT_DETAILS_SERIALIZER, POINT_OF_SERVICE_NORMALIZER, PROCESS_FEATURE, PRODUCT_DETAIL_ENTITY, PRODUCT_FEATURE, PRODUCT_INTERESTS, PRODUCT_INTERESTS_NORMALIZER, PRODUCT_NORMALIZER, PRODUCT_REFERENCES_NORMALIZER, PRODUCT_REVIEW_NORMALIZER, PRODUCT_REVIEW_SERIALIZER, PRODUCT_SEARCH_PAGE_NORMALIZER, PRODUCT_SUGGESTION_NORMALIZER, PageContext, PageMetaResolver, PageMetaService, PageRobotsMeta, PageType, PersonalizationConfig, PersonalizationContextService, PersonalizationModule, PriceType, ProcessModule, process_selectors as ProcessSelectors, productGroup_actions as ProductActions, ProductAdapter, ProductConnector, ProductImageNormalizer, ProductLoadingService, ProductModule, ProductNameNormalizer, ProductOccModule, ProductPageMetaResolver, ProductReferenceNormalizer, ProductReferenceService, ProductReferencesAdapter, ProductReferencesConnector, ProductReviewService, ProductReviewsAdapter, ProductReviewsConnector, ProductScope, ProductSearchAdapter, ProductSearchConnector, ProductSearchService, productGroup_selectors as ProductSelectors, ProductService, PromotionLocation, ProtectedRoutesGuard, ProtectedRoutesService, REGIONS, REGION_NORMALIZER, REGISTER_USER_PROCESS_ID, REMOVE_PRODUCT_INTERESTS_PROCESS_ID, REMOVE_USER_PROCESS_ID, ROUTING_FEATURE, routingGroup_actions as RoutingActions, RoutingConfig, RoutingConfigService, RoutingModule, routingGroup_selectors as RoutingSelector, RoutingService, SERVER_REQUEST_ORIGIN, SERVER_REQUEST_URL, SET_DELIVERY_ADDRESS_PROCESS_ID, SET_DELIVERY_MODE_PROCESS_ID, SET_PAYMENT_DETAILS_PROCESS_ID, SET_SUPPORTED_DELIVERY_MODE_PROCESS_ID, SITE_CONTEXT_FEATURE, STORE_COUNT_NORMALIZER, STORE_FINDER_DATA, STORE_FINDER_FEATURE, STORE_FINDER_SEARCH_PAGE_NORMALIZER, SUBSCRIBE_CUSTOMER_COUPON_PROCESS_ID, SearchPageMetaResolver, SearchboxService, SelectiveCartService, SemanticPathService, SiteAdapter, SiteConnector, siteContextGroup_actions as SiteContextActions, SiteContextConfig, SiteContextInterceptor, SiteContextModule, SiteContextOccModule, siteContextGroup_selectors as SiteContextSelectors, SmartEditModule, SmartEditService, StateConfig, entity_action as StateEntityActions, entityLoader_action as StateEntityLoaderActions, entityLoader_selectors as StateEntityLoaderSelectors, entityProcessesLoader_action as StateEntityProcessesLoaderActions, entityProcessesLoader_selectors as StateEntityProcessesLoaderSelectors, entity_selectors as StateEntitySelectors, loader_action as StateLoaderActions, loader_selectors as StateLoaderSelectors, StateModule, processesLoader_action as StateProcessesLoaderActions, processesLoader_selectors as StateProcessesLoaderSelectors, StateTransferType, StorageSyncType, StoreDataService, storeFinderGroup_actions as StoreFinderActions, StoreFinderAdapter, StoreFinderConfig, StoreFinderConnector, StoreFinderCoreModule, StoreFinderOccModule, storeFinderGroup_selectors as StoreFinderSelectors, StoreFinderService, TITLE_NORMALIZER, TOKEN_REVOCATION_HEADER, TestConfigModule, TranslatePipe, TranslationChunkService, TranslationService, UNSUBSCRIBE_CUSTOMER_COUPON_PROCESS_ID, UPDATE_EMAIL_PROCESS_ID, UPDATE_NOTIFICATION_PREFERENCES_PROCESS_ID, UPDATE_PASSWORD_PROCESS_ID, UPDATE_USER_DETAILS_PROCESS_ID, USER_ADDRESSES, USER_CONSENTS, USER_FEATURE, USER_NORMALIZER, USER_ORDERS, USER_ORDER_DETAILS, USER_PAYMENT_METHODS, USER_RETURN_REQUESTS, USER_RETURN_REQUEST_DETAILS, USER_SERIALIZER, USER_SIGN_UP_SERIALIZER, USE_CLIENT_TOKEN, USE_CUSTOMER_SUPPORT_AGENT_TOKEN, UnknownErrorHandler, UrlMatcherFactoryService, UrlModule, UrlPipe, userGroup_actions as UserActions, UserAdapter, UserAddressAdapter, UserAddressConnector, UserAddressService, UserConnector, UserConsentAdapter, UserConsentConnector, UserConsentService, UserInterestsAdapter, UserInterestsConnector, UserInterestsService, UserModule, UserNotificationPreferenceService, UserOccModule, UserOrderAdapter, UserOrderConnector, UserOrderService, UserPaymentAdapter, UserPaymentConnector, UserPaymentService, UserService, usersGroup_selectors as UsersSelectors, VariantQualifier, VariantType, WITHDRAW_CONSENT_PROCESS_ID, WindowRef, WishListEffects, WishListService, WithCredentialsInterceptor, clearCartState, clearMultiCartState, configInitializerFactory, configurationFactory, contextServiceMapProvider, deprecatedContextServiceProviders as contextServiceProviders, defaultAnonymousConsentsConfig, defaultCmsModuleConfig, defaultOccConfig, defaultStateConfig, effects$5 as effects, entityLoaderReducer, entityProcessesLoaderReducer, entityReducer, errorHandlers, getMultiCartReducers, getReducers$5 as getReducers, getServerRequestProviders, getStateSlice, httpErrorInterceptors, initConfigurableRoutes, deprecatedInitSiteContextRoutesHandler as initSiteContextRoutesHandler, initialEntityState, initialLoaderState, initialProcessesState, inititializeContext, isFeatureEnabled, isFeatureLevel, loaderReducer, mediaServerConfigFromMetaTagFactory, metaReducers$3 as metaReducers, multiCartMetaReducers, multiCartReducerProvider, multiCartReducerToken, occConfigValidator, occServerConfigFromMetaTagFactory, ofLoaderFail, ofLoaderLoad, ofLoaderSuccess, processesLoaderReducer, provideConfig, provideConfigFactory, provideConfigFromMetaTags, provideConfigValidator, reducerProvider$5 as reducerProvider, reducerToken$5 as reducerToken, serviceMapFactory, deprecatedSiteContextParamsProviders as siteContextParamsProviders, testestsd, validateConfig, withCredentialsInterceptorProvider, TEST_CONFIG_COOKIE_NAME as ɵa, configFromCookieFactory as ɵb, AnonymousConsentsInterceptor as ɵba, asmStoreConfigFactory as ɵbb, AsmStoreModule as ɵbc, getReducers$3 as ɵbd, reducerToken$3 as ɵbe, reducerProvider$3 as ɵbf, clearCustomerSupportAgentAsmState as ɵbg, metaReducers$2 as ɵbh, effects$3 as ɵbi, CustomerEffects as ɵbj, CustomerSupportAgentTokenEffects as ɵbk, UserAuthenticationTokenService as ɵbl, reducer$7 as ɵbm, defaultAsmConfig as ɵbn, interceptors$2 as ɵbo, CustomerSupportAgentAuthErrorInterceptor as ɵbp, CustomerSupportAgentErrorHandlingService as ɵbq, authStoreConfigFactory as ɵbr, AuthStoreModule as ɵbs, getReducers as ɵbt, reducerToken as ɵbu, reducerProvider as ɵbv, clearAuthState as ɵbw, metaReducers as ɵbx, effects as ɵby, ClientTokenEffect as ɵbz, CONFIG_INITIALIZER_FORROOT_GUARD as ɵc, UserTokenEffects as ɵca, ClientAuthenticationTokenService as ɵcb, reducer as ɵcc, defaultAuthConfig as ɵcd, interceptors as ɵce, ClientTokenInterceptor as ɵcf, UserTokenInterceptor as ɵcg, AuthErrorInterceptor as ɵch, UserErrorHandlingService as ɵci, UrlParsingService as ɵcj, ClientErrorHandlingService as ɵck, TokenRevocationInterceptor as ɵcl, AuthServices as ɵcm, cartStoreConfigFactory as ɵcn, CartStoreModule as ɵco, SaveCartConnector as ɵcp, SaveCartAdapter as ɵcq, reducer$9 as ɵcr, multiCartStoreConfigFactory as ɵcs, MultiCartStoreModule as ɵct, MultiCartEffects as ɵcu, processesLoaderReducer as ɵcv, activeCartReducer as ɵcw, cartEntitiesReducer as ɵcx, wishListReducer as ɵcy, CartPageMetaResolver as ɵcz, initConfig as ɵd, CheckoutStoreModule as ɵda, getReducers$6 as ɵdb, reducerToken$6 as ɵdc, reducerProvider$6 as ɵdd, effects$6 as ɵde, AddressVerificationEffect as ɵdf, CardTypesEffects as ɵdg, CheckoutEffects as ɵdh, reducer$c as ɵdi, reducer$b as ɵdj, reducer$a as ɵdk, cmsStoreConfigFactory as ɵdl, CmsStoreModule as ɵdm, getReducers$8 as ɵdn, reducerToken$8 as ɵdo, reducerProvider$8 as ɵdp, clearCmsState as ɵdq, metaReducers$4 as ɵdr, effects$8 as ɵds, PageEffects as ɵdt, ComponentEffects as ɵdu, NavigationEntryItemEffects as ɵdv, reducer$g as ɵdw, reducer$h as ɵdx, reducer$e as ɵdy, reducer$f as ɵdz, initializeContext as ɵe, configValidatorFactory as ɵea, ConfigValidatorModule as ɵeb, GlobalMessageStoreModule as ɵec, getReducers$4 as ɵed, reducerToken$4 as ɵee, reducerProvider$4 as ɵef, reducer$8 as ɵeg, GlobalMessageEffect as ɵeh, defaultGlobalMessageConfigFactory as ɵei, InternalServerErrorHandler as ɵej, HttpErrorInterceptor as ɵek, defaultI18nConfig as ɵel, i18nextProviders as ɵem, i18nextInit as ɵen, MockTranslationService as ɵeo, kymaStoreConfigFactory as ɵep, KymaStoreModule as ɵeq, getReducers$9 as ɵer, reducerToken$9 as ɵes, reducerProvider$9 as ɵet, clearKymaState as ɵeu, metaReducers$5 as ɵev, effects$9 as ɵew, OpenIdTokenEffect as ɵex, OpenIdAuthenticationTokenService as ɵey, defaultKymaConfig as ɵez, contextServiceProviders as ɵf, defaultOccAsmConfig as ɵfa, defaultOccCartConfig as ɵfb, OccSaveCartAdapter as ɵfc, defaultOccProductConfig as ɵfd, defaultOccSiteContextConfig as ɵfe, defaultOccStoreFinderConfig as ɵff, defaultOccUserConfig as ɵfg, UserNotificationPreferenceAdapter as ɵfh, defaultPersonalizationConfig as ɵfi, interceptors$3 as ɵfj, OccPersonalizationIdInterceptor as ɵfk, OccPersonalizationTimeInterceptor as ɵfl, ProcessStoreModule as ɵfm, getReducers$a as ɵfn, reducerToken$a as ɵfo, reducerProvider$a as ɵfp, productStoreConfigFactory as ɵfq, ProductStoreModule as ɵfr, getReducers$b as ɵfs, reducerToken$b as ɵft, reducerProvider$b as ɵfu, clearProductsState as ɵfv, metaReducers$6 as ɵfw, effects$a as ɵfx, ProductReferencesEffects as ɵfy, ProductReviewsEffects as ɵfz, initSiteContextRoutesHandler as ɵg, ProductsSearchEffects as ɵga, ProductEffects as ɵgb, reducer$i as ɵgc, entityScopedLoaderReducer as ɵgd, scopedLoaderReducer as ɵge, reducer$k as ɵgf, reducer$j as ɵgg, PageMetaResolver as ɵgh, ProductURLPipe as ɵgi, addExternalRoutesFactory as ɵgj, getReducers$7 as ɵgk, reducer$d as ɵgl, reducerToken$7 as ɵgm, reducerProvider$7 as ɵgn, CustomSerializer as ɵgo, effects$7 as ɵgp, RouterEffects as ɵgq, SiteContextParamsService as ɵgr, SiteContextUrlSerializer as ɵgs, SiteContextRoutesHandler as ɵgt, defaultSiteContextConfigFactory as ɵgu, siteContextStoreConfigFactory as ɵgv, SiteContextStoreModule as ɵgw, getReducers$1 as ɵgx, reducerToken$1 as ɵgy, reducerProvider$1 as ɵgz, siteContextParamsProviders as ɵh, effects$2 as ɵha, LanguagesEffects as ɵhb, CurrenciesEffects as ɵhc, BaseSiteEffects as ɵhd, reducer$3 as ɵhe, reducer$2 as ɵhf, reducer$1 as ɵhg, baseSiteConfigValidator as ɵhh, interceptors$4 as ɵhi, CmsTicketInterceptor as ɵhj, defaultStoreFinderConfig as ɵhk, StoreFinderStoreModule as ɵhl, getReducers$c as ɵhm, reducerToken$c as ɵhn, reducerProvider$c as ɵho, effects$b as ɵhp, FindStoresEffect as ɵhq, ViewAllStoresEffect as ɵhr, UserStoreModule as ɵhs, getReducers$d as ɵht, reducerToken$d as ɵhu, reducerProvider$d as ɵhv, clearUserState as ɵhw, metaReducers$8 as ɵhx, effects$c as ɵhy, BillingCountriesEffect as ɵhz, anonymousConsentsStoreConfigFactory as ɵi, ClearMiscsDataEffect as ɵia, ConsignmentTrackingEffects as ɵib, DeliveryCountriesEffects as ɵic, NotificationPreferenceEffects as ɵid, OrderDetailsEffect as ɵie, OrderReturnRequestEffect as ɵif, UserPaymentMethodsEffects as ɵig, RegionsEffects as ɵih, ResetPasswordEffects as ɵii, TitlesEffects as ɵij, UserAddressesEffects as ɵik, UserConsentsEffect as ɵil, UserDetailsEffects as ɵim, UserOrdersEffect as ɵin, UserRegisterEffects as ɵio, CustomerCouponEffects as ɵip, ProductInterestsEffect as ɵiq, ForgotPasswordEffects as ɵir, UpdateEmailEffects as ɵis, UpdatePasswordEffects as ɵit, UserNotificationPreferenceConnector as ɵiu, reducer$w as ɵiv, reducer$u as ɵiw, reducer$l as ɵix, reducer$v as ɵiy, reducer$q as ɵiz, AnonymousConsentsStoreModule as ɵj, reducer$x as ɵja, reducer$p as ɵjb, reducer$A as ɵjc, reducer$n as ɵjd, reducer$t as ɵje, reducer$r as ɵjf, reducer$s as ɵjg, reducer$m as ɵjh, reducer$y as ɵji, reducer$o as ɵjj, reducer$z as ɵjk, FindProductPageMetaResolver as ɵjl, PageMetaResolver as ɵjm, TRANSFER_STATE_META_REDUCER as ɵk, STORAGE_SYNC_META_REDUCER as ɵl, stateMetaReducers as ɵm, getStorageSyncReducer as ɵn, getTransferStateReducer as ɵo, getReducers$2 as ɵp, reducerToken$2 as ɵq, reducerProvider$2 as ɵr, clearAnonymousConsentTemplates as ɵs, metaReducers$1 as ɵt, effects$1 as ɵu, AnonymousConsentsEffects as ɵv, reducer$6 as ɵw, reducer$4 as ɵx, reducer$5 as ɵy, interceptors$1 as ɵz };
//# sourceMappingURL=spartacus-core.js.map
